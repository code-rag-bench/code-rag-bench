<h1 id="sparse-docs">torch.sparse</h1> <div class="admonition warning" id="torch-sparse"> <p class="admonition-title">Warning</p> <p>The PyTorch API of sparse tensors is in beta and may change in the near future. We highly welcome feature requests, bug reports and general suggestions as GitHub issues.</p> </div>  <h2 id="why-and-when-to-use-sparsity">Why and when to use sparsity</h2> <p>By default PyTorch stores <a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor"><code>torch.Tensor</code></a> stores elements contiguously physical memory. This leads to efficient implementations of various array processing algorithms that require fast access to elements.</p> <p>Now, some users might decide to represent data such as graph adjacency matrices, pruned weights or points clouds by Tensors whose <em>elements are mostly zero valued</em>. We recognize these are important applications and aim to provide performance optimizations for these use cases via sparse storage formats.</p> <p>Various sparse storage formats such as COO, CSR/CSC, semi-structured, LIL, etc. have been developed over the years. While they differ in exact layouts, they all compress data through efficient representation of zero valued elements. We call the uncompressed values <em>specified</em> in contrast to <em>unspecified</em>, compressed elements.</p> <p>By compressing repeat zeros sparse storage formats aim to save memory and computational resources on various CPUs and GPUs. Especially for high degrees of sparsity or highly structured sparsity this can have significant performance implications. As such sparse storage formats can be seen as a performance optimization.</p> <p>Like many other performance optimization sparse storage formats are not always advantageous. When trying sparse formats for your use case you might find your execution time to increase rather than decrease.</p> <p>Please feel encouraged to open a GitHub issue if you analytically expected to see a stark increase in performance but measured a degradation instead. This helps us prioritize the implementation of efficient kernels and wider performance optimizations.</p> <p>We make it easy to try different sparsity layouts, and convert between them, without being opinionated on what’s best for your particular application.</p>   <h2 id="functionality-overview">Functionality overview</h2> <p>We want it to be straightforward to construct a sparse Tensor from a given dense Tensor by providing conversion routines for each layout.</p> <p>In the next example we convert a 2D Tensor with default dense (strided) layout to a 2D Tensor backed by the COO memory layout. Only values and indices of non-zero elements are stored in this case.</p> <pre data-language="python">&gt;&gt;&gt; a = torch.tensor([[0, 2.], [3, 0]])
&gt;&gt;&gt; a.to_sparse()
tensor(indices=tensor([[0, 1],
                       [1, 0]]),
       values=tensor([2., 3.]),
       size=(2, 2), nnz=2, layout=torch.sparse_coo)
</pre> <p>PyTorch currently supports <a class="reference internal" href="#sparse-coo-docs"><span class="std std-ref">COO</span></a>, <a class="reference internal" href="#sparse-csr-docs"><span class="std std-ref">CSR</span></a>, <a class="reference internal" href="#sparse-csc-docs"><span class="std std-ref">CSC</span></a>, <a class="reference internal" href="#sparse-bsr-docs"><span class="std std-ref">BSR</span></a>, and <a class="reference internal" href="#sparse-bsc-docs"><span class="std std-ref">BSC</span></a>.</p> <p>We also have a prototype implementation to support :ref: <code>semi-structured sparsity&lt;sparse-semi-structured-docs&gt;</code>. Please see the references for more details.</p> <p>Note that we provide slight generalizations of these formats.</p> <p>Batching: Devices such as GPUs require batching for optimal performance and thus we support batch dimensions.</p> <p>We currently offer a very simple version of batching where each component of a sparse format itself is batched. This also requires the same number of specified elements per batch entry. In this example we construct a 3D (batched) CSR Tensor from a 3D dense Tensor.</p> <pre data-language="python">&gt;&gt;&gt; t = torch.tensor([[[1., 0], [2., 3.]], [[4., 0], [5., 6.]]])
&gt;&gt;&gt; t.dim()
3
&gt;&gt;&gt; t.to_sparse_csr()
tensor(crow_indices=tensor([[0, 1, 3],
                            [0, 1, 3]]),
       col_indices=tensor([[0, 0, 1],
                           [0, 0, 1]]),
       values=tensor([[1., 2., 3.],
                      [4., 5., 6.]]), size=(2, 2, 2), nnz=3,
       layout=torch.sparse_csr)
</pre> <p>Dense dimensions: On the other hand, some data such as Graph embeddings might be better viewed as sparse collections of vectors instead of scalars.</p> <p>In this example we create a 3D Hybrid COO Tensor with 2 sparse and 1 dense dimension from a 3D strided Tensor. If an entire row in the 3D strided Tensor is zero, it is not stored. If however any of the values in the row are non-zero, they are stored entirely. This reduces the number of indices since we need one index one per row instead of one per element. But it also increases the amount of storage for the values. Since only rows that are <em>entirely</em> zero can be emitted and the presence of any non-zero valued elements cause the entire row to be stored.</p> <pre data-language="python">&gt;&gt;&gt; t = torch.tensor([[[0., 0], [1., 2.]], [[0., 0], [3., 4.]]])
&gt;&gt;&gt; t.to_sparse(sparse_dim=2)
tensor(indices=tensor([[0, 1],
                       [1, 1]]),
       values=tensor([[1., 2.],
                      [3., 4.]]),
       size=(2, 2, 2), nnz=2, layout=torch.sparse_coo)
</pre>   <h2 id="operator-overview">Operator overview</h2> <p>Fundamentally, operations on Tensor with sparse storage formats behave the same as operations on Tensor with strided (or other) storage formats. The particularities of storage, that is the physical layout of the data, influences the performance of an operation but should not influence the semantics.</p> <p>We are actively increasing operator coverage for sparse tensors. Users should not expect support same level of support as for dense Tensors yet. See our <a class="reference internal" href="#sparse-ops-docs"><span class="std std-ref">operator</span></a> documentation for a list.</p> <pre data-language="python">&gt;&gt;&gt; b = torch.tensor([[0, 0, 1, 2, 3, 0], [4, 5, 0, 6, 0, 0]])
&gt;&gt;&gt; b_s = b.to_sparse_csr()
&gt;&gt;&gt; b_s.cos()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
RuntimeError: unsupported tensor layout: SparseCsr
&gt;&gt;&gt; b_s.sin()
tensor(crow_indices=tensor([0, 3, 6]),
       col_indices=tensor([2, 3, 4, 0, 1, 3]),
       values=tensor([ 0.8415,  0.9093,  0.1411, -0.7568, -0.9589, -0.2794]),
       size=(2, 6), nnz=6, layout=torch.sparse_csr)
</pre> <p>As shown in the example above, we don’t support non-zero preserving unary operators such as cos. The output of a non-zero preserving unary operation will not be able to take advantage of sparse storage formats to the same extent as the input and potentially result in a catastrophic increase in memory. We instead rely on the user to explicitly convert to a dense Tensor first and then run the operation.</p> <pre data-language="python">&gt;&gt;&gt; b_s.to_dense().cos()
tensor([[ 1.0000, -0.4161],
        [-0.9900,  1.0000]])
</pre> <p>We are aware that some users want to ignore compressed zeros for operations such as <code>cos</code> instead of preserving the exact semantics of the operation. For this we can point to torch.masked and its MaskedTensor, which is in turn also backed and powered by sparse storage formats and kernels.</p> <p>Also note that, for now, the user doesn’t have a choice of the output layout. For example, adding a sparse Tensor to a regular strided Tensor results in a strided Tensor. Some users might prefer for this to stay a sparse layout, because they know the result will still be sufficiently sparse.</p> <pre data-language="python">&gt;&gt;&gt; a + b.to_sparse()
tensor([[0., 3.],
        [3., 0.]])
</pre> <p>We acknowledge that access to kernels that can efficiently produce different output layouts can be very useful. A subsequent operation might significantly benefit from receiving a particular layout. We are working on an API to control the result layout and recognize it is an important feature to plan a more optimal path of execution for any given model.</p>   <h2 id="sparse-semi-structured-docs">Sparse Semi-Structured Tensors</h2> <div class="admonition warning" id="sparse-semi-structured-tensors"> <p class="admonition-title">Warning</p> <p>Sparse semi-sturctured tensors are currently a prototype feature and subject to change. Please feel free to open an issue to report a bug or if you have feedback to share.</p> </div> <p>Semi-Structured sparsity is a sparse data layout that was first introduced in NVIDIA’s Ampere architecture. It is also referred to as <strong>fine-grained structured sparsity</strong> or <strong>2:4 structured sparsity</strong>.</p> <p>This sparse layout stores <code>n</code> elements out of every <code>2n</code> elements, with <code>n</code> being determined by the width of the Tensor’s data type (dtype). The most frequently used dtype is float16, where <code>n=2</code>, thus the term “2:4 structured sparsity.”</p> <p>Semi-structured sparsity is explained in greater detail in <a class="reference external" href="https://developer.nvidia.com/blog/exploiting-ampere-structured-sparsity-with-cusparselt">this NVIDIA blog post</a>.</p> <p>In PyTorch, semi-structured sparsity is implemented via a Tensor subclass. By subclassing, we can override <code>__torch_dispatch__</code> , allowing us to use faster sparse kernels when performing matrix multiplication. We can also store the tensor in it’s compressed form inside the subclass to reduce memory overhead.</p> <p>In this compressed form, the sparse tensor is stored by retaining only the <em>specified</em> elements and some metadata, which encodes the mask.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The specified elements and metadata mask of a semi-structured sparse tensor are stored together in a single flat compressed tensor. They are appended to each other to form a contiguous chunk of memory.</p> <p>compressed tensor = [ specified elements of original tensor | metadata_mask ]</p> <p>For an original tensor of size <code>(r, c)</code> we expect the first <code>m * k // 2</code> elements to be the kept elements and the rest of the tensor is metadata.</p> <p>In order to make it easier for the user to view the specified elements and mask, one can use <code>.indices()</code> and <code>.values()</code> to access the mask and specified elements respectively.</p> <ul class="simple"> <li>
<code>.values()</code> returns the specified elements in a tensor of size <code>(r, c//2)</code> and with the same dtype as the dense matrix.</li> <li>
<code>.indices()</code> returns the metadata_mask in a tensor of size <code>(r, c//2 )</code> and with element type <code>torch.int16</code> if dtype is torch.float16 or torch.bfloat16, and element type <code>torch.int32</code> if dtype is torch.int8.</li> </ul> </div> <p>For 2:4 sparse tensors, the metadata overhead is minor - just 2 bits per specified element.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>It’s important to note that <code>torch.float32</code> is only supported for 1:2 sparsity. Therefore, it does not follow the same formula as above.</p> </div> <p>Here, we break down how to calculate the compression ratio ( size dense / size sparse) of a 2:4 sparse tensor.</p> <p>Let <code>(r, c) = tensor.shape</code> and <code>e = bitwidth(tensor.dtype)</code>, so <code>e = 16</code> for <code>torch.float16</code> and <code>torch.bfloat16</code> and <code>e = 8</code> for <code>torch.int8</code>.</p> <div class="math"> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>M</mi><mrow><mi>d</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>=</mo><mi>r</mi><mo>×</mo><mi>c</mi><mo>×</mo><mi>e</mi><mspace linebreak="newline"></mspace><msub><mi>M</mi><mrow><mi>s</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>=</mo><msub><mi>M</mi><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>f</mi><mi>i</mi><mi>e</mi><mi>d</mi></mrow></msub><mo>+</mo><msub><mi>M</mi><mrow><mi>m</mi><mi>e</mi><mi>t</mi><mi>a</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi></mrow></msub><mo>=</mo><mi>r</mi><mo>×</mo><mfrac><mi>c</mi><mn>2</mn></mfrac><mo>×</mo><mi>e</mi><mo>+</mo><mi>r</mi><mo>×</mo><mfrac><mi>c</mi><mn>2</mn></mfrac><mo>×</mo><mn>2</mn><mo>=</mo><mfrac><mrow><mi>r</mi><mi>c</mi><mi>e</mi></mrow><mn>2</mn></mfrac><mo>+</mo><mi>r</mi><mi>c</mi><mo>=</mo><mi>r</mi><mi>c</mi><mi>e</mi><mo stretchy="false">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>+</mo><mfrac><mn>1</mn><mi>e</mi></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M_{dense} = r \times c \times e \\ M_{sparse} = M_{specified} + M_{metadata} = r \times \frac{c}{2} \times e + r \times \frac{c}{2} \times 2 = \frac{rce}{2} + rc =rce(\frac{1}{2} +\frac{1}{e}) </annotation></semantics></math></span></span></span>
</div>
<p>Using these calculations, we can determine the total memory footprint for both the original dense and the new sparse representation.</p> <p>This gives us a simple formula for the compression ratio, which is dependent only on the bitwidth of the tensor datatype.</p> <div class="math"> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo>=</mo><mfrac><msub><mi>M</mi><mrow><mi>s</mi><mi>p</mi><mi>a</mi><mi>r</mi><mi>s</mi><mi>e</mi></mrow></msub><msub><mi>M</mi><mrow><mi>d</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>e</mi></mrow></msub></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>+</mo><mfrac><mn>1</mn><mi>e</mi></mfrac></mrow><annotation encoding="application/x-tex">C = \frac{M_{sparse}}{M_{dense}} = \frac{1}{2} + \frac{1}{e} </annotation></semantics></math></span></span></span>
</div>
<p>By using this formula, we find that the compression ratio is 56.25% for <code>torch.float16</code> or <code>torch.bfloat16</code>, and 62.5% for <code>torch.int8</code>.</p>  <h3 id="constructing-sparse-semi-structured-tensors">Constructing Sparse Semi-Structured Tensors</h3> <p>You can transform a dense tensor into a sparse semi-structured tensor by simply using the <code>torch.to_sparse_semi_structured</code> function.</p> <p>Please also note that we only support CUDA tensors since hardware compatibility for semi-structured sparsity is limited to NVIDIA GPUs.</p> <p>The following datatypes are supported for semi-structured sparsity. Note that each datatype has its own shape constraints and compression factor.</p> <table class="colwidths-given docutils colwidths-auto align-default">  <thead> <tr>
<th class="head"><p>PyTorch dtype</p></th> <th class="head"><p>Shape Constraints</p></th> <th class="head"><p>Compression Factor</p></th> <th class="head"><p>Sparsity Pattern</p></th> </tr> </thead>  <tr>
<td><p><code>torch.float16</code></p></td> <td><p>Tensor must be 2D and (r, c) must both be a positive multiple of 64</p></td> <td><p>9/16</p></td> <td><p>2:4</p></td> </tr> <tr>
<td><p><code>torch.bfloat16</code></p></td> <td><p>Tensor must be 2D and (r, c) must both be a positive multiple of 64</p></td> <td><p>9/16</p></td> <td><p>2:4</p></td> </tr> <tr>
<td><p><code>torch.int8</code></p></td> <td><p>Tensor must be 2D and (r, c) must both be a positive multiple of 128</p></td> <td><p>10/16</p></td> <td><p>2:4</p></td> </tr>  </table> <p>To construct a semi-structured sparse tensor, start by creating a regular dense tensor that adheres to a 2:4 (or semi-structured) sparse format. To do this we tile a small 1x4 strip to create a 16x16 dense float16 tensor. Afterwards, we can call <code>to_sparse_semi_structured</code> function to compress it for accelerated inference.</p> <pre data-language="python">&gt;&gt;&gt; from torch.sparse import to_sparse_semi_structured
&gt;&gt;&gt; A = torch.Tensor([0, 0, 1, 1]).tile((128, 32)).half().cuda()
tensor([[0., 0., 1.,  ..., 0., 1., 1.],
        [0., 0., 1.,  ..., 0., 1., 1.],
        [0., 0., 1.,  ..., 0., 1., 1.],
        ...,
        [0., 0., 1.,  ..., 0., 1., 1.],
        [0., 0., 1.,  ..., 0., 1., 1.],
        [0., 0., 1.,  ..., 0., 1., 1.]], device='cuda:0', dtype=torch.float16)
&gt;&gt;&gt; A_sparse = to_sparse_semi_structured(A)
SparseSemiStructuredTensor(shape=torch.Size([128, 128]), transposed=False, values=tensor([[1., 1., 1.,  ..., 1., 1., 1.],
        [1., 1., 1.,  ..., 1., 1., 1.],
        [1., 1., 1.,  ..., 1., 1., 1.],
        ...,
        [1., 1., 1.,  ..., 1., 1., 1.],
        [1., 1., 1.,  ..., 1., 1., 1.],
        [1., 1., 1.,  ..., 1., 1., 1.]], device='cuda:0', dtype=torch.float16), metadata=tensor([[-4370, -4370, -4370,  ..., -4370, -4370, -4370],
        [-4370, -4370, -4370,  ..., -4370, -4370, -4370],
        [-4370, -4370, -4370,  ..., -4370, -4370, -4370],
        ...,
        [-4370, -4370, -4370,  ..., -4370, -4370, -4370],
        [-4370, -4370, -4370,  ..., -4370, -4370, -4370],
        [-4370, -4370, -4370,  ..., -4370, -4370, -4370]], device='cuda:0',
dtype=torch.int16))
</pre>   <h3 id="sparse-semi-structured-tensor-operations">Sparse Semi-Structured Tensor Operations</h3> <p>Currently, the following operations are supported for semi-structured sparse tensors:</p> <ul class="simple"> <li>torch.addmm(bias, dense, sparse.t())</li> <li>torch.mm(dense, sparse)</li> <li>torch.mm(sparse, dense)</li> <li>aten.linear.default(dense, sparse, bias)</li> <li>aten.t.default(sparse)</li> <li>aten.t.detach(sparse)</li> </ul> <p>To use these ops, simply pass the output of <code>to_sparse_semi_structured(tensor)</code> instead of using <code>tensor</code> once your tensor has 0s in a semi-structured sparse format, like this:</p> <pre data-language="python">&gt;&gt;&gt; a = torch.Tensor([0, 0, 1, 1]).tile((64, 16)).half().cuda()
&gt;&gt;&gt; b = torch.rand(64, 64).half().cuda()
&gt;&gt;&gt; c = torch.mm(a, b)
&gt;&gt;&gt; a_sparse = to_sparse_semi_structured(a)
&gt;&gt;&gt; torch.allclose(c, torch.mm(a_sparse, b))
True
</pre>   <h3 id="accelerating-nn-linear-with-semi-structured-sparsity">Accelerating nn.Linear with semi-structured sparsity</h3> <p>You can accelerate the linear layers in your model if the weights are already semi-structured sparse with just a few lines of code:</p> <pre data-language="python">&gt;&gt;&gt; input = torch.rand(64, 64).half().cuda()
&gt;&gt;&gt; mask = torch.Tensor([0, 0, 1, 1]).tile((64, 16)).cuda().bool()
&gt;&gt;&gt; linear = nn.Linear(64, 64).half().cuda()
&gt;&gt;&gt; linear.weight = nn.Parameter(to_sparse_semi_structured(linear.weight.masked_fill(~mask, 0)))
</pre>    <h2 id="sparse-coo-docs">Sparse COO tensors</h2> <p id="sparse-coo-tensors">PyTorch implements the so-called Coordinate format, or COO format, as one of the storage formats for implementing sparse tensors. In COO format, the specified elements are stored as tuples of element indices and the corresponding values. In particular,</p>  <ul class="simple"> <li>the indices of specified elements are collected in <code>indices</code> tensor of size <code>(ndim, nse)</code> and with element type <code>torch.int64</code>,</li> <li>the corresponding values are collected in <code>values</code> tensor of size <code>(nse,)</code> and with an arbitrary integer or floating point number element type,</li> </ul>  <p>where <code>ndim</code> is the dimensionality of the tensor and <code>nse</code> is the number of specified elements.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The memory consumption of a sparse COO tensor is at least <code>(ndim *
8 + &lt;size of element type in bytes&gt;) * nse</code> bytes (plus a constant overhead from storing other tensor data).</p> <p>The memory consumption of a strided tensor is at least <code>product(&lt;tensor shape&gt;) * &lt;size of element type in bytes&gt;</code>.</p> <p>For example, the memory consumption of a 10 000 x 10 000 tensor with 100 000 non-zero 32-bit floating point numbers is at least <code>(2 * 8 + 4) * 100 000 = 2 000 000</code> bytes when using COO tensor layout and <code>10 000 * 10 000 * 4 = 400 000 000</code> bytes when using the default strided tensor layout. Notice the 200 fold memory saving from using the COO storage format.</p> </div>  <h3 id="construction">Construction</h3> <p>A sparse COO tensor can be constructed by providing the two tensors of indices and values, as well as the size of the sparse tensor (when it cannot be inferred from the indices and values tensors) to a function <a class="reference internal" href="generated/torch.sparse_coo_tensor#torch.sparse_coo_tensor" title="torch.sparse_coo_tensor"><code>torch.sparse_coo_tensor()</code></a>.</p> <p>Suppose we want to define a sparse tensor with the entry 3 at location (0, 2), entry 4 at location (1, 0), and entry 5 at location (1, 2). Unspecified elements are assumed to have the same value, fill value, which is zero by default. We would then write:</p> <pre data-language="python">&gt;&gt;&gt; i = [[0, 1, 1],
         [2, 0, 2]]
&gt;&gt;&gt; v =  [3, 4, 5]
&gt;&gt;&gt; s = torch.sparse_coo_tensor(i, v, (2, 3))
&gt;&gt;&gt; s
tensor(indices=tensor([[0, 1, 1],
                       [2, 0, 2]]),
       values=tensor([3, 4, 5]),
       size=(2, 3), nnz=3, layout=torch.sparse_coo)
&gt;&gt;&gt; s.to_dense()
tensor([[0, 0, 3],
        [4, 0, 5]])
</pre> <p>Note that the input <code>i</code> is NOT a list of index tuples. If you want to write your indices this way, you should transpose before passing them to the sparse constructor:</p> <pre data-language="python">&gt;&gt;&gt; i = [[0, 2], [1, 0], [1, 2]]
&gt;&gt;&gt; v =  [3,      4,      5    ]
&gt;&gt;&gt; s = torch.sparse_coo_tensor(list(zip(*i)), v, (2, 3))
&gt;&gt;&gt; # Or another equivalent formulation to get s
&gt;&gt;&gt; s = torch.sparse_coo_tensor(torch.tensor(i).t(), v, (2, 3))
&gt;&gt;&gt; torch.sparse_coo_tensor(i.t(), v, torch.Size([2,3])).to_dense()
tensor([[0, 0, 3],
        [4, 0, 5]])
</pre> <p>An empty sparse COO tensor can be constructed by specifying its size only:</p> <pre data-language="python">&gt;&gt;&gt; torch.sparse_coo_tensor(size=(2, 3))
tensor(indices=tensor([], size=(2, 0)),
       values=tensor([], size=(0,)),
       size=(2, 3), nnz=0, layout=torch.sparse_coo)
</pre>   <h3 id="sparse-hybrid-coo-docs">Sparse hybrid COO tensors</h3> <p id="sparse-hybrid-coo-tensors">PyTorch implements an extension of sparse tensors with scalar values to sparse tensors with (contiguous) tensor values. Such tensors are called hybrid tensors.</p> <p>PyTorch hybrid COO tensor extends the sparse COO tensor by allowing the <code>values</code> tensor to be a multi-dimensional tensor so that we have:</p>  <ul class="simple"> <li>the indices of specified elements are collected in <code>indices</code> tensor of size <code>(sparse_dims, nse)</code> and with element type <code>torch.int64</code>,</li> <li>the corresponding (tensor) values are collected in <code>values</code> tensor of size <code>(nse, dense_dims)</code> and with an arbitrary integer or floating point number element type.</li> </ul>  <div class="admonition note"> <p class="admonition-title">Note</p> <p>We use (M + K)-dimensional tensor to denote a N-dimensional sparse hybrid tensor, where M and K are the numbers of sparse and dense dimensions, respectively, such that M + K == N holds.</p> </div> <p>Suppose we want to create a (2 + 1)-dimensional tensor with the entry [3, 4] at location (0, 2), entry [5, 6] at location (1, 0), and entry [7, 8] at location (1, 2). We would write</p> <pre data-language="python">&gt;&gt;&gt; i = [[0, 1, 1],
         [2, 0, 2]]
&gt;&gt;&gt; v =  [[3, 4], [5, 6], [7, 8]]
&gt;&gt;&gt; s = torch.sparse_coo_tensor(i, v, (2, 3, 2))
&gt;&gt;&gt; s
tensor(indices=tensor([[0, 1, 1],
                       [2, 0, 2]]),
       values=tensor([[3, 4],
                      [5, 6],
                      [7, 8]]),
       size=(2, 3, 2), nnz=3, layout=torch.sparse_coo)
</pre> <pre data-language="python">&gt;&gt;&gt; s.to_dense()
tensor([[[0, 0],
         [0, 0],
         [3, 4]],
        [[5, 6],
         [0, 0],
         [7, 8]]])
</pre> <p>In general, if <code>s</code> is a sparse COO tensor and <code>M =
s.sparse_dim()</code>, <code>K = s.dense_dim()</code>, then we have the following invariants:</p>  <ul class="simple"> <li>
<code>M + K == len(s.shape) == s.ndim</code> - dimensionality of a tensor is the sum of the number of sparse and dense dimensions,</li> <li>
<code>s.indices().shape == (M, nse)</code> - sparse indices are stored explicitly,</li> <li>
<code>s.values().shape == (nse,) + s.shape[M : M + K]</code> - the values of a hybrid tensor are K-dimensional tensors,</li> <li>
<code>s.values().layout == torch.strided</code> - values are stored as strided tensors.</li> </ul>  <div class="admonition note"> <p class="admonition-title">Note</p> <p>Dense dimensions always follow sparse dimensions, that is, mixing of dense and sparse dimensions is not supported.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>To be sure that a constructed sparse tensor has consistent indices, values, and size, the invariant checks can be enabled per tensor creation via <code>check_invariants=True</code> keyword argument, or globally using <a class="reference internal" href="generated/torch.sparse.check_sparse_tensor_invariants#torch.sparse.check_sparse_tensor_invariants" title="torch.sparse.check_sparse_tensor_invariants"><code>torch.sparse.check_sparse_tensor_invariants</code></a> context manager instance. By default, the sparse tensor invariants checks are disabled.</p> </div>   <h3 id="sparse-uncoalesced-coo-docs">Uncoalesced sparse COO tensors</h3> <p id="uncoalesced-sparse-coo-tensors">PyTorch sparse COO tensor format permits sparse <em>uncoalesced</em> tensors, where there may be duplicate coordinates in the indices; in this case, the interpretation is that the value at that index is the sum of all duplicate value entries. For example, one can specify multiple values, <code>3</code> and <code>4</code>, for the same index <code>1</code>, that leads to an 1-D uncoalesced tensor:</p> <pre data-language="python">&gt;&gt;&gt; i = [[1, 1]]
&gt;&gt;&gt; v =  [3, 4]
&gt;&gt;&gt; s=torch.sparse_coo_tensor(i, v, (3,))
&gt;&gt;&gt; s
tensor(indices=tensor([[1, 1]]),
       values=tensor(  [3, 4]),
       size=(3,), nnz=2, layout=torch.sparse_coo)
</pre> <p>while the coalescing process will accumulate the multi-valued elements into a single value using summation:</p> <pre data-language="python">&gt;&gt;&gt; s.coalesce()
tensor(indices=tensor([[1]]),
       values=tensor([7]),
       size=(3,), nnz=1, layout=torch.sparse_coo)
</pre> <p>In general, the output of <a class="reference internal" href="generated/torch.tensor.coalesce#torch.Tensor.coalesce" title="torch.Tensor.coalesce"><code>torch.Tensor.coalesce()</code></a> method is a sparse tensor with the following properties:</p> <ul class="simple"> <li>the indices of specified tensor elements are unique,</li> <li>the indices are sorted in lexicographical order,</li> <li>
<a class="reference internal" href="generated/torch.tensor.is_coalesced#torch.Tensor.is_coalesced" title="torch.Tensor.is_coalesced"><code>torch.Tensor.is_coalesced()</code></a> returns <code>True</code>.</li> </ul> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For the most part, you shouldn’t have to care whether or not a sparse tensor is coalesced or not, as most operations will work identically given a sparse coalesced or uncoalesced tensor.</p> <p>However, some operations can be implemented more efficiently on uncoalesced tensors, and some on coalesced tensors.</p> <p>For instance, addition of sparse COO tensors is implemented by simply concatenating the indices and values tensors:</p> <pre data-language="python">&gt;&gt;&gt; a = torch.sparse_coo_tensor([[1, 1]], [5, 6], (2,))
&gt;&gt;&gt; b = torch.sparse_coo_tensor([[0, 0]], [7, 8], (2,))
&gt;&gt;&gt; a + b
tensor(indices=tensor([[0, 0, 1, 1]]),
       values=tensor([7, 8, 5, 6]),
       size=(2,), nnz=4, layout=torch.sparse_coo)
</pre> <p>If you repeatedly perform an operation that can produce duplicate entries (e.g., <a class="reference internal" href="generated/torch.tensor.add#torch.Tensor.add" title="torch.Tensor.add"><code>torch.Tensor.add()</code></a>), you should occasionally coalesce your sparse tensors to prevent them from growing too large.</p> <p>On the other hand, the lexicographical ordering of indices can be advantageous for implementing algorithms that involve many element selection operations, such as slicing or matrix products.</p> </div>   <h3 id="working-with-sparse-coo-tensors">Working with sparse COO tensors</h3> <p>Let’s consider the following example:</p> <pre data-language="python">&gt;&gt;&gt; i = [[0, 1, 1],
         [2, 0, 2]]
&gt;&gt;&gt; v =  [[3, 4], [5, 6], [7, 8]]
&gt;&gt;&gt; s = torch.sparse_coo_tensor(i, v, (2, 3, 2))
</pre> <p>As mentioned above, a sparse COO tensor is a <a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor"><code>torch.Tensor</code></a> instance and to distinguish it from the <code>Tensor</code> instances that use some other layout, on can use <a class="reference internal" href="generated/torch.tensor.is_sparse#torch.Tensor.is_sparse" title="torch.Tensor.is_sparse"><code>torch.Tensor.is_sparse</code></a> or <code>torch.Tensor.layout</code> properties:</p> <pre data-language="python">&gt;&gt;&gt; isinstance(s, torch.Tensor)
True
&gt;&gt;&gt; s.is_sparse
True
&gt;&gt;&gt; s.layout == torch.sparse_coo
True
</pre> <p>The number of sparse and dense dimensions can be acquired using methods <a class="reference internal" href="generated/torch.tensor.sparse_dim#torch.Tensor.sparse_dim" title="torch.Tensor.sparse_dim"><code>torch.Tensor.sparse_dim()</code></a> and <a class="reference internal" href="generated/torch.tensor.dense_dim#torch.Tensor.dense_dim" title="torch.Tensor.dense_dim"><code>torch.Tensor.dense_dim()</code></a>, respectively. For instance:</p> <pre data-language="python">&gt;&gt;&gt; s.sparse_dim(), s.dense_dim()
(2, 1)
</pre> <p>If <code>s</code> is a sparse COO tensor then its COO format data can be acquired using methods <a class="reference internal" href="generated/torch.tensor.indices#torch.Tensor.indices" title="torch.Tensor.indices"><code>torch.Tensor.indices()</code></a> and <a class="reference internal" href="generated/torch.tensor.values#torch.Tensor.values" title="torch.Tensor.values"><code>torch.Tensor.values()</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Currently, one can acquire the COO format data only when the tensor instance is coalesced:</p> <pre data-language="python">&gt;&gt;&gt; s.indices()
RuntimeError: Cannot get indices on an uncoalesced tensor, please call .coalesce() first
</pre> <p>For acquiring the COO format data of an uncoalesced tensor, use <code>torch.Tensor._values()</code> and <code>torch.Tensor._indices()</code>:</p> <pre data-language="python">&gt;&gt;&gt; s._indices()
tensor([[0, 1, 1],
        [2, 0, 2]])
</pre> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Calling <code>torch.Tensor._values()</code> will return a <em>detached</em> tensor. To track gradients, <code>torch.Tensor.coalesce().values()</code> must be used instead.</p> </div> </div> <p>Constructing a new sparse COO tensor results a tensor that is not coalesced:</p> <pre data-language="python">&gt;&gt;&gt; s.is_coalesced()
False
</pre> <p>but one can construct a coalesced copy of a sparse COO tensor using the <a class="reference internal" href="generated/torch.tensor.coalesce#torch.Tensor.coalesce" title="torch.Tensor.coalesce"><code>torch.Tensor.coalesce()</code></a> method:</p> <pre data-language="python">&gt;&gt;&gt; s2 = s.coalesce()
&gt;&gt;&gt; s2.indices()
tensor([[0, 1, 1],
       [2, 0, 2]])
</pre> <p>When working with uncoalesced sparse COO tensors, one must take into an account the additive nature of uncoalesced data: the values of the same indices are the terms of a sum that evaluation gives the value of the corresponding tensor element. For example, the scalar multiplication on a sparse uncoalesced tensor could be implemented by multiplying all the uncoalesced values with the scalar because <code>c *
(a + b) == c * a + c * b</code> holds. However, any nonlinear operation, say, a square root, cannot be implemented by applying the operation to uncoalesced data because <code>sqrt(a + b) == sqrt(a) + sqrt(b)</code> does not hold in general.</p> <p>Slicing (with positive step) of a sparse COO tensor is supported only for dense dimensions. Indexing is supported for both sparse and dense dimensions:</p> <pre data-language="python">&gt;&gt;&gt; s[1]
tensor(indices=tensor([[0, 2]]),
       values=tensor([[5, 6],
                      [7, 8]]),
       size=(3, 2), nnz=2, layout=torch.sparse_coo)
&gt;&gt;&gt; s[1, 0, 1]
tensor(6)
&gt;&gt;&gt; s[1, 0, 1:]
tensor([6])
</pre> <p>In PyTorch, the fill value of a sparse tensor cannot be specified explicitly and is assumed to be zero in general. However, there exists operations that may interpret the fill value differently. For instance, <a class="reference internal" href="generated/torch.sparse.softmax#torch.sparse.softmax" title="torch.sparse.softmax"><code>torch.sparse.softmax()</code></a> computes the softmax with the assumption that the fill value is negative infinity.</p>    <h2 id="sparse-compressed-docs">Sparse Compressed Tensors</h2> <p id="sparse-compressed-tensors">Sparse Compressed Tensors represents a class of sparse tensors that have a common feature of compressing the indices of a certain dimension using an encoding that enables certain optimizations on linear algebra kernels of sparse compressed tensors. This encoding is based on the <a class="reference external" href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)">Compressed Sparse Row (CSR)</a> format that PyTorch sparse compressed tensors extend with the support of sparse tensor batches, allowing multi-dimensional tensor values, and storing sparse tensor values in dense blocks.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>We use (B + M + K)-dimensional tensor to denote a N-dimensional sparse compressed hybrid tensor, where B, M, and K are the numbers of batch, sparse, and dense dimensions, respectively, such that <code>B + M + K == N</code> holds. The number of sparse dimensions for sparse compressed tensors is always two, <code>M == 2</code>.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>We say that an indices tensor <code>compressed_indices</code> uses CSR encoding if the following invariants are satisfied:</p> <ul class="simple"> <li>
<code>compressed_indices</code> is a contiguous strided 32 or 64 bit integer tensor</li> <li>
<code>compressed_indices</code> shape is <code>(*batchsize,
compressed_dim_size + 1)</code> where <code>compressed_dim_size</code> is the number of compressed dimensions (e.g. rows or columns)</li> <li>
<code>compressed_indices[..., 0] == 0</code> where <code>...</code> denotes batch indices</li> <li>
<code>compressed_indices[..., compressed_dim_size] == nse</code> where <code>nse</code> is the number of specified elements</li> <li>
<code>0 &lt;= compressed_indices[..., i] - compressed_indices[..., i -
1] &lt;= plain_dim_size</code> for <code>i=1, ..., compressed_dim_size</code>, where <code>plain_dim_size</code> is the number of plain dimensions (orthogonal to compressed dimensions, e.g. columns or rows).</li> </ul> <p>To be sure that a constructed sparse tensor has consistent indices, values, and size, the invariant checks can be enabled per tensor creation via <code>check_invariants=True</code> keyword argument, or globally using <a class="reference internal" href="generated/torch.sparse.check_sparse_tensor_invariants#torch.sparse.check_sparse_tensor_invariants" title="torch.sparse.check_sparse_tensor_invariants"><code>torch.sparse.check_sparse_tensor_invariants</code></a> context manager instance. By default, the sparse tensor invariants checks are disabled.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The generalization of sparse compressed layouts to N-dimensional tensors can lead to some confusion regarding the count of specified elements. When a sparse compressed tensor contains batch dimensions the number of specified elements will correspond to the number of such elements per-batch. When a sparse compressed tensor has dense dimensions the element considered is now the K-dimensional array. Also for block sparse compressed layouts the 2-D block is considered as the element being specified. Take as an example a 3-dimensional block sparse tensor, with one batch dimension of length <code>b</code>, and a block shape of <code>p, q</code>. If this tensor has <code>n</code> specified elements, then in fact we have <code>n</code> blocks specified per batch. This tensor would have <code>values</code> with shape <code>(b, n, p, q)</code>. This interpretation of the number of specified elements comes from all sparse compressed layouts being derived from the compression of a 2-dimensional matrix. Batch dimensions are treated as stacking of sparse matrices, dense dimensions change the meaning of the element from a simple scalar value to an array with its own dimensions.</p> </div>  <h3 id="sparse-csr-docs">Sparse CSR Tensor</h3> <p id="sparse-csr-tensor">The primary advantage of the CSR format over the COO format is better use of storage and much faster computation operations such as sparse matrix-vector multiplication using MKL and MAGMA backends.</p> <p>In the simplest case, a (0 + 2 + 0)-dimensional sparse CSR tensor consists of three 1-D tensors: <code>crow_indices</code>, <code>col_indices</code> and <code>values</code>:</p>  <ul class="simple"> <li>The <code>crow_indices</code> tensor consists of compressed row indices. This is a 1-D tensor of size <code>nrows + 1</code> (the number of rows plus 1). The last element of <code>crow_indices</code> is the number of specified elements, <code>nse</code>. This tensor encodes the index in <code>values</code> and <code>col_indices</code> depending on where the given row starts. Each successive number in the tensor subtracted by the number before it denotes the number of elements in a given row.</li> <li>The <code>col_indices</code> tensor contains the column indices of each element. This is a 1-D tensor of size <code>nse</code>.</li> <li>The <code>values</code> tensor contains the values of the CSR tensor elements. This is a 1-D tensor of size <code>nse</code>.</li> </ul>  <div class="admonition note"> <p class="admonition-title">Note</p> <p>The index tensors <code>crow_indices</code> and <code>col_indices</code> should have element type either <code>torch.int64</code> (default) or <code>torch.int32</code>. If you want to use MKL-enabled matrix operations, use <code>torch.int32</code>. This is as a result of the default linking of pytorch being with MKL LP64, which uses 32 bit integer indexing.</p> </div> <p>In the general case, the (B + 2 + K)-dimensional sparse CSR tensor consists of two (B + 1)-dimensional index tensors <code>crow_indices</code> and <code>col_indices</code>, and of (1 + K)-dimensional <code>values</code> tensor such that</p>  <ul class="simple"> <li><code>crow_indices.shape == (*batchsize, nrows + 1)</code></li> <li><code>col_indices.shape == (*batchsize, nse)</code></li> <li><code>values.shape == (nse, *densesize)</code></li> </ul>  <p>while the shape of the sparse CSR tensor is <code>(*batchsize, nrows,
ncols, *densesize)</code> where <code>len(batchsize) == B</code> and <code>len(densesize) == K</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The batches of sparse CSR tensors are dependent: the number of specified elements in all batches must be the same. This somewhat artificial constraint allows efficient storage of the indices of different CSR batches.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The number of sparse and dense dimensions can be acquired using <a class="reference internal" href="generated/torch.tensor.sparse_dim#torch.Tensor.sparse_dim" title="torch.Tensor.sparse_dim"><code>torch.Tensor.sparse_dim()</code></a> and <a class="reference internal" href="generated/torch.tensor.dense_dim#torch.Tensor.dense_dim" title="torch.Tensor.dense_dim"><code>torch.Tensor.dense_dim()</code></a> methods. The batch dimensions can be computed from the tensor shape: <code>batchsize = tensor.shape[:-tensor.sparse_dim() -
tensor.dense_dim()]</code>.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The memory consumption of a sparse CSR tensor is at least <code>(nrows * 8 + (8 + &lt;size of element type in bytes&gt; *
prod(densesize)) * nse) * prod(batchsize)</code> bytes (plus a constant overhead from storing other tensor data).</p> <p>With the same example data of <a class="reference internal" href="#sparse-coo-docs"><span class="std std-ref">the note in sparse COO format introduction</span></a>, the memory consumption of a 10 000 x 10 000 tensor with 100 000 non-zero 32-bit floating point numbers is at least <code>(10000 * 8 + (8 + 4 * 1) * 100 000) * 1 = 1 280 000</code> bytes when using CSR tensor layout. Notice the 1.6 and 310 fold savings from using CSR storage format compared to using the COO and strided formats, respectively.</p> </div>  <h4 id="construction-of-csr-tensors">Construction of CSR tensors</h4> <p>Sparse CSR tensors can be directly constructed by using the <a class="reference internal" href="generated/torch.sparse_csr_tensor#torch.sparse_csr_tensor" title="torch.sparse_csr_tensor"><code>torch.sparse_csr_tensor()</code></a> function. The user must supply the row and column indices and values tensors separately where the row indices must be specified using the CSR compression encoding. The <code>size</code> argument is optional and will be deduced from the <code>crow_indices</code> and <code>col_indices</code> if it is not present.</p> <pre data-language="python">&gt;&gt;&gt; crow_indices = torch.tensor([0, 2, 4])
&gt;&gt;&gt; col_indices = torch.tensor([0, 1, 0, 1])
&gt;&gt;&gt; values = torch.tensor([1, 2, 3, 4])
&gt;&gt;&gt; csr = torch.sparse_csr_tensor(crow_indices, col_indices, values, dtype=torch.float64)
&gt;&gt;&gt; csr
tensor(crow_indices=tensor([0, 2, 4]),
       col_indices=tensor([0, 1, 0, 1]),
       values=tensor([1., 2., 3., 4.]), size=(2, 2), nnz=4,
       dtype=torch.float64)
&gt;&gt;&gt; csr.to_dense()
tensor([[1., 2.],
        [3., 4.]], dtype=torch.float64)
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The values of sparse dimensions in deduced <code>size</code> is computed from the size of <code>crow_indices</code> and the maximal index value in <code>col_indices</code>. If the number of columns needs to be larger than in the deduced <code>size</code> then the <code>size</code> argument must be specified explicitly.</p> </div> <p>The simplest way of constructing a 2-D sparse CSR tensor from a strided or sparse COO tensor is to use <a class="reference internal" href="generated/torch.tensor.to_sparse_csr#torch.Tensor.to_sparse_csr" title="torch.Tensor.to_sparse_csr"><code>torch.Tensor.to_sparse_csr()</code></a> method. Any zeros in the (strided) tensor will be interpreted as missing values in the sparse tensor:</p> <pre data-language="python">&gt;&gt;&gt; a = torch.tensor([[0, 0, 1, 0], [1, 2, 0, 0], [0, 0, 0, 0]], dtype=torch.float64)
&gt;&gt;&gt; sp = a.to_sparse_csr()
&gt;&gt;&gt; sp
tensor(crow_indices=tensor([0, 1, 3, 3]),
      col_indices=tensor([2, 0, 1]),
      values=tensor([1., 1., 2.]), size=(3, 4), nnz=3, dtype=torch.float64)
</pre>   <h4 id="csr-tensor-operations">CSR Tensor Operations</h4> <p>The sparse matrix-vector multiplication can be performed with the <code>tensor.matmul()</code> method. This is currently the only math operation supported on CSR tensors.</p> <pre data-language="python">&gt;&gt;&gt; vec = torch.randn(4, 1, dtype=torch.float64)
&gt;&gt;&gt; sp.matmul(vec)
tensor([[0.9078],
        [1.3180],
        [0.0000]], dtype=torch.float64)
</pre>    <h3 id="sparse-csc-docs">Sparse CSC Tensor</h3> <p id="sparse-csc-tensor">The sparse CSC (Compressed Sparse Column) tensor format implements the CSC format for storage of 2 dimensional tensors with an extension to supporting batches of sparse CSC tensors and values being multi-dimensional tensors.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Sparse CSC tensor is essentially a transpose of the sparse CSR tensor when the transposition is about swapping the sparse dimensions.</p> </div> <p>Similarly to <a class="reference internal" href="#sparse-csr-docs"><span class="std std-ref">sparse CSR tensors</span></a>, a sparse CSC tensor consists of three tensors: <code>ccol_indices</code>, <code>row_indices</code> and <code>values</code>:</p>  <ul class="simple"> <li>The <code>ccol_indices</code> tensor consists of compressed column indices. This is a (B + 1)-D tensor of shape <code>(*batchsize, ncols + 1)</code>. The last element is the number of specified elements, <code>nse</code>. This tensor encodes the index in <code>values</code> and <code>row_indices</code> depending on where the given column starts. Each successive number in the tensor subtracted by the number before it denotes the number of elements in a given column.</li> <li>The <code>row_indices</code> tensor contains the row indices of each element. This is a (B + 1)-D tensor of shape <code>(*batchsize, nse)</code>.</li> <li>The <code>values</code> tensor contains the values of the CSC tensor elements. This is a (1 + K)-D tensor of shape <code>(nse, *densesize)</code>.</li> </ul>   <h4 id="construction-of-csc-tensors">Construction of CSC tensors</h4> <p>Sparse CSC tensors can be directly constructed by using the <a class="reference internal" href="generated/torch.sparse_csc_tensor#torch.sparse_csc_tensor" title="torch.sparse_csc_tensor"><code>torch.sparse_csc_tensor()</code></a> function. The user must supply the row and column indices and values tensors separately where the column indices must be specified using the CSR compression encoding. The <code>size</code> argument is optional and will be deduced from the <code>row_indices</code> and <code>ccol_indices</code> tensors if it is not present.</p> <pre data-language="python">&gt;&gt;&gt; ccol_indices = torch.tensor([0, 2, 4])
&gt;&gt;&gt; row_indices = torch.tensor([0, 1, 0, 1])
&gt;&gt;&gt; values = torch.tensor([1, 2, 3, 4])
&gt;&gt;&gt; csc = torch.sparse_csc_tensor(ccol_indices, row_indices, values, dtype=torch.float64)
&gt;&gt;&gt; csc
tensor(ccol_indices=tensor([0, 2, 4]),
       row_indices=tensor([0, 1, 0, 1]),
       values=tensor([1., 2., 3., 4.]), size=(2, 2), nnz=4,
       dtype=torch.float64, layout=torch.sparse_csc)
&gt;&gt;&gt; csc.to_dense()
tensor([[1., 3.],
        [2., 4.]], dtype=torch.float64)
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The sparse CSC tensor constructor function has the compressed column indices argument before the row indices argument.</p> </div> <p>The (0 + 2 + 0)-dimensional sparse CSC tensors can be constructed from any two-dimensional tensor using <a class="reference internal" href="generated/torch.tensor.to_sparse_csc#torch.Tensor.to_sparse_csc" title="torch.Tensor.to_sparse_csc"><code>torch.Tensor.to_sparse_csc()</code></a> method. Any zeros in the (strided) tensor will be interpreted as missing values in the sparse tensor:</p> <pre data-language="python">&gt;&gt;&gt; a = torch.tensor([[0, 0, 1, 0], [1, 2, 0, 0], [0, 0, 0, 0]], dtype=torch.float64)
&gt;&gt;&gt; sp = a.to_sparse_csc()
&gt;&gt;&gt; sp
tensor(ccol_indices=tensor([0, 1, 2, 3, 3]),
       row_indices=tensor([1, 1, 0]),
       values=tensor([1., 2., 1.]), size=(3, 4), nnz=3, dtype=torch.float64,
       layout=torch.sparse_csc)
</pre>    <h3 id="sparse-bsr-docs">Sparse BSR Tensor</h3> <p id="sparse-bsr-tensor">The sparse BSR (Block compressed Sparse Row) tensor format implements the BSR format for storage of two-dimensional tensors with an extension to supporting batches of sparse BSR tensors and values being blocks of multi-dimensional tensors.</p> <p>A sparse BSR tensor consists of three tensors: <code>crow_indices</code>, <code>col_indices</code> and <code>values</code>:</p>  <ul class="simple"> <li>The <code>crow_indices</code> tensor consists of compressed row indices. This is a (B + 1)-D tensor of shape <code>(*batchsize,
nrowblocks + 1)</code>. The last element is the number of specified blocks, <code>nse</code>. This tensor encodes the index in <code>values</code> and <code>col_indices</code> depending on where the given column block starts. Each successive number in the tensor subtracted by the number before it denotes the number of blocks in a given row.</li> <li>The <code>col_indices</code> tensor contains the column block indices of each element. This is a (B + 1)-D tensor of shape <code>(*batchsize,
nse)</code>.</li> <li>The <code>values</code> tensor contains the values of the sparse BSR tensor elements collected into two-dimensional blocks. This is a (1 + 2 + K)-D tensor of shape <code>(nse, nrowblocks, ncolblocks,
*densesize)</code>.</li> </ul>   <h4 id="construction-of-bsr-tensors">Construction of BSR tensors</h4> <p>Sparse BSR tensors can be directly constructed by using the <a class="reference internal" href="generated/torch.sparse_bsr_tensor#torch.sparse_bsr_tensor" title="torch.sparse_bsr_tensor"><code>torch.sparse_bsr_tensor()</code></a> function. The user must supply the row and column block indices and values tensors separately where the row block indices must be specified using the CSR compression encoding. The <code>size</code> argument is optional and will be deduced from the <code>crow_indices</code> and <code>col_indices</code> tensors if it is not present.</p> <pre data-language="python">&gt;&gt;&gt; crow_indices = torch.tensor([0, 2, 4])
&gt;&gt;&gt; col_indices = torch.tensor([0, 1, 0, 1])
&gt;&gt;&gt; values = torch.tensor([[[0, 1, 2], [6, 7, 8]],
...                        [[3, 4, 5], [9, 10, 11]],
...                        [[12, 13, 14], [18, 19, 20]],
...                        [[15, 16, 17], [21, 22, 23]]])
&gt;&gt;&gt; bsr = torch.sparse_bsr_tensor(crow_indices, col_indices, values, dtype=torch.float64)
&gt;&gt;&gt; bsr
tensor(crow_indices=tensor([0, 2, 4]),
       col_indices=tensor([0, 1, 0, 1]),
       values=tensor([[[ 0.,  1.,  2.],
                       [ 6.,  7.,  8.]],
                      [[ 3.,  4.,  5.],
                       [ 9., 10., 11.]],
                      [[12., 13., 14.],
                       [18., 19., 20.]],
                      [[15., 16., 17.],
                       [21., 22., 23.]]]),
       size=(4, 6), nnz=4, dtype=torch.float64, layout=torch.sparse_bsr)
&gt;&gt;&gt; bsr.to_dense()
tensor([[ 0.,  1.,  2.,  3.,  4.,  5.],
        [ 6.,  7.,  8.,  9., 10., 11.],
        [12., 13., 14., 15., 16., 17.],
        [18., 19., 20., 21., 22., 23.]], dtype=torch.float64)
</pre> <p>The (0 + 2 + 0)-dimensional sparse BSR tensors can be constructed from any two-dimensional tensor using <a class="reference internal" href="generated/torch.tensor.to_sparse_bsr#torch.Tensor.to_sparse_bsr" title="torch.Tensor.to_sparse_bsr"><code>torch.Tensor.to_sparse_bsr()</code></a> method that also requires the specification of the values block size:</p> <pre data-language="python">&gt;&gt;&gt; dense = torch.tensor([[0, 1, 2, 3, 4, 5],
...                       [6, 7, 8, 9, 10, 11],
...                       [12, 13, 14, 15, 16, 17],
...                       [18, 19, 20, 21, 22, 23]])
&gt;&gt;&gt; bsr = dense.to_sparse_bsr(blocksize=(2, 3))
&gt;&gt;&gt; bsr
tensor(crow_indices=tensor([0, 2, 4]),
       col_indices=tensor([0, 1, 0, 1]),
       values=tensor([[[ 0,  1,  2],
                       [ 6,  7,  8]],
                      [[ 3,  4,  5],
                       [ 9, 10, 11]],
                      [[12, 13, 14],
                       [18, 19, 20]],
                      [[15, 16, 17],
                       [21, 22, 23]]]), size=(4, 6), nnz=4,
       layout=torch.sparse_bsr)
</pre>    <h3 id="sparse-bsc-docs">Sparse BSC Tensor</h3> <p id="sparse-bsc-tensor">The sparse BSC (Block compressed Sparse Column) tensor format implements the BSC format for storage of two-dimensional tensors with an extension to supporting batches of sparse BSC tensors and values being blocks of multi-dimensional tensors.</p> <p>A sparse BSC tensor consists of three tensors: <code>ccol_indices</code>, <code>row_indices</code> and <code>values</code>:</p>  <ul class="simple"> <li>The <code>ccol_indices</code> tensor consists of compressed column indices. This is a (B + 1)-D tensor of shape <code>(*batchsize,
ncolblocks + 1)</code>. The last element is the number of specified blocks, <code>nse</code>. This tensor encodes the index in <code>values</code> and <code>row_indices</code> depending on where the given row block starts. Each successive number in the tensor subtracted by the number before it denotes the number of blocks in a given column.</li> <li>The <code>row_indices</code> tensor contains the row block indices of each element. This is a (B + 1)-D tensor of shape <code>(*batchsize,
nse)</code>.</li> <li>The <code>values</code> tensor contains the values of the sparse BSC tensor elements collected into two-dimensional blocks. This is a (1 + 2 + K)-D tensor of shape <code>(nse, nrowblocks, ncolblocks,
*densesize)</code>.</li> </ul>   <h4 id="construction-of-bsc-tensors">Construction of BSC tensors</h4> <p>Sparse BSC tensors can be directly constructed by using the <a class="reference internal" href="generated/torch.sparse_bsc_tensor#torch.sparse_bsc_tensor" title="torch.sparse_bsc_tensor"><code>torch.sparse_bsc_tensor()</code></a> function. The user must supply the row and column block indices and values tensors separately where the column block indices must be specified using the CSR compression encoding. The <code>size</code> argument is optional and will be deduced from the <code>ccol_indices</code> and <code>row_indices</code> tensors if it is not present.</p> <pre data-language="python">&gt;&gt;&gt; ccol_indices = torch.tensor([0, 2, 4])
&gt;&gt;&gt; row_indices = torch.tensor([0, 1, 0, 1])
&gt;&gt;&gt; values = torch.tensor([[[0, 1, 2], [6, 7, 8]],
...                        [[3, 4, 5], [9, 10, 11]],
...                        [[12, 13, 14], [18, 19, 20]],
...                        [[15, 16, 17], [21, 22, 23]]])
&gt;&gt;&gt; bsc = torch.sparse_bsc_tensor(ccol_indices, row_indices, values, dtype=torch.float64)
&gt;&gt;&gt; bsc
tensor(ccol_indices=tensor([0, 2, 4]),
       row_indices=tensor([0, 1, 0, 1]),
       values=tensor([[[ 0.,  1.,  2.],
                       [ 6.,  7.,  8.]],
                      [[ 3.,  4.,  5.],
                       [ 9., 10., 11.]],
                      [[12., 13., 14.],
                       [18., 19., 20.]],
                      [[15., 16., 17.],
                       [21., 22., 23.]]]), size=(4, 6), nnz=4,
       dtype=torch.float64, layout=torch.sparse_bsc)
</pre>    <h3 id="tools-for-working-with-sparse-compressed-tensors">Tools for working with sparse compressed tensors</h3> <p>All sparse compressed tensors — CSR, CSC, BSR, and BSC tensors — are conceptionally very similar in that their indices data is split into two parts: so-called compressed indices that use the CSR encoding, and so-called plain indices that are orthogonal to the compressed indices. This allows various tools on these tensors to share the same implementations that are parameterized by tensor layout.</p>  <h4 id="construction-of-sparse-compressed-tensors">Construction of sparse compressed tensors</h4> <p>Sparse CSR, CSC, BSR, and CSC tensors can be constructed by using <a class="reference internal" href="generated/torch.sparse_compressed_tensor#torch.sparse_compressed_tensor" title="torch.sparse_compressed_tensor"><code>torch.sparse_compressed_tensor()</code></a> function that have the same interface as the above discussed constructor functions <a class="reference internal" href="generated/torch.sparse_csr_tensor#torch.sparse_csr_tensor" title="torch.sparse_csr_tensor"><code>torch.sparse_csr_tensor()</code></a>, <a class="reference internal" href="generated/torch.sparse_csc_tensor#torch.sparse_csc_tensor" title="torch.sparse_csc_tensor"><code>torch.sparse_csc_tensor()</code></a>, <a class="reference internal" href="generated/torch.sparse_bsr_tensor#torch.sparse_bsr_tensor" title="torch.sparse_bsr_tensor"><code>torch.sparse_bsr_tensor()</code></a>, and <a class="reference internal" href="generated/torch.sparse_bsc_tensor#torch.sparse_bsc_tensor" title="torch.sparse_bsc_tensor"><code>torch.sparse_bsc_tensor()</code></a>, respectively, but with an extra required <code>layout</code> argument. The following example illustrates a method of constructing CSR and CSC tensors using the same input data by specifying the corresponding layout parameter to the <a class="reference internal" href="generated/torch.sparse_compressed_tensor#torch.sparse_compressed_tensor" title="torch.sparse_compressed_tensor"><code>torch.sparse_compressed_tensor()</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; compressed_indices = torch.tensor([0, 2, 4])
&gt;&gt;&gt; plain_indices = torch.tensor([0, 1, 0, 1])
&gt;&gt;&gt; values = torch.tensor([1, 2, 3, 4])
&gt;&gt;&gt; csr = torch.sparse_compressed_tensor(compressed_indices, plain_indices, values, layout=torch.sparse_csr)
&gt;&gt;&gt; csr
tensor(crow_indices=tensor([0, 2, 4]),
       col_indices=tensor([0, 1, 0, 1]),
       values=tensor([1, 2, 3, 4]), size=(2, 2), nnz=4,
       layout=torch.sparse_csr)
&gt;&gt;&gt; csc = torch.sparse_compressed_tensor(compressed_indices, plain_indices, values, layout=torch.sparse_csc)
&gt;&gt;&gt; csc
tensor(ccol_indices=tensor([0, 2, 4]),
       row_indices=tensor([0, 1, 0, 1]),
       values=tensor([1, 2, 3, 4]), size=(2, 2), nnz=4,
       layout=torch.sparse_csc)
&gt;&gt;&gt; (csr.transpose(0, 1).to_dense() == csc.to_dense()).all()
tensor(True)
</pre>     <h2 id="sparse-ops-docs">Supported operations</h2>  <h3 id="supported-operations">Linear Algebra operations</h3> <p>The following table summarizes supported Linear Algebra operations on sparse matrices where the operands layouts may vary. Here <code>T[layout]</code> denotes a tensor with a given layout. Similarly, <code>M[layout]</code> denotes a matrix (2-D PyTorch tensor), and <code>V[layout]</code> denotes a vector (1-D PyTorch tensor). In addition, <code>f</code> denotes a scalar (float or 0-D PyTorch tensor), <code>*</code> is element-wise multiplication, and <code>@</code> is matrix multiplication.</p> <table class="colwidths-given docutils colwidths-auto align-default">  <thead> <tr>
<th class="head"><p>PyTorch operation</p></th> <th class="head"><p>Sparse grad?</p></th> <th class="head"><p>Layout signature</p></th> </tr> </thead>  <tr>
<td><p><a class="reference internal" href="generated/torch.mv#torch.mv" title="torch.mv"><code>torch.mv()</code></a></p></td> <td><p>no</p></td> <td><p><code>M[sparse_coo] @ V[strided] -&gt; V[strided]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.mv#torch.mv" title="torch.mv"><code>torch.mv()</code></a></p></td> <td><p>no</p></td> <td><p><code>M[sparse_csr] @ V[strided] -&gt; V[strided]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.matmul#torch.matmul" title="torch.matmul"><code>torch.matmul()</code></a></p></td> <td><p>no</p></td> <td><p><code>M[sparse_coo] @ M[strided] -&gt; M[strided]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.matmul#torch.matmul" title="torch.matmul"><code>torch.matmul()</code></a></p></td> <td><p>no</p></td> <td><p><code>M[sparse_csr] @ M[strided] -&gt; M[strided]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.matmul#torch.matmul" title="torch.matmul"><code>torch.matmul()</code></a></p></td> <td><p>no</p></td> <td><p><code>M[SparseSemiStructured] @ M[strided] -&gt; M[strided]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.matmul#torch.matmul" title="torch.matmul"><code>torch.matmul()</code></a></p></td> <td><p>no</p></td> <td><p><code>M[strided] @ M[SparseSemiStructured] -&gt; M[strided]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.mm#torch.mm" title="torch.mm"><code>torch.mm()</code></a></p></td> <td><p>no</p></td> <td><p><code>M[sparse_coo] @ M[strided] -&gt; M[strided]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.mm#torch.mm" title="torch.mm"><code>torch.mm()</code></a></p></td> <td><p>no</p></td> <td><p><code>M[SparseSemiStructured] @ M[strided] -&gt; M[strided]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.mm#torch.mm" title="torch.mm"><code>torch.mm()</code></a></p></td> <td><p>no</p></td> <td><p><code>M[strided] @ M[SparseSemiStructured] -&gt; M[strided]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.sparse.mm#torch.sparse.mm" title="torch.sparse.mm"><code>torch.sparse.mm()</code></a></p></td> <td><p>yes</p></td> <td><p><code>M[sparse_coo] @ M[strided] -&gt; M[strided]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.smm#torch.smm" title="torch.smm"><code>torch.smm()</code></a></p></td> <td><p>no</p></td> <td><p><code>M[sparse_coo] @ M[strided] -&gt; M[sparse_coo]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.hspmm#torch.hspmm" title="torch.hspmm"><code>torch.hspmm()</code></a></p></td> <td><p>no</p></td> <td><p><code>M[sparse_coo] @ M[strided] -&gt; M[hybrid sparse_coo]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.bmm#torch.bmm" title="torch.bmm"><code>torch.bmm()</code></a></p></td> <td><p>no</p></td> <td><p><code>T[sparse_coo] @ T[strided] -&gt; T[strided]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.addmm#torch.addmm" title="torch.addmm"><code>torch.addmm()</code></a></p></td> <td><p>no</p></td> <td><p><code>f * M[strided] + f * (M[sparse_coo] @ M[strided]) -&gt; M[strided]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.addmm#torch.addmm" title="torch.addmm"><code>torch.addmm()</code></a></p></td> <td><p>no</p></td> <td><p><code>f * M[strided] + f * (M[SparseSemiStructured] @ M[strided]) -&gt; M[strided]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.addmm#torch.addmm" title="torch.addmm"><code>torch.addmm()</code></a></p></td> <td><p>no</p></td> <td><p><code>f * M[strided] + f * (M[strided] @ M[SparseSemiStructured]) -&gt; M[strided]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.sparse.addmm#torch.sparse.addmm" title="torch.sparse.addmm"><code>torch.sparse.addmm()</code></a></p></td> <td><p>yes</p></td> <td><p><code>f * M[strided] + f * (M[sparse_coo] @ M[strided]) -&gt; M[strided]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.sspaddmm#torch.sspaddmm" title="torch.sspaddmm"><code>torch.sspaddmm()</code></a></p></td> <td><p>no</p></td> <td><p><code>f * M[sparse_coo] + f * (M[sparse_coo] @ M[strided]) -&gt; M[sparse_coo]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.lobpcg#torch.lobpcg" title="torch.lobpcg"><code>torch.lobpcg()</code></a></p></td> <td><p>no</p></td> <td><p><code>GENEIG(M[sparse_coo]) -&gt; M[strided], M[strided]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.pca_lowrank#torch.pca_lowrank" title="torch.pca_lowrank"><code>torch.pca_lowrank()</code></a></p></td> <td><p>yes</p></td> <td><p><code>PCA(M[sparse_coo]) -&gt; M[strided], M[strided], M[strided]</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.svd_lowrank#torch.svd_lowrank" title="torch.svd_lowrank"><code>torch.svd_lowrank()</code></a></p></td> <td><p>yes</p></td> <td><p><code>SVD(M[sparse_coo]) -&gt; M[strided], M[strided], M[strided]</code></p></td> </tr>  </table> <p>where “Sparse grad?” column indicates if the PyTorch operation supports backward with respect to sparse matrix argument. All PyTorch operations, except <a class="reference internal" href="generated/torch.smm#torch.smm" title="torch.smm"><code>torch.smm()</code></a>, support backward with respect to strided matrix arguments.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Currently, PyTorch does not support matrix multiplication with the layout signature <code>M[strided] @ M[sparse_coo]</code>. However, applications can still compute this using the matrix relation <code>D @
S == (S.t() @ D.t()).t()</code>.</p> </div>   <h3 id="tensor-methods-and-sparse">Tensor methods and sparse</h3> <p>The following Tensor methods are related to sparse tensors:</p> <table class="autosummary longtable docutils colwidths-auto align-default">  <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.is_sparse#torch.Tensor.is_sparse" title="torch.Tensor.is_sparse"><code>Tensor.is_sparse</code></a></p></td> <td><p>Is <code>True</code> if the Tensor uses sparse COO storage layout, <code>False</code> otherwise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.is_sparse_csr#torch.Tensor.is_sparse_csr" title="torch.Tensor.is_sparse_csr"><code>Tensor.is_sparse_csr</code></a></p></td> <td><p>Is <code>True</code> if the Tensor uses sparse CSR storage layout, <code>False</code> otherwise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.dense_dim#torch.Tensor.dense_dim" title="torch.Tensor.dense_dim"><code>Tensor.dense_dim</code></a></p></td> <td><p>Return the number of dense dimensions in a <a class="reference internal" href="#sparse-docs"><span class="std std-ref">sparse tensor</span></a> <code>self</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.sparse_dim#torch.Tensor.sparse_dim" title="torch.Tensor.sparse_dim"><code>Tensor.sparse_dim</code></a></p></td> <td><p>Return the number of sparse dimensions in a <a class="reference internal" href="#sparse-docs"><span class="std std-ref">sparse tensor</span></a> <code>self</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.sparse_mask#torch.Tensor.sparse_mask" title="torch.Tensor.sparse_mask"><code>Tensor.sparse_mask</code></a></p></td> <td><p>Returns a new <a class="reference internal" href="#sparse-docs"><span class="std std-ref">sparse tensor</span></a> with values from a strided tensor <code>self</code> filtered by the indices of the sparse tensor <code>mask</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.to_sparse#torch.Tensor.to_sparse" title="torch.Tensor.to_sparse"><code>Tensor.to_sparse</code></a></p></td> <td><p>Returns a sparse copy of the tensor.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.to_sparse_coo#torch.Tensor.to_sparse_coo" title="torch.Tensor.to_sparse_coo"><code>Tensor.to_sparse_coo</code></a></p></td> <td><p>Convert a tensor to <a class="reference internal" href="#sparse-coo-docs"><span class="std std-ref">coordinate format</span></a>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.to_sparse_csr#torch.Tensor.to_sparse_csr" title="torch.Tensor.to_sparse_csr"><code>Tensor.to_sparse_csr</code></a></p></td> <td><p>Convert a tensor to compressed row storage format (CSR).</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.to_sparse_csc#torch.Tensor.to_sparse_csc" title="torch.Tensor.to_sparse_csc"><code>Tensor.to_sparse_csc</code></a></p></td> <td><p>Convert a tensor to compressed column storage (CSC) format.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.to_sparse_bsr#torch.Tensor.to_sparse_bsr" title="torch.Tensor.to_sparse_bsr"><code>Tensor.to_sparse_bsr</code></a></p></td> <td><p>Convert a tensor to a block sparse row (BSR) storage format of given blocksize.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.to_sparse_bsc#torch.Tensor.to_sparse_bsc" title="torch.Tensor.to_sparse_bsc"><code>Tensor.to_sparse_bsc</code></a></p></td> <td><p>Convert a tensor to a block sparse column (BSC) storage format of given blocksize.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.to_dense#torch.Tensor.to_dense" title="torch.Tensor.to_dense"><code>Tensor.to_dense</code></a></p></td> <td><p>Creates a strided copy of <code>self</code> if <code>self</code> is not a strided tensor, otherwise returns <code>self</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.values#torch.Tensor.values" title="torch.Tensor.values"><code>Tensor.values</code></a></p></td> <td><p>Return the values tensor of a <a class="reference internal" href="#sparse-coo-docs"><span class="std std-ref">sparse COO tensor</span></a>.</p></td> </tr>  </table> <p>The following Tensor methods are specific to sparse COO tensors:</p> <table class="autosummary longtable docutils colwidths-auto align-default">  <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.coalesce#torch.Tensor.coalesce" title="torch.Tensor.coalesce"><code>Tensor.coalesce</code></a></p></td> <td><p>Returns a coalesced copy of <code>self</code> if <code>self</code> is an <a class="reference internal" href="#sparse-uncoalesced-coo-docs"><span class="std std-ref">uncoalesced tensor</span></a>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.sparse_resize_#torch.Tensor.sparse_resize_" title="torch.Tensor.sparse_resize_"><code>Tensor.sparse_resize_</code></a></p></td> <td><p>Resizes <code>self</code> <a class="reference internal" href="#sparse-docs"><span class="std std-ref">sparse tensor</span></a> to the desired size and the number of sparse and dense dimensions.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.sparse_resize_and_clear_#torch.Tensor.sparse_resize_and_clear_" title="torch.Tensor.sparse_resize_and_clear_"><code>Tensor.sparse_resize_and_clear_</code></a></p></td> <td><p>Removes all specified elements from a <a class="reference internal" href="#sparse-docs"><span class="std std-ref">sparse tensor</span></a> <code>self</code> and resizes <code>self</code> to the desired size and the number of sparse and dense dimensions.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.is_coalesced#torch.Tensor.is_coalesced" title="torch.Tensor.is_coalesced"><code>Tensor.is_coalesced</code></a></p></td> <td><p>Returns <code>True</code> if <code>self</code> is a <a class="reference internal" href="#sparse-coo-docs"><span class="std std-ref">sparse COO tensor</span></a> that is coalesced, <code>False</code> otherwise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.indices#torch.Tensor.indices" title="torch.Tensor.indices"><code>Tensor.indices</code></a></p></td> <td><p>Return the indices tensor of a <a class="reference internal" href="#sparse-coo-docs"><span class="std std-ref">sparse COO tensor</span></a>.</p></td> </tr>  </table> <p>The following methods are specific to <a class="reference internal" href="#sparse-csr-docs"><span class="std std-ref">sparse CSR tensors</span></a> and <a class="reference internal" href="#sparse-bsr-docs"><span class="std std-ref">sparse BSR tensors</span></a>:</p> <table class="autosummary longtable docutils colwidths-auto align-default">  <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.crow_indices#torch.Tensor.crow_indices" title="torch.Tensor.crow_indices"><code>Tensor.crow_indices</code></a></p></td> <td><p>Returns the tensor containing the compressed row indices of the <code>self</code> tensor when <code>self</code> is a sparse CSR tensor of layout <code>sparse_csr</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.col_indices#torch.Tensor.col_indices" title="torch.Tensor.col_indices"><code>Tensor.col_indices</code></a></p></td> <td><p>Returns the tensor containing the column indices of the <code>self</code> tensor when <code>self</code> is a sparse CSR tensor of layout <code>sparse_csr</code>.</p></td> </tr>  </table> <p>The following methods are specific to <a class="reference internal" href="#sparse-csc-docs"><span class="std std-ref">sparse CSC tensors</span></a> and <a class="reference internal" href="#sparse-bsc-docs"><span class="std std-ref">sparse BSC tensors</span></a>:</p> <table class="autosummary longtable docutils colwidths-auto align-default">  <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.row_indices#torch.Tensor.row_indices" title="torch.Tensor.row_indices"><code>Tensor.row_indices</code></a></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.tensor.ccol_indices#torch.Tensor.ccol_indices" title="torch.Tensor.ccol_indices"><code>Tensor.ccol_indices</code></a></p></td> <td></td> </tr>  </table> <p>The following Tensor methods support sparse COO tensors:</p> <p><a class="reference internal" href="generated/torch.tensor.add#torch.Tensor.add" title="torch.Tensor.add"><code>add()</code></a> <a class="reference internal" href="generated/torch.tensor.add_#torch.Tensor.add_" title="torch.Tensor.add_"><code>add_()</code></a> <a class="reference internal" href="generated/torch.tensor.addmm#torch.Tensor.addmm" title="torch.Tensor.addmm"><code>addmm()</code></a> <a class="reference internal" href="generated/torch.tensor.addmm_#torch.Tensor.addmm_" title="torch.Tensor.addmm_"><code>addmm_()</code></a> <a class="reference internal" href="generated/torch.tensor.any#torch.Tensor.any" title="torch.Tensor.any"><code>any()</code></a> <a class="reference internal" href="generated/torch.tensor.asin#torch.Tensor.asin" title="torch.Tensor.asin"><code>asin()</code></a> <a class="reference internal" href="generated/torch.tensor.asin_#torch.Tensor.asin_" title="torch.Tensor.asin_"><code>asin_()</code></a> <a class="reference internal" href="generated/torch.tensor.arcsin#torch.Tensor.arcsin" title="torch.Tensor.arcsin"><code>arcsin()</code></a> <a class="reference internal" href="generated/torch.tensor.arcsin_#torch.Tensor.arcsin_" title="torch.Tensor.arcsin_"><code>arcsin_()</code></a> <a class="reference internal" href="generated/torch.tensor.bmm#torch.Tensor.bmm" title="torch.Tensor.bmm"><code>bmm()</code></a> <a class="reference internal" href="generated/torch.tensor.clone#torch.Tensor.clone" title="torch.Tensor.clone"><code>clone()</code></a> <a class="reference internal" href="generated/torch.tensor.deg2rad#torch.Tensor.deg2rad" title="torch.Tensor.deg2rad"><code>deg2rad()</code></a> <code>deg2rad_()</code> <a class="reference internal" href="generated/torch.tensor.detach#torch.Tensor.detach" title="torch.Tensor.detach"><code>detach()</code></a> <a class="reference internal" href="generated/torch.tensor.detach_#torch.Tensor.detach_" title="torch.Tensor.detach_"><code>detach_()</code></a> <a class="reference internal" href="generated/torch.tensor.dim#torch.Tensor.dim" title="torch.Tensor.dim"><code>dim()</code></a> <a class="reference internal" href="generated/torch.tensor.div#torch.Tensor.div" title="torch.Tensor.div"><code>div()</code></a> <a class="reference internal" href="generated/torch.tensor.div_#torch.Tensor.div_" title="torch.Tensor.div_"><code>div_()</code></a> <a class="reference internal" href="generated/torch.tensor.floor_divide#torch.Tensor.floor_divide" title="torch.Tensor.floor_divide"><code>floor_divide()</code></a> <a class="reference internal" href="generated/torch.tensor.floor_divide_#torch.Tensor.floor_divide_" title="torch.Tensor.floor_divide_"><code>floor_divide_()</code></a> <a class="reference internal" href="generated/torch.tensor.get_device#torch.Tensor.get_device" title="torch.Tensor.get_device"><code>get_device()</code></a> <a class="reference internal" href="generated/torch.tensor.index_select#torch.Tensor.index_select" title="torch.Tensor.index_select"><code>index_select()</code></a> <a class="reference internal" href="generated/torch.tensor.isnan#torch.Tensor.isnan" title="torch.Tensor.isnan"><code>isnan()</code></a> <a class="reference internal" href="generated/torch.tensor.log1p#torch.Tensor.log1p" title="torch.Tensor.log1p"><code>log1p()</code></a> <a class="reference internal" href="generated/torch.tensor.log1p_#torch.Tensor.log1p_" title="torch.Tensor.log1p_"><code>log1p_()</code></a> <a class="reference internal" href="generated/torch.tensor.mm#torch.Tensor.mm" title="torch.Tensor.mm"><code>mm()</code></a> <a class="reference internal" href="generated/torch.tensor.mul#torch.Tensor.mul" title="torch.Tensor.mul"><code>mul()</code></a> <a class="reference internal" href="generated/torch.tensor.mul_#torch.Tensor.mul_" title="torch.Tensor.mul_"><code>mul_()</code></a> <a class="reference internal" href="generated/torch.tensor.mv#torch.Tensor.mv" title="torch.Tensor.mv"><code>mv()</code></a> <a class="reference internal" href="generated/torch.tensor.narrow_copy#torch.Tensor.narrow_copy" title="torch.Tensor.narrow_copy"><code>narrow_copy()</code></a> <a class="reference internal" href="generated/torch.tensor.neg#torch.Tensor.neg" title="torch.Tensor.neg"><code>neg()</code></a> <a class="reference internal" href="generated/torch.tensor.neg_#torch.Tensor.neg_" title="torch.Tensor.neg_"><code>neg_()</code></a> <a class="reference internal" href="generated/torch.tensor.negative#torch.Tensor.negative" title="torch.Tensor.negative"><code>negative()</code></a> <a class="reference internal" href="generated/torch.tensor.negative_#torch.Tensor.negative_" title="torch.Tensor.negative_"><code>negative_()</code></a> <a class="reference internal" href="generated/torch.tensor.numel#torch.Tensor.numel" title="torch.Tensor.numel"><code>numel()</code></a> <a class="reference internal" href="generated/torch.tensor.rad2deg#torch.Tensor.rad2deg" title="torch.Tensor.rad2deg"><code>rad2deg()</code></a> <code>rad2deg_()</code> <a class="reference internal" href="generated/torch.tensor.resize_as_#torch.Tensor.resize_as_" title="torch.Tensor.resize_as_"><code>resize_as_()</code></a> <a class="reference internal" href="generated/torch.tensor.size#torch.Tensor.size" title="torch.Tensor.size"><code>size()</code></a> <a class="reference internal" href="generated/torch.tensor.pow#torch.Tensor.pow" title="torch.Tensor.pow"><code>pow()</code></a> <a class="reference internal" href="generated/torch.tensor.sqrt#torch.Tensor.sqrt" title="torch.Tensor.sqrt"><code>sqrt()</code></a> <a class="reference internal" href="generated/torch.tensor.square#torch.Tensor.square" title="torch.Tensor.square"><code>square()</code></a> <a class="reference internal" href="generated/torch.tensor.smm#torch.Tensor.smm" title="torch.Tensor.smm"><code>smm()</code></a> <a class="reference internal" href="generated/torch.tensor.sspaddmm#torch.Tensor.sspaddmm" title="torch.Tensor.sspaddmm"><code>sspaddmm()</code></a> <a class="reference internal" href="generated/torch.tensor.sub#torch.Tensor.sub" title="torch.Tensor.sub"><code>sub()</code></a> <a class="reference internal" href="generated/torch.tensor.sub_#torch.Tensor.sub_" title="torch.Tensor.sub_"><code>sub_()</code></a> <a class="reference internal" href="generated/torch.tensor.t#torch.Tensor.t" title="torch.Tensor.t"><code>t()</code></a> <a class="reference internal" href="generated/torch.tensor.t_#torch.Tensor.t_" title="torch.Tensor.t_"><code>t_()</code></a> <a class="reference internal" href="generated/torch.tensor.transpose#torch.Tensor.transpose" title="torch.Tensor.transpose"><code>transpose()</code></a> <a class="reference internal" href="generated/torch.tensor.transpose_#torch.Tensor.transpose_" title="torch.Tensor.transpose_"><code>transpose_()</code></a> <a class="reference internal" href="generated/torch.tensor.zero_#torch.Tensor.zero_" title="torch.Tensor.zero_"><code>zero_()</code></a></p>   <h3 id="torch-functions-specific-to-sparse-tensors">Torch functions specific to sparse Tensors</h3> <table class="autosummary longtable docutils colwidths-auto align-default">  <tr>
<td>


<a class="reference internal" href="generated/torch.sparse_coo_tensor#torch.sparse_coo_tensor" title="torch.sparse_coo_tensor"><code>sparse_coo_tensor</code></a>
</td> <td><p>Constructs a <a class="reference internal" href="#sparse-coo-docs"><span class="std std-ref">sparse tensor in COO(rdinate) format</span></a> with specified values at the given <code>indices</code>.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.sparse_csr_tensor#torch.sparse_csr_tensor" title="torch.sparse_csr_tensor"><code>sparse_csr_tensor</code></a>
</td> <td><p>Constructs a <a class="reference internal" href="#sparse-csr-docs"><span class="std std-ref">sparse tensor in CSR (Compressed Sparse Row)</span></a> with specified values at the given <code>crow_indices</code> and <code>col_indices</code>.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.sparse_csc_tensor#torch.sparse_csc_tensor" title="torch.sparse_csc_tensor"><code>sparse_csc_tensor</code></a>
</td> <td><p>Constructs a <a class="reference internal" href="#sparse-csc-docs"><span class="std std-ref">sparse tensor in CSC (Compressed Sparse Column)</span></a> with specified values at the given <code>ccol_indices</code> and <code>row_indices</code>.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.sparse_bsr_tensor#torch.sparse_bsr_tensor" title="torch.sparse_bsr_tensor"><code>sparse_bsr_tensor</code></a>
</td> <td><p>Constructs a <a class="reference internal" href="#sparse-bsr-docs"><span class="std std-ref">sparse tensor in BSR (Block Compressed Sparse Row))</span></a> with specified 2-dimensional blocks at the given <code>crow_indices</code> and <code>col_indices</code>.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.sparse_bsc_tensor#torch.sparse_bsc_tensor" title="torch.sparse_bsc_tensor"><code>sparse_bsc_tensor</code></a>
</td> <td><p>Constructs a <a class="reference internal" href="#sparse-bsc-docs"><span class="std std-ref">sparse tensor in BSC (Block Compressed Sparse Column))</span></a> with specified 2-dimensional blocks at the given <code>ccol_indices</code> and <code>row_indices</code>.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.sparse_compressed_tensor#torch.sparse_compressed_tensor" title="torch.sparse_compressed_tensor"><code>sparse_compressed_tensor</code></a>
</td> <td><p>Constructs a <a class="reference internal" href="#sparse-compressed-docs"><span class="std std-ref">sparse tensor in Compressed Sparse format - CSR, CSC, BSR, or BSC -</span></a> with specified values at the given <code>compressed_indices</code> and <code>plain_indices</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.sparse.sum#torch.sparse.sum" title="torch.sparse.sum"><code>sparse.sum</code></a></p></td> <td><p>Returns the sum of each row of the sparse tensor <code>input</code> in the given dimensions <code>dim</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.sparse.addmm#torch.sparse.addmm" title="torch.sparse.addmm"><code>sparse.addmm</code></a></p></td> <td><p>This function does exact same thing as <a class="reference internal" href="generated/torch.addmm#torch.addmm" title="torch.addmm"><code>torch.addmm()</code></a> in the forward, except that it supports backward for sparse COO matrix <code>mat1</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.sparse.sampled_addmm#torch.sparse.sampled_addmm" title="torch.sparse.sampled_addmm"><code>sparse.sampled_addmm</code></a></p></td> <td><p>Performs a matrix multiplication of the dense matrices <code>mat1</code> and <code>mat2</code> at the locations specified by the sparsity pattern of <code>input</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.sparse.mm#torch.sparse.mm" title="torch.sparse.mm"><code>sparse.mm</code></a></p></td> <td><p>Performs a matrix multiplication of the sparse matrix <code>mat1</code></p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.sspaddmm#torch.sspaddmm" title="torch.sspaddmm"><code>sspaddmm</code></a>
</td> <td><p>Matrix multiplies a sparse tensor <code>mat1</code> with a dense tensor <code>mat2</code>, then adds the sparse tensor <code>input</code> to the result.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.hspmm#torch.hspmm" title="torch.hspmm"><code>hspmm</code></a>
</td> <td><p>Performs a matrix multiplication of a <a class="reference internal" href="#sparse-coo-docs"><span class="std std-ref">sparse COO matrix</span></a> <code>mat1</code> and a strided matrix <code>mat2</code>.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.smm#torch.smm" title="torch.smm"><code>smm</code></a>
</td> <td><p>Performs a matrix multiplication of the sparse matrix <code>input</code> with the dense matrix <code>mat</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.sparse.softmax#torch.sparse.softmax" title="torch.sparse.softmax"><code>sparse.softmax</code></a></p></td> <td><p>Applies a softmax function.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.sparse.log_softmax#torch.sparse.log_softmax" title="torch.sparse.log_softmax"><code>sparse.log_softmax</code></a></p></td> <td><p>Applies a softmax function followed by logarithm.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.sparse.spdiags#torch.sparse.spdiags" title="torch.sparse.spdiags"><code>sparse.spdiags</code></a></p></td> <td><p>Creates a sparse 2D tensor by placing the values from rows of <code>diagonals</code> along specified diagonals of the output</p></td> </tr>  </table>   <h3 id="other-functions">Other functions</h3> <p>The following <a class="reference internal" href="torch#module-torch" title="torch"><code>torch</code></a> functions support sparse tensors:</p> <p><a class="reference internal" href="generated/torch.cat#torch.cat" title="torch.cat"><code>cat()</code></a> <a class="reference internal" href="generated/torch.dstack#torch.dstack" title="torch.dstack"><code>dstack()</code></a> <a class="reference internal" href="generated/torch.empty#torch.empty" title="torch.empty"><code>empty()</code></a> <a class="reference internal" href="generated/torch.empty_like#torch.empty_like" title="torch.empty_like"><code>empty_like()</code></a> <a class="reference internal" href="generated/torch.hstack#torch.hstack" title="torch.hstack"><code>hstack()</code></a> <a class="reference internal" href="generated/torch.index_select#torch.index_select" title="torch.index_select"><code>index_select()</code></a> <a class="reference internal" href="generated/torch.is_complex#torch.is_complex" title="torch.is_complex"><code>is_complex()</code></a> <a class="reference internal" href="generated/torch.is_floating_point#torch.is_floating_point" title="torch.is_floating_point"><code>is_floating_point()</code></a> <a class="reference internal" href="generated/torch.is_nonzero#torch.is_nonzero" title="torch.is_nonzero"><code>is_nonzero()</code></a> <code>is_same_size()</code> <code>is_signed()</code> <a class="reference internal" href="generated/torch.is_tensor#torch.is_tensor" title="torch.is_tensor"><code>is_tensor()</code></a> <a class="reference internal" href="generated/torch.lobpcg#torch.lobpcg" title="torch.lobpcg"><code>lobpcg()</code></a> <a class="reference internal" href="generated/torch.mm#torch.mm" title="torch.mm"><code>mm()</code></a> <code>native_norm()</code> <a class="reference internal" href="generated/torch.pca_lowrank#torch.pca_lowrank" title="torch.pca_lowrank"><code>pca_lowrank()</code></a> <a class="reference internal" href="generated/torch.select#torch.select" title="torch.select"><code>select()</code></a> <a class="reference internal" href="generated/torch.stack#torch.stack" title="torch.stack"><code>stack()</code></a> <a class="reference internal" href="generated/torch.svd_lowrank#torch.svd_lowrank" title="torch.svd_lowrank"><code>svd_lowrank()</code></a> <a class="reference internal" href="generated/torch.unsqueeze#torch.unsqueeze" title="torch.unsqueeze"><code>unsqueeze()</code></a> <a class="reference internal" href="generated/torch.vstack#torch.vstack" title="torch.vstack"><code>vstack()</code></a> <a class="reference internal" href="generated/torch.zeros#torch.zeros" title="torch.zeros"><code>zeros()</code></a> <a class="reference internal" href="generated/torch.zeros_like#torch.zeros_like" title="torch.zeros_like"><code>zeros_like()</code></a></p> <p>To manage checking sparse tensor invariants, see:</p> <table class="autosummary longtable docutils colwidths-auto align-default">  <tr>
<td><p><a class="reference internal" href="generated/torch.sparse.check_sparse_tensor_invariants#torch.sparse.check_sparse_tensor_invariants" title="torch.sparse.check_sparse_tensor_invariants"><code>sparse.check_sparse_tensor_invariants</code></a></p></td> <td><p>A tool to control checking sparse tensor invariants.</p></td> </tr>  </table> <p>To use sparse tensors with <a class="reference internal" href="generated/torch.autograd.gradcheck#torch.autograd.gradcheck" title="torch.autograd.gradcheck"><code>gradcheck()</code></a> function, see:</p> <table class="autosummary longtable docutils colwidths-auto align-default">  <tr>
<td><p><a class="reference internal" href="generated/torch.sparse.as_sparse_gradcheck#torch.sparse.as_sparse_gradcheck" title="torch.sparse.as_sparse_gradcheck"><code>sparse.as_sparse_gradcheck</code></a></p></td> <td><p>Decorator for torch.autograd.gradcheck or its functools.partial variants that extends the gradcheck function with support to input functions that operate on or/and return sparse tensors.</p></td> </tr>  </table>   <h3 id="unary-functions">Unary functions</h3> <p>We aim to support all zero-preserving unary functions.</p> <p>If you find that we are missing a zero-preserving unary function that you need, please feel encouraged to open an issue for a feature request. As always please kindly try the search function first before opening an issue.</p> <p>The following operators currently support sparse COO/CSR/CSC/BSR/CSR tensor inputs.</p> <p><a class="reference internal" href="generated/torch.abs#torch.abs" title="torch.abs"><code>abs()</code></a> <a class="reference internal" href="generated/torch.asin#torch.asin" title="torch.asin"><code>asin()</code></a> <a class="reference internal" href="generated/torch.asinh#torch.asinh" title="torch.asinh"><code>asinh()</code></a> <a class="reference internal" href="generated/torch.atan#torch.atan" title="torch.atan"><code>atan()</code></a> <a class="reference internal" href="generated/torch.atanh#torch.atanh" title="torch.atanh"><code>atanh()</code></a> <a class="reference internal" href="generated/torch.ceil#torch.ceil" title="torch.ceil"><code>ceil()</code></a> <a class="reference internal" href="generated/torch.conj_physical#torch.conj_physical" title="torch.conj_physical"><code>conj_physical()</code></a> <a class="reference internal" href="generated/torch.floor#torch.floor" title="torch.floor"><code>floor()</code></a> <a class="reference internal" href="generated/torch.log1p#torch.log1p" title="torch.log1p"><code>log1p()</code></a> <a class="reference internal" href="generated/torch.neg#torch.neg" title="torch.neg"><code>neg()</code></a> <a class="reference internal" href="generated/torch.round#torch.round" title="torch.round"><code>round()</code></a> <a class="reference internal" href="generated/torch.sin#torch.sin" title="torch.sin"><code>sin()</code></a> <a class="reference internal" href="generated/torch.sinh#torch.sinh" title="torch.sinh"><code>sinh()</code></a> <a class="reference internal" href="generated/torch.sign#torch.sign" title="torch.sign"><code>sign()</code></a> <a class="reference internal" href="generated/torch.sgn#torch.sgn" title="torch.sgn"><code>sgn()</code></a> <a class="reference internal" href="generated/torch.signbit#torch.signbit" title="torch.signbit"><code>signbit()</code></a> <a class="reference internal" href="generated/torch.tan#torch.tan" title="torch.tan"><code>tan()</code></a> <a class="reference internal" href="generated/torch.tanh#torch.tanh" title="torch.tanh"><code>tanh()</code></a> <a class="reference internal" href="generated/torch.trunc#torch.trunc" title="torch.trunc"><code>trunc()</code></a> <a class="reference internal" href="generated/torch.expm1#torch.expm1" title="torch.expm1"><code>expm1()</code></a> <a class="reference internal" href="generated/torch.sqrt#torch.sqrt" title="torch.sqrt"><code>sqrt()</code></a> <a class="reference internal" href="generated/torch.angle#torch.angle" title="torch.angle"><code>angle()</code></a> <a class="reference internal" href="generated/torch.isinf#torch.isinf" title="torch.isinf"><code>isinf()</code></a> <a class="reference internal" href="generated/torch.isposinf#torch.isposinf" title="torch.isposinf"><code>isposinf()</code></a> <a class="reference internal" href="generated/torch.isneginf#torch.isneginf" title="torch.isneginf"><code>isneginf()</code></a> <a class="reference internal" href="generated/torch.isnan#torch.isnan" title="torch.isnan"><code>isnan()</code></a> <a class="reference internal" href="generated/torch.erf#torch.erf" title="torch.erf"><code>erf()</code></a> <a class="reference internal" href="generated/torch.erfinv#torch.erfinv" title="torch.erfinv"><code>erfinv()</code></a></p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2024, PyTorch Contributors<br>PyTorch has a BSD-style license, as found in the <a href="https://github.com/pytorch/pytorch/blob/main/LICENSE">LICENSE</a> file.<br>
    <a href="https://pytorch.org/docs/2.1/sparse.html" class="_attribution-link">https://pytorch.org/docs/2.1/sparse.html</a>
  </p>
</div>
