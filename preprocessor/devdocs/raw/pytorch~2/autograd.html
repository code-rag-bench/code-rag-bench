<h1 id="automatic-differentiation-package-torch-autograd">Automatic differentiation package - torch.autograd</h1> <p id="module-torch.autograd"><code>torch.autograd</code> provides classes and functions implementing automatic differentiation of arbitrary scalar valued functions. It requires minimal changes to the existing code - you only need to declare <code>Tensor</code> s for which gradients should be computed with the <code>requires_grad=True</code> keyword. As of now, we only support autograd for floating point <code>Tensor</code> types ( half, float, double and bfloat16) and complex <code>Tensor</code> types (cfloat, cdouble).</p> <table class="autosummary longtable docutils colwidths-auto align-default">  <tr>
<td>


<a class="reference internal" href="generated/torch.autograd.backward#torch.autograd.backward" title="torch.autograd.backward"><code>backward</code></a>
</td> <td><p>Computes the sum of gradients of given tensors with respect to graph leaves.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.autograd.grad#torch.autograd.grad" title="torch.autograd.grad"><code>grad</code></a>
</td> <td><p>Computes and returns the sum of gradients of outputs with respect to the inputs.</p></td> </tr>  </table>  <h2 id="forward-mode-ad">Forward-mode Automatic Differentiation</h2> <div class="admonition warning" id="forward-mode-automatic-differentiation"> <p class="admonition-title">Warning</p> <p>This API is in beta. Even though the function signatures are very unlikely to change, improved operator coverage is planned before we consider this stable.</p> </div> <p>Please see the <a class="reference external" href="https://pytorch.org/tutorials/intermediate/forward_ad_usage.html">forward-mode AD tutorial</a> for detailed steps on how to use this API.</p> <table class="autosummary longtable docutils colwidths-auto align-default">  <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.forward_ad.dual_level#torch.autograd.forward_ad.dual_level" title="torch.autograd.forward_ad.dual_level"><code>forward_ad.dual_level</code></a></p></td> <td><p>Context-manager that enables forward AD.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.forward_ad.make_dual#torch.autograd.forward_ad.make_dual" title="torch.autograd.forward_ad.make_dual"><code>forward_ad.make_dual</code></a></p></td> <td><p>Associates a tensor value with a forward gradient, the tangent, to create a "dual tensor", which is used to compute forward AD gradients.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.forward_ad.unpack_dual#torch.autograd.forward_ad.unpack_dual" title="torch.autograd.forward_ad.unpack_dual"><code>forward_ad.unpack_dual</code></a></p></td> <td><p>Unpacks a "dual tensor" to get both its Tensor value and its forward AD gradient.</p></td> </tr>  </table>   <h2 id="functional-api">Functional higher level API</h2> <div class="admonition warning" id="functional-higher-level-api"> <p class="admonition-title">Warning</p> <p>This API is in beta. Even though the function signatures are very unlikely to change, major improvements to performances are planned before we consider this stable.</p> </div> <p>This section contains the higher level API for the autograd that builds on the basic API above and allows you to compute jacobians, hessians, etc.</p> <p>This API works with user-provided functions that take only Tensors as input and return only Tensors. If your function takes other arguments that are not Tensors or Tensors that don’t have requires_grad set, you can use a lambda to capture them. For example, for a function <code>f</code> that takes three inputs, a Tensor for which we want the jacobian, another tensor that should be considered constant and a boolean flag as <code>f(input, constant, flag=flag)</code> you can use it as <code>functional.jacobian(lambda x: f(x, constant, flag=flag), input)</code>.</p> <table class="autosummary longtable docutils colwidths-auto align-default">  <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.functional.jacobian#torch.autograd.functional.jacobian" title="torch.autograd.functional.jacobian"><code>functional.jacobian</code></a></p></td> <td><p>Function that computes the Jacobian of a given function.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.functional.hessian#torch.autograd.functional.hessian" title="torch.autograd.functional.hessian"><code>functional.hessian</code></a></p></td> <td><p>Function that computes the Hessian of a given scalar function.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.functional.vjp#torch.autograd.functional.vjp" title="torch.autograd.functional.vjp"><code>functional.vjp</code></a></p></td> <td><p>Function that computes the dot product between a vector <code>v</code> and the Jacobian of the given function at the point given by the inputs.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.functional.jvp#torch.autograd.functional.jvp" title="torch.autograd.functional.jvp"><code>functional.jvp</code></a></p></td> <td><p>Function that computes the dot product between the Jacobian of the given function at the point given by the inputs and a vector <code>v</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.functional.vhp#torch.autograd.functional.vhp" title="torch.autograd.functional.vhp"><code>functional.vhp</code></a></p></td> <td><p>Function that computes the dot product between a vector <code>v</code> and the Hessian of a given scalar function at the point given by the inputs.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.functional.hvp#torch.autograd.functional.hvp" title="torch.autograd.functional.hvp"><code>functional.hvp</code></a></p></td> <td><p>Function that computes the dot product between the Hessian of a given scalar function and a vector <code>v</code> at the point given by the inputs.</p></td> </tr>  </table>   <h2 id="locally-disable-grad">Locally disabling gradient computation</h2> <p id="locally-disabling-gradient-computation">See <a class="reference internal" href="https://pytorch.org/docs/2.1/notes/autograd.html#locally-disable-grad-doc"><span class="std std-ref">Locally disabling gradient computation</span></a> for more information on the differences between no-grad and inference mode as well as other related mechanisms that may be confused with the two. Also see <a class="reference internal" href="torch#torch-rst-local-disable-grad"><span class="std std-ref">Locally disabling gradient computation</span></a> for a list of functions that can be used to locally disable gradients.</p>   <h2 id="default-grad-layouts">Default gradient layouts</h2> <p id="default-gradient-layouts">When a non-sparse <code>param</code> receives a non-sparse gradient during <a class="reference internal" href="generated/torch.autograd.backward#torch.autograd.backward" title="torch.autograd.backward"><code>torch.autograd.backward()</code></a> or <a class="reference internal" href="generated/torch.tensor.backward#torch.Tensor.backward" title="torch.Tensor.backward"><code>torch.Tensor.backward()</code></a> <code>param.grad</code> is accumulated as follows.</p> <p>If <code>param.grad</code> is initially <code>None</code>:</p> <ol class="arabic simple"> <li>If <code>param</code>’s memory is non-overlapping and dense, <code>.grad</code> is created with strides matching <code>param</code> (thus matching <code>param</code>’s layout).</li> <li>Otherwise, <code>.grad</code> is created with rowmajor-contiguous strides.</li> </ol> <p>If <code>param</code> already has a non-sparse <code>.grad</code> attribute:</p> <ol class="arabic simple" start="3"> <li>If <code>create_graph=False</code>, <code>backward()</code> accumulates into <code>.grad</code> in-place, which preserves its strides.</li> <li>If <code>create_graph=True</code>, <code>backward()</code> replaces <code>.grad</code> with a new tensor <code>.grad + new grad</code>, which attempts (but does not guarantee) matching the preexisting <code>.grad</code>’s strides.</li> </ol> <p>The default behavior (letting <code>.grad</code>s be <code>None</code> before the first <code>backward()</code>, such that their layout is created according to 1 or 2, and retained over time according to 3 or 4) is recommended for best performance. Calls to <code>model.zero_grad()</code> or <code>optimizer.zero_grad()</code> will not affect <code>.grad</code> layouts.</p> <p>In fact, resetting all <code>.grad</code>s to <code>None</code> before each accumulation phase, e.g.:</p> <pre data-language="python">for iterations...
    ...
    for param in model.parameters():
        param.grad = None
    loss.backward()
</pre> <p>such that they’re recreated according to 1 or 2 every time, is a valid alternative to <code>model.zero_grad()</code> or <code>optimizer.zero_grad()</code> that may improve performance for some networks.</p>  <h3 id="manual-gradient-layouts">Manual gradient layouts</h3> <p>If you need manual control over <code>.grad</code>’s strides, assign <code>param.grad =</code> a zeroed tensor with desired strides before the first <code>backward()</code>, and never reset it to <code>None</code>. 3 guarantees your layout is preserved as long as <code>create_graph=False</code>. 4 indicates your layout is <em>likely</em> preserved even if <code>create_graph=True</code>.</p>    <h2 id="in-place-operations-on-tensors">In-place operations on Tensors</h2> <p>Supporting in-place operations in autograd is a hard matter, and we discourage their use in most cases. Autograd’s aggressive buffer freeing and reuse makes it very efficient and there are very few occasions when in-place operations actually lower memory usage by any significant amount. Unless you’re operating under heavy memory pressure, you might never need to use them.</p>  <h3 id="in-place-correctness-checks">In-place correctness checks</h3> <p>All <code>Tensor</code> s keep track of in-place operations applied to them, and if the implementation detects that a tensor was saved for backward in one of the functions, but it was modified in-place afterwards, an error will be raised once backward pass is started. This ensures that if you’re using in-place functions and not seeing any errors, you can be sure that the computed gradients are correct.</p>    <h2 id="variable-deprecated">Variable (deprecated)</h2> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The Variable API has been deprecated: Variables are no longer necessary to use autograd with tensors. Autograd automatically supports Tensors with <code>requires_grad</code> set to <code>True</code>. Below please find a quick guide on what has changed:</p> <ul class="simple"> <li>
<code>Variable(tensor)</code> and <code>Variable(tensor, requires_grad)</code> still work as expected, but they return Tensors instead of Variables.</li> <li>
<code>var.data</code> is the same thing as <code>tensor.data</code>.</li> <li>Methods such as <code>var.backward(), var.detach(), var.register_hook()</code> now work on tensors with the same method names.</li> </ul> <p>In addition, one can now create tensors with <code>requires_grad=True</code> using factory methods such as <a class="reference internal" href="generated/torch.randn#torch.randn" title="torch.randn"><code>torch.randn()</code></a>, <a class="reference internal" href="generated/torch.zeros#torch.zeros" title="torch.zeros"><code>torch.zeros()</code></a>, <a class="reference internal" href="generated/torch.ones#torch.ones" title="torch.ones"><code>torch.ones()</code></a>, and others like the following:</p> <p><code>autograd_tensor = torch.randn((2, 3, 4), requires_grad=True)</code></p> </div>   <h2 id="tensor-autograd-functions">Tensor autograd functions</h2> <table class="autosummary longtable docutils colwidths-auto align-default">  <tr>
<td><p><code>torch.Tensor.grad</code></p></td> <td><p>This attribute is <code>None</code> by default and becomes a Tensor the first time a call to <a class="reference internal" href="generated/torch.autograd.backward#torch.autograd.backward" title="torch.autograd.backward"><code>backward()</code></a> computes gradients for <code>self</code>.</p></td> </tr> <tr>
<td><p><code>torch.Tensor.requires_grad</code></p></td> <td><p>Is <code>True</code> if gradients need to be computed for this Tensor, <code>False</code> otherwise.</p></td> </tr> <tr>
<td><p><code>torch.Tensor.is_leaf</code></p></td> <td><p>All Tensors that have <code>requires_grad</code> which is <code>False</code> will be leaf Tensors by convention.</p></td> </tr> <tr>
<td><p><code>torch.Tensor.backward</code>([gradient, ...])</p></td> <td><p>Computes the gradient of current tensor wrt graph leaves.</p></td> </tr> <tr>
<td><p><code>torch.Tensor.detach</code></p></td> <td><p>Returns a new Tensor, detached from the current graph.</p></td> </tr> <tr>
<td><p><code>torch.Tensor.detach_</code></p></td> <td><p>Detaches the Tensor from the graph that created it, making it a leaf.</p></td> </tr> <tr>
<td><p><code>torch.Tensor.register_hook</code>(hook)</p></td> <td><p>Registers a backward hook.</p></td> </tr> <tr>
<td><p><code>torch.Tensor.register_post_accumulate_grad_hook</code>(hook)</p></td> <td><p>Registers a backward hook that runs after grad accumulation.</p></td> </tr> <tr>
<td><p><code>torch.Tensor.retain_grad</code>()</p></td> <td><p>Enables this Tensor to have their <a class="reference internal" href="generated/torch.autograd.grad#torch.autograd.grad" title="torch.autograd.grad"><code>grad</code></a> populated during <a class="reference internal" href="generated/torch.autograd.backward#torch.autograd.backward" title="torch.autograd.backward"><code>backward()</code></a>.</p></td> </tr>  </table>   <h2 id="function"><span class="hidden-section">Function</span></h2> <dl class="py class"> <dt class="sig sig-object py" id="torch.autograd.Function">
<code>class torch.autograd.Function(*args, **kwargs)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/autograd/function.html#Function"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Base class to create custom <code>autograd.Function</code></p> <p>To create a custom <code>autograd.Function</code>, subclass this class and implement the <a class="reference internal" href="generated/torch.autograd.function.forward#torch.autograd.Function.forward" title="torch.autograd.Function.forward"><code>forward()</code></a> and <a class="reference internal" href="generated/torch.autograd.backward#torch.autograd.backward" title="torch.autograd.backward"><code>backward()</code></a> static methods. Then, to use your custom op in the forward pass, call the class method <code>apply</code>. Do not call <a class="reference internal" href="generated/torch.autograd.function.forward#torch.autograd.Function.forward" title="torch.autograd.Function.forward"><code>forward()</code></a> directly.</p> <p>To ensure correctness and best performance, make sure you are calling the correct methods on <code>ctx</code> and validating your backward function using <a class="reference internal" href="generated/torch.autograd.gradcheck#torch.autograd.gradcheck" title="torch.autograd.gradcheck"><code>torch.autograd.gradcheck()</code></a>.</p> <p>See <a class="reference internal" href="https://pytorch.org/docs/2.1/notes/extending.html#extending-autograd"><span class="std std-ref">Extending torch.autograd</span></a> for more details on how to use this class.</p> <p>Examples:</p> <pre data-language="python">&gt;&gt;&gt; class Exp(Function):
&gt;&gt;&gt;     @staticmethod
&gt;&gt;&gt;     def forward(ctx, i):
&gt;&gt;&gt;         result = i.exp()
&gt;&gt;&gt;         ctx.save_for_backward(result)
&gt;&gt;&gt;         return result
&gt;&gt;&gt;
&gt;&gt;&gt;     @staticmethod
&gt;&gt;&gt;     def backward(ctx, grad_output):
&gt;&gt;&gt;         result, = ctx.saved_tensors
&gt;&gt;&gt;         return grad_output * result
&gt;&gt;&gt;
&gt;&gt;&gt; # Use it by calling the apply method:
&gt;&gt;&gt; output = Exp.apply(input)
</pre> </dd>
</dl> <table class="autosummary longtable docutils colwidths-auto align-default">  <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.function.forward#torch.autograd.Function.forward" title="torch.autograd.Function.forward"><code>Function.forward</code></a></p></td> <td><p>This function is to be overridden by all subclasses.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.function.backward#torch.autograd.Function.backward" title="torch.autograd.Function.backward"><code>Function.backward</code></a></p></td> <td><p>Defines a formula for differentiating the operation with backward mode automatic differentiation (alias to the vjp function).</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.function.jvp#torch.autograd.Function.jvp" title="torch.autograd.Function.jvp"><code>Function.jvp</code></a></p></td> <td><p>Defines a formula for differentiating the operation with forward mode automatic differentiation.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.function.vmap#torch.autograd.Function.vmap" title="torch.autograd.Function.vmap"><code>Function.vmap</code></a></p></td> <td><p>Defines a rule for the behavior of this autograd.Function underneath <a class="reference internal" href="generated/torch.vmap#torch.vmap" title="torch.vmap"><code>torch.vmap()</code></a>.</p></td> </tr>  </table>   <h2 id="context-method-mixins">Context method mixins</h2> <p>When creating a new <a class="reference internal" href="#torch.autograd.Function" title="torch.autograd.Function"><code>Function</code></a>, the following methods are available to <code>ctx</code>.</p> <table class="autosummary longtable docutils colwidths-auto align-default">  <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.function.functionctx.mark_dirty#torch.autograd.function.FunctionCtx.mark_dirty" title="torch.autograd.function.FunctionCtx.mark_dirty"><code>function.FunctionCtx.mark_dirty</code></a></p></td> <td><p>Marks given tensors as modified in an in-place operation.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.function.functionctx.mark_non_differentiable#torch.autograd.function.FunctionCtx.mark_non_differentiable" title="torch.autograd.function.FunctionCtx.mark_non_differentiable"><code>function.FunctionCtx.mark_non_differentiable</code></a></p></td> <td><p>Marks outputs as non-differentiable.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.function.functionctx.save_for_backward#torch.autograd.function.FunctionCtx.save_for_backward" title="torch.autograd.function.FunctionCtx.save_for_backward"><code>function.FunctionCtx.save_for_backward</code></a></p></td> <td><p>Saves given tensors for a future call to <a class="reference internal" href="generated/torch.autograd.function.backward#torch.autograd.Function.backward" title="torch.autograd.Function.backward"><code>backward()</code></a>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.function.functionctx.set_materialize_grads#torch.autograd.function.FunctionCtx.set_materialize_grads" title="torch.autograd.function.FunctionCtx.set_materialize_grads"><code>function.FunctionCtx.set_materialize_grads</code></a></p></td> <td><p>Sets whether to materialize grad tensors.</p></td> </tr>  </table>   <h2 id="grad-check">Numerical gradient checking</h2> <table class="autosummary longtable docutils colwidths-auto align-default" id="numerical-gradient-checking">  <tr>
<td>


<a class="reference internal" href="generated/torch.autograd.gradcheck#torch.autograd.gradcheck" title="torch.autograd.gradcheck"><code>gradcheck</code></a>
</td> <td><p>Check gradients computed via small finite differences against analytical gradients wrt tensors in <code>inputs</code> that are of floating point or complex type and with <code>requires_grad=True</code>.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.autograd.gradgradcheck#torch.autograd.gradgradcheck" title="torch.autograd.gradgradcheck"><code>gradgradcheck</code></a>
</td> <td><p>Check gradients of gradients computed via small finite differences against analytical gradients wrt tensors in <code>inputs</code> and <code>grad_outputs</code> that are of floating point or complex type and with <code>requires_grad=True</code>.</p></td> </tr>  </table>   <h2 id="profiler">Profiler</h2> <p>Autograd includes a profiler that lets you inspect the cost of different operators inside your model - both on the CPU and GPU. There are three modes implemented at the moment - CPU-only using <a class="reference internal" href="#torch.autograd.profiler.profile" title="torch.autograd.profiler.profile"><code>profile</code></a>. nvprof based (registers both CPU and GPU activity) using <a class="reference internal" href="#torch.autograd.profiler.emit_nvtx" title="torch.autograd.profiler.emit_nvtx"><code>emit_nvtx</code></a>. and vtune profiler based using <a class="reference internal" href="#torch.autograd.profiler.emit_itt" title="torch.autograd.profiler.emit_itt"><code>emit_itt</code></a>.</p> <dl class="py class"> <dt class="sig sig-object py" id="torch.autograd.profiler.profile">
<code>class torch.autograd.profiler.profile(enabled=True, *, use_cuda=False, use_device=None, record_shapes=False, with_flops=False, profile_memory=False, with_stack=False, with_modules=False, use_kineto=False, use_cpu=True, use_mtia=False, experimental_config=None)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/autograd/profiler.html#profile"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Context manager that manages autograd profiler state and holds a summary of results. Under the hood it just records events of functions being executed in C++ and exposes those events to Python. You can wrap any code into it and it will only report runtime of PyTorch functions. Note: profiler is thread local and is automatically propagated into the async tasks</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>enabled</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – Setting this to False makes this context manager a no-op.</li> <li>
<strong>use_cuda</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – Enables timing of CUDA events as well using the cudaEvent API. Adds approximately 4us of overhead to each tensor operation.</li> <li>
<strong>record_shapes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – If shapes recording is set, information about input dimensions will be collected. This allows one to see which dimensions have been used under the hood and further group by them using prof.key_averages(group_by_input_shape=True). Please note that shape recording might skew your profiling data. It is recommended to use separate runs with and without shape recording to validate the timing. Most likely the skew will be negligible for bottom most events (in a case of nested function calls). But for higher level functions the total self cpu time might be artificially increased because of the shape collection.</li> <li>
<strong>with_flops</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – If with_flops is set, the profiler will estimate the FLOPs (floating point operations) value using the operator’s input shape. This allows one to estimate the hardware performance. Currently, this option only works for the matrix multiplication and 2D convolution operators.</li> <li>
<strong>profile_memory</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – track tensor memory allocation/deallocation.</li> <li>
<strong>with_stack</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – record source information (file and line number) for the ops.</li> <li>
<strong>with_modules</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – record module hierarchy (including function names) corresponding to the callstack of the op. e.g. If module A’s forward call’s module B’s forward which contains an aten::add op, then aten::add’s module hierarchy is A.B Note that this support exist, at the moment, only for TorchScript models and not eager mode models.</li> <li>
<strong>use_kineto</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – experimental, enable profiling with Kineto profiler.</li> <li>
<strong>use_cpu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – profile CPU events; setting to <code>False</code> requires <code>use_kineto=True</code> and can be used to lower the overhead for GPU-only profiling.</li> <li>
<strong>experimental_config</strong> (<em>_ExperimentalConfig</em>) – A set of experimental options used by profiler libraries like Kineto. Note, backward compatibility is not guaranteed.</li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; x = torch.randn((1, 1), requires_grad=True)
&gt;&gt;&gt; with torch.autograd.profiler.profile() as prof:
&gt;&gt;&gt;     for _ in range(100):  # any normal python code, really!
&gt;&gt;&gt;         y = x ** 2
&gt;&gt;&gt;         y.backward()
&gt;&gt;&gt; # NOTE: some columns were removed for brevity
&gt;&gt;&gt; print(prof.key_averages().table(sort_by="self_cpu_time_total"))
-----------------------------------  ---------------  ---------------  ---------------
Name                                 Self CPU total   CPU time avg     Number of Calls
-----------------------------------  ---------------  ---------------  ---------------
mul                                  32.048ms         32.048ms         200
pow                                  27.041ms         27.041ms         200
PowBackward0                         9.727ms          55.483ms         100
torch::autograd::AccumulateGrad      9.148ms          9.148ms          100
torch::autograd::GraphRoot           691.816us        691.816us        100
-----------------------------------  ---------------  ---------------  ---------------
</pre> </dd>
</dl> <table class="autosummary longtable docutils colwidths-auto align-default">  <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.profiler.profile.export_chrome_trace#torch.autograd.profiler.profile.export_chrome_trace" title="torch.autograd.profiler.profile.export_chrome_trace"><code>profiler.profile.export_chrome_trace</code></a></p></td> <td><p>Exports an EventList as a Chrome tracing tools file.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.profiler.profile.key_averages#torch.autograd.profiler.profile.key_averages" title="torch.autograd.profiler.profile.key_averages"><code>profiler.profile.key_averages</code></a></p></td> <td><p>Averages all function events over their keys.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.profiler.profile.self_cpu_time_total#torch.autograd.profiler.profile.self_cpu_time_total" title="torch.autograd.profiler.profile.self_cpu_time_total"><code>profiler.profile.self_cpu_time_total</code></a></p></td> <td><p>Returns total time spent on CPU obtained as a sum of all self times across all the events.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.profiler.profile.total_average#torch.autograd.profiler.profile.total_average" title="torch.autograd.profiler.profile.total_average"><code>profiler.profile.total_average</code></a></p></td> <td><p>Averages all events.</p></td> </tr>  </table> <dl class="py class"> <dt class="sig sig-object py" id="torch.autograd.profiler.emit_nvtx">
<code>class torch.autograd.profiler.emit_nvtx(enabled=True, record_shapes=False)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/autograd/profiler.html#emit_nvtx"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Context manager that makes every autograd operation emit an NVTX range.</p> <p>It is useful when running the program under nvprof:</p> <pre data-language="python">nvprof --profile-from-start off -o trace_name.prof -- &lt;regular command here&gt;
</pre> <p>Unfortunately, there’s no way to force nvprof to flush the data it collected to disk, so for CUDA profiling one has to use this context manager to annotate nvprof traces and wait for the process to exit before inspecting them. Then, either NVIDIA Visual Profiler (nvvp) can be used to visualize the timeline, or <a class="reference internal" href="generated/torch.autograd.profiler.load_nvprof#torch.autograd.profiler.load_nvprof" title="torch.autograd.profiler.load_nvprof"><code>torch.autograd.profiler.load_nvprof()</code></a> can load the results for inspection e.g. in Python REPL.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>enabled</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – Setting <code>enabled=False</code> makes this context manager a no-op. Default: <code>True</code>.</li> <li>
<strong>record_shapes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – If <code>record_shapes=True</code>, the nvtx range wrapping each autograd op will append information about the sizes of Tensor arguments received by that op, in the following format: <code>[[arg0.size(0), arg0.size(1), ...], [arg1.size(0), arg1.size(1), ...], ...]</code> Non-tensor arguments will be represented by <code>[]</code>. Arguments will be listed in the order they are received by the backend op. Please note that this order may not match the order in which those arguments were passed on the Python side. Also note that shape recording may increase the overhead of nvtx range creation. Default: <code>False</code>
</li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; with torch.cuda.profiler.profile():
...     model(x)  # Warmup CUDA memory allocator and profiler
...     with torch.autograd.profiler.emit_nvtx():
...         model(x)
</pre> <p><strong>Forward-backward correlation</strong></p> <p>When viewing a profile created using <a class="reference internal" href="#torch.autograd.profiler.emit_nvtx" title="torch.autograd.profiler.emit_nvtx"><code>emit_nvtx</code></a> in the Nvidia Visual Profiler, correlating each backward-pass op with the corresponding forward-pass op can be difficult. To ease this task, <a class="reference internal" href="#torch.autograd.profiler.emit_nvtx" title="torch.autograd.profiler.emit_nvtx"><code>emit_nvtx</code></a> appends sequence number information to the ranges it generates.</p> <p>During the forward pass, each function range is decorated with <code>seq=&lt;N&gt;</code>. <code>seq</code> is a running counter, incremented each time a new backward Function object is created and stashed for backward. Thus, the <code>seq=&lt;N&gt;</code> annotation associated with each forward function range tells you that if a backward Function object is created by this forward function, the backward object will receive sequence number N. During the backward pass, the top-level range wrapping each C++ backward Function’s <code>apply()</code> call is decorated with <code>stashed seq=&lt;M&gt;</code>. <code>M</code> is the sequence number that the backward object was created with. By comparing <code>stashed seq</code> numbers in backward with <code>seq</code> numbers in forward, you can track down which forward op created each backward Function.</p> <p>Any functions executed during the backward pass are also decorated with <code>seq=&lt;N&gt;</code>. During default backward (with <code>create_graph=False</code>) this information is irrelevant, and in fact, <code>N</code> may simply be 0 for all such functions. Only the top-level ranges associated with backward Function objects’ <code>apply()</code> methods are useful, as a way to correlate these Function objects with the earlier forward pass.</p> <p><strong>Double-backward</strong></p> <p>If, on the other hand, a backward pass with <code>create_graph=True</code> is underway (in other words, if you are setting up for a double-backward), each function’s execution during backward is given a nonzero, useful <code>seq=&lt;N&gt;</code>. Those functions may themselves create Function objects to be executed later during double-backward, just as the original functions in the forward pass did. The relationship between backward and double-backward is conceptually the same as the relationship between forward and backward: The functions still emit current-sequence-number-tagged ranges, the Function objects they create still stash those sequence numbers, and during the eventual double-backward, the Function objects’ <code>apply()</code> ranges are still tagged with <code>stashed seq</code> numbers, which can be compared to <code>seq</code> numbers from the backward pass.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.autograd.profiler.emit_itt">
<code>class torch.autograd.profiler.emit_itt(enabled=True, record_shapes=False)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/autograd/profiler.html#emit_itt"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Context manager that makes every autograd operation emit an ITT range.</p> <p>It is useful when running the program under Intel(R) VTune Profiler:</p> <pre data-language="python">vtune &lt;--vtune-flags&gt; &lt;regular command here&gt;
</pre> <p>The Instrumentation and Tracing Technology (ITT) API enables your application to generate and control the collection of trace data during its execution across different Intel tools. This context manager is to annotate Intel(R) VTune Profiling trace. With help of this context manager, you will be able to see labled ranges in Intel(R) VTune Profiler GUI.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>enabled</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – Setting <code>enabled=False</code> makes this context manager a no-op. Default: <code>True</code>.</li> <li>
<strong>record_shapes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – If <code>record_shapes=True</code>, the itt range wrapping each autograd op will append information about the sizes of Tensor arguments received by that op, in the following format: <code>[[arg0.size(0), arg0.size(1), ...], [arg1.size(0), arg1.size(1), ...], ...]</code> Non-tensor arguments will be represented by <code>[]</code>. Arguments will be listed in the order they are received by the backend op. Please note that this order may not match the order in which those arguments were passed on the Python side. Also note that shape recording may increase the overhead of itt range creation. Default: <code>False</code>
</li> </ul> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; with torch.autograd.profiler.emit_itt():
...     model(x)
</pre> </dd>
</dl> <table class="autosummary longtable docutils colwidths-auto align-default">  <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.profiler.load_nvprof#torch.autograd.profiler.load_nvprof" title="torch.autograd.profiler.load_nvprof"><code>profiler.load_nvprof</code></a></p></td> <td><p>Opens an nvprof trace file and parses autograd annotations.</p></td> </tr>  </table>   <h2 id="anomaly-detection">Anomaly detection</h2> <dl class="py class"> <dt class="sig sig-object py" id="torch.autograd.detect_anomaly">
<code>class torch.autograd.detect_anomaly(check_nan=True)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/autograd/anomaly_mode.html#detect_anomaly"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Context-manager that enable anomaly detection for the autograd engine.</p> <p>This does two things:</p> <ul class="simple"> <li>Running the forward pass with detection enabled will allow the backward pass to print the traceback of the forward operation that created the failing backward function.</li> <li>If <code>check_nan</code> is <code>True</code>, any backward computation that generate “nan” value will raise an error. Default <code>True</code>.</li> </ul> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This mode should be enabled only for debugging as the different tests will slow down your program execution.</p> </div> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; import torch
&gt;&gt;&gt; from torch import autograd
&gt;&gt;&gt; class MyFunc(autograd.Function):
...     @staticmethod
...     def forward(ctx, inp):
...         return inp.clone()
...     @staticmethod
...     def backward(ctx, gO):
...         # Error during the backward pass
...         raise RuntimeError("Some error in backward")
...         return gO.clone()
&gt;&gt;&gt; def run_fn(a):
...     out = MyFunc.apply(a)
...     return out.sum()
&gt;&gt;&gt; inp = torch.rand(10, 10, requires_grad=True)
&gt;&gt;&gt; out = run_fn(inp)
&gt;&gt;&gt; out.backward()
    Traceback (most recent call last):
      File "&lt;stdin&gt;", line 1, in &lt;module&gt;
      File "/your/pytorch/install/torch/_tensor.py", line 93, in backward
        torch.autograd.backward(self, gradient, retain_graph, create_graph)
      File "/your/pytorch/install/torch/autograd/__init__.py", line 90, in backward
        allow_unreachable=True)  # allow_unreachable flag
      File "/your/pytorch/install/torch/autograd/function.py", line 76, in apply
        return self._forward_cls.backward(self, *args)
      File "&lt;stdin&gt;", line 8, in backward
    RuntimeError: Some error in backward
&gt;&gt;&gt; with autograd.detect_anomaly():
...     inp = torch.rand(10, 10, requires_grad=True)
...     out = run_fn(inp)
...     out.backward()
    Traceback of forward call that caused the error:
      File "tmp.py", line 53, in &lt;module&gt;
        out = run_fn(inp)
      File "tmp.py", line 44, in run_fn
        out = MyFunc.apply(a)
    Traceback (most recent call last):
      File "&lt;stdin&gt;", line 4, in &lt;module&gt;
      File "/your/pytorch/install/torch/_tensor.py", line 93, in backward
        torch.autograd.backward(self, gradient, retain_graph, create_graph)
      File "/your/pytorch/install/torch/autograd/__init__.py", line 90, in backward
        allow_unreachable=True)  # allow_unreachable flag
      File "/your/pytorch/install/torch/autograd/function.py", line 76, in apply
        return self._forward_cls.backward(self, *args)
      File "&lt;stdin&gt;", line 8, in backward
    RuntimeError: Some error in backward
</pre>  </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.autograd.set_detect_anomaly">
<code>class torch.autograd.set_detect_anomaly(mode, check_nan=True)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/autograd/anomaly_mode.html#set_detect_anomaly"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Context-manager that sets the anomaly detection for the autograd engine on or off.</p> <p><code>set_detect_anomaly</code> will enable or disable the autograd anomaly detection based on its argument <code>mode</code>. It can be used as a context-manager or as a function.</p> <p>See <code>detect_anomaly</code> above for details of the anomaly detection behaviour.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – Flag whether to enable anomaly detection (<code>True</code>), or disable (<code>False</code>).</li> <li>
<strong>check_nan</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – Flag whether to raise an error when the backward generate “nan”</li> </ul> </dd> </dl> </dd>
</dl>   <h2 id="autograd-graph">Autograd graph</h2> <p>Autograd exposes methods that allow one to inspect the graph and interpose behavior during the backward pass.</p> <p>The <code>grad_fn</code> attribute of a <a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor"><code>torch.Tensor</code></a> holds a <code>torch.autograd.graph.Node</code> if the tensor is the output of a operation that was recorded by autograd (i.e., grad_mode is enabled and at least one of the inputs required gradients), or <code>None</code> otherwise.</p> <table class="autosummary longtable docutils colwidths-auto align-default">  <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.graph.node.name#torch.autograd.graph.Node.name" title="torch.autograd.graph.Node.name"><code>graph.Node.name</code></a></p></td> <td><p>Returns the name.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.graph.node.metadata#torch.autograd.graph.Node.metadata" title="torch.autograd.graph.Node.metadata"><code>graph.Node.metadata</code></a></p></td> <td><p>Returns the metadata.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.graph.node.next_functions#torch.autograd.graph.Node.next_functions" title="torch.autograd.graph.Node.next_functions"><code>graph.Node.next_functions</code></a></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.graph.node.register_hook#torch.autograd.graph.Node.register_hook" title="torch.autograd.graph.Node.register_hook"><code>graph.Node.register_hook</code></a></p></td> <td><p>Registers a backward hook.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/torch.autograd.graph.node.register_prehook#torch.autograd.graph.Node.register_prehook" title="torch.autograd.graph.Node.register_prehook"><code>graph.Node.register_prehook</code></a></p></td> <td><p>Registers a backward pre-hook.</p></td> </tr>  </table> <p>Some operations need intermediary results to be saved during the forward pass in order to execute the backward pass. These intermediary results are saved as attributes on the <code>grad_fn</code> and can be accessed. For example:</p> <pre data-language="python">&gt;&gt;&gt; a = torch.tensor([0., 0., 0.], requires_grad=True)
&gt;&gt;&gt; b = a.exp()
&gt;&gt;&gt; print(isinstance(b.grad_fn, torch.autograd.graph.Node))
True
&gt;&gt;&gt; print(dir(b.grad_fn))
['__call__', '__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '_raw_saved_result', '_register_hook_dict', '_saved_result', 'metadata', 'name', 'next_functions', 'register_hook', 'register_prehook', 'requires_grad']
&gt;&gt;&gt; print(torch.allclose(b.grad_fn._saved_result, b))
True
</pre> <p>You can also define how these saved tensors should be packed / unpacked using hooks. A common application is to trade compute for memory by saving those intermediary results to disk or to CPU instead of leaving them on the GPU. This is especially useful if you notice your model fits on GPU during evaluation, but not training. Also see <a class="reference internal" href="https://pytorch.org/docs/2.1/notes/autograd.html#saved-tensors-hooks-doc"><span class="std std-ref">Hooks for saved tensors</span></a>.</p> <dl class="py class"> <dt class="sig sig-object py" id="torch.autograd.graph.saved_tensors_hooks">
<code>class torch.autograd.graph.saved_tensors_hooks(pack_hook, unpack_hook)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/autograd/graph.html#saved_tensors_hooks"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Context-manager that sets a pair of pack / unpack hooks for saved tensors.</p> <p>Use this context-manager to define how intermediary results of an operation should be packed before saving, and unpacked on retrieval.</p> <p>In that context, the <code>pack_hook</code> function will be called everytime an operation saves a tensor for backward (this includes intermediary results saved using <code>save_for_backward()</code> but also those recorded by a PyTorch-defined operation). The output of <code>pack_hook</code> is then stored in the computation graph instead of the original tensor.</p> <p>The <code>unpack_hook</code> is called when the saved tensor needs to be accessed, namely when executing <a class="reference internal" href="generated/torch.tensor.backward#torch.Tensor.backward" title="torch.Tensor.backward"><code>torch.Tensor.backward()</code></a> or <a class="reference internal" href="generated/torch.autograd.grad#torch.autograd.grad" title="torch.autograd.grad"><code>torch.autograd.grad()</code></a>. It takes as argument the <em>packed</em> object returned by <code>pack_hook</code> and should return a tensor which has the same content as the original tensor (passed as input to the corresponding <code>pack_hook</code>).</p> <p>The hooks should have the following signatures:</p>  <p>pack_hook(tensor: Tensor) -&gt; Any</p> <p>unpack_hook(Any) -&gt; Tensor</p>  <p>where the return value of <code>pack_hook</code> is a valid input to <code>unpack_hook</code>.</p> <p>In general, you want <code>unpack_hook(pack_hook(t))</code> to be equal to <code>t</code> in terms of value, size, dtype and device.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; def pack_hook(x):
...     print("Packing", x)
...     return x
&gt;&gt;&gt;
&gt;&gt;&gt; def unpack_hook(x):
...     print("Unpacking", x)
...     return x
&gt;&gt;&gt;
&gt;&gt;&gt; a = torch.ones(5, requires_grad=True)
&gt;&gt;&gt; b = torch.ones(5, requires_grad=True) * 2
&gt;&gt;&gt; with torch.autograd.graph.saved_tensors_hooks(pack_hook, unpack_hook):
...     y = a * b
Packing tensor([1., 1., 1., 1., 1.], requires_grad=True)
Packing tensor([2., 2., 2., 2., 2.], grad_fn=&lt;MulBackward0&gt;)
&gt;&gt;&gt; y.sum().backward()
Unpacking tensor([1., 1., 1., 1., 1.], requires_grad=True)
Unpacking tensor([2., 2., 2., 2., 2.], grad_fn=&lt;MulBackward0&gt;)
</pre> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Performing an inplace operation on the input to either hooks may lead to undefined behavior.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Only one pair of hooks is allowed at a time. When recursively nesting this context-manager, only the inner-most pair of hooks will be applied.</p> </div>  </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.autograd.graph.save_on_cpu">
<code>class torch.autograd.graph.save_on_cpu(pin_memory=False, device_type='cuda')</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/autograd/graph.html#save_on_cpu"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Context-manager under which tensors saved by the forward pass will be stored on cpu, then retrieved for backward.</p> <p>When performing operations within this context manager, intermediary results saved in the graph during the forward pass will be moved to CPU, then copied back to the original device when needed for the backward pass. If the graph was already on CPU, no tensor copy is performed.</p> <p>Use this context-manager to trade compute for GPU memory usage (e.g. when your model doesn’t fit in GPU memory during training).</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>pin_memory</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If <code>True</code> tensors will be saved to CPU pinned memory during packing and copied to GPU asynchronously during unpacking. Defaults to <code>False</code>. Also see <a class="reference internal" href="https://pytorch.org/docs/2.1/notes/cuda.html#cuda-memory-pinning"><span class="std std-ref">Use pinned memory buffers</span></a>.</p> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; a = torch.randn(5, requires_grad=True, device="cuda")
&gt;&gt;&gt; b = torch.randn(5, requires_grad=True, device="cuda")
&gt;&gt;&gt; c = torch.randn(5, requires_grad=True, device="cuda")
&gt;&gt;&gt;
&gt;&gt;&gt; def f(a, b, c):
...     prod_1 = a * b           # a and b are saved on GPU
...     with torch.autograd.graph.save_on_cpu():
...         prod_2 = prod_1 * c  # prod_1 and c are saved on CPU
...     y = prod_2 * a           # prod_2 and a are saved on GPU
...     return y
&gt;&gt;&gt;
&gt;&gt;&gt; y = f(a, b, c)
&gt;&gt;&gt; del a, b, c  # for illustration only
&gt;&gt;&gt; # the content of a, b, and prod_2 are still alive on GPU
&gt;&gt;&gt; # the content of prod_1 and c only live on CPU
&gt;&gt;&gt; y.sum().backward()  # all CPU tensors are moved back to GPU, for backward
&gt;&gt;&gt; # all intermediary tensors are released (deleted) after the call to backward
</pre> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.autograd.graph.disable_saved_tensors_hooks">
<code>class torch.autograd.graph.disable_saved_tensors_hooks(error_message)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/autograd/graph.html#disable_saved_tensors_hooks"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Context-manager that disables the saved tensors default hooks feature.</p> <p>Useful for if you are creating a feature that does not work with saved tensors default hooks.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>error_message</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a>) – When saved tensors default hooks are used when they have been are disabled, a RuntimeError with this error message gets raised.</p> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; message = "saved tensors default hooks are disabled"
&gt;&gt;&gt; with torch.autograd.graph.disable_saved_tensors_hooks(message):
...     # Raises RuntimeError: saved tensors default hooks are disabled
...     with torch.autograd.graph.save_on_cpu():
...         pass
</pre> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.autograd.graph.register_multi_grad_hook">
<code>class torch.autograd.graph.register_multi_grad_hook(tensors, fn)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/autograd/graph.html#register_multi_grad_hook"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Registers a multi-grad backward hook.</p> <p>The hook will be called after gradients with respect to every tensor in <code>tensors</code> have been computed. If a tensor is in <code>tensors</code> but is not part of the graph, or if a tensor is not needed to compute the gradients for any <code>inputs</code> specified for the current <code>.backward()</code> or <code>.grad()</code> call, this tensor will be ignored and the hook will not wait for its gradient to be computed.</p> <p>After every non-ignored tensor’s gradient has been computed, <code>fn</code> will be called with those gradients. <code>None</code> will be passed for tensors that did not have their gradients computed.</p> <p>The hook should not modify its arguments.</p> <p>This function returns a handle with a method <code>handle.remove()</code> that removes the hook.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>See <a class="reference internal" href="https://pytorch.org/docs/2.1/notes/autograd.html#backward-hooks-execution"><span class="std std-ref">Backward Hooks execution</span></a> for more information on how when this hook is executed, and how its execution is ordered relative to other hooks.</p> </div> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; import torch
&gt;&gt;&gt;
&gt;&gt;&gt; a = torch.rand(2, 3, requires_grad=True)
&gt;&gt;&gt; b = torch.rand(2, 3, requires_grad=True)
&gt;&gt;&gt; c = a * b
&gt;&gt;&gt; d = a * b
&gt;&gt;&gt;
&gt;&gt;&gt; def fn(grads):
...     print([g is not None for g in grads])
...
&gt;&gt;&gt; torch.autograd.graph.register_multi_grad_hook((a, b, c, d), fn)
&gt;&gt;&gt;
&gt;&gt;&gt; c.sum().backward(retain_graph=True)
[True, True, True, False]
&gt;&gt;&gt; c.sum().backward(inputs=(a,), retain_graph=True)
[True, False, True, False]
&gt;&gt;&gt;
</pre>  </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.autograd.graph.allow_mutation_on_saved_tensors">
<code>class torch.autograd.graph.allow_mutation_on_saved_tensors</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/autograd/graph.html#allow_mutation_on_saved_tensors"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Context manager under which mutating tensors saved for backward is allowed</p> <p>Under this context manager, tensors saved for backward are cloned on mutation, so the original version can still be used during backward. Normally, mutating a tensor saved for backward will result in an error raised when it’s used during backward.</p> <p>To ensure the correct behavior, both the forward and backward should be run under the same context manager.</p> <dl class="field-list simple"> <dt class="field-odd">Returns</dt> <dd class="field-odd">
<p>An _AllowMutationOnSavedContext object storing the state managed by this context manager. This object can be useful for debugging purposes. The state managed by the context manager is automatically cleared upon exiting.</p> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; import torch
&gt;&gt;&gt; with torch.autograd.graph.allow_mutation_on_saved_tensors():
...     # forward
...     a = torch.ones(2, 3, requires_grad=True)
...     b = a.clone()
...     out = (b**2).sum()
...     b.sin_()
...     # backward
...     out.sum().backward()
...
tensor([[0.8415, 0.8415, 0.8415],
        [0.8415, 0.8415, 0.8415]], grad_fn=&lt;SinBackward0&gt;)
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2024, PyTorch Contributors<br>PyTorch has a BSD-style license, as found in the <a href="https://github.com/pytorch/pytorch/blob/main/LICENSE">LICENSE</a> file.<br>
    <a href="https://pytorch.org/docs/2.1/autograd.html" class="_attribution-link">https://pytorch.org/docs/2.1/autograd.html</a>
  </p>
</div>
