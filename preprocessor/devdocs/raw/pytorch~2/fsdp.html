<h1 id="fullyshardeddataparallel">FullyShardedDataParallel</h1> <dl class="py class" id="module-torch.distributed.fsdp"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel">
<code>class torch.distributed.fsdp.FullyShardedDataParallel(module, process_group=None, sharding_strategy=None, cpu_offload=None, auto_wrap_policy=None, backward_prefetch=BackwardPrefetch.BACKWARD_PRE, mixed_precision=None, ignored_modules=None, param_init_fn=None, device_id=None, sync_module_states=False, forward_prefetch=False, limit_all_gathers=True, use_orig_params=False, ignored_states=None)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>A wrapper for sharding module parameters across data parallel workers. This is inspired by <a class="reference external" href="https://arxiv.org/abs/2004.13336">Xu et al.</a> as well as the ZeRO Stage 3 from <a class="reference external" href="https://www.deepspeed.ai/">DeepSpeed</a>. FullyShardedDataParallel is commonly shortened to FSDP.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; import torch
&gt;&gt;&gt; from torch.distributed.fsdp import FullyShardedDataParallel as FSDP
&gt;&gt;&gt; torch.cuda.set_device(device_id)
&gt;&gt;&gt; sharded_module = FSDP(my_module)
&gt;&gt;&gt; optim = torch.optim.Adam(sharded_module.parameters(), lr=0.0001)
&gt;&gt;&gt; x = sharded_module(x, y=3, z=torch.Tensor([1]))
&gt;&gt;&gt; loss = x.sum()
&gt;&gt;&gt; loss.backward()
&gt;&gt;&gt; optim.step()
</pre> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The optimizer must be initialized <em>after</em> the module has been wrapped with FSDP since FSDP will shard and transform the module’s parameters in a way that may not preserve the original parameter variables. Thus, the previously initialized optimizer may have stale references to the parameters.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>If the destination CUDA device has ID <code>dev_id</code>, either (1) <code>module</code> should already be placed on that device, (2) the device should be set using <code>torch.cuda.set_device(dev_id)</code>, or (3) <code>dev_id</code> should be passed into the <code>device_id</code> constructor argument. This FSDP instance’s compute device will be that destination device. For (1) and (3), the FSDP initialization always occurs on GPU. For (2), the FSDP initialization happens on <code>module</code> ‘s current device, which may be CPU.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>FSDP currently does not support gradient accumulation outside <code>no_sync()</code> when using CPU offloading. Trying to do so yields incorrect results since FSDP will use the newly-reduced gradient instead of accumulating with any existing gradient.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Changing the original parameter variable names after construction will lead to undefined behavior.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Passing in the <code>sync_module_states=True</code> flag requires <code>module</code> to be on GPU or to use the <code>device_id</code> argument to specify a CUDA device that FSDP will move <code>module</code> to in the FSDP constructor. This is because <code>sync_module_states=True</code> requires GPU communication.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>As of PyTorch 1.12, FSDP only offers limited support for shared parameters (for example, setting one <code>Linear</code> layer’s weight to another’s). In particular, modules that share parameters must be wrapped as part of the same FSDP unit. If enhanced shared parameter support is needed for your use case, please ping <a class="reference external" href="https://github.com/pytorch/pytorch/issues/77724">https://github.com/pytorch/pytorch/issues/77724</a></p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>FSDP has some constraints on freezing parameters (i.e. setting <code>param.requires_grad=False</code>). For <code>use_orig_params=False</code>, each FSDP instance must manage parameters that are all frozen or all non-frozen. For <code>use_orig_params=True</code>, FSDP supports mixing frozen and non-frozen, but we recommend not doing so since then the gradient memory usage will be higher than expected (namely, equivalent to not freezing those parameters). This means that ideally, frozen parameters should be isolated into their own <code>nn.Module</code> s and wrapped separately with FSDP.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Attempting to run the forward pass of a submodule that is contained in an FSDP instance is not supported and will result in errors. This is because the submodule’s parameters will be sharded, but it itself is not an FSDP instance, so its forward pass will not all-gather the full parameters appropriately. This could potentially happen when attempting to run only the encoder of a encoder-decoder model, and the encoder is not wrapped in its own FSDP instance. To resolve this, please wrap the submodule in its own FSDP unit.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>FSDP moves input tensors to the <code>forward</code> method to the GPU compute device, so the user does not need to manually move them from CPU.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The user should not modify the parameters between forward and backward without using the <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.summon_full_params" title="torch.distributed.fsdp.FullyShardedDataParallel.summon_full_params"><code>summon_full_params()</code></a> context since the modifications may not persist. Moreover, for <code>use_orig_params=False</code>, accessing the original parameters between forward and backward may raise an illegal memory access.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>For <code>use_orig_params=True</code>, <code>ShardingStrategy.SHARD_GRAD_OP</code> exposes the unsharded parameters, not the sharded parameters, after forward since it does not free the unsharded ones, unlike <code>ShardingStrategy.FULL_SHARD</code>. One caveat is that, since gradients are always sharded or <code>None</code>, <code>ShardingStrategy.SHARD_GRAD_OP</code> will not expose the sharded gradients with the unsharded parameters after forward. If you want to inspect the gradients, try <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.summon_full_params" title="torch.distributed.fsdp.FullyShardedDataParallel.summon_full_params"><code>summon_full_params()</code></a> with <code>with_grads=True</code>.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>FSDP replaces managed modules’ parameters with <code>torch.Tensor</code> views during forward and backward computation for autograd-related reasons. If your module’s forward relies on saved references to the parameters instead of reacquiring the references each iteration, then it will not see FSDP’s newly created views, and autograd will not work correctly.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>With <code>limit_all_gathers=True</code>, you may see a gap in the FSDP pre-forward where the CPU thread is not issuing any kernels. This is intentional and shows the rate limiter in effect. Synchronizing the CPU thread in that way prevents over-allocating memory for subsequent all-gathers, and it should not actually delay GPU kernel execution.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>When using <code>sharding_strategy=ShardingStrategy.HYBRID_SHARD</code> with the sharding process group being intra-node and the replication process group being inter-node, setting <code>NCCL_CROSS_NIC=1</code> can help improve the all-reduce times over the replication process group for some cluster setups.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>module</strong> (<a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">nn.Module</a>) – This is the module to be wrapped with FSDP.</li> <li>
<strong>process_group</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>ProcessGroup</em><em>, </em><em>Tuple</em><em>[</em><em>ProcessGroup</em><em>, </em><em>ProcessGroup</em><em>]</em><em>]</em><em>]</em>) – This is the process group over which the model is sharded and thus the one used for FSDP’s all-gather and reduce-scatter collective communications. If <code>None</code>, then FSDP uses the default process group. For hybrid sharding strategies such as <code>ShardingStrategy.HYBRID_SHARD</code>, users can pass in a tuple of process groups, representing the groups over which to shard and replicate, respectively. If <code>None</code>, then FSDP constructs process groups for the user to shard intra-node and replicate inter-node. (Default: <code>None</code>)</li> <li>
<strong>sharding_strategy</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="#torch.distributed.fsdp.ShardingStrategy" title="torch.distributed.fsdp.ShardingStrategy">ShardingStrategy</a><em>]</em>) – This configures the sharding strategy, which may trade off memory saving and communication overhead. See <a class="reference internal" href="#torch.distributed.fsdp.ShardingStrategy" title="torch.distributed.fsdp.ShardingStrategy"><code>ShardingStrategy</code></a> for details. (Default: <code>FULL_SHARD</code>)</li> <li>
<strong>cpu_offload</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="#torch.distributed.fsdp.CPUOffload" title="torch.distributed.fsdp.CPUOffload">CPUOffload</a><em>]</em>) – This configures CPU offloading. If this is set to <code>None</code>, then no CPU offloading happens. See <a class="reference internal" href="#torch.distributed.fsdp.CPUOffload" title="torch.distributed.fsdp.CPUOffload"><code>CPUOffload</code></a> for details. (Default: <code>None</code>)</li> <li>
<p><strong>auto_wrap_policy</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>Callable</em><em>[</em><em>[</em><a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">nn.Module</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)">int</a><em>]</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>]</em><em>, </em><em>ModuleWrapPolicy</em><em>]</em><em>]</em>) – </p>
<p>This specifies a policy to apply FSDP to submodules of <code>module</code>, which is needed for communication and computation overlap and thus affects performance. If <code>None</code>, then FSDP only applies to <code>module</code>, and users should manually apply FSDP to parent modules themselves (proceeding bottom-up). For convenience, this accepts <code>ModuleWrapPolicy</code> directly, which allows users to specify the module classes to wrap (e.g. the transformer block). Otherwise, this should be a callable that takes in three arguments <code>module: nn.Module</code>, <code>recurse: bool</code>, and <code>nonwrapped_numel: int</code> and should return a <code>bool</code> specifying whether the passed-in <code>module</code> should have FSDP applied if <code>recurse=False</code> or if the traversal should continue into the module’s subtree if <code>recurse=True</code>. Users may add additional arguments to the callable. The <code>size_based_auto_wrap_policy</code> in <code>torch.distributed.fsdp.wrap.py</code> gives an example callable that applies FSDP to a module if the parameters in its subtree exceed 100M numel. We recommend printing the model after applying FSDP and adjusting as needed.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; def custom_auto_wrap_policy(
&gt;&gt;&gt;     module: nn.Module,
&gt;&gt;&gt;     recurse: bool,
&gt;&gt;&gt;     nonwrapped_numel: int,
&gt;&gt;&gt;     # Additional custom arguments
&gt;&gt;&gt;     min_num_params: int = int(1e8),
&gt;&gt;&gt; ) -&gt; bool:
&gt;&gt;&gt;     return nonwrapped_numel &gt;= min_num_params
&gt;&gt;&gt; # Configure a custom `min_num_params`
&gt;&gt;&gt; my_auto_wrap_policy = functools.partial(custom_auto_wrap_policy, min_num_params=int(1e5))
</pre> </li> <li>
<strong>backward_prefetch</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="#torch.distributed.fsdp.BackwardPrefetch" title="torch.distributed.fsdp.BackwardPrefetch">BackwardPrefetch</a><em>]</em>) – This configures explicit backward prefetching of all-gathers. If <code>None</code>, then FSDP does not backward prefetch, and there is no communication and computation overlap in the backward pass. See <a class="reference internal" href="#torch.distributed.fsdp.BackwardPrefetch" title="torch.distributed.fsdp.BackwardPrefetch"><code>BackwardPrefetch</code></a> for details. (Default: <code>BACKWARD_PRE</code>)</li> <li>
<strong>mixed_precision</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="#torch.distributed.fsdp.MixedPrecision" title="torch.distributed.fsdp.MixedPrecision">MixedPrecision</a><em>]</em>) – This configures native mixed precision for FSDP. If this is set to <code>None</code>, then no mixed precision is used. Otherwise, parameter, buffer, and gradient reduction dtypes can be set. See <a class="reference internal" href="#torch.distributed.fsdp.MixedPrecision" title="torch.distributed.fsdp.MixedPrecision"><code>MixedPrecision</code></a> for details. (Default: <code>None</code>)</li> <li>
<strong>ignored_modules</strong> (<em>Optional</em><em>[</em><em>Iterable</em><em>[</em><a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">torch.nn.Module</a><em>]</em><em>]</em>) – Modules whose own parameters and child modules’ parameters and buffers are ignored by this instance. None of the modules directly in <code>ignored_modules</code> should be <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel" title="torch.distributed.fsdp.FullyShardedDataParallel"><code>FullyShardedDataParallel</code></a> instances, and any child modules that are already-constructed <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel" title="torch.distributed.fsdp.FullyShardedDataParallel"><code>FullyShardedDataParallel</code></a> instances will not be ignored if they are nested under this instance. This argument may be used to avoid sharding specific parameters at module granularity when using an <code>auto_wrap_policy</code> or if parameters’ sharding is not managed by FSDP. (Default: <code>None</code>)</li> <li>
<p><strong>param_init_fn</strong> (<em>Optional</em><em>[</em><em>Callable</em><em>[</em><em>[</em><a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">nn.Module</a><em>]</em><em>, </em><em>None</em><em>]</em><em>]</em>) – </p>
<p>A <code>Callable[torch.nn.Module] -&gt; None</code> that specifies how modules that are currently on the meta device should be initialized onto an actual device. As of v1.12, FSDP detects modules with parameters or buffers on meta device via <code>is_meta</code> and either applies <code>param_init_fn</code> if specified or calls <code>nn.Module.reset_parameters()</code> otherwise. For both cases, the implementation should <em>only</em> initialize the parameters/buffers of the module, not those of its submodules. This is to avoid re-initialization. In addition, FSDP also supports deferred initialization via torchdistX’s (<a class="reference external" href="https://github.com/pytorch/torchdistX">https://github.com/pytorch/torchdistX</a>) <code>deferred_init()</code> API, where the deferred modules are initialized by calling <code>param_init_fn</code> if specified or torchdistX’s default <code>materialize_module()</code> otherwise. If <code>param_init_fn</code> is specified, then it is applied to all meta-device modules, meaning that it should probably case on the module type. FSDP calls the initialization function before parameter flattening and sharding.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; module = MyModule(device="meta")
&gt;&gt;&gt; def my_init_fn(module: nn.Module):
&gt;&gt;&gt;     # E.g. initialize depending on the module type
&gt;&gt;&gt;     ...
&gt;&gt;&gt; fsdp_model = FSDP(module, param_init_fn=my_init_fn, auto_wrap_policy=size_based_auto_wrap_policy)
&gt;&gt;&gt; print(next(fsdp_model.parameters()).device) # current CUDA device
&gt;&gt;&gt; # With torchdistX
&gt;&gt;&gt; module = deferred_init.deferred_init(MyModule, device="cuda")
&gt;&gt;&gt; # Will initialize via deferred_init.materialize_module().
&gt;&gt;&gt; fsdp_model = FSDP(module, auto_wrap_policy=size_based_auto_wrap_policy)
</pre> </li> <li>
<strong>device_id</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)">int</a><em>, </em><a class="reference internal" href="tensor_attributes#torch.device" title="torch.device">torch.device</a><em>]</em><em>]</em>) – An <code>int</code> or <code>torch.device</code> giving the CUDA device on which FSDP initialization takes place, including the module initialization if needed and the parameter sharding. This should be specified to improve initialization speed if <code>module</code> is on CPU. If the default CUDA device was set (e.g. via <code>torch.cuda.set_device</code>), then the user may pass <code>torch.cuda.current_device</code> to this. (Default: <code>None</code>)</li> <li>
<strong>sync_module_states</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If <code>True</code>, then each FSDP module will broadcast module parameters and buffers from rank 0 to ensure that they are replicated across ranks (adding communication overhead to this constructor). This can help load <code>state_dict</code> checkpoints via <code>load_state_dict</code> in a memory efficient way. See <a class="reference internal" href="#torch.distributed.fsdp.FullStateDictConfig" title="torch.distributed.fsdp.FullStateDictConfig"><code>FullStateDictConfig</code></a> for an example of this. (Default: <code>False</code>)</li> <li>
<strong>forward_prefetch</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If <code>True</code>, then FSDP <em>explicitly</em> prefetches the next forward-pass all-gather before the current forward computation. This is only useful for CPU-bound workloads, in which case issuing the next all-gather earlier may improve overlap. This should only be used for static-graph models since the prefetching follows the first iteration’s execution order. (Default: <code>False</code>)</li> <li>
<strong>limit_all_gathers</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If <code>True</code>, then FSDP explicitly synchronizes the CPU thread to ensure GPU memory usage from only <em>two</em> consecutive FSDP instances (the current instance running computation and the next instance whose all-gather is prefetched). If <code>False</code>, then FSDP allows the CPU thread to issue all-gathers without any extra synchronization. (Default: <code>True</code>) We often refer to this feature as the “rate limiter”. This flag should only be set to <code>False</code> for specific CPU-bound workloads with low memory pressure in which case the CPU thread can aggressively issue all kernels without concern for the GPU memory usage.</li> <li>
<strong>use_orig_params</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – Setting this to <code>True</code> has FSDP use <code>module</code> ‘s original parameters. FSDP exposes those original parameters to the user via <code>nn.Module.named_parameters()</code> instead of FSDP’s internal <code>FlatParameter</code> s. This means that the optimizer step runs on the original parameters, enabling per-original-parameter hyperparameters. FSDP preserves the original parameter variables and manipulates their data between unsharded and sharded forms, where they are always views into the underlying unsharded or sharded <code>FlatParameter</code>, respectively. With the current algorithm, the sharded form is always 1D, losing the original tensor structure. An original parameter may have all, some, or none of its data present for a given rank. In the none case, its data will be like a size-0 empty tensor. Users should not author programs relying on what data is present for a given original parameter in its sharded form. <code>True</code> is required to use <code>torch.compile()</code>. Setting this to <code>False</code> exposes FSDP’s internal <code>FlatParameter</code> s to the user via <code>nn.Module.named_parameters()</code>. (Default: <code>False</code>)</li> <li>
<strong>ignored_states</strong> (<em>Optional</em><em>[</em><em>Iterable</em><em>[</em><em>torch.nn.Parameter</em><em>]</em><em>]</em><em>, </em><em>Optional</em><em>[</em><em>Iterable</em><em>[</em><a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">torch.nn.Module</a><em>]</em><em>]</em>) – Ignored parameters or modules that will not be managed by this FSDP instance, meaning that the parameters are not sharded and their gradients are not reduced across ranks. This argument unifies with the existing <code>ignored_modules</code> argument, and we may deprecate <code>ignored_modules</code> soon. For backward compatibility, we keep both <code>ignored_states</code> and <code>ignored_modules`</code>, but FSDP only allows one of them to be specified as not <code>None</code>.</li> </ul> </dd> </dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.apply">
<code>apply(fn)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.apply"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Applies <code>fn</code> recursively to every submodule (as returned by <code>.children()</code>) as well as self. Typical use includes initializing the parameters of a model (see also <a class="reference internal" href="nn.init#nn-init-doc"><span class="std std-ref">torch.nn.init</span></a>).</p> <p>Compared to <code>torch.nn.Module.apply</code>, this version additionally gathers the full parameters before applying <code>fn</code>. It should not be called from within another <code>summon_full_params</code> context.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>fn</strong> (<code>Module</code> -&gt; None) – function to be applied to each submodule</p> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>self</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">


<a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">Module</a> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.clip_grad_norm_">
<code>clip_grad_norm_(max_norm, norm_type=2.0)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.clip_grad_norm_"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Clips the gradient norm of all parameters. The norm is computed over all parameters’ gradients as viewed as a single vector, and the gradients are modified in-place.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>max_norm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)">float</a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)">int</a>) – max norm of the gradients</li> <li>
<strong>norm_type</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)">float</a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)">int</a>) – type of the used p-norm. Can be <code>'inf'</code> for infinity norm.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>Total norm of the parameters (viewed as a single vector).</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a></p> </dd> </dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If every FSDP instance uses <code>NO_SHARD</code>, meaning that no gradients are sharded across ranks, then you may directly use <a class="reference internal" href="generated/torch.nn.utils.clip_grad_norm_#torch.nn.utils.clip_grad_norm_" title="torch.nn.utils.clip_grad_norm_"><code>torch.nn.utils.clip_grad_norm_()</code></a>.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If at least some FSDP instance uses a sharded strategy (i.e. one other than <code>NO_SHARD</code>), then you should use this method instead of <a class="reference internal" href="generated/torch.nn.utils.clip_grad_norm_#torch.nn.utils.clip_grad_norm_" title="torch.nn.utils.clip_grad_norm_"><code>torch.nn.utils.clip_grad_norm_()</code></a> since this method handles the fact that gradients are sharded across ranks.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The total norm returned will have the “largest” dtype across all parameters/gradients as defined by PyTorch’s type promotion semantics. For example, if <em>all</em> parameters/gradients use a low precision dtype, then the returned norm’s dtype will be that low precision dtype, but if there exists at least one parameter/ gradient using FP32, then the returned norm’s dtype will be FP32.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This needs to be called on all ranks since it uses collective communications.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.flatten_sharded_optim_state_dict">
<code>static flatten_sharded_optim_state_dict(sharded_optim_state_dict, model, optim)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.flatten_sharded_optim_state_dict"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>The API is similar to <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.shard_full_optim_state_dict" title="torch.distributed.fsdp.FullyShardedDataParallel.shard_full_optim_state_dict"><code>shard_full_optim_state_dict()</code></a>. The only difference is that the input <code>sharded_optim_state_dict</code> should be returned from <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.sharded_optim_state_dict" title="torch.distributed.fsdp.FullyShardedDataParallel.sharded_optim_state_dict"><code>sharded_optim_state_dict()</code></a>. Therefore, there will be all-gather calls on each rank to gather <code>ShardedTensor</code> s.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>sharded_optim_state_dict</strong> (<em>Dict</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a><em>, </em><em>Any</em><em>]</em>) – Optimizer state dict corresponding to the unflattened parameters and holding the sharded optimizer state.</li> <li>
<strong>model</strong> (<a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">torch.nn.Module</a>) – Refer to <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.shard_full_optim_state_dict" title="torch.distributed.fsdp.FullyShardedDataParallel.shard_full_optim_state_dict"><code>shard_full_optim_state_dict()</code></a>.</li> <li>
<strong>optim</strong> (<a class="reference internal" href="optim#torch.optim.Optimizer" title="torch.optim.Optimizer">torch.optim.Optimizer</a>) – Optimizer for <code>model</code> ‘s parameters.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>Refer to <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.shard_full_optim_state_dict" title="torch.distributed.fsdp.FullyShardedDataParallel.shard_full_optim_state_dict"><code>shard_full_optim_state_dict()</code></a>.</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Dict" title="(in Python v3.12)">Dict</a>[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a>, <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.12)">Any</a>]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.forward">
<code>forward(*args, **kwargs)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.forward"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Runs the forward pass for the wrapped module, inserting FSDP-specific pre- and post-forward sharding logic.</p> <dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.12)">Any</a></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.fsdp_modules">
<code>static fsdp_modules(module, root_only=False)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.fsdp_modules"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns all nested FSDP instances, possibly including <code>module</code> itself and only including FSDP root modules if <code>root_only=True</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>module</strong> (<a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">torch.nn.Module</a>) – Root module, which may or may not be an <code>FSDP</code> module.</li> <li>
<strong>root_only</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – Whether to return only FSDP root modules. (Default: <code>False</code>)</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>FSDP modules that are nested in the input <code>module</code>.</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p>List[<a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel" title="torch.distributed.fsdp.FullyShardedDataParallel">FullyShardedDataParallel</a>]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.full_optim_state_dict">
<code>static full_optim_state_dict(model, optim, optim_input=None, rank0_only=True, group=None)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.full_optim_state_dict"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Consolidates the full optimizer state on rank 0 and returns it as a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><code>dict</code></a> following the convention of <a class="reference internal" href="generated/torch.optim.optimizer.state_dict#torch.optim.Optimizer.state_dict" title="torch.optim.Optimizer.state_dict"><code>torch.optim.Optimizer.state_dict()</code></a>, i.e. with keys <code>"state"</code> and <code>"param_groups"</code>. The flattened parameters in <code>FSDP</code> modules contained in <code>model</code> are mapped back to their unflattened parameters.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This needs to be called on all ranks since it uses collective communications. However, if <code>rank0_only=True</code>, then the state dict is only populated on rank 0, and all other ranks return an empty <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><code>dict</code></a>.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Unlike <code>torch.optim.Optimizer.state_dict()</code>, this method uses full parameter names as keys instead of parameter IDs.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Like in <a class="reference internal" href="generated/torch.optim.optimizer.state_dict#torch.optim.Optimizer.state_dict" title="torch.optim.Optimizer.state_dict"><code>torch.optim.Optimizer.state_dict()</code></a>, the tensors contained in the optimizer state dict are not cloned, so there may be aliasing surprises. For best practices, consider saving the returned optimizer state dict immediately, e.g. using <code>torch.save()</code>.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>model</strong> (<a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">torch.nn.Module</a>) – Root module (which may or may not be a <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel" title="torch.distributed.fsdp.FullyShardedDataParallel"><code>FullyShardedDataParallel</code></a> instance) whose parameters were passed into the optimizer <code>optim</code>.</li> <li>
<strong>optim</strong> (<a class="reference internal" href="optim#torch.optim.Optimizer" title="torch.optim.Optimizer">torch.optim.Optimizer</a>) – Optimizer for <code>model</code> ‘s parameters.</li> <li>
<strong>optim_input</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>List</em><em>[</em><em>Dict</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a><em>, </em><em>Any</em><em>]</em><em>]</em><em>, </em><em>Iterable</em><em>[</em><em>torch.nn.Parameter</em><em>]</em><em>]</em><em>]</em>) – Input passed into the optimizer <code>optim</code> representing either a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><code>list</code></a> of parameter groups or an iterable of parameters; if <code>None</code>, then this method assumes the input was <code>model.parameters()</code>. This argument is deprecated, and there is no need to pass it in anymore. (Default: <code>None</code>)</li> <li>
<strong>rank0_only</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If <code>True</code>, saves the populated <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><code>dict</code></a> only on rank 0; if <code>False</code>, saves it on all ranks. (Default: <code>True</code>)</li> <li>
<strong>group</strong> (<em>dist.ProcessGroup</em>) – Model’s process group or <code>None</code> if using the default process group. (Default: <code>None</code>)</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>A <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><code>dict</code></a> containing the optimizer state for <code>model</code> ‘s original unflattened parameters and including keys “state” and “param_groups” following the convention of <a class="reference internal" href="generated/torch.optim.optimizer.state_dict#torch.optim.Optimizer.state_dict" title="torch.optim.Optimizer.state_dict"><code>torch.optim.Optimizer.state_dict()</code></a>. If <code>rank0_only=True</code>, then nonzero ranks return an empty <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><code>dict</code></a>.</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p>Dict[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a>, Any]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.get_state_dict_type">
<code>static get_state_dict_type(module)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.get_state_dict_type"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get the state_dict_type and the corresponding configurations for the FSDP modules rooted at <code>module</code>. The target module does not have to be an FSDP module.</p> <dl class="field-list simple"> <dt class="field-odd">Returns</dt> <dd class="field-odd">
<p>A <code>StateDictSettings</code> containing the state_dict_type and state_dict / optim_state_dict configs that are currently set.</p> </dd> <dt class="field-even">Raises</dt> <dd class="field-even">
<ul class="simple"> <li>
<strong>AssertionError` if the StateDictSettings for differen</strong> – </li> <li>
<strong>FSDP submodules differ.</strong> – </li> </ul> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#torch.distributed.fsdp.StateDictSettings" title="torch.distributed.fsdp.api.StateDictSettings">StateDictSettings</a></p> </dd> </dl> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.module">
<code>property module: Module</code> </dt> <dd>
<p>Returns the wrapped module (like <code>DistributedDataParallel</code>).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.named_buffers">
<code>named_buffers(*args, **kwargs)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.named_buffers"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Overrides <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.named_buffers" title="torch.distributed.fsdp.FullyShardedDataParallel.named_buffers"><code>named_buffers()</code></a> to intercept buffer names and remove all occurrences of the FSDP-specific flattened buffer prefix when inside the <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.summon_full_params" title="torch.distributed.fsdp.FullyShardedDataParallel.summon_full_params"><code>summon_full_params()</code></a> context manager.</p> <dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Iterator" title="(in Python v3.12)">Iterator</a>[<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Tuple" title="(in Python v3.12)">Tuple</a>[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a>, <a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a>]]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.named_parameters">
<code>named_parameters(*args, **kwargs)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.named_parameters"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Overrides <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.named_parameters" title="torch.distributed.fsdp.FullyShardedDataParallel.named_parameters"><code>named_parameters()</code></a> to intercept parameter names and remove all occurrences of the FSDP-specific flattened parameter prefix when inside the <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.summon_full_params" title="torch.distributed.fsdp.FullyShardedDataParallel.summon_full_params"><code>summon_full_params()</code></a> context manager.</p> <dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Iterator" title="(in Python v3.12)">Iterator</a>[<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Tuple" title="(in Python v3.12)">Tuple</a>[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a>, <a class="reference internal" href="generated/torch.nn.parameter.parameter#torch.nn.parameter.Parameter" title="torch.nn.parameter.Parameter">Parameter</a>]]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.no_sync">
<code>no_sync()</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.no_sync"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>A context manager to disable gradient synchronizations across FSDP instances. Within this context, gradients will be accumulated in module variables, which will later be synchronized in the first forward-backward pass after exiting the context. This should only be used on the root FSDP instance and will recursively apply to all children FSDP instances.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This likely results in higher memory usage because FSDP will accumulate the full model gradients (instead of gradient shards) until the eventual sync.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>When used with CPU offloading, the gradients will not be offloaded to CPU when inside the context manager. Instead, they will only be offloaded right after the eventual sync.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Generator" title="(in Python v3.12)">Generator</a></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.optim_state_dict">
<code>static optim_state_dict(model, optim, optim_state_dict=None, group=None)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.optim_state_dict"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Transforms the state_dict of <code>optim</code> for the <code>model</code> that is sharded by FSDP to one of the three types: 1) full optimizer state_dict, 2) sharded optimizer state_dict, 3) local optimizer state_dict.</p> <p>For full optimizer state_dict, all states are unflattened and not sharded. Rank0 only and CPU only can be specified via <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.state_dict_type" title="torch.distributed.fsdp.FullyShardedDataParallel.state_dict_type"><code>state_dict_type()</code></a> to avoid OOM.</p> <p>For sharded optimizer state_dict, all states are unflattened but sharded. CPU only can be specified via <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.state_dict_type" title="torch.distributed.fsdp.FullyShardedDataParallel.state_dict_type"><code>state_dict_type()</code></a> to further save memory.</p> <p>For local state_dict, no transformation will be performed. But a state will be converted from nn.Tensor to ShardedTensor to represent its sharding nature (this is not supported yet).</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; from torch.distributed.fsdp import FullyShardedDataParallel as FSDP
&gt;&gt;&gt; from torch.distributed.fsdp import StateDictType
&gt;&gt;&gt; from torch.distributed.fsdp import FullStateDictConfig
&gt;&gt;&gt; from torch.distributed.fsdp import FullOptimStateDictConfig
&gt;&gt;&gt; # Save a checkpoint
&gt;&gt;&gt; model, optim = ...
&gt;&gt;&gt; FSDP.set_state_dict_type(
&gt;&gt;&gt;     model,
&gt;&gt;&gt;     StateDictType.FULL_STATE_DICT,
&gt;&gt;&gt;     FullStateDictConfig(rank0_only=False),
&gt;&gt;&gt;     FullOptimStateDictConfig(rank0_only=False),
&gt;&gt;&gt; )
&gt;&gt;&gt; state_dict = model.state_dict()
&gt;&gt;&gt; optim_state_dict = FSDP.optim_state_dict(model, optim)
&gt;&gt;&gt; save_a_checkpoint(state_dict, optim_state_dict)
&gt;&gt;&gt; # Load a checkpoint
&gt;&gt;&gt; model, optim = ...
&gt;&gt;&gt; state_dict, optim_state_dict = load_a_checkpoint()
&gt;&gt;&gt; FSDP.set_state_dict_type(
&gt;&gt;&gt;     model,
&gt;&gt;&gt;     StateDictType.FULL_STATE_DICT,
&gt;&gt;&gt;     FullStateDictConfig(rank0_only=False),
&gt;&gt;&gt;     FullOptimStateDictConfig(rank0_only=False),
&gt;&gt;&gt; )
&gt;&gt;&gt; model.load_state_dict(state_dict)
&gt;&gt;&gt; optim_state_dict = FSDP.optim_state_dict_to_load(
&gt;&gt;&gt;     optim_state_dict, model, optim
&gt;&gt;&gt; )
&gt;&gt;&gt; optim.load_state_dict(optim_state_dict)
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>model</strong> (<a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">torch.nn.Module</a>) – Root module (which may or may not be a <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel" title="torch.distributed.fsdp.FullyShardedDataParallel"><code>FullyShardedDataParallel</code></a> instance) whose parameters were passed into the optimizer <code>optim</code>.</li> <li>
<strong>optim</strong> (<a class="reference internal" href="optim#torch.optim.Optimizer" title="torch.optim.Optimizer">torch.optim.Optimizer</a>) – Optimizer for <code>model</code> ‘s parameters.</li> <li>
<strong>optim_state_dict</strong> (<em>Dict</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a><em>, </em><em>Any</em><em>]</em>) – the target optimizer state_dict to transform. If the value is None, optim.state_dict() will be used. ( Default: <code>None</code>)</li> <li>
<strong>group</strong> (<em>dist.ProcessGroup</em>) – Model’s process group across which parameters are sharded or <code>None</code> if using the default process group. ( Default: <code>None</code>)</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>A <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><code>dict</code></a> containing the optimizer state for <code>model</code>. The sharding of the optimizer state is based on <code>state_dict_type</code>.</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p>Dict[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a>, Any]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.optim_state_dict_to_load">
<code>static optim_state_dict_to_load(model, optim, optim_state_dict, is_named_optimizer=False, load_directly=False, group=None)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.optim_state_dict_to_load"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Given a <code>optim_state_dict</code> that is transformed through <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.optim_state_dict" title="torch.distributed.fsdp.FullyShardedDataParallel.optim_state_dict"><code>optim_state_dict()</code></a>, converts it to the flattened optimizer state_dict that can be loaded to <code>optim</code> which is the optimizer for <code>model</code>. <code>model</code> must be sharded by FullyShardedDataParallel.</p> <pre data-language="python">&gt;&gt;&gt; from torch.distributed.fsdp import FullyShardedDataParallel as FSDP
&gt;&gt;&gt; from torch.distributed.fsdp import StateDictType
&gt;&gt;&gt; from torch.distributed.fsdp import FullStateDictConfig
&gt;&gt;&gt; from torch.distributed.fsdp import FullOptimStateDictConfig
&gt;&gt;&gt; # Save a checkpoint
&gt;&gt;&gt; model, optim = ...
&gt;&gt;&gt; FSDP.set_state_dict_type(
&gt;&gt;&gt;     model,
&gt;&gt;&gt;     StateDictType.FULL_STATE_DICT,
&gt;&gt;&gt;     FullStateDictConfig(rank0_only=False),
&gt;&gt;&gt;     FullOptimStateDictConfig(rank0_only=False),
&gt;&gt;&gt; )
&gt;&gt;&gt; state_dict = model.state_dict()
&gt;&gt;&gt; original_osd = optim.state_dict()
&gt;&gt;&gt; optim_state_dict = FSDP.optim_state_dict(
&gt;&gt;&gt;     model,
&gt;&gt;&gt;     optim,
&gt;&gt;&gt;     optim_state_dict=original_osd
&gt;&gt;&gt; )
&gt;&gt;&gt; save_a_checkpoint(state_dict, optim_state_dict)
&gt;&gt;&gt; # Load a checkpoint
&gt;&gt;&gt; model, optim = ...
&gt;&gt;&gt; state_dict, optim_state_dict = load_a_checkpoint()
&gt;&gt;&gt; FSDP.set_state_dict_type(
&gt;&gt;&gt;     model,
&gt;&gt;&gt;     StateDictType.FULL_STATE_DICT,
&gt;&gt;&gt;     FullStateDictConfig(rank0_only=False),
&gt;&gt;&gt;     FullOptimStateDictConfig(rank0_only=False),
&gt;&gt;&gt; )
&gt;&gt;&gt; model.load_state_dict(state_dict)
&gt;&gt;&gt; optim_state_dict = FSDP.optim_state_dict_to_load(
&gt;&gt;&gt;     optim_state_dict, model, optim
&gt;&gt;&gt; )
&gt;&gt;&gt; optim.load_state_dict(optim_state_dict)
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>model</strong> (<a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">torch.nn.Module</a>) – Root module (which may or may not be a <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel" title="torch.distributed.fsdp.FullyShardedDataParallel"><code>FullyShardedDataParallel</code></a> instance) whose parameters were passed into the optimizer <code>optim</code>.</li> <li>
<strong>optim</strong> (<a class="reference internal" href="optim#torch.optim.Optimizer" title="torch.optim.Optimizer">torch.optim.Optimizer</a>) – Optimizer for <code>model</code> ‘s parameters.</li> <li>
<strong>optim_state_dict</strong> (<em>Dict</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a><em>, </em><em>Any</em><em>]</em>) – The optimizer states to be loaded.</li> <li>
<strong>is_named_optimizer</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – Is this optimizer a NamedOptimizer or KeyedOptimizer. Only set to True if <code>optim</code> is TorchRec’s KeyedOptimizer or torch.distributed’s NamedOptimizer.</li> <li>
<strong>load_directly</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If this is set to True, this API will also call optim.load_state_dict(result) before returning the result. Otherwise, users are responsible to call <code>optim.load_state_dict()</code> (Default: <code>False</code>)</li> <li>
<strong>group</strong> (<em>dist.ProcessGroup</em>) – Model’s process group across which parameters are sharded or <code>None</code> if using the default process group. ( Default: <code>None</code>)</li> </ul> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Dict" title="(in Python v3.12)">Dict</a>[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a>, <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.12)">Any</a>]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.register_comm_hook">
<code>register_comm_hook(state, hook)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.register_comm_hook"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Registers a communication hook which is an enhancement that provides a flexible hook to users where they can specify how FSDP aggregates gradients across multiple workers. This hook can be used to implement several algorithms like <a class="reference external" href="https://arxiv.org/abs/1803.05880">GossipGrad</a> and gradient compression which involve different communication strategies for parameter syncs while training with <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel" title="torch.distributed.fsdp.FullyShardedDataParallel"><code>FullyShardedDataParallel</code></a>.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>FSDP communication hook should be registered before running an initial forward pass and only once.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<p><strong>state</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)">object</a>) – </p>
<p>Passed to the hook to maintain any state information during the training process. Examples include error feedback in gradient compression, peers to communicate with next in <a class="reference external" href="https://arxiv.org/abs/1803.05880">GossipGrad</a>, etc. It is locally stored by each worker and shared by all the gradient tensors on the worker.</p> </li> <li>
<strong>hook</strong> (<em>Callable</em>) – Callable, which has one of the following signatures: 1) <code>hook: Callable[torch.Tensor] -&gt; None</code>: This function takes in a Python tensor, which represents the full, flattened, unsharded gradient with respect to all variables corresponding to the model this FSDP unit is wrapping (that are not wrapped by other FSDP sub-units). It then performs all necessary processing and returns <code>None</code>; 2) <code>hook: Callable[torch.Tensor, torch.Tensor] -&gt; None</code>: This function takes in two Python tensors, the first one represents the full, flattened, unsharded gradient with respect to all variables corresponding to the model this FSDP unit is wrapping (that are not wrapped by other FSDP sub-units). The latter represents a pre-sized tensor to store a chunk of a sharded gradient after reduction. In both cases, callable performs all necessary processing and returns <code>None</code>. Callables with signature 1 are expected to handle gradient communication for a <code>NO_SHARD</code> case. Callables with signature 2 are expected to handle gradient communication for sharded cases.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.rekey_optim_state_dict">
<code>static rekey_optim_state_dict(optim_state_dict, optim_state_key_type, model, optim_input=None, optim=None)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.rekey_optim_state_dict"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Re-keys the optimizer state dict <code>optim_state_dict</code> to use the key type <code>optim_state_key_type</code>. This can be used to achieve compatibility between optimizer state dicts from models with FSDP instances and ones without.</p> <p>To re-key an FSDP full optimizer state dict (i.e. from <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.full_optim_state_dict" title="torch.distributed.fsdp.FullyShardedDataParallel.full_optim_state_dict"><code>full_optim_state_dict()</code></a>) to use parameter IDs and be loadable to a non-wrapped model:</p> <pre data-language="python">&gt;&gt;&gt; wrapped_model, wrapped_optim = ...
&gt;&gt;&gt; full_osd = FSDP.full_optim_state_dict(wrapped_model, wrapped_optim)
&gt;&gt;&gt; nonwrapped_model, nonwrapped_optim = ...
&gt;&gt;&gt; rekeyed_osd = FSDP.rekey_optim_state_dict(full_osd, OptimStateKeyType.PARAM_ID, nonwrapped_model)
&gt;&gt;&gt; nonwrapped_optim.load_state_dict(rekeyed_osd)
</pre> <p>To re-key a normal optimizer state dict from a non-wrapped model to be loadable to a wrapped model:</p> <pre data-language="python">&gt;&gt;&gt; nonwrapped_model, nonwrapped_optim = ...
&gt;&gt;&gt; osd = nonwrapped_optim.state_dict()
&gt;&gt;&gt; rekeyed_osd = FSDP.rekey_optim_state_dict(osd, OptimStateKeyType.PARAM_NAME, nonwrapped_model)
&gt;&gt;&gt; wrapped_model, wrapped_optim = ...
&gt;&gt;&gt; sharded_osd = FSDP.shard_full_optim_state_dict(rekeyed_osd, wrapped_model)
&gt;&gt;&gt; wrapped_optim.load_state_dict(sharded_osd)
</pre> <dl class="field-list simple"> <dt class="field-odd">Returns</dt> <dd class="field-odd">
<p>The optimizer state dict re-keyed using the parameter keys specified by <code>optim_state_key_type</code>.</p> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p>Dict[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a>, Any]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.scatter_full_optim_state_dict">
<code>static scatter_full_optim_state_dict(full_optim_state_dict, model, optim_input=None, optim=None, group=None)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.scatter_full_optim_state_dict"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Scatters the full optimizer state dict from rank 0 to all other ranks, returning the sharded optimizer state dict on each rank. The return value is the same as <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.shard_full_optim_state_dict" title="torch.distributed.fsdp.FullyShardedDataParallel.shard_full_optim_state_dict"><code>shard_full_optim_state_dict()</code></a>, and on rank 0, the first argument should be the return value of <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.full_optim_state_dict" title="torch.distributed.fsdp.FullyShardedDataParallel.full_optim_state_dict"><code>full_optim_state_dict()</code></a>.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; from torch.distributed.fsdp import FullyShardedDataParallel as FSDP
&gt;&gt;&gt; model, optim = ...
&gt;&gt;&gt; full_osd = FSDP.full_optim_state_dict(model, optim)  # only non-empty on rank 0
&gt;&gt;&gt; # Define new model with possibly different world size
&gt;&gt;&gt; new_model, new_optim, new_group = ...
&gt;&gt;&gt; sharded_osd = FSDP.scatter_full_optim_state_dict(full_osd, new_model, group=new_group)
&gt;&gt;&gt; new_optim.load_state_dict(sharded_osd)
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Both <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.shard_full_optim_state_dict" title="torch.distributed.fsdp.FullyShardedDataParallel.shard_full_optim_state_dict"><code>shard_full_optim_state_dict()</code></a> and <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.scatter_full_optim_state_dict" title="torch.distributed.fsdp.FullyShardedDataParallel.scatter_full_optim_state_dict"><code>scatter_full_optim_state_dict()</code></a> may be used to get the sharded optimizer state dict to load. Assuming that the full optimizer state dict resides in CPU memory, the former requires each rank to have the full dict in CPU memory, where each rank individually shards the dict without any communication, while the latter requires only rank 0 to have the full dict in CPU memory, where rank 0 moves each shard to GPU memory (for NCCL) and communicates it to ranks appropriately. Hence, the former has higher aggregate CPU memory cost, while the latter has higher communication cost.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>full_optim_state_dict</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a><em>, </em><em>Any</em><em>]</em><em>]</em>) – Optimizer state dict corresponding to the unflattened parameters and holding the full non-sharded optimizer state if on rank 0; the argument is ignored on nonzero ranks.</li> <li>
<strong>model</strong> (<a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">torch.nn.Module</a>) – Root module (which may or may not be a <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel" title="torch.distributed.fsdp.FullyShardedDataParallel"><code>FullyShardedDataParallel</code></a> instance) whose parameters correspond to the optimizer state in <code>full_optim_state_dict</code>.</li> <li>
<strong>optim_input</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>List</em><em>[</em><em>Dict</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a><em>, </em><em>Any</em><em>]</em><em>]</em><em>, </em><em>Iterable</em><em>[</em><em>torch.nn.Parameter</em><em>]</em><em>]</em><em>]</em>) – Input passed into the optimizer representing either a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><code>list</code></a> of parameter groups or an iterable of parameters; if <code>None</code>, then this method assumes the input was <code>model.parameters()</code>. This argument is deprecated, and there is no need to pass it in anymore. (Default: <code>None</code>)</li> <li>
<strong>optim</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="optim#torch.optim.Optimizer" title="torch.optim.Optimizer">torch.optim.Optimizer</a><em>]</em>) – Optimizer that will load the state dict returned by this method. This is the preferred argument to use over <code>optim_input</code>. (Default: <code>None</code>)</li> <li>
<strong>group</strong> (<em>dist.ProcessGroup</em>) – Model’s process group or <code>None</code> if using the default process group. (Default: <code>None</code>)</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>The full optimizer state dict now remapped to flattened parameters instead of unflattened parameters and restricted to only include this rank’s part of the optimizer state.</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p>Dict[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a>, Any]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.set_state_dict_type">
<code>static set_state_dict_type(module, state_dict_type, state_dict_config=None, optim_state_dict_config=None)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.set_state_dict_type"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the <code>state_dict_type</code> and the corresponding (optional) configurations of all the descendant FSDP modules of the target module. The target module does not have to be a FSDP module. If the target module is a FSDP module, its <code>state_dict_type</code> will also be changed.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This API should be called for only the top-level (root) module.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This API enables users to transparently use the conventional <code>state_dict</code> API to take model checkpoints in cases where the root FSDP module is wrapped by another <code>nn.Module</code>. For example, the following will ensure <code>state_dict</code> is called on all non-FSDP instances, while dispatching into <code>sharded_state_dict</code> implementation for FSDP:</p> </div> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; model = DDP(FSDP(...))
&gt;&gt;&gt; FSDP.set_state_dict_type(
&gt;&gt;&gt;     model,
&gt;&gt;&gt;     StateDictType.SHARDED_STATE_DICT,
&gt;&gt;&gt;     state_dict_config = ShardedStateDictConfig(offload_to_cpu=True),
&gt;&gt;&gt;     optim_state_dict_config = OptimStateDictConfig(offload_to_cpu=True),
&gt;&gt;&gt; )
&gt;&gt;&gt; param_state_dict = model.state_dict()
&gt;&gt;&gt; optim_state_dict = FSDP.optim_state_dict(model, optim)
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>module</strong> (<a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">torch.nn.Module</a>) – Root module.</li> <li>
<strong>state_dict_type</strong> (<em>StateDictType</em>) – the desired <code>state_dict_type</code> to set.</li> <li>
<strong>state_dict_config</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="#torch.distributed.fsdp.StateDictConfig" title="torch.distributed.fsdp.StateDictConfig">StateDictConfig</a><em>]</em>) – the configuration for the target <code>state_dict_type</code>.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>A StateDictSettings that include the previous state_dict type and configuration for the module.</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#torch.distributed.fsdp.StateDictSettings" title="torch.distributed.fsdp.api.StateDictSettings">StateDictSettings</a></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.shard_full_optim_state_dict">
<code>static shard_full_optim_state_dict(full_optim_state_dict, model, optim_input=None, optim=None)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.shard_full_optim_state_dict"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Shards the full optimizer state dict <code>full_optim_state_dict</code> by remapping the state to flattened parameters instead of unflattened parameters and restricting to only this rank’s part of the optimizer state. The first argument should be the return value of <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.full_optim_state_dict" title="torch.distributed.fsdp.FullyShardedDataParallel.full_optim_state_dict"><code>full_optim_state_dict()</code></a>.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; from torch.distributed.fsdp import FullyShardedDataParallel as FSDP
&gt;&gt;&gt; model, optim = ...
&gt;&gt;&gt; full_osd = FSDP.full_optim_state_dict(model, optim)
&gt;&gt;&gt; torch.save(full_osd, PATH)
&gt;&gt;&gt; # Define new model with possibly different world size
&gt;&gt;&gt; new_model, new_optim = ...
&gt;&gt;&gt; full_osd = torch.load(PATH)
&gt;&gt;&gt; sharded_osd = FSDP.shard_full_optim_state_dict(full_osd, new_model)
&gt;&gt;&gt; new_optim.load_state_dict(sharded_osd)
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Both <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.shard_full_optim_state_dict" title="torch.distributed.fsdp.FullyShardedDataParallel.shard_full_optim_state_dict"><code>shard_full_optim_state_dict()</code></a> and <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.scatter_full_optim_state_dict" title="torch.distributed.fsdp.FullyShardedDataParallel.scatter_full_optim_state_dict"><code>scatter_full_optim_state_dict()</code></a> may be used to get the sharded optimizer state dict to load. Assuming that the full optimizer state dict resides in CPU memory, the former requires each rank to have the full dict in CPU memory, where each rank individually shards the dict without any communication, while the latter requires only rank 0 to have the full dict in CPU memory, where rank 0 moves each shard to GPU memory (for NCCL) and communicates it to ranks appropriately. Hence, the former has higher aggregate CPU memory cost, while the latter has higher communication cost.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>full_optim_state_dict</strong> (<em>Dict</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a><em>, </em><em>Any</em><em>]</em>) – Optimizer state dict corresponding to the unflattened parameters and holding the full non-sharded optimizer state.</li> <li>
<strong>model</strong> (<a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">torch.nn.Module</a>) – Root module (which may or may not be a <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel" title="torch.distributed.fsdp.FullyShardedDataParallel"><code>FullyShardedDataParallel</code></a> instance) whose parameters correspond to the optimizer state in <code>full_optim_state_dict</code>.</li> <li>
<strong>optim_input</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>List</em><em>[</em><em>Dict</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a><em>, </em><em>Any</em><em>]</em><em>]</em><em>, </em><em>Iterable</em><em>[</em><em>torch.nn.Parameter</em><em>]</em><em>]</em><em>]</em>) – Input passed into the optimizer representing either a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><code>list</code></a> of parameter groups or an iterable of parameters; if <code>None</code>, then this method assumes the input was <code>model.parameters()</code>. This argument is deprecated, and there is no need to pass it in anymore. (Default: <code>None</code>)</li> <li>
<strong>optim</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="optim#torch.optim.Optimizer" title="torch.optim.Optimizer">torch.optim.Optimizer</a><em>]</em>) – Optimizer that will load the state dict returned by this method. This is the preferred argument to use over <code>optim_input</code>. (Default: <code>None</code>)</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>The full optimizer state dict now remapped to flattened parameters instead of unflattened parameters and restricted to only include this rank’s part of the optimizer state.</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p>Dict[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a>, Any]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.sharded_optim_state_dict">
<code>static sharded_optim_state_dict(model, optim, group=None)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.sharded_optim_state_dict"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>The API is similar to <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.full_optim_state_dict" title="torch.distributed.fsdp.FullyShardedDataParallel.full_optim_state_dict"><code>full_optim_state_dict()</code></a> but this API chunks all non-zero-dimension states to <code>ShardedTensor</code> to save memory. This API should only be used when the model <code>state_dict</code> is derived with the context manager <code>with state_dict_type(SHARDED_STATE_DICT):</code>.</p> <p>For the detailed usage, refer to <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.full_optim_state_dict" title="torch.distributed.fsdp.FullyShardedDataParallel.full_optim_state_dict"><code>full_optim_state_dict()</code></a>.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The returned state dict contains <code>ShardedTensor</code> and cannot be directly used by the regular <code>optim.load_state_dict</code>.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Dict" title="(in Python v3.12)">Dict</a>[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a>, <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.12)">Any</a>]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.state_dict_type">
<code>static state_dict_type(module, state_dict_type, state_dict_config=None, optim_state_dict_config=None)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.state_dict_type"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>A context manager to set the <code>state_dict_type</code> of all the descendant FSDP modules of the target module. This context manager has the same functions as <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.set_state_dict_type" title="torch.distributed.fsdp.FullyShardedDataParallel.set_state_dict_type"><code>set_state_dict_type()</code></a>. Read the document of <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel.set_state_dict_type" title="torch.distributed.fsdp.FullyShardedDataParallel.set_state_dict_type"><code>set_state_dict_type()</code></a> for the detail.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; model = DDP(FSDP(...))
&gt;&gt;&gt; with FSDP.state_dict_type(
&gt;&gt;&gt;     model,
&gt;&gt;&gt;     StateDictType.SHARDED_STATE_DICT,
&gt;&gt;&gt; ):
&gt;&gt;&gt;     checkpoint = model.state_dict()
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>module</strong> (<a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module">torch.nn.Module</a>) – Root module.</li> <li>
<strong>state_dict_type</strong> (<em>StateDictType</em>) – the desired <code>state_dict_type</code> to set.</li> <li>
<strong>state_dict_config</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="#torch.distributed.fsdp.StateDictConfig" title="torch.distributed.fsdp.StateDictConfig">StateDictConfig</a><em>]</em>) – the model <code>state_dict</code> configuration for the target <code>state_dict_type</code>.</li> <li>
<strong>optim_state_dict_config</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="#torch.distributed.fsdp.OptimStateDictConfig" title="torch.distributed.fsdp.OptimStateDictConfig">OptimStateDictConfig</a><em>]</em>) – the optimizer <code>state_dict</code> configuration for the target <code>state_dict_type</code>.</li> </ul> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Generator" title="(in Python v3.12)">Generator</a></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullyShardedDataParallel.summon_full_params">
<code>static summon_full_params(module, recurse=True, writeback=True, rank0_only=False, offload_to_cpu=False, with_grads=False)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/fully_sharded_data_parallel.html#FullyShardedDataParallel.summon_full_params"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>A context manager to expose full params for FSDP instances. Can be useful <em>after</em> forward/backward for a model to get the params for additional processing or checking. It can take a non-FSDP module and will summon full params for all contained FSDP modules as well as their children, depending on the <code>recurse</code> argument.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This can be used on inner FSDPs.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This can <em>not</em> be used within a forward or backward pass. Nor can forward and backward be started from within this context.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Parameters will revert to their local shards after the context manager exits, storage behavior is the same as forward.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The full parameters can be modified, but only the portion corresponding to the local param shard will persist after the context manager exits (unless <code>writeback=False</code>, in which case changes will be discarded). In the case where FSDP does not shard the parameters, currently only when <code>world_size == 1</code>, or <code>NO_SHARD</code> config, the modification is persisted regardless of <code>writeback</code>.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This method works on modules which are not FSDP themselves but may contain multiple independent FSDP units. In that case, the given arguments will apply to all contained FSDP units.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Note that <code>rank0_only=True</code> in conjunction with <code>writeback=True</code> is not currently supported and will raise an error. This is because model parameter shapes would be different across ranks within the context, and writing to them can lead to inconsistency across ranks when the context is exited.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Note that <code>offload_to_cpu</code> and <code>rank0_only=False</code> will result in full parameters being redundantly copied to CPU memory for GPUs that reside on the same machine, which may incur the risk of CPU OOM. It is recommended to use <code>offload_to_cpu</code> with <code>rank0_only=True</code>.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>recurse</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>Optional</em>) – recursively summon all params for nested FSDP instances (default: True).</li> <li>
<strong>writeback</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>Optional</em>) – if <code>False</code>, modifications to params are discarded after the context manager exits; disabling this can be slightly more efficient (default: True)</li> <li>
<strong>rank0_only</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>Optional</em>) – if <code>True</code>, full parameters are materialized on only global rank 0. This means that within the context, only rank 0 will have full parameters and the other ranks will have sharded parameters. Note that setting <code>rank0_only=True</code> with <code>writeback=True</code> is not supported, as model parameter shapes will be different across ranks within the context, and writing to them can lead to inconsistency across ranks when the context is exited.</li> <li>
<strong>offload_to_cpu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>Optional</em>) – If <code>True</code>, full parameters are offloaded to CPU. Note that this offloading currently only occurs if the parameter is sharded (which is only not the case for world_size = 1 or <code>NO_SHARD</code> config). It is recommended to use <code>offload_to_cpu</code> with <code>rank0_only=True</code> to avoid redundant copies of model parameters being offloaded to the same CPU memory.</li> <li>
<strong>with_grads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>Optional</em>) – If <code>True</code>, gradients are also unsharded with the parameters. Currently, this is only supported when passing <code>use_orig_params=True</code> to the FSDP constructor and <code>offload_to_cpu=False</code> to this method. (Default: <code>False</code>)</li> </ul> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Generator" title="(in Python v3.12)">Generator</a></p> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.distributed.fsdp.BackwardPrefetch">
<code>class torch.distributed.fsdp.BackwardPrefetch(value)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/api.html#BackwardPrefetch"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This configures explicit backward prefetching, which improves throughput by enabling communication and computation overlap in the backward pass at the cost of slightly increased memory usage.</p> <ul class="simple"> <li>
<code>BACKWARD_PRE</code>: This enables the most overlap but increases memory usage the most. This prefetches the next set of parameters <em>before</em> the current set of parameters’ gradient computation. This overlaps the <em>next all-gather</em> and the <em>current gradient computation</em>, and at the peak, it holds the current set of parameters, next set of parameters, and current set of gradients in memory.</li> <li>
<code>BACKWARD_POST</code>: This enables less overlap but requires less memory usage. This prefetches the next set of parameters <em>after</em> the current set of parameters’ gradient computation. This overlaps the <em>current reduce-scatter</em> and the <em>next gradient computation</em>, and it frees the current set of parameters before allocating memory for the next set of parameters, only holding the next set of parameters and current set of gradients in memory at the peak.</li> <li>FSDP’s <code>backward_prefetch</code> argument accepts <code>None</code>, which disables the backward prefetching altogether. This has no overlap and does not increase memory usage. In general, we do not recommend this setting since it may degrade throughput significantly.</li> </ul> <p>For more technical context: For a single process group using NCCL backend, any collectives, even if issued from different streams, contend for the same per-device NCCL stream, which implies that the relative order in which the collectives are issued matters for overlapping. The two backward prefetching values correspond to different issue orders.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.distributed.fsdp.ShardingStrategy">
<code>class torch.distributed.fsdp.ShardingStrategy(value)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/api.html#ShardingStrategy"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This specifies the sharding strategy to be used for distributed training by <a class="reference internal" href="#torch.distributed.fsdp.FullyShardedDataParallel" title="torch.distributed.fsdp.FullyShardedDataParallel"><code>FullyShardedDataParallel</code></a>.</p> <ul class="simple"> <li>
<code>FULL_SHARD</code>: Parameters, gradients, and optimizer states are sharded. For the parameters, this strategy unshards (via all-gather) before the forward, reshards after the forward, unshards before the backward computation, and reshards after the backward computation. For gradients, it synchronizes and shards them (via reduce-scatter) after the backward computation. The sharded optimizer states are updated locally per rank.</li> <li>
<code>SHARD_GRAD_OP</code>: Gradients and optimizer states are sharded during computation, and additionally, parameters are sharded outside computation. For the parameters, this strategy unshards before the forward, does not reshard them after the forward, and only reshards them after the backward computation. The sharded optimizer states are updated locally per rank. Inside <code>no_sync()</code>, the parameters are not resharded after the backward computation.</li> <li>
<code>NO_SHARD</code>: Parameters, gradients, and optimizer states are not sharded but instead replicated across ranks similar to PyTorch’s <code>DistributedDataParallel</code> API. For gradients, this strategy synchronizes them (via all-reduce) after the backward computation. The unsharded optimizer states are updated locally per rank.</li> <li>
<code>HYBRID_SHARD</code>: Apply <code>FULL_SHARD</code> within a node, and replicate parameters across nodes. This results in reduced communication volume as expensive all-gathers and reduce-scatters are only done within a node, which can be more performant for medium -sized models.</li> <li>
<code>_HYBRID_SHARD_ZERO2</code>: Apply <code>SHARD_GRAD_OP</code> within a node, and replicate parameters across nodes. This is like <code>HYBRID_SHARD</code>, except this may provide even higher throughput since the unsharded parameters are not freed after the forward pass, saving the all-gathers in the pre-backward.</li> </ul> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.distributed.fsdp.MixedPrecision">
<code>class torch.distributed.fsdp.MixedPrecision(param_dtype=None, reduce_dtype=None, buffer_dtype=None, keep_low_precision_grads=False, cast_forward_inputs=False, cast_root_forward_inputs=True, _module_classes_to_ignore=(&lt;class 'torch.nn.modules.batchnorm._BatchNorm'&gt;, ))</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/api.html#MixedPrecision"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This configures FSDP-native mixed precision training.</p> <dl class="field-list simple"> <dt class="field-odd">Variables</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>param_dtype</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="tensor_attributes#torch.dtype" title="torch.dtype">torch.dtype</a><em>]</em>) – This specifies the dtype for model parameters during forward and backward and thus the dtype for forward and backward computation. Outside forward and backward, the <em>sharded</em> parameters are kept in full precision (e.g. for the optimizer step), and for model checkpointing, the parameters are always saved in full precision. (Default: <code>None</code>)</li> <li>
<strong>reduce_dtype</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="tensor_attributes#torch.dtype" title="torch.dtype">torch.dtype</a><em>]</em>) – This specifies the dtype for gradient reduction (i.e. reduce-scatter or all-reduce). If this is <code>None</code> but <code>param_dtype</code> is not <code>None</code>, then this takes on the <code>param_dtype</code> value, still running gradient reduction in low precision. This is permitted to differ from <code>param_dtype</code>, e.g. to force gradient reduction to run in full precision. (Default: <code>None</code>)</li> <li>
<strong>buffer_dtype</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="tensor_attributes#torch.dtype" title="torch.dtype">torch.dtype</a><em>]</em>) – This specifies the dtype for buffers. FSDP does not shard buffers. Rather, FSDP casts them to <code>buffer_dtype</code> in the first forward pass and keeps them in that dtype thereafter. For model checkpointing, the buffers are saved in full precision except for <code>LOCAL_STATE_DICT</code>. (Default: <code>None</code>)</li> <li>
<strong>keep_low_precision_grads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If <code>False</code>, then FSDP upcasts gradients to full precision after the backward pass in preparation for the optimizer step. If <code>True</code>, then FSDP keeps the gradients in the dtype used for gradient reduction, which can save memory if using a custom optimizer that supports running in low precision. (Default: <code>False</code>)</li> <li>
<strong>cast_forward_inputs</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If <code>True</code>, then this FSDP module casts its forward args and kwargs to <code>param_dtype</code>. This is to ensure that parameter and input dtypes match for forward computation, as required by many ops. This may need to be set to <code>True</code> when only applying mixed precision to some but not all FSDP modules, in which case a mixed-precision FSDP submodule needs to recast its inputs. (Default: <code>False</code>)</li> <li>
<strong>cast_root_forward_inputs</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If <code>True</code>, then the root FSDP module casts its forward args and kwargs to <code>param_dtype</code>, overriding the value of <code>cast_forward_inputs</code>. For non-root FSDP modules, this does not do anything. (Default: <code>True</code>)</li> <li>
<strong>_module_classes_to_ignore</strong> (<em>Sequence</em><em>[</em><em>Type</em><em>[</em><a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.modules.module.Module">torch.nn.modules.module.Module</a><em>]</em><em>]</em>) – (Sequence[Type[nn.Module]]): This specifies module classes to ignore for mixed precision when using an <code>auto_wrap_policy</code>: Modules of these classes will have FSDP applied to them separately with mixed precision disabled (meaning that the final FSDP construction would deviate from the specified policy). If <code>auto_wrap_policy</code> is not specified, then this does not do anything. This API is experimental and subject to change. (Default: <code>(_BatchNorm,)</code>)</li> </ul> </dd> </dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This API is experimental and subject to change.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Only floating point tensors are cast to their specified dtypes.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In <code>summon_full_params</code>, parameters are forced to full precision, but buffers are not.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Layer norm and batch norm accumulate in <code>float32</code> even when their inputs are in a low precision like <code>float16</code> or <code>bfloat16</code>. Disabling FSDP’s mixed precision for those norm modules only means that the affine parameters are kept in <code>float32</code>. However, this incurs separate all-gathers and reduce-scatters for those norm modules, which may be inefficient, so if the workload permits, the user should prefer to still apply mixed precision to those modules.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>By default, if the user passes a model with any <code>_BatchNorm</code> modules and specifies an <code>auto_wrap_policy</code>, then the batch norm modules will have FSDP applied to them separately with mixed precision disabled. See the <code>_module_classes_to_ignore</code> argument.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code>MixedPrecision</code> has <code>cast_root_forward_inputs=True</code> and <code>cast_forward_inputs=False</code> by default. For the root FSDP instance, its <code>cast_root_forward_inputs</code> takes precedence over its <code>cast_forward_inputs</code>. For non-root FSDP instances, their <code>cast_root_forward_inputs</code> values are ignored. The default setting is sufficient for the typical case where each FSDP instance has the same <code>MixedPrecision</code> configuration and only needs to cast inputs to the <code>param_dtype</code> at the beginning of the model’s forward pass.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For nested FSDP instances with different <code>MixedPrecision</code> configurations, we recommend setting individual <code>cast_forward_inputs</code> values to configure casting inputs or not before each instance’s forward. In such a case, since the casts happen before each FSDP instance’s forward, a parent FSDP instance should have its non-FSDP submodules run before its FSDP submodules to avoid the activation dtype being changed due to a different <code>MixedPrecision</code> configuration.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; model = nn.Sequential(nn.Linear(3, 3), nn.Linear(3, 3))
&gt;&gt;&gt; model[1] = FSDP(
&gt;&gt;&gt;     model[1],
&gt;&gt;&gt;     mixed_precision=MixedPrecision(param_dtype=torch.float16, cast_forward_inputs=True),
&gt;&gt;&gt; )
&gt;&gt;&gt; model = FSDP(
&gt;&gt;&gt;     model,
&gt;&gt;&gt;     mixed_precision=MixedPrecision(param_dtype=torch.bfloat16, cast_forward_inputs=True),
&gt;&gt;&gt; )
</pre> <p>The above shows a working example. On the other hand, if <code>model[1]</code> were replaced with <code>model[0]</code>, meaning that the submodule using different <code>MixedPrecision</code> ran its forward first, then <code>model[1]</code> would incorrectly see <code>float16</code> activations instead of <code>bfloat16</code> ones.</p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.distributed.fsdp.CPUOffload">
<code>class torch.distributed.fsdp.CPUOffload(offload_params=False)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/api.html#CPUOffload"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This configures CPU offloading.</p> <dl class="field-list simple"> <dt class="field-odd">Variables</dt> <dd class="field-odd">
<p><strong>offload_params</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – This specifies whether to offload parameters to CPU when not involved in computation. If <code>True</code>, then this offloads gradients to CPU as well, meaning that the optimizer step runs on CPU.</p> </dd> </dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.distributed.fsdp.StateDictConfig">
<code>class torch.distributed.fsdp.StateDictConfig(offload_to_cpu=False, use_dtensor=False)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/api.html#StateDictConfig"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><code>StateDictConfig</code> is the base class for all <code>state_dict</code> configuration classes. Users should instantiate a child class (e.g. <code>FullStateDictConfig</code>) in order to configure settings for the corresponding <code>state_dict</code> type supported by FSDP.</p> <dl class="field-list simple"> <dt class="field-odd">Variables</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>offload_to_cpu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If <code>True</code>, then FSDP offloads the state dict values to CPU, and if <code>False</code>, then FSDP keeps them on GPU. (Default: <code>False</code>)</li> <li>
<strong>use_dtensor</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If <code>True</code>, then FSDP saves the state dict values as <code>DTensor</code> if the value is sharded, and if <code>False</code>, then FSDP saves them as <code>ShardedTensor</code>. (Default: <code>False</code>)</li> </ul> </dd> </dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullStateDictConfig">
<code>class torch.distributed.fsdp.FullStateDictConfig(offload_to_cpu=False, use_dtensor=False, rank0_only=False)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/api.html#FullStateDictConfig"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><code>FullStateDictConfig</code> is a config class meant to be used with <code>StateDictType.FULL_STATE_DICT</code>. We recommend enabling both <code>offload_to_cpu=True</code> and <code>rank0_only=True</code> when saving full state dicts to save GPU memory and CPU memory, respectively. This config class is meant to be used via the <code>state_dict_type()</code> context manager as follows:</p> <pre data-language="python">&gt;&gt;&gt; from torch.distributed.fsdp import FullyShardedDataParallel as FSDP
&gt;&gt;&gt; fsdp = FSDP(model, auto_wrap_policy=...)
&gt;&gt;&gt; cfg = FullStateDictConfig(offload_to_cpu=True, rank0_only=True)
&gt;&gt;&gt; with FSDP.state_dict_type(fsdp, StateDictType.FULL_STATE_DICT, cfg):
&gt;&gt;&gt;     state = fsdp.state_dict()
&gt;&gt;&gt;     # `state` will be empty on non rank 0 and contain CPU tensors on rank 0.
&gt;&gt;&gt; # To reload checkpoint for inference, finetuning, transfer learning, etc:
&gt;&gt;&gt; model = model_fn() # Initialize model on CPU in preparation for wrapping with FSDP
&gt;&gt;&gt; if dist.get_rank() == 0:
&gt;&gt;&gt;     # Load checkpoint only on rank 0 to avoid memory redundancy
&gt;&gt;&gt;     state_dict = torch.load("my_checkpoint.pt")
&gt;&gt;&gt;     model.load_state_dict(state_dict)
&gt;&gt;&gt; # All ranks initialize FSDP module as usual. `sync_module_states` argument
&gt;&gt;&gt; # communicates loaded checkpoint states from rank 0 to rest of the world.
&gt;&gt;&gt; fsdp = FSDP(model, device_id=torch.cuda.current_device(), auto_wrap_policy=..., sync_module_states=True)
&gt;&gt;&gt; # After this point, all ranks have FSDP model with loaded checkpoint.
</pre> <dl class="field-list simple"> <dt class="field-odd">Variables</dt> <dd class="field-odd">
<p><strong>rank0_only</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If <code>True</code>, then only rank 0 saves the full state dict, and nonzero ranks save an empty dict. If <code>False</code>, then all ranks save the full state dict. (Default: <code>False</code>)</p> </dd> </dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.distributed.fsdp.ShardedStateDictConfig">
<code>class torch.distributed.fsdp.ShardedStateDictConfig(offload_to_cpu: bool = False, use_dtensor: bool = False)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/api.html#ShardedStateDictConfig"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.distributed.fsdp.LocalStateDictConfig">
<code>class torch.distributed.fsdp.LocalStateDictConfig(offload_to_cpu: bool = False, use_dtensor: bool = False)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/api.html#LocalStateDictConfig"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.distributed.fsdp.OptimStateDictConfig">
<code>class torch.distributed.fsdp.OptimStateDictConfig(offload_to_cpu=True, use_dtensor=False)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/api.html#OptimStateDictConfig"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><code>OptimStateDictConfig</code> is the base class for all <code>optim_state_dict</code> configuration classes. Users should instantiate a child class (e.g. <code>FullOptimStateDictConfig</code>) in order to configure settings for the corresponding <code>optim_state_dict</code> type supported by FSDP.</p> <dl class="field-list simple"> <dt class="field-odd">Variables</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>offload_to_cpu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If <code>True</code>, then FSDP offloads the state dict’s tensor values to CPU, and if <code>False</code>, then FSDP keeps them on the original device (which is GPU unless parameter CPU offloading is enabled). (Default: <code>True</code>)</li> <li>
<strong>use_dtensor</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If <code>True</code>, then FSDP saves the state dict values as <code>DTensor</code> if the value is sharded, and if <code>False</code>, then FSDP saves them as <code>ShardedTensor</code>. (Default: <code>False</code>)</li> </ul> </dd> </dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.distributed.fsdp.FullOptimStateDictConfig">
<code>class torch.distributed.fsdp.FullOptimStateDictConfig(offload_to_cpu=True, use_dtensor=False, rank0_only=False)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/api.html#FullOptimStateDictConfig"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Variables</dt> <dd class="field-odd">
<p><strong>rank0_only</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If <code>True</code>, then only rank 0 saves the full state dict, and nonzero ranks save an empty dict. If <code>False</code>, then all ranks save the full state dict. (Default: <code>False</code>)</p> </dd> </dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.distributed.fsdp.ShardedOptimStateDictConfig">
<code>class torch.distributed.fsdp.ShardedOptimStateDictConfig(offload_to_cpu: bool = True, use_dtensor: bool = False)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/api.html#ShardedOptimStateDictConfig"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.distributed.fsdp.LocalOptimStateDictConfig">
<code>class torch.distributed.fsdp.LocalOptimStateDictConfig(offload_to_cpu: bool = False, use_dtensor: bool = False)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/api.html#LocalOptimStateDictConfig"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.distributed.fsdp.StateDictSettings">
<code>class torch.distributed.fsdp.StateDictSettings(state_dict_type: torch.distributed.fsdp.api.StateDictType, state_dict_config: torch.distributed.fsdp.api.StateDictConfig, optim_state_dict_config: torch.distributed.fsdp.api.OptimStateDictConfig)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/distributed/fsdp/api.html#StateDictSettings"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2024, PyTorch Contributors<br>PyTorch has a BSD-style license, as found in the <a href="https://github.com/pytorch/pytorch/blob/main/LICENSE">LICENSE</a> file.<br>
    <a href="https://pytorch.org/docs/2.1/fsdp.html" class="_attribution-link">https://pytorch.org/docs/2.1/fsdp.html</a>
  </p>
</div>
