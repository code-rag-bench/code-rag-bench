<h1 id="torchscript">TorchScript</h1>      <ul> <li class="toctree-l1"><a class="reference internal" href="jit_language_reference_v2">TorchScript Language Reference</a></li> </ul>   <ul class="simple"> <li><a class="reference internal" href="#creating-torchscript-code" id="id4">Creating TorchScript Code</a></li> <li><a class="reference internal" href="#mixing-tracing-and-scripting" id="id5">Mixing Tracing and Scripting</a></li> <li><a class="reference internal" href="#torchscript-language" id="id6">TorchScript Language</a></li> <li>
<p><a class="reference internal" href="#built-in-functions-and-modules" id="id7">Built-in Functions and Modules</a></p> <ul> <li><a class="reference internal" href="#pytorch-functions-and-modules" id="id8">PyTorch Functions and Modules</a></li> <li><a class="reference internal" href="#python-functions-and-modules" id="id9">Python Functions and Modules</a></li> <li><a class="reference internal" href="#python-language-reference-comparison" id="id10">Python Language Reference Comparison</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#debugging" id="id11">Debugging</a></p> <ul> <li><a class="reference internal" href="#disable-jit-for-debugging" id="id12">Disable JIT for Debugging</a></li> <li><a class="reference internal" href="#inspecting-code" id="id13">Inspecting Code</a></li> <li><a class="reference internal" href="#interpreting-graphs" id="id14">Interpreting Graphs</a></li> <li><a class="reference internal" href="#tracer" id="id15">Tracer</a></li> </ul> </li> <li><a class="reference internal" href="#frequently-asked-questions" id="id16">Frequently Asked Questions</a></li> <li><a class="reference internal" href="#known-issues" id="id17">Known Issues</a></li> <li>
<p><a class="reference internal" href="#appendix" id="id18">Appendix</a></p> <ul> <li><a class="reference internal" href="#migrating-to-pytorch-1-2-recursive-scripting-api" id="id19">Migrating to PyTorch 1.2 Recursive Scripting API</a></li> <li><a class="reference internal" href="#fusion-backends" id="id20">Fusion Backends</a></li> <li><a class="reference internal" href="#references" id="id21">References</a></li> </ul> </li> </ul>  <p id="module-torch.jit">TorchScript is a way to create serializable and optimizable models from PyTorch code. Any TorchScript program can be saved from a Python process and loaded in a process where there is no Python dependency.</p> <p>We provide tools to incrementally transition a model from a pure Python program to a TorchScript program that can be run independently from Python, such as in a standalone C++ program. This makes it possible to train models in PyTorch using familiar tools in Python and then export the model via TorchScript to a production environment where Python programs may be disadvantageous for performance and multi-threading reasons.</p> <p>For a gentle introduction to TorchScript, see the <a class="reference external" href="https://pytorch.org/tutorials/beginner/Intro_to_TorchScript_tutorial.html">Introduction to TorchScript</a> tutorial.</p> <p>For an end-to-end example of converting a PyTorch model to TorchScript and running it in C++, see the <a class="reference external" href="https://pytorch.org/tutorials/advanced/cpp_export.html">Loading a PyTorch Model in C++</a> tutorial.</p>  <h2 id="creating-torchscript-code">Creating TorchScript Code</h2> <table class="autosummary longtable docutils colwidths-auto align-default">  <tr>
<td>


<a class="reference internal" href="generated/torch.jit.script#torch.jit.script" title="torch.jit.script"><code>script</code></a>
</td> <td><p>Scripting a function or <code>nn.Module</code> will inspect the source code, compile it as TorchScript code using the TorchScript compiler, and return a <a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a> or <a class="reference internal" href="generated/torch.jit.scriptfunction#torch.jit.ScriptFunction" title="torch.jit.ScriptFunction"><code>ScriptFunction</code></a>.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.trace#torch.jit.trace" title="torch.jit.trace"><code>trace</code></a>
</td> <td><p>Trace a function and return an executable or <a class="reference internal" href="generated/torch.jit.scriptfunction#torch.jit.ScriptFunction" title="torch.jit.ScriptFunction"><code>ScriptFunction</code></a> that will be optimized using just-in-time compilation.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.script_if_tracing#torch.jit.script_if_tracing" title="torch.jit.script_if_tracing"><code>script_if_tracing</code></a>
</td> <td><p>Compiles <code>fn</code> when it is first called during tracing.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.trace_module#torch.jit.trace_module" title="torch.jit.trace_module"><code>trace_module</code></a>
</td> <td><p>Trace a module and return an executable <a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a> that will be optimized using just-in-time compilation.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.fork#torch.jit.fork" title="torch.jit.fork"><code>fork</code></a>
</td> <td><p>Creates an asynchronous task executing <code>func</code> and a reference to the value of the result of this execution.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.wait#torch.jit.wait" title="torch.jit.wait"><code>wait</code></a>
</td> <td><p>Forces completion of a <code>torch.jit.Future[T]</code> asynchronous task, returning the result of the task.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a>
</td> <td><p>A wrapper around C++ <code>torch::jit::Module</code>.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.scriptfunction#torch.jit.ScriptFunction" title="torch.jit.ScriptFunction"><code>ScriptFunction</code></a>
</td> <td><p>Functionally equivalent to a <a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a>, but represents a single function and does not have any attributes or Parameters.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.freeze#torch.jit.freeze" title="torch.jit.freeze"><code>freeze</code></a>
</td> <td><p>Freezing a <a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a> will clone it and attempt to inline the cloned module's submodules, parameters, and attributes as constants in the TorchScript IR Graph.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.optimize_for_inference#torch.jit.optimize_for_inference" title="torch.jit.optimize_for_inference"><code>optimize_for_inference</code></a>
</td> <td><p>Performs a set of optimization passes to optimize a model for the purposes of inference.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.enable_onednn_fusion#torch.jit.enable_onednn_fusion" title="torch.jit.enable_onednn_fusion"><code>enable_onednn_fusion</code></a>
</td> <td><p>Enables or disables onednn JIT fusion based on the parameter <code>enabled</code>.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.onednn_fusion_enabled#torch.jit.onednn_fusion_enabled" title="torch.jit.onednn_fusion_enabled"><code>onednn_fusion_enabled</code></a>
</td> <td><p>Returns whether onednn JIT fusion is enabled</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.set_fusion_strategy#torch.jit.set_fusion_strategy" title="torch.jit.set_fusion_strategy"><code>set_fusion_strategy</code></a>
</td> <td><p>Sets the type and number of specializations that can occur during fusion.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.strict_fusion#torch.jit.strict_fusion" title="torch.jit.strict_fusion"><code>strict_fusion</code></a>
</td> <td><p>This class errors if not all nodes have been fused in inference, or symbolically differentiated in training.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.save#torch.jit.save" title="torch.jit.save"><code>save</code></a>
</td> <td><p>Save an offline version of this module for use in a separate process.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.load#torch.jit.load" title="torch.jit.load"><code>load</code></a>
</td> <td><p>Load a <a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a> or <a class="reference internal" href="generated/torch.jit.scriptfunction#torch.jit.ScriptFunction" title="torch.jit.ScriptFunction"><code>ScriptFunction</code></a> previously saved with <a class="reference internal" href="generated/torch.jit.save#torch.jit.save" title="torch.jit.save"><code>torch.jit.save</code></a></p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.ignore#torch.jit.ignore" title="torch.jit.ignore"><code>ignore</code></a>
</td> <td><p>This decorator indicates to the compiler that a function or method should be ignored and left as a Python function.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.unused#torch.jit.unused" title="torch.jit.unused"><code>unused</code></a>
</td> <td><p>This decorator indicates to the compiler that a function or method should be ignored and replaced with the raising of an exception.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.isinstance#torch.jit.isinstance" title="torch.jit.isinstance"><code>isinstance</code></a>
</td> <td><p>This function provides for container type refinement in TorchScript.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.attribute#torch.jit.Attribute" title="torch.jit.Attribute"><code>Attribute</code></a>
</td> <td><p>This method is a pass-through function that returns <code>value</code>, mostly used to indicate to the TorchScript compiler that the left-hand side expression is a class instance attribute with type of <code>type</code>.</p></td> </tr> <tr>
<td>


<a class="reference internal" href="generated/torch.jit.annotate#torch.jit.annotate" title="torch.jit.annotate"><code>annotate</code></a>
</td> <td><p>This method is a pass-through function that returns <code>the_value</code>, used to hint TorchScript compiler the type of <code>the_value</code>.</p></td> </tr>  </table>   <h2 id="mixing-tracing-and-scripting">Mixing Tracing and Scripting</h2> <p>In many cases either tracing or scripting is an easier approach for converting a model to TorchScript. Tracing and scripting can be composed to suit the particular requirements of a part of a model.</p> <p>Scripted functions can call traced functions. This is particularly useful when you need to use control-flow around a simple feed-forward model. For instance the beam search of a sequence to sequence model will typically be written in script but can call an encoder module generated using tracing.</p> <p>Example (calling a traced function in script):</p> <pre data-language="python">import torch

def foo(x, y):
    return 2 * x + y

traced_foo = torch.jit.trace(foo, (torch.rand(3), torch.rand(3)))

@torch.jit.script
def bar(x):
    return traced_foo(x, x)
</pre> <p>Traced functions can call script functions. This is useful when a small part of a model requires some control-flow even though most of the model is just a feed-forward network. Control-flow inside of a script function called by a traced function is preserved correctly.</p> <p>Example (calling a script function in a traced function):</p> <pre data-language="python">import torch

@torch.jit.script
def foo(x, y):
    if x.max() &gt; y.max():
        r = x
    else:
        r = y
    return r


def bar(x, y, z):
    return foo(x, y) + z

traced_bar = torch.jit.trace(bar, (torch.rand(3), torch.rand(3), torch.rand(3)))
</pre> <p>This composition also works for <code>nn.Module</code>s as well, where it can be used to generate a submodule using tracing that can be called from the methods of a script module.</p> <p>Example (using a traced module):</p> <pre data-language="python">import torch
import torchvision

class MyScriptModule(torch.nn.Module):
    def __init__(self):
        super().__init__()
        self.means = torch.nn.Parameter(torch.tensor([103.939, 116.779, 123.68])
                                        .resize_(1, 3, 1, 1))
        self.resnet = torch.jit.trace(torchvision.models.resnet18(),
                                      torch.rand(1, 3, 224, 224))

    def forward(self, input):
        return self.resnet(input - self.means)

my_script_module = torch.jit.script(MyScriptModule())
</pre>   <h2 id="torchscript-language">TorchScript Language</h2> <p>TorchScript is a statically typed subset of Python, so many Python features apply directly to TorchScript. See the full <a class="reference internal" href="jit_language_reference#language-reference"><span class="std std-ref">TorchScript Language Reference</span></a> for details.</p>   <h2 id="builtin-functions">Built-in Functions and Modules</h2> <p id="built-in-functions-and-modules">TorchScript supports the use of most PyTorch functions and many Python built-ins. See <a class="reference internal" href="jit_builtin_functions#builtin-functions"><span class="std std-ref">TorchScript Builtins</span></a> for a full reference of supported functions.</p>  <h3 id="pytorch-functions-and-modules">PyTorch Functions and Modules</h3> <p>TorchScript supports a subset of the tensor and neural network functions that PyTorch provides. Most methods on Tensor as well as functions in the <code>torch</code> namespace, all functions in <code>torch.nn.functional</code> and most modules from <code>torch.nn</code> are supported in TorchScript.</p> <p>See <a class="reference internal" href="jit_unsupported#jit-unsupported"><span class="std std-ref">TorchScript Unsupported PyTorch Constructs</span></a> for a list of unsupported PyTorch functions and modules.</p>   <h3 id="python-functions-and-modules">Python Functions and Modules</h3> <p>Many of Python’s <a class="reference external" href="https://docs.python.org/3/library/functions.html">built-in functions</a> are supported in TorchScript. The <a class="reference external" href="https://docs.python.org/3/library/math.html#module-math" title="(in Python v3.12)"><code>math</code></a> module is also supported (see <a class="reference internal" href="jit_builtin_functions#math-module"><span class="std std-ref">math Module</span></a> for details), but no other Python modules (built-in or third party) are supported.</p>   <h3 id="python-language-reference-comparison">Python Language Reference Comparison</h3> <p>For a full listing of supported Python features, see <a class="reference internal" href="jit_python_reference#python-language-reference"><span class="std std-ref">Python Language Reference Coverage</span></a>.</p>    <h2 id="debugging">Debugging</h2>  <h3 id="disable-torchscript">Disable JIT for Debugging</h3> <dl class="std envvar" id="disable-jit-for-debugging"> <dt class="sig sig-object std" id="envvar-PYTORCH_JIT">
<code>PYTORCH_JIT</code> </dt> 
</dl> <p>Setting the environment variable <code>PYTORCH_JIT=0</code> will disable all script and tracing annotations. If there is hard-to-debug error in one of your TorchScript models, you can use this flag to force everything to run using native Python. Since TorchScript (scripting and tracing) is disabled with this flag, you can use tools like <code>pdb</code> to debug the model code. For example:</p> <pre data-language="python">@torch.jit.script
def scripted_fn(x : torch.Tensor):
    for i in range(12):
        x = x + x
    return x

def fn(x):
    x = torch.neg(x)
    import pdb; pdb.set_trace()
    return scripted_fn(x)

traced_fn = torch.jit.trace(fn, (torch.rand(4, 5),))
traced_fn(torch.rand(3, 4))
</pre> <p>Debugging this script with <code>pdb</code> works except for when we invoke the <a class="reference internal" href="generated/torch.jit.script#torch.jit.script" title="torch.jit.script"><code>@torch.jit.script</code></a> function. We can globally disable JIT, so that we can call the <a class="reference internal" href="generated/torch.jit.script#torch.jit.script" title="torch.jit.script"><code>@torch.jit.script</code></a> function as a normal Python function and not compile it. If the above script is called <code>disable_jit_example.py</code>, we can invoke it like so:</p> <pre data-language="python">$ PYTORCH_JIT=0 python disable_jit_example.py
</pre> <p>and we will be able to step into the <a class="reference internal" href="generated/torch.jit.script#torch.jit.script" title="torch.jit.script"><code>@torch.jit.script</code></a> function as a normal Python function. To disable the TorchScript compiler for a specific function, see <a class="reference internal" href="generated/torch.jit.ignore#torch.jit.ignore" title="torch.jit.ignore"><code>@torch.jit.ignore</code></a>.</p>   <h3 id="id1">Inspecting Code</h3> <p id="inspecting-code">TorchScript provides a code pretty-printer for all <a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a> instances. This pretty-printer gives an interpretation of the script method’s code as valid Python syntax. For example:</p> <pre data-language="python">@torch.jit.script
def foo(len):
    # type: (int) -&gt; torch.Tensor
    rv = torch.zeros(3, 4)
    for i in range(len):
        if i &lt; 10:
            rv = rv - 1.0
        else:
            rv = rv + 1.0
    return rv

print(foo.code)
</pre> <p>A <a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a> with a single <code>forward</code> method will have an attribute <code>code</code>, which you can use to inspect the <a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a>’s code. If the <a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a> has more than one method, you will need to access <code>.code</code> on the method itself and not the module. We can inspect the code of a method named <code>foo</code> on a <a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a> by accessing <code>.foo.code</code>. The example above produces this output:</p> <pre data-language="python">def foo(len: int) -&gt; Tensor:
    rv = torch.zeros([3, 4], dtype=None, layout=None, device=None, pin_memory=None)
    rv0 = rv
    for i in range(len):
        if torch.lt(i, 10):
            rv1 = torch.sub(rv0, 1., 1)
        else:
            rv1 = torch.add(rv0, 1., 1)
        rv0 = rv1
    return rv0
</pre> <p>This is TorchScript’s compilation of the code for the <code>forward</code> method. You can use this to ensure TorchScript (tracing or scripting) has captured your model code correctly.</p>   <h3 id="id2">Interpreting Graphs</h3> <p id="interpreting-graphs">TorchScript also has a representation at a lower level than the code pretty- printer, in the form of IR graphs.</p> <p>TorchScript uses a static single assignment (SSA) intermediate representation (IR) to represent computation. The instructions in this format consist of ATen (the C++ backend of PyTorch) operators and other primitive operators, including control flow operators for loops and conditionals. As an example:</p> <pre data-language="python">@torch.jit.script
def foo(len):
    # type: (int) -&gt; torch.Tensor
    rv = torch.zeros(3, 4)
    for i in range(len):
        if i &lt; 10:
            rv = rv - 1.0
        else:
            rv = rv + 1.0
    return rv

print(foo.graph)
</pre> <p><code>graph</code> follows the same rules described in the <a class="reference internal" href="#inspecting-code"><span class="std std-ref">Inspecting Code</span></a> section with regard to <code>forward</code> method lookup.</p> <p>The example script above produces the graph:</p> <pre data-language="python">graph(%len.1 : int):
  %24 : int = prim::Constant[value=1]()
  %17 : bool = prim::Constant[value=1]() # test.py:10:5
  %12 : bool? = prim::Constant()
  %10 : Device? = prim::Constant()
  %6 : int? = prim::Constant()
  %1 : int = prim::Constant[value=3]() # test.py:9:22
  %2 : int = prim::Constant[value=4]() # test.py:9:25
  %20 : int = prim::Constant[value=10]() # test.py:11:16
  %23 : float = prim::Constant[value=1]() # test.py:12:23
  %4 : int[] = prim::ListConstruct(%1, %2)
  %rv.1 : Tensor = aten::zeros(%4, %6, %6, %10, %12) # test.py:9:10
  %rv : Tensor = prim::Loop(%len.1, %17, %rv.1) # test.py:10:5
    block0(%i.1 : int, %rv.14 : Tensor):
      %21 : bool = aten::lt(%i.1, %20) # test.py:11:12
      %rv.13 : Tensor = prim::If(%21) # test.py:11:9
        block0():
          %rv.3 : Tensor = aten::sub(%rv.14, %23, %24) # test.py:12:18
          -&gt; (%rv.3)
        block1():
          %rv.6 : Tensor = aten::add(%rv.14, %23, %24) # test.py:14:18
          -&gt; (%rv.6)
      -&gt; (%17, %rv.13)
  return (%rv)
</pre> <p>Take the instruction <code>%rv.1 : Tensor = aten::zeros(%4, %6, %6, %10, %12) # test.py:9:10</code> for example.</p> <ul class="simple"> <li>
<code>%rv.1 : Tensor</code> means we assign the output to a (unique) value named <code>rv.1</code>, that value is of <code>Tensor</code> type and that we do not know its concrete shape.</li> <li>
<code>aten::zeros</code> is the operator (equivalent to <code>torch.zeros</code>) and the input list <code>(%4, %6, %6, %10, %12)</code> specifies which values in scope should be passed as inputs. The schema for built-in functions like <code>aten::zeros</code> can be found at <a class="reference internal" href="#builtin-functions">Builtin Functions</a>.</li> <li>
<code># test.py:9:10</code> is the location in the original source file that generated this instruction. In this case, it is a file named <code>test.py</code>, on line 9, and at character 10.</li> </ul> <p>Notice that operators can also have associated <code>blocks</code>, namely the <code>prim::Loop</code> and <code>prim::If</code> operators. In the graph print-out, these operators are formatted to reflect their equivalent source code forms to facilitate easy debugging.</p> <p>Graphs can be inspected as shown to confirm that the computation described by a <a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a> is correct, in both automated and manual fashion, as described below.</p>   <h3 id="tracer">Tracer</h3>  <h4 id="tracing-edge-cases">Tracing Edge Cases</h4> <p>There are some edge cases that exist where the trace of a given Python function/module will not be representative of the underlying code. These cases can include:</p> <ul class="simple"> <li>Tracing of control flow that is dependent on inputs (e.g. tensor shapes)</li> <li>Tracing of in-place operations of tensor views (e.g. indexing on the left-hand side of an assignment)</li> </ul> <p>Note that these cases may in fact be traceable in the future.</p>   <h4 id="automatic-trace-checking">Automatic Trace Checking</h4> <p>One way to automatically catch many errors in traces is by using <code>check_inputs</code> on the <code>torch.jit.trace()</code> API. <code>check_inputs</code> takes a list of tuples of inputs that will be used to re-trace the computation and verify the results. For example:</p> <pre data-language="python">def loop_in_traced_fn(x):
    result = x[0]
    for i in range(x.size(0)):
        result = result * x[i]
    return result

inputs = (torch.rand(3, 4, 5),)
check_inputs = [(torch.rand(4, 5, 6),), (torch.rand(2, 3, 4),)]

traced = torch.jit.trace(loop_in_traced_fn, inputs, check_inputs=check_inputs)
</pre> <p>Gives us the following diagnostic information:</p> <pre data-language="python">ERROR: Graphs differed across invocations!
Graph diff:

            graph(%x : Tensor) {
            %1 : int = prim::Constant[value=0]()
            %2 : int = prim::Constant[value=0]()
            %result.1 : Tensor = aten::select(%x, %1, %2)
            %4 : int = prim::Constant[value=0]()
            %5 : int = prim::Constant[value=0]()
            %6 : Tensor = aten::select(%x, %4, %5)
            %result.2 : Tensor = aten::mul(%result.1, %6)
            %8 : int = prim::Constant[value=0]()
            %9 : int = prim::Constant[value=1]()
            %10 : Tensor = aten::select(%x, %8, %9)
        -   %result : Tensor = aten::mul(%result.2, %10)
        +   %result.3 : Tensor = aten::mul(%result.2, %10)
        ?          ++
            %12 : int = prim::Constant[value=0]()
            %13 : int = prim::Constant[value=2]()
            %14 : Tensor = aten::select(%x, %12, %13)
        +   %result : Tensor = aten::mul(%result.3, %14)
        +   %16 : int = prim::Constant[value=0]()
        +   %17 : int = prim::Constant[value=3]()
        +   %18 : Tensor = aten::select(%x, %16, %17)
        -   %15 : Tensor = aten::mul(%result, %14)
        ?     ^                                 ^
        +   %19 : Tensor = aten::mul(%result, %18)
        ?     ^                                 ^
        -   return (%15);
        ?             ^
        +   return (%19);
        ?             ^
            }
</pre> <p>This message indicates to us that the computation differed between when we first traced it and when we traced it with the <code>check_inputs</code>. Indeed, the loop within the body of <code>loop_in_traced_fn</code> depends on the shape of the input <code>x</code>, and thus when we try another <code>x</code> with a different shape, the trace differs.</p> <p>In this case, data-dependent control flow like this can be captured using <a class="reference internal" href="generated/torch.jit.script#torch.jit.script" title="torch.jit.script"><code>torch.jit.script()</code></a> instead:</p> <pre data-language="python">def fn(x):
    result = x[0]
    for i in range(x.size(0)):
        result = result * x[i]
    return result

inputs = (torch.rand(3, 4, 5),)
check_inputs = [(torch.rand(4, 5, 6),), (torch.rand(2, 3, 4),)]

scripted_fn = torch.jit.script(fn)
print(scripted_fn.graph)
#print(str(scripted_fn.graph).strip())

for input_tuple in [inputs] + check_inputs:
    torch.testing.assert_close(fn(*input_tuple), scripted_fn(*input_tuple))
</pre> <p>Which produces:</p> <pre data-language="python">graph(%x : Tensor) {
    %5 : bool = prim::Constant[value=1]()
    %1 : int = prim::Constant[value=0]()
    %result.1 : Tensor = aten::select(%x, %1, %1)
    %4 : int = aten::size(%x, %1)
    %result : Tensor = prim::Loop(%4, %5, %result.1)
    block0(%i : int, %7 : Tensor) {
        %10 : Tensor = aten::select(%x, %1, %i)
        %result.2 : Tensor = aten::mul(%7, %10)
        -&gt; (%5, %result.2)
    }
    return (%result);
}
</pre>   <h4 id="tracer-warnings">Tracer Warnings</h4> <p>The tracer produces warnings for several problematic patterns in traced computation. As an example, take a trace of a function that contains an in-place assignment on a slice (a view) of a Tensor:</p> <pre data-language="python">def fill_row_zero(x):
    x[0] = torch.rand(*x.shape[1:2])
    return x

traced = torch.jit.trace(fill_row_zero, (torch.rand(3, 4),))
print(traced.graph)
</pre> <p>Produces several warnings and a graph which simply returns the input:</p> <pre data-language="python">fill_row_zero.py:4: TracerWarning: There are 2 live references to the data region being modified when tracing in-place operator copy_ (possibly due to an assignment). This might cause the trace to be incorrect, because all other views that also reference this data will not reflect this change in the trace! On the other hand, if all other views use the same memory chunk, but are disjoint (e.g. are outputs of torch.split), this might still be safe.
    x[0] = torch.rand(*x.shape[1:2])
fill_row_zero.py:6: TracerWarning: Output nr 1. of the traced function does not match the corresponding output of the Python function. Detailed error:
Not within tolerance rtol=1e-05 atol=1e-05 at input[0, 1] (0.09115803241729736 vs. 0.6782537698745728) and 3 other locations (33.00%)
    traced = torch.jit.trace(fill_row_zero, (torch.rand(3, 4),))
graph(%0 : Float(3, 4)) {
    return (%0);
}
</pre> <p>We can fix this by modifying the code to not use the in-place update, but rather build up the result tensor out-of-place with <code>torch.cat</code>:</p> <pre data-language="python">def fill_row_zero(x):
    x = torch.cat((torch.rand(1, *x.shape[1:2]), x[1:2]), dim=0)
    return x

traced = torch.jit.trace(fill_row_zero, (torch.rand(3, 4),))
print(traced.graph)
</pre>     <h2 id="frequently-asked-questions">Frequently Asked Questions</h2> <p>Q: I would like to train a model on GPU and do inference on CPU. What are the best practices?</p>  <p>First convert your model from GPU to CPU and then save it, like so:</p> <pre data-language="python">cpu_model = gpu_model.cpu()
sample_input_cpu = sample_input_gpu.cpu()
traced_cpu = torch.jit.trace(cpu_model, sample_input_cpu)
torch.jit.save(traced_cpu, "cpu.pt")

traced_gpu = torch.jit.trace(gpu_model, sample_input_gpu)
torch.jit.save(traced_gpu, "gpu.pt")

# ... later, when using the model:

if use_gpu:
  model = torch.jit.load("gpu.pt")
else:
  model = torch.jit.load("cpu.pt")

model(input)
</pre> <p>This is recommended because the tracer may witness tensor creation on a specific device, so casting an already-loaded model may have unexpected effects. Casting the model <em>before</em> saving it ensures that the tracer has the correct device information.</p>  <p>Q: How do I store attributes on a <a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a>?</p>  <p>Say we have a model like:</p> <pre data-language="python">import torch

class Model(torch.nn.Module):
    def __init__(self):
        super().__init__()
        self.x = 2

    def forward(self):
        return self.x

m = torch.jit.script(Model())
</pre> <p>If <code>Model</code> is instantiated it will result in a compilation error since the compiler doesn’t know about <code>x</code>. There are 4 ways to inform the compiler of attributes on <a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a>:</p> <p>1. <code>nn.Parameter</code> - Values wrapped in <code>nn.Parameter</code> will work as they do on <code>nn.Module</code>s</p> <p>2. <code>register_buffer</code> - Values wrapped in <code>register_buffer</code> will work as they do on <code>nn.Module</code>s. This is equivalent to an attribute (see 4) of type <code>Tensor</code>.</p> <p>3. Constants - Annotating a class member as <code>Final</code> (or adding it to a list called <code>__constants__</code> at the class definition level) will mark the contained names as constants. Constants are saved directly in the code of the model. See <code>builtin-constants</code> for details.</p> <p>4. Attributes - Values that are a <code>supported type</code> can be added as mutable attributes. Most types can be inferred but some may need to be specified, see <code>module attributes</code> for details.</p>  <p>Q: I would like to trace module’s method but I keep getting this error:</p> <p><code>RuntimeError: Cannot insert a Tensor that requires grad as a constant. Consider making it a parameter or input, or detaching the gradient</code></p>  <p>This error usually means that the method you are tracing uses a module’s parameters and you are passing the module’s method instead of the module instance (e.g. <code>my_module_instance.forward</code> vs <code>my_module_instance</code>).</p>  <ul class="simple"> <li>Invoking <code>trace</code> with a module’s method captures module parameters (which may require gradients) as <strong>constants</strong>.</li> <li>On the other hand, invoking <code>trace</code> with module’s instance (e.g. <code>my_module</code>) creates a new module and correctly copies parameters into the new module, so they can accumulate gradients if required.</li> </ul>  <p>To trace a specific method on a module, see <a class="reference internal" href="generated/torch.jit.trace_module#torch.jit.trace_module" title="torch.jit.trace_module"><code>torch.jit.trace_module</code></a></p>    <h2 id="known-issues">Known Issues</h2> <p>If you’re using <code>Sequential</code> with TorchScript, the inputs of some of the <code>Sequential</code> submodules may be falsely inferred to be <code>Tensor</code>, even if they’re annotated otherwise. The canonical solution is to subclass <code>nn.Sequential</code> and redeclare <code>forward</code> with the input typed correctly.</p>   <h2 id="appendix">Appendix</h2>  <h3 id="migrating-to-pytorch-1-2-recursive-scripting-api">Migrating to PyTorch 1.2 Recursive Scripting API</h3> <p>This section details the changes to TorchScript in PyTorch 1.2. If you are new to TorchScript you can skip this section. There are two main changes to the TorchScript API with PyTorch 1.2.</p> <p>1. <a class="reference internal" href="generated/torch.jit.script#torch.jit.script" title="torch.jit.script"><code>torch.jit.script</code></a> will now attempt to recursively compile functions, methods, and classes that it encounters. Once you call <code>torch.jit.script</code>, compilation is “opt-out”, rather than “opt-in”.</p> <p>2. <code>torch.jit.script(nn_module_instance)</code> is now the preferred way to create <a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a>s, instead of inheriting from <code>torch.jit.ScriptModule</code>. These changes combine to provide a simpler, easier-to-use API for converting your <code>nn.Module</code>s into <a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a>s, ready to be optimized and executed in a non-Python environment.</p> <p>The new usage looks like this:</p> <pre data-language="python">import torch
import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))

my_model = Model()
my_scripted_model = torch.jit.script(my_model)
</pre> <ul class="simple"> <li>The module’s <code>forward</code> is compiled by default. Methods called from <code>forward</code> are lazily compiled in the order they are used in <code>forward</code>.</li> <li>To compile a method other than <code>forward</code> that is not called from <code>forward</code>, add <code>@torch.jit.export</code>.</li> <li>To stop the compiler from compiling a method, add <a class="reference internal" href="generated/torch.jit.ignore#torch.jit.ignore" title="torch.jit.ignore"><code>@torch.jit.ignore</code></a> or <a class="reference internal" href="generated/torch.jit.unused#torch.jit.unused" title="torch.jit.unused"><code>@torch.jit.unused</code></a>. <code>@ignore</code> leaves the</li> <li>method as a call to python, and <code>@unused</code> replaces it with an exception. <code>@ignored</code> cannot be exported; <code>@unused</code> can.</li> <li>Most attribute types can be inferred, so <code>torch.jit.Attribute</code> is not necessary. For empty container types, annotate their types using <a class="reference external" href="https://www.python.org/dev/peps/pep-0526/#class-and-instance-variable-annotations">PEP 526-style</a> class annotations.</li> <li>Constants can be marked with a <code>Final</code> class annotation instead of adding the name of the member to <code>__constants__</code>.</li> <li>Python 3 type hints can be used in place of <code>torch.jit.annotate</code>
</li> </ul> <dl class="simple"> <dt>As a result of these changes, the following items are considered deprecated and should not appear in new code:</dt>
<dd>
<ul class="simple"> <li>The <code>@torch.jit.script_method</code> decorator</li> <li>Classes that inherit from <code>torch.jit.ScriptModule</code>
</li> <li>The <code>torch.jit.Attribute</code> wrapper class</li> <li>The <code>__constants__</code> array</li> <li>The <code>torch.jit.annotate</code> function</li> </ul> </dd> </dl>  <h4 id="modules">Modules</h4> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The <a class="reference internal" href="generated/torch.jit.ignore#torch.jit.ignore" title="torch.jit.ignore"><code>@torch.jit.ignore</code></a> annotation’s behavior changes in PyTorch 1.2. Before PyTorch 1.2 the @ignore decorator was used to make a function or method callable from code that is exported. To get this functionality back, use <code>@torch.jit.unused()</code>. <code>@torch.jit.ignore</code> is now equivalent to <code>@torch.jit.ignore(drop=False)</code>. See <a class="reference internal" href="generated/torch.jit.ignore#torch.jit.ignore" title="torch.jit.ignore"><code>@torch.jit.ignore</code></a> and <a class="reference internal" href="generated/torch.jit.unused#torch.jit.unused" title="torch.jit.unused"><code>@torch.jit.unused</code></a> for details.</p> </div> <p>When passed to the <a class="reference internal" href="generated/torch.jit.script#torch.jit.script" title="torch.jit.script"><code>torch.jit.script</code></a> function, a <code>torch.nn.Module</code>'s data is copied to a <a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a> and the TorchScript compiler compiles the module. The module’s <code>forward</code> is compiled by default. Methods called from <code>forward</code> are lazily compiled in the order they are used in <code>forward</code>, as well as any <code>@torch.jit.export</code> methods.</p> <dl class="py function"> <dt class="sig sig-object py" id="torch.jit.export">
<code>torch.jit.export(fn)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/_jit_internal.html#export"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This decorator indicates that a method on an <code>nn.Module</code> is used as an entry point into a <a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a> and should be compiled.</p> <p><code>forward</code> implicitly is assumed to be an entry point, so it does not need this decorator. Functions and methods called from <code>forward</code> are compiled as they are seen by the compiler, so they do not need this decorator either.</p> <p>Example (using <code>@torch.jit.export</code> on a method):</p> <pre data-language="python">import torch
import torch.nn as nn

class MyModule(nn.Module):
    def implicitly_compiled_method(self, x):
        return x + 99

    # `forward` is implicitly decorated with `@torch.jit.export`,
    # so adding it here would have no effect
    def forward(self, x):
        return x + 10

    @torch.jit.export
    def another_forward(self, x):
        # When the compiler sees this call, it will compile
        # `implicitly_compiled_method`
        return self.implicitly_compiled_method(x)

    def unused_method(self, x):
        return x - 20

# `m` will contain compiled methods:
#     `forward`
#     `another_forward`
#     `implicitly_compiled_method`
# `unused_method` will not be compiled since it was not called from
# any compiled methods and wasn't decorated with `@torch.jit.export`
m = torch.jit.script(MyModule())
</pre> </dd>
</dl>   <h4 id="functions">Functions</h4> <p>Functions don’t change much, they can be decorated with <a class="reference internal" href="generated/torch.jit.ignore#torch.jit.ignore" title="torch.jit.ignore"><code>@torch.jit.ignore</code></a> or <a class="reference internal" href="generated/torch.jit.unused#torch.jit.unused" title="torch.jit.unused"><code>torch.jit.unused</code></a> if needed.</p> <pre data-language="python"># Same behavior as pre-PyTorch 1.2
@torch.jit.script
def some_fn():
    return 2

# Marks a function as ignored, if nothing
# ever calls it then this has no effect
@torch.jit.ignore
def some_fn2():
    return 2

# As with ignore, if nothing calls it then it has no effect.
# If it is called in script it is replaced with an exception.
@torch.jit.unused
def some_fn3():
  import pdb; pdb.set_trace()
  return 4

# Doesn't do anything, this function is already
# the main entry point
@torch.jit.export
def some_fn4():
    return 2
</pre>   <h4 id="torchscript-classes">TorchScript Classes</h4> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>TorchScript class support is experimental. Currently it is best suited for simple record-like types (think a <code>NamedTuple</code> with methods attached).</p> </div> <p>Everything in a user defined <a class="reference external" href="torchscript-class">TorchScript Class</a> is exported by default, functions can be decorated with <a class="reference internal" href="generated/torch.jit.ignore#torch.jit.ignore" title="torch.jit.ignore"><code>@torch.jit.ignore</code></a> if needed.</p>   <h4 id="attributes">Attributes</h4> <p>The TorchScript compiler needs to know the types of <code>module attributes</code>. Most types can be inferred from the value of the member. Empty lists and dicts cannot have their types inferred and must have their types annotated with <a class="reference external" href="https://www.python.org/dev/peps/pep-0526/#class-and-instance-variable-annotations">PEP 526-style</a> class annotations. If a type cannot be inferred and is not explicitly annotated, it will not be added as an attribute to the resulting <a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a></p> <p>Old API:</p> <pre data-language="python">from typing import Dict
import torch

class MyModule(torch.jit.ScriptModule):
    def __init__(self):
        super().__init__()
        self.my_dict = torch.jit.Attribute({}, Dict[str, int])
        self.my_int = torch.jit.Attribute(20, int)

m = MyModule()
</pre> <p>New API:</p> <pre data-language="python">from typing import Dict

class MyModule(torch.nn.Module):
    my_dict: Dict[str, int]

    def __init__(self):
        super().__init__()
        # This type cannot be inferred and must be specified
        self.my_dict = {}

        # The attribute type here is inferred to be `int`
        self.my_int = 20

    def forward(self):
        pass

m = torch.jit.script(MyModule())
</pre>   <h4 id="constants">Constants</h4> <p>The <code>Final</code> type constructor can be used to mark members as <code>constant</code>. If members are not marked constant, they will be copied to the resulting <a class="reference internal" href="generated/torch.jit.scriptmodule#torch.jit.ScriptModule" title="torch.jit.ScriptModule"><code>ScriptModule</code></a> as an attribute. Using <code>Final</code> opens opportunities for optimization if the value is known to be fixed and gives additional type safety.</p> <p>Old API:</p> <pre data-language="python">class MyModule(torch.jit.ScriptModule):
    __constants__ = ['my_constant']

    def __init__(self):
        super().__init__()
        self.my_constant = 2

    def forward(self):
        pass
m = MyModule()
</pre> <p>New API:</p> <pre data-language="python">from typing import Final

class MyModule(torch.nn.Module):

    my_constant: Final[int]

    def __init__(self):
        super().__init__()
        self.my_constant = 2

    def forward(self):
        pass

m = torch.jit.script(MyModule())
</pre>   <h4 id="python-3-type-hints">Variables</h4> <p id="variables">Containers are assumed to have type <code>Tensor</code> and be non-optional (see <code>Default Types</code> for more information). Previously, <code>torch.jit.annotate</code> was used to tell the TorchScript compiler what the type should be. Python 3 style type hints are now supported.</p> <pre data-language="python">import torch
from typing import Dict, Optional

@torch.jit.script
def make_dict(flag: bool):
    x: Dict[str, int] = {}
    x['hi'] = 2
    b: Optional[int] = None
    if flag:
        b = 2
    return x, b
</pre>    <h3 id="fusion-backends">Fusion Backends</h3> <p>There are a couple of fusion backends available to optimize TorchScript execution. The default fuser on CPUs is NNC, which can perform fusions for both CPUs and GPUs. The default fuser on GPUs is NVFuser, which supports a wider range of operators and has demonstrated generated kernels with improved throughput. See the <a class="reference external" href="https://github.com/pytorch/pytorch/blob/main/torch/csrc/jit/codegen/cuda/README.md">NVFuser documentation</a> for more details on usage and debugging.</p>   <h3 id="references">References</h3>  <ul id="module-torch.jit.mobile"> <li class="toctree-l1"><a class="reference internal" href="jit_python_reference">Python Language Reference Coverage</a></li> <li class="toctree-l1"><a class="reference internal" href="jit_unsupported">TorchScript Unsupported PyTorch Constructs</a></li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2024, PyTorch Contributors<br>PyTorch has a BSD-style license, as found in the <a href="https://github.com/pytorch/pytorch/blob/main/LICENSE">LICENSE</a> file.<br>
    <a href="https://pytorch.org/docs/2.1/jit.html" class="_attribution-link">https://pytorch.org/docs/2.1/jit.html</a>
  </p>
</div>
