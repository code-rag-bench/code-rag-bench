<h1 id="torch-linalg-svd">torch.linalg.svd</h1> <dl class="py function"> <dt class="sig sig-object py" id="torch.linalg.svd">
<code>torch.linalg.svd(A, full_matrices=True, *, driver=None, out=None)</code> </dt> <dd>
<p>Computes the singular value decomposition (SVD) of a matrix.</p> <p>Letting <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">K</mi></mrow><annotation encoding="application/x-tex">\mathbb{K}</annotation></semantics></math></span></span></span> be <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span></span></span> or <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span></span></span>, the <strong>full SVD</strong> of a matrix <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∈</mo><msup><mi mathvariant="double-struck">K</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">A \in \mathbb{K}^{m \times n}</annotation></semantics></math></span></span></span>, if <code>k = min(m,n)</code>, is defined as</p> <div class="math"> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo>=</mo><mi>U</mi><mi mathvariant="normal">diag</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><msup><mi>V</mi><mtext>H</mtext></msup><mpadded width="0px"><mrow><mspace width="2em"></mspace><mi>U</mi><mo>∈</mo><msup><mi mathvariant="double-struck">K</mi><mrow><mi>m</mi><mo>×</mo><mi>m</mi></mrow></msup><mo separator="true">,</mo><mi>S</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>k</mi></msup><mo separator="true">,</mo><mi>V</mi><mo>∈</mo><msup><mi mathvariant="double-struck">K</mi><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow></mpadded></mrow><annotation encoding="application/x-tex">A = U \operatorname{diag}(S) V^{\text{H}} \mathrlap{\qquad U \in \mathbb{K}^{m \times m}, S \in \mathbb{R}^k, V \in \mathbb{K}^{n \times n}}</annotation></semantics></math></span></span></span>
</div>
<p>where <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">diag</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>∈</mo><msup><mi mathvariant="double-struck">K</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\operatorname{diag}(S) \in \mathbb{K}^{m \times n}</annotation></semantics></math></span></span></span>, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>V</mi><mtext>H</mtext></msup></mrow><annotation encoding="application/x-tex">V^{\text{H}}</annotation></semantics></math></span></span></span> is the conjugate transpose when <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span></span></span> is complex, and the transpose when <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span></span></span> is real-valued. The matrices <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span></span></span>, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span></span></span> (and thus <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>V</mi><mtext>H</mtext></msup></mrow><annotation encoding="application/x-tex">V^{\text{H}}</annotation></semantics></math></span></span></span>) are orthogonal in the real case, and unitary in the complex case.</p> <p>When <code>m &gt; n</code> (resp. <code>m &lt; n</code>) we can drop the last <code>m - n</code> (resp. <code>n - m</code>) columns of <code>U</code> (resp. <code>V</code>) to form the <strong>reduced SVD</strong>:</p> <div class="math"> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mo>=</mo><mi>U</mi><mi mathvariant="normal">diag</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><msup><mi>V</mi><mtext>H</mtext></msup><mpadded width="0px"><mrow><mspace width="2em"></mspace><mi>U</mi><mo>∈</mo><msup><mi mathvariant="double-struck">K</mi><mrow><mi>m</mi><mo>×</mo><mi>k</mi></mrow></msup><mo separator="true">,</mo><mi>S</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mi>k</mi></msup><mo separator="true">,</mo><mi>V</mi><mo>∈</mo><msup><mi mathvariant="double-struck">K</mi><mrow><mi>k</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow></mpadded></mrow><annotation encoding="application/x-tex">A = U \operatorname{diag}(S) V^{\text{H}} \mathrlap{\qquad U \in \mathbb{K}^{m \times k}, S \in \mathbb{R}^k, V \in \mathbb{K}^{k \times n}}</annotation></semantics></math></span></span></span>
</div>
<p>where <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">diag</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>∈</mo><msup><mi mathvariant="double-struck">K</mi><mrow><mi>k</mi><mo>×</mo><mi>k</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\operatorname{diag}(S) \in \mathbb{K}^{k \times k}</annotation></semantics></math></span></span></span>. In this case, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span></span></span> and <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span></span></span> also have orthonormal columns.</p> <p>Supports input of float, double, cfloat and cdouble dtypes. Also supports batches of matrices, and if <code>A</code> is a batch of matrices then the output has the same batch dimensions.</p> <p>The returned decomposition is a named tuple <code>(U, S, Vh)</code> which corresponds to <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span></span></span>, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span></span></span>, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>V</mi><mtext>H</mtext></msup></mrow><annotation encoding="application/x-tex">V^{\text{H}}</annotation></semantics></math></span></span></span> above.</p> <p>The singular values are returned in descending order.</p> <p>The parameter <code>full_matrices</code> chooses between the full (default) and reduced SVD.</p> <p>The <code>driver</code> kwarg may be used in CUDA with a cuSOLVER backend to choose the algorithm used to compute the SVD. The choice of a driver is a trade-off between accuracy and speed.</p> <ul class="simple"> <li>
<p>If <code>A</code> is well-conditioned (its <a class="reference external" href="https://pytorch.org/docs/master/linalg.html#torch.linalg.cond">condition number</a> is not too large), or you do not mind some precision loss.</p> <ul> <li>For a general matrix: <code>‘gesvdj’</code> (Jacobi method)</li> <li>If <code>A</code> is tall or wide (<code>m &gt;&gt; n</code> or <code>m &lt;&lt; n</code>): <code>‘gesvda’</code> (Approximate method)</li> </ul> </li> <li>If <code>A</code> is not well-conditioned or precision is relevant: <code>‘gesvd’</code> (QR based)</li> </ul> <p>By default (<code>driver</code><code>= None</code>), we call <code>‘gesvdj’</code> and, if it fails, we fallback to <code>‘gesvd’</code>.</p> <p>Differences with <code>numpy.linalg.svd</code>:</p> <ul class="simple"> <li>Unlike <code>numpy.linalg.svd</code>, this function always returns a tuple of three tensors and it doesn’t support <code>compute_uv</code> argument. Please use <a class="reference internal" href="torch.linalg.svdvals#torch.linalg.svdvals" title="torch.linalg.svdvals"><code>torch.linalg.svdvals()</code></a>, which computes only the singular values, instead of <code>compute_uv=False</code>.</li> </ul> <div class="admonition note"> <p class="admonition-title">Note</p> <p>When <code>full_matrices</code><code>= True</code>, the gradients with respect to <code>U[…, :, min(m, n):]</code> and <code>Vh[…, min(m, n):, :]</code> will be ignored, as those vectors can be arbitrary bases of the corresponding subspaces.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The returned tensors <code>U</code> and <code>V</code> are not unique, nor are they continuous with respect to <code>A</code>. Due to this lack of uniqueness, different hardware and software may compute different singular vectors.</p> <p>This non-uniqueness is caused by the fact that multiplying any pair of singular vectors <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">u_k, v_k</annotation></semantics></math></span></span></span> by <code>-1</code> in the real case or by <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>e</mi><mrow><mi>i</mi><mi>ϕ</mi></mrow></msup><mo separator="true">,</mo><mi>ϕ</mi><mo>∈</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">e^{i \phi}, \phi \in \mathbb{R}</annotation></semantics></math></span></span></span> in the complex case produces another two valid singular vectors of the matrix. For this reason, the loss function shall not depend on this <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>e</mi><mrow><mi>i</mi><mi>ϕ</mi></mrow></msup></mrow><annotation encoding="application/x-tex">e^{i \phi}</annotation></semantics></math></span></span></span> quantity, as it is not well-defined. This is checked for complex inputs when computing the gradients of this function. As such, when inputs are complex and are on a CUDA device, the computation of the gradients of this function synchronizes that device with the CPU.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Gradients computed using <code>U</code> or <code>Vh</code> will only be finite when <code>A</code> does not have repeated singular values. If <code>A</code> is rectangular, additionally, zero must also not be one of its singular values. Furthermore, if the distance between any two singular values is close to zero, the gradient will be numerically unstable, as it depends on the singular values <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_i</annotation></semantics></math></span></span></span> through the computation of <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mrow><msub><mrow><mi>min</mi><mo>⁡</mo></mrow><mrow><mi>i</mi><mo mathvariant="normal">≠</mo><mi>j</mi></mrow></msub><msubsup><mi>σ</mi><mi>i</mi><mn>2</mn></msubsup><mo>−</mo><msubsup><mi>σ</mi><mi>j</mi><mn>2</mn></msubsup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{\min_{i \neq j} \sigma_i^2 - \sigma_j^2}</annotation></semantics></math></span></span></span>. In the rectangular case, the gradient will also be numerically unstable when <code>A</code> has small singular values, as it also depends on the computation of <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><msub><mi>σ</mi><mi>i</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{\sigma_i}</annotation></semantics></math></span></span></span>.</p> </div> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="torch.linalg.svdvals#torch.linalg.svdvals" title="torch.linalg.svdvals"><code>torch.linalg.svdvals()</code></a> computes only the singular values. Unlike <a class="reference internal" href="#torch.linalg.svd" title="torch.linalg.svd"><code>torch.linalg.svd()</code></a>, the gradients of <a class="reference internal" href="torch.linalg.svdvals#torch.linalg.svdvals" title="torch.linalg.svdvals"><code>svdvals()</code></a> are always numerically stable.</p> <p><a class="reference internal" href="torch.linalg.eig#torch.linalg.eig" title="torch.linalg.eig"><code>torch.linalg.eig()</code></a> for a function that computes another type of spectral decomposition of a matrix. The eigendecomposition works just on square matrices.</p> <p><a class="reference internal" href="torch.linalg.eigh#torch.linalg.eigh" title="torch.linalg.eigh"><code>torch.linalg.eigh()</code></a> for a (faster) function that computes the eigenvalue decomposition for Hermitian and symmetric matrices.</p> <p><a class="reference internal" href="torch.linalg.qr#torch.linalg.qr" title="torch.linalg.qr"><code>torch.linalg.qr()</code></a> for another (much faster) decomposition that works on general matrices.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>A</strong> (<a class="reference internal" href="../tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – tensor of shape <code>(*, m, n)</code> where <code>*</code> is zero or more batch dimensions.</li> <li>
<strong>full_matrices</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – controls whether to compute the full or reduced SVD, and consequently, the shape of the returned tensors <code>U</code> and <code>Vh</code>. Default: <code>True</code>.</li> </ul> </dd> <dt class="field-even">Keyword Arguments</dt> <dd class="field-even">
<ul class="simple"> <li>
<strong>driver</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a><em>, </em><em>optional</em>) – name of the cuSOLVER method to be used. This keyword argument only works on CUDA inputs. Available options are: <code>None</code>, <code>gesvd</code>, <code>gesvdj</code>, and <code>gesvda</code>. Default: <code>None</code>.</li> <li>
<strong>out</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)">tuple</a><em>, </em><em>optional</em>) – output tuple of three tensors. Ignored if <code>None</code>.</li> </ul> </dd> <dt class="field-odd">Returns</dt> <dd class="field-odd">

<p>A named tuple <code>(U, S, Vh)</code> which corresponds to <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span></span></span>, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span></span></span>, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>V</mi><mtext>H</mtext></msup></mrow><annotation encoding="application/x-tex">V^{\text{H}}</annotation></semantics></math></span></span></span> above.</p> <p><code>S</code> will always be real-valued, even when <code>A</code> is complex. It will also be ordered in descending order.</p> <p><code>U</code> and <code>Vh</code> will have the same dtype as <code>A</code>. The left / right singular vectors will be given by the columns of <code>U</code> and the rows of <code>Vh</code> respectively.</p> </dd> </dl> <p>Examples:</p> <pre data-language="python">&gt;&gt;&gt; A = torch.randn(5, 3)
&gt;&gt;&gt; U, S, Vh = torch.linalg.svd(A, full_matrices=False)
&gt;&gt;&gt; U.shape, S.shape, Vh.shape
(torch.Size([5, 3]), torch.Size([3]), torch.Size([3, 3]))
&gt;&gt;&gt; torch.dist(A, U @ torch.diag(S) @ Vh)
tensor(1.0486e-06)

&gt;&gt;&gt; U, S, Vh = torch.linalg.svd(A)
&gt;&gt;&gt; U.shape, S.shape, Vh.shape
(torch.Size([5, 5]), torch.Size([3]), torch.Size([3, 3]))
&gt;&gt;&gt; torch.dist(A, U[:, :3] @ torch.diag(S) @ Vh)
tensor(1.0486e-06)

&gt;&gt;&gt; A = torch.randn(7, 5, 3)
&gt;&gt;&gt; U, S, Vh = torch.linalg.svd(A, full_matrices=False)
&gt;&gt;&gt; torch.dist(A, U @ torch.diag_embed(S) @ Vh)
tensor(3.0957e-06)
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2024, PyTorch Contributors<br>PyTorch has a BSD-style license, as found in the <a href="https://github.com/pytorch/pytorch/blob/main/LICENSE">LICENSE</a> file.<br>
    <a href="https://pytorch.org/docs/2.1/generated/torch.linalg.svd.html" class="_attribution-link">https://pytorch.org/docs/2.1/generated/torch.linalg.svd.html</a>
  </p>
</div>
