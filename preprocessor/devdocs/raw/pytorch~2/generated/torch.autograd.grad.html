<h1 id="torch-autograd-grad">torch.autograd.grad</h1> <dl class="py function"> <dt class="sig sig-object py" id="torch.autograd.grad">
<code>torch.autograd.grad(outputs, inputs, grad_outputs=None, retain_graph=None, create_graph=False, only_inputs=True, allow_unused=None, is_grads_batched=False, materialize_grads=False)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/autograd.html#grad"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Computes and returns the sum of gradients of outputs with respect to the inputs.</p> <p><code>grad_outputs</code> should be a sequence of length matching <code>output</code> containing the “vector” in vector-Jacobian product, usually the pre-computed gradients w.r.t. each of the outputs. If an output doesn’t require_grad, then the gradient can be <code>None</code>).</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you run any forward ops, create <code>grad_outputs</code>, and/or call <code>grad</code> in a user-specified CUDA stream context, see <a class="reference internal" href="https://pytorch.org/docs/2.1/notes/cuda.html#bwd-cuda-stream-semantics"><span class="std std-ref">Stream semantics of backward passes</span></a>.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code>only_inputs</code> argument is deprecated and is ignored now (defaults to <code>True</code>). To accumulate gradient for other parts of the graph, please use <code>torch.autograd.backward</code>.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>outputs</strong> (<em>sequence</em><em> of </em><a class="reference internal" href="../tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – outputs of the differentiated function.</li> <li>
<strong>inputs</strong> (<em>sequence</em><em> of </em><a class="reference internal" href="../tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – Inputs w.r.t. which the gradient will be returned (and not accumulated into <code>.grad</code>).</li> <li>
<strong>grad_outputs</strong> (<em>sequence</em><em> of </em><a class="reference internal" href="../tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – The “vector” in the vector-Jacobian product. Usually gradients w.r.t. each output. None values can be specified for scalar Tensors or ones that don’t require grad. If a None value would be acceptable for all grad_tensors, then this argument is optional. Default: None.</li> <li>
<strong>retain_graph</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – If <code>False</code>, the graph used to compute the grad will be freed. Note that in nearly all cases setting this option to <code>True</code> is not needed and often can be worked around in a much more efficient way. Defaults to the value of <code>create_graph</code>.</li> <li>
<strong>create_graph</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, graph of the derivative will be constructed, allowing to compute higher order derivative products. Default: <code>False</code>.</li> <li>
<strong>allow_unused</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>]</em><em>, </em><em>optional</em>) – If <code>False</code>, specifying inputs that were not used when computing outputs (and therefore their grad is always zero) is an error. Defaults to the value of <code>materialize_grads</code>.</li> <li>
<strong>is_grads_batched</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, the first dimension of each tensor in <code>grad_outputs</code> will be interpreted as the batch dimension. Instead of computing a single vector-Jacobian product, we compute a batch of vector-Jacobian products for each “vector” in the batch. We use the vmap prototype feature as the backend to vectorize calls to the autograd engine so that this computation can be performed in a single call. This should lead to performance improvements when compared to manually looping and performing backward multiple times. Note that due to this feature being experimental, there may be performance cliffs. Please use <code>torch._C._debug_only_display_vmap_fallback_warnings(True)</code> to show any performance warnings and file an issue on github if warnings exist for your use case. Defaults to <code>False</code>.</li> <li>
<strong>materialize_grads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, set the gradient for unused inputs to zero instead of None. This is useful when computing higher-order derivatives. If <code>materialize_grads</code> is <code>True</code> and <code>allow_unused</code> is <code>False</code>, an error will be raised. Defaults to <code>False</code>.</li> </ul> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Tuple" title="(in Python v3.12)">Tuple</a>[<a class="reference internal" href="../tensors#torch.Tensor" title="torch.Tensor">Tensor</a>, …]</p> </dd> </dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2024, PyTorch Contributors<br>PyTorch has a BSD-style license, as found in the <a href="https://github.com/pytorch/pytorch/blob/main/LICENSE">LICENSE</a> file.<br>
    <a href="https://pytorch.org/docs/2.1/generated/torch.autograd.grad.html" class="_attribution-link">https://pytorch.org/docs/2.1/generated/torch.autograd.grad.html</a>
  </p>
</div>
