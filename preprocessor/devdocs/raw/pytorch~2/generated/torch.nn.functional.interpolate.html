<h1 id="torch-nn-functional-interpolate">torch.nn.functional.interpolate</h1> <dl class="py function"> <dt class="sig sig-object py" id="torch.nn.functional.interpolate">
<code>torch.nn.functional.interpolate(input, size=None, scale_factor=None, mode='nearest', align_corners=None, recompute_scale_factor=None, antialias=False)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/nn/functional.html#interpolate"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Down/up samples the input to either the given <code>size</code> or the given <code>scale_factor</code></p> <p>The algorithm used for interpolation is determined by <code>mode</code>.</p> <p>Currently temporal, spatial and volumetric sampling are supported, i.e. expected inputs are 3-D, 4-D or 5-D in shape.</p> <p>The input dimensions are interpreted in the form: <code>mini-batch x channels x [optional depth] x [optional height] x width</code>.</p> <p>The modes available for resizing are: <code>nearest</code>, <code>linear</code> (3D-only), <code>bilinear</code>, <code>bicubic</code> (4D-only), <code>trilinear</code> (5D-only), <code>area</code>, <code>nearest-exact</code></p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="../tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – the input tensor</li> <li>
<strong>size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)">int</a><em> or </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)">int</a><em>] or </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)">int</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)">int</a><em>] or </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)">int</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)">int</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)">int</a><em>]</em>) – output spatial size.</li> <li>
<strong>scale_factor</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)">float</a><em> or </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)">float</a><em>]</em>) – multiplier for spatial size. If <code>scale_factor</code> is a tuple, its length has to match the number of spatial dimensions; <code>input.dim() - 2</code>.</li> <li>
<strong>mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a>) – algorithm used for upsampling: <code>'nearest'</code> | <code>'linear'</code> | <code>'bilinear'</code> | <code>'bicubic'</code> | <code>'trilinear'</code> | <code>'area'</code> | <code>'nearest-exact'</code>. Default: <code>'nearest'</code>
</li> <li>
<strong>align_corners</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – Geometrically, we consider the pixels of the input and output as squares rather than points. If set to <code>True</code>, the input and output tensors are aligned by the center points of their corner pixels, preserving the values at the corner pixels. If set to <code>False</code>, the input and output tensors are aligned by the corner points of their corner pixels, and the interpolation uses edge value padding for out-of-boundary values, making this operation <em>independent</em> of input size when <code>scale_factor</code> is kept the same. This only has an effect when <code>mode</code> is <code>'linear'</code>, <code>'bilinear'</code>, <code>'bicubic'</code> or <code>'trilinear'</code>. Default: <code>False</code>
</li> <li>
<strong>recompute_scale_factor</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – recompute the scale_factor for use in the interpolation calculation. If <code>recompute_scale_factor</code> is <code>True</code>, then <code>scale_factor</code> must be passed in and <code>scale_factor</code> is used to compute the output <code>size</code>. The computed output <code>size</code> will be used to infer new scales for the interpolation. Note that when <code>scale_factor</code> is floating-point, it may differ from the recomputed <code>scale_factor</code> due to rounding and precision issues. If <code>recompute_scale_factor</code> is <code>False</code>, then <code>size</code> or <code>scale_factor</code> will be used directly for interpolation. Default: <code>None</code>.</li> <li>
<strong>antialias</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – flag to apply anti-aliasing. Default: <code>False</code>. Using anti-alias option together with <code>align_corners=False</code>, interpolation result would match Pillow result for downsampling operation. Supported modes: <code>'bilinear'</code>, <code>'bicubic'</code>.</li> </ul> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p><a class="reference internal" href="../tensors#torch.Tensor" title="torch.Tensor">Tensor</a></p> </dd> </dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>With <code>mode='bicubic'</code>, it’s possible to cause overshoot, in other words it can produce negative values or values greater than 255 for images. Explicitly call <code>result.clamp(min=0, max=255)</code> if you want to reduce the overshoot when displaying the image.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Mode <code>mode='nearest-exact'</code> matches Scikit-Image and PIL nearest neighbours interpolation algorithms and fixes known issues with <code>mode='nearest'</code>. This mode is introduced to keep backward compatibility. Mode <code>mode='nearest'</code> matches buggy OpenCV’s <code>INTER_NEAREST</code> interpolation algorithm.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The gradients for the dtype <code>float16</code> on CUDA may be inaccurate in the upsample operation when using modes <code>['linear', 'bilinear', 'bicubic', 'trilinear', 'area']</code>. For more details, please refer to the discussion in <a class="reference external" href="https://github.com/pytorch/pytorch/issues/104157">issue#104157</a>.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This operation may produce nondeterministic gradients when given tensors on a CUDA device. See <a class="reference internal" href="https://pytorch.org/docs/2.1/notes/randomness.html"><span class="doc">Reproducibility</span></a> for more information.</p> </div> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2024, PyTorch Contributors<br>PyTorch has a BSD-style license, as found in the <a href="https://github.com/pytorch/pytorch/blob/main/LICENSE">LICENSE</a> file.<br>
    <a href="https://pytorch.org/docs/2.1/generated/torch.nn.functional.interpolate.html" class="_attribution-link">https://pytorch.org/docs/2.1/generated/torch.nn.functional.interpolate.html</a>
  </p>
</div>
