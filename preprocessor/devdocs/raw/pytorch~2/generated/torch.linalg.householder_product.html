<h1 id="torch-linalg-householder-product">torch.linalg.householder_product</h1> <dl class="py function"> <dt class="sig sig-object py" id="torch.linalg.householder_product">
<code>torch.linalg.householder_product(A, tau, *, out=None) → Tensor</code> </dt> <dd>
<p>Computes the first <code>n</code> columns of a product of Householder matrices.</p> <p>Let <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">K</mi></mrow><annotation encoding="application/x-tex">\mathbb{K}</annotation></semantics></math></span></span></span> be <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span></span></span> or <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">C</mi></mrow><annotation encoding="application/x-tex">\mathbb{C}</annotation></semantics></math></span></span></span>, and let <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>∈</mo><msup><mi mathvariant="double-struck">K</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">V \in \mathbb{K}^{m \times n}</annotation></semantics></math></span></span></span> be a matrix with columns <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">K</mi><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">v_i \in \mathbb{K}^m</annotation></semantics></math></span></span></span> for <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">i=1,\ldots,m</annotation></semantics></math></span></span></span> with <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≥</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \geq n</annotation></semantics></math></span></span></span>. Denote by <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span></span></span> the vector resulting from zeroing out the first <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span></span></span> components of <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span></span></span> and setting to <code>1</code> the <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span></span></span>-th. For a vector <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo>∈</mo><msup><mi mathvariant="double-struck">K</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">\tau \in \mathbb{K}^k</annotation></semantics></math></span></span></span> with <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">k \leq n</annotation></semantics></math></span></span></span>, this function computes the first <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span></span></span> columns of the matrix</p> <div class="math"> <span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><msub><mi>H</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>H</mi><mi>k</mi></msub><mspace width="2em"></mspace><mtext>with</mtext><mspace width="2em"></mspace><msub><mi>H</mi><mi>i</mi></msub><mo>=</mo><msub><mi mathvariant="normal">I</mi><mi>m</mi></msub><mo>−</mo><msub><mi>τ</mi><mi>i</mi></msub><msub><mi>w</mi><mi>i</mi></msub><msubsup><mi>w</mi><mi>i</mi><mtext>H</mtext></msubsup></mrow><annotation encoding="application/x-tex">H_1H_2 ... H_k \qquad\text{with}\qquad H_i = \mathrm{I}_m - \tau_i w_i w_i^{\text{H}}</annotation></semantics></math></span></span></span>
</div>
<p>where <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">I</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\mathrm{I}_m</annotation></semantics></math></span></span></span> is the <code>m</code>-dimensional identity matrix and <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>w</mi><mtext>H</mtext></msup></mrow><annotation encoding="application/x-tex">w^{\text{H}}</annotation></semantics></math></span></span></span> is the conjugate transpose when <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span></span></span> is complex, and the transpose when <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span></span></span> is real-valued. The output matrix is the same size as the input matrix <code>A</code>.</p> <p>See <a class="reference external" href="https://www.netlib.org/lapack/lug/node128.html">Representation of Orthogonal or Unitary Matrices</a> for further details.</p> <p>Supports inputs of float, double, cfloat and cdouble dtypes. Also supports batches of matrices, and if the inputs are batches of matrices then the output has the same batch dimensions.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="torch.geqrf#torch.geqrf" title="torch.geqrf"><code>torch.geqrf()</code></a> can be used together with this function to form the <code>Q</code> from the <a class="reference internal" href="torch.linalg.qr#torch.linalg.qr" title="torch.linalg.qr"><code>qr()</code></a> decomposition.</p> <p><a class="reference internal" href="torch.ormqr#torch.ormqr" title="torch.ormqr"><code>torch.ormqr()</code></a> is a related function that computes the matrix multiplication of a product of Householder matrices with another matrix. However, that function is not supported by autograd.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Gradient computations are only well-defined if <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><msub><mi>u</mi><mi>i</mi></msub><mo mathvariant="normal">≠</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>v</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">tau_i \neq \frac{1}{||v_i||^2}</annotation></semantics></math></span></span></span>. If this condition is not met, no error will be thrown, but the gradient produced may contain <code>NaN</code>.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>A</strong> (<a class="reference internal" href="../tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – tensor of shape <code>(*, m, n)</code> where <code>*</code> is zero or more batch dimensions.</li> <li>
<strong>tau</strong> (<a class="reference internal" href="../tensors#torch.Tensor" title="torch.Tensor">Tensor</a>) – tensor of shape <code>(*, k)</code> where <code>*</code> is zero or more batch dimensions.</li> </ul> </dd> <dt class="field-even">Keyword Arguments</dt> <dd class="field-even">
<p><strong>out</strong> (<a class="reference internal" href="../tensors#torch.Tensor" title="torch.Tensor">Tensor</a><em>, </em><em>optional</em>) – output tensor. Ignored if <code>None</code>. Default: <code>None</code>.</p> </dd> <dt class="field-odd">Raises</dt> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.12)"><strong>RuntimeError</strong></a> – if <code>A</code> doesn’t satisfy the requirement <code>m &gt;= n</code>, or <code>tau</code> doesn’t satisfy the requirement <code>n &gt;= k</code>.</p> </dd> </dl> <p>Examples:</p> <pre data-language="python">&gt;&gt;&gt; A = torch.randn(2, 2)
&gt;&gt;&gt; h, tau = torch.geqrf(A)
&gt;&gt;&gt; Q = torch.linalg.householder_product(h, tau)
&gt;&gt;&gt; torch.dist(Q, torch.linalg.qr(A).Q)
tensor(0.)

&gt;&gt;&gt; h = torch.randn(3, 2, 2, dtype=torch.complex128)
&gt;&gt;&gt; tau = torch.randn(3, 1, dtype=torch.complex128)
&gt;&gt;&gt; Q = torch.linalg.householder_product(h, tau)
&gt;&gt;&gt; Q
tensor([[[ 1.8034+0.4184j,  0.2588-1.0174j],
        [-0.6853+0.7953j,  2.0790+0.5620j]],

        [[ 1.4581+1.6989j, -1.5360+0.1193j],
        [ 1.3877-0.6691j,  1.3512+1.3024j]],

        [[ 1.4766+0.5783j,  0.0361+0.6587j],
        [ 0.6396+0.1612j,  1.3693+0.4481j]]], dtype=torch.complex128)
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2024, PyTorch Contributors<br>PyTorch has a BSD-style license, as found in the <a href="https://github.com/pytorch/pytorch/blob/main/LICENSE">LICENSE</a> file.<br>
    <a href="https://pytorch.org/docs/2.1/generated/torch.linalg.householder_product.html" class="_attribution-link">https://pytorch.org/docs/2.1/generated/torch.linalg.householder_product.html</a>
  </p>
</div>
