<h1 id="automatic-mixed-precision-package-torch-amp">Automatic Mixed Precision package - torch.amp</h1> <p id="module-torch.amp"><a class="reference internal" href="#module-torch.amp" title="torch.amp"><code>torch.amp</code></a> provides convenience methods for mixed precision, where some operations use the <code>torch.float32</code> (<code>float</code>) datatype and other operations use lower precision floating point datatype (<code>lower_precision_fp</code>): <code>torch.float16</code> (<code>half</code>) or <code>torch.bfloat16</code>. Some ops, like linear layers and convolutions, are much faster in <code>lower_precision_fp</code>. Other ops, like reductions, often require the dynamic range of <code>float32</code>. Mixed precision tries to match each op to its appropriate datatype.</p> <p>Ordinarily, “automatic mixed precision training” with datatype of <code>torch.float16</code> uses <a class="reference internal" href="#torch.autocast" title="torch.autocast"><code>torch.autocast</code></a> and <a class="reference internal" href="#torch.cuda.amp.GradScaler" title="torch.cuda.amp.GradScaler"><code>torch.cuda.amp.GradScaler</code></a> together, as shown in the <a class="reference internal" href="https://pytorch.org/docs/2.1/notes/amp_examples.html#amp-examples"><span class="std std-ref">CUDA Automatic Mixed Precision examples</span></a> and <a class="reference external" href="https://pytorch.org/tutorials/recipes/recipes/amp_recipe.html">CUDA Automatic Mixed Precision recipe</a>. However, <a class="reference internal" href="#torch.autocast" title="torch.autocast"><code>torch.autocast</code></a> and <a class="reference internal" href="#torch.cuda.amp.GradScaler" title="torch.cuda.amp.GradScaler"><code>torch.cuda.amp.GradScaler</code></a> are modular, and may be used separately if desired. As shown in the CPU example section of <a class="reference internal" href="#torch.autocast" title="torch.autocast"><code>torch.autocast</code></a>, “automatic mixed precision training/inference” on CPU with datatype of <code>torch.bfloat16</code> only uses <a class="reference internal" href="#torch.autocast" title="torch.autocast"><code>torch.autocast</code></a>.</p> <p>For CUDA and CPU, APIs are also provided separately:</p> <ul class="simple"> <li>
<code>torch.autocast("cuda", args...)</code> is equivalent to <code>torch.cuda.amp.autocast(args...)</code>.</li> <li>
<code>torch.autocast("cpu", args...)</code> is equivalent to <code>torch.cpu.amp.autocast(args...)</code>. For CPU, only lower precision floating point datatype of <code>torch.bfloat16</code> is supported for now.</li> </ul> <p><a class="reference internal" href="#torch.autocast" title="torch.autocast"><code>torch.autocast</code></a> and <a class="reference internal" href="#torch.cpu.amp.autocast" title="torch.cpu.amp.autocast"><code>torch.cpu.amp.autocast</code></a> are new in version <code>1.10</code>.</p>  <ul class="simple"> <li><a class="reference internal" href="#autocasting" id="id4">Autocasting</a></li> <li><a class="reference internal" href="#gradient-scaling" id="id5">Gradient Scaling</a></li> <li>
<p><a class="reference internal" href="#autocast-op-reference" id="id6">Autocast Op Reference</a></p> <ul> <li><a class="reference internal" href="#op-eligibility" id="id7">Op Eligibility</a></li> <li>
<p><a class="reference internal" href="#cuda-op-specific-behavior" id="id8">CUDA Op-Specific Behavior</a></p> <ul> <li><a class="reference internal" href="#cuda-ops-that-can-autocast-to-float16" id="id9">CUDA Ops that can autocast to <code>float16</code></a></li> <li><a class="reference internal" href="#cuda-ops-that-can-autocast-to-float32" id="id10">CUDA Ops that can autocast to <code>float32</code></a></li> <li><a class="reference internal" href="#cuda-ops-that-promote-to-the-widest-input-type" id="id11">CUDA Ops that promote to the widest input type</a></li> <li><a class="reference internal" href="#prefer-binary-cross-entropy-with-logits-over-binary-cross-entropy" id="id12">Prefer <code>binary_cross_entropy_with_logits</code> over <code>binary_cross_entropy</code></a></li> </ul> </li> <li>
<p><a class="reference internal" href="#cpu-op-specific-behavior" id="id13">CPU Op-Specific Behavior</a></p> <ul> <li><a class="reference internal" href="#cpu-ops-that-can-autocast-to-bfloat16" id="id14">CPU Ops that can autocast to <code>bfloat16</code></a></li> <li><a class="reference internal" href="#cpu-ops-that-can-autocast-to-float32" id="id15">CPU Ops that can autocast to <code>float32</code></a></li> <li><a class="reference internal" href="#cpu-ops-that-promote-to-the-widest-input-type" id="id16">CPU Ops that promote to the widest input type</a></li> </ul> </li> </ul> </li> </ul>   <h2 id="id1">Autocasting</h2> <dl class="py class" id="autocasting"> <dt class="sig sig-object py" id="torch.autocast">
<code>class torch.autocast(device_type, dtype=None, enabled=True, cache_enabled=None)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/amp/autocast_mode.html#autocast"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Instances of <a class="reference internal" href="#torch.autocast" title="torch.autocast"><code>autocast</code></a> serve as context managers or decorators that allow regions of your script to run in mixed precision.</p> <p>In these regions, ops run in an op-specific dtype chosen by autocast to improve performance while maintaining accuracy. See the <a class="reference internal" href="#autocast-op-reference"><span class="std std-ref">Autocast Op Reference</span></a> for details.</p> <p>When entering an autocast-enabled region, Tensors may be any type. You should not call <code>half()</code> or <code>bfloat16()</code> on your model(s) or inputs when using autocasting.</p> <p><a class="reference internal" href="#torch.autocast" title="torch.autocast"><code>autocast</code></a> should wrap only the forward pass(es) of your network, including the loss computation(s). Backward passes under autocast are not recommended. Backward ops run in the same type that autocast used for corresponding forward ops.</p> <p>Example for CUDA Devices:</p> <pre data-language="python"># Creates model and optimizer in default precision
model = Net().cuda()
optimizer = optim.SGD(model.parameters(), ...)

for input, target in data:
    optimizer.zero_grad()

    # Enables autocasting for the forward pass (model + loss)
    with torch.autocast(device_type="cuda"):
        output = model(input)
        loss = loss_fn(output, target)

    # Exits the context manager before backward()
    loss.backward()
    optimizer.step()
</pre> <p>See the <a class="reference internal" href="https://pytorch.org/docs/2.1/notes/amp_examples.html#amp-examples"><span class="std std-ref">CUDA Automatic Mixed Precision examples</span></a> for usage (along with gradient scaling) in more complex scenarios (e.g., gradient penalty, multiple models/losses, custom autograd functions).</p> <p><a class="reference internal" href="#torch.autocast" title="torch.autocast"><code>autocast</code></a> can also be used as a decorator, e.g., on the <code>forward</code> method of your model:</p> <pre data-language="python">class AutocastModel(nn.Module):
    ...
    @torch.autocast(device_type="cuda")
    def forward(self, input):
        ...
</pre> <p>Floating-point Tensors produced in an autocast-enabled region may be <code>float16</code>. After returning to an autocast-disabled region, using them with floating-point Tensors of different dtypes may cause type mismatch errors. If so, cast the Tensor(s) produced in the autocast region back to <code>float32</code> (or other dtype if desired). If a Tensor from the autocast region is already <code>float32</code>, the cast is a no-op, and incurs no additional overhead. CUDA Example:</p> <pre data-language="python"># Creates some tensors in default dtype (here assumed to be float32)
a_float32 = torch.rand((8, 8), device="cuda")
b_float32 = torch.rand((8, 8), device="cuda")
c_float32 = torch.rand((8, 8), device="cuda")
d_float32 = torch.rand((8, 8), device="cuda")

with torch.autocast(device_type="cuda"):
    # torch.mm is on autocast's list of ops that should run in float16.
    # Inputs are float32, but the op runs in float16 and produces float16 output.
    # No manual casts are required.
    e_float16 = torch.mm(a_float32, b_float32)
    # Also handles mixed input types
    f_float16 = torch.mm(d_float32, e_float16)

# After exiting autocast, calls f_float16.float() to use with d_float32
g_float32 = torch.mm(d_float32, f_float16.float())
</pre> <p>CPU Training Example:</p> <pre data-language="python"># Creates model and optimizer in default precision
model = Net()
optimizer = optim.SGD(model.parameters(), ...)

for epoch in epochs:
    for input, target in data:
        optimizer.zero_grad()

        # Runs the forward pass with autocasting.
        with torch.autocast(device_type="cpu", dtype=torch.bfloat16):
            output = model(input)
            loss = loss_fn(output, target)

        loss.backward()
        optimizer.step()
</pre> <p>CPU Inference Example:</p> <pre data-language="python"># Creates model in default precision
model = Net().eval()

with torch.autocast(device_type="cpu", dtype=torch.bfloat16):
    for input in data:
        # Runs the forward pass with autocasting.
        output = model(input)
</pre> <p>CPU Inference Example with Jit Trace:</p> <pre data-language="python">class TestModel(nn.Module):
    def __init__(self, input_size, num_classes):
        super().__init__()
        self.fc1 = nn.Linear(input_size, num_classes)
    def forward(self, x):
        return self.fc1(x)

input_size = 2
num_classes = 2
model = TestModel(input_size, num_classes).eval()

# For now, we suggest to disable the Jit Autocast Pass,
# As the issue: https://github.com/pytorch/pytorch/issues/75956
torch._C._jit_set_autocast_mode(False)

with torch.cpu.amp.autocast(cache_enabled=False):
    model = torch.jit.trace(model, torch.randn(1, input_size))
model = torch.jit.freeze(model)
# Models Run
for _ in range(3):
    model(torch.randn(1, input_size))
</pre> <p>Type mismatch errors <em>in</em> an autocast-enabled region are a bug; if this is what you observe, please file an issue.</p> <p><code>autocast(enabled=False)</code> subregions can be nested in autocast-enabled regions. Locally disabling autocast can be useful, for example, if you want to force a subregion to run in a particular <code>dtype</code>. Disabling autocast gives you explicit control over the execution type. In the subregion, inputs from the surrounding region should be cast to <code>dtype</code> before use:</p> <pre data-language="python"># Creates some tensors in default dtype (here assumed to be float32)
a_float32 = torch.rand((8, 8), device="cuda")
b_float32 = torch.rand((8, 8), device="cuda")
c_float32 = torch.rand((8, 8), device="cuda")
d_float32 = torch.rand((8, 8), device="cuda")

with torch.autocast(device_type="cuda"):
    e_float16 = torch.mm(a_float32, b_float32)
    with torch.autocast(device_type="cuda", enabled=False):
        # Calls e_float16.float() to ensure float32 execution
        # (necessary because e_float16 was created in an autocasted region)
        f_float32 = torch.mm(c_float32, e_float16.float())

    # No manual casts are required when re-entering the autocast-enabled region.
    # torch.mm again runs in float16 and produces float16 output, regardless of input types.
    g_float16 = torch.mm(d_float32, f_float32)
</pre> <p>The autocast state is thread-local. If you want it enabled in a new thread, the context manager or decorator must be invoked in that thread. This affects <a class="reference internal" href="generated/torch.nn.dataparallel#torch.nn.DataParallel" title="torch.nn.DataParallel"><code>torch.nn.DataParallel</code></a> and <a class="reference internal" href="generated/torch.nn.parallel.distributeddataparallel#torch.nn.parallel.DistributedDataParallel" title="torch.nn.parallel.DistributedDataParallel"><code>torch.nn.parallel.DistributedDataParallel</code></a> when used with more than one GPU per process (see <a class="reference internal" href="https://pytorch.org/docs/2.1/notes/amp_examples.html#amp-multigpu"><span class="std std-ref">Working with Multiple GPUs</span></a>).</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>device_type</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a><em>, </em><em>required</em>) – Device type to use. Possible values are: ‘cuda’, ‘cpu’, ‘xpu’ and ‘hpu’. The type is the same as the <code>type</code> attribute of a <a class="reference internal" href="tensor_attributes#torch.device" title="torch.device"><code>torch.device</code></a>. Thus, you may obtain the device type of a tensor using <code>Tensor.device.type</code>.</li> <li>
<strong>enabled</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – Whether autocasting should be enabled in the region. Default: <code>True</code>
</li> <li>
<strong>dtype</strong> (<em>torch_dtype</em><em>, </em><em>optional</em>) – Whether to use torch.float16 or torch.bfloat16.</li> <li>
<strong>cache_enabled</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – Whether the weight cache inside autocast should be enabled. Default: <code>True</code>
</li> </ul> </dd> </dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.cuda.amp.autocast">
<code>class torch.cuda.amp.autocast(enabled=True, dtype=torch.float16, cache_enabled=True)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/cuda/amp/autocast_mode.html#autocast"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>See <a class="reference internal" href="#torch.autocast" title="torch.autocast"><code>torch.autocast</code></a>. <code>torch.cuda.amp.autocast(args...)</code> is equivalent to <code>torch.autocast("cuda", args...)</code></p>  </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="torch.cuda.amp.custom_fwd">
<code>torch.cuda.amp.custom_fwd(fwd=None, *, cast_inputs=None)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/cuda/amp/autocast_mode.html#custom_fwd"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Helper decorator for <code>forward</code> methods of custom autograd functions (subclasses of <a class="reference internal" href="autograd#torch.autograd.Function" title="torch.autograd.Function"><code>torch.autograd.Function</code></a>). See the <a class="reference internal" href="https://pytorch.org/docs/2.1/notes/amp_examples.html#amp-custom-examples"><span class="std std-ref">example page</span></a> for more detail.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>cast_inputs</strong> (<a class="reference internal" href="tensor_attributes#torch.dtype" title="torch.dtype"><code>torch.dtype</code></a> or None, optional, default=None) – If not <code>None</code>, when <code>forward</code> runs in an autocast-enabled region, casts incoming floating-point CUDA Tensors to the target dtype (non-floating-point Tensors are not affected), then executes <code>forward</code> with autocast disabled. If <code>None</code>, <code>forward</code>’s internal ops execute with the current autocast state.</p> </dd> </dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If the decorated <code>forward</code> is called outside an autocast-enabled region, <a class="reference internal" href="#torch.cuda.amp.custom_fwd" title="torch.cuda.amp.custom_fwd"><code>custom_fwd</code></a> is a no-op and <code>cast_inputs</code> has no effect.</p> </div> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="torch.cuda.amp.custom_bwd">
<code>torch.cuda.amp.custom_bwd(bwd)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/cuda/amp/autocast_mode.html#custom_bwd"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Helper decorator for backward methods of custom autograd functions (subclasses of <a class="reference internal" href="autograd#torch.autograd.Function" title="torch.autograd.Function"><code>torch.autograd.Function</code></a>). Ensures that <code>backward</code> executes with the same autocast state as <code>forward</code>. See the <a class="reference internal" href="https://pytorch.org/docs/2.1/notes/amp_examples.html#amp-custom-examples"><span class="std std-ref">example page</span></a> for more detail.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="torch.cpu.amp.autocast">
<code>class torch.cpu.amp.autocast(enabled=True, dtype=torch.bfloat16, cache_enabled=True)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/cpu/amp/autocast_mode.html#autocast"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>See <a class="reference internal" href="#torch.autocast" title="torch.autocast"><code>torch.autocast</code></a>. <code>torch.cpu.amp.autocast(args...)</code> is equivalent to <code>torch.autocast("cpu", args...)</code></p>  </dd>
</dl>   <h2 id="id2">Gradient Scaling</h2> <p id="gradient-scaling">If the forward pass for a particular op has <code>float16</code> inputs, the backward pass for that op will produce <code>float16</code> gradients. Gradient values with small magnitudes may not be representable in <code>float16</code>. These values will flush to zero (“underflow”), so the update for the corresponding parameters will be lost.</p> <p>To prevent underflow, “gradient scaling” multiplies the network’s loss(es) by a scale factor and invokes a backward pass on the scaled loss(es). Gradients flowing backward through the network are then scaled by the same factor. In other words, gradient values have a larger magnitude, so they don’t flush to zero.</p> <p>Each parameter’s gradient (<code>.grad</code> attribute) should be unscaled before the optimizer updates the parameters, so the scale factor does not interfere with the learning rate.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>AMP/fp16 may not work for every model! For example, most bf16-pretrained models cannot operate in the fp16 numerical range of max 65504 and will cause gradients to overflow instead of underflow. In this case, the scale factor may decrease under 1 as an attempt to bring gradients to a number representable in the fp16 dynamic range. While one may expect the scale to always be above 1, our GradScaler does NOT make this guarantee to maintain performance. If you encounter NaNs in your loss or gradients when running with AMP/fp16, verify your model is compatible.</p> </div> <dl class="py class"> <dt class="sig sig-object py" id="torch.cuda.amp.GradScaler">
<code>class torch.cuda.amp.GradScaler(init_scale=65536.0, growth_factor=2.0, backoff_factor=0.5, growth_interval=2000, enabled=True)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/cuda/amp/grad_scaler.html#GradScaler"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="py method"> <dt class="sig sig-object py" id="torch.cuda.amp.GradScaler.get_backoff_factor">
<code>get_backoff_factor()</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/cuda/amp/grad_scaler.html#GradScaler.get_backoff_factor"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a Python float containing the scale backoff factor.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.cuda.amp.GradScaler.get_growth_factor">
<code>get_growth_factor()</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/cuda/amp/grad_scaler.html#GradScaler.get_growth_factor"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a Python float containing the scale growth factor.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.cuda.amp.GradScaler.get_growth_interval">
<code>get_growth_interval()</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/cuda/amp/grad_scaler.html#GradScaler.get_growth_interval"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a Python int containing the growth interval.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.cuda.amp.GradScaler.get_scale">
<code>get_scale()</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/cuda/amp/grad_scaler.html#GradScaler.get_scale"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a Python float containing the current scale, or 1.0 if scaling is disabled.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><a class="reference internal" href="#torch.cuda.amp.GradScaler.get_scale" title="torch.cuda.amp.GradScaler.get_scale"><code>get_scale()</code></a> incurs a CPU-GPU sync.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.cuda.amp.GradScaler.is_enabled">
<code>is_enabled()</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/cuda/amp/grad_scaler.html#GradScaler.is_enabled"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a bool indicating whether this instance is enabled.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.cuda.amp.GradScaler.load_state_dict">
<code>load_state_dict(state_dict)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/cuda/amp/grad_scaler.html#GradScaler.load_state_dict"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Loads the scaler state. If this instance is disabled, <a class="reference internal" href="#torch.cuda.amp.GradScaler.load_state_dict" title="torch.cuda.amp.GradScaler.load_state_dict"><code>load_state_dict()</code></a> is a no-op.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>state_dict</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)">dict</a>) – scaler state. Should be an object returned from a call to <a class="reference internal" href="#torch.cuda.amp.GradScaler.state_dict" title="torch.cuda.amp.GradScaler.state_dict"><code>state_dict()</code></a>.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.cuda.amp.GradScaler.scale">
<code>scale(outputs)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/cuda/amp/grad_scaler.html#GradScaler.scale"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Multiplies (‘scales’) a tensor or list of tensors by the scale factor.</p> <p>Returns scaled outputs. If this instance of <a class="reference internal" href="#torch.cuda.amp.GradScaler" title="torch.cuda.amp.GradScaler"><code>GradScaler</code></a> is not enabled, outputs are returned unmodified.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>outputs</strong> (<a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor">Tensor</a><em> or </em><em>iterable</em><em> of </em><em>Tensors</em>) – Outputs to scale.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.cuda.amp.GradScaler.set_backoff_factor">
<code>set_backoff_factor(new_factor)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/cuda/amp/grad_scaler.html#GradScaler.set_backoff_factor"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>new_scale</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)">float</a>) – Value to use as the new scale backoff factor.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.cuda.amp.GradScaler.set_growth_factor">
<code>set_growth_factor(new_factor)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/cuda/amp/grad_scaler.html#GradScaler.set_growth_factor"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>new_scale</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.12)">float</a>) – Value to use as the new scale growth factor.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.cuda.amp.GradScaler.set_growth_interval">
<code>set_growth_interval(new_interval)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/cuda/amp/grad_scaler.html#GradScaler.set_growth_interval"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>new_interval</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)">int</a>) – Value to use as the new growth interval.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.cuda.amp.GradScaler.state_dict">
<code>state_dict()</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/cuda/amp/grad_scaler.html#GradScaler.state_dict"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns the state of the scaler as a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><code>dict</code></a>. It contains five entries:</p> <ul class="simple"> <li>
<code>"scale"</code> - a Python float containing the current scale</li> <li>
<code>"growth_factor"</code> - a Python float containing the current growth factor</li> <li>
<code>"backoff_factor"</code> - a Python float containing the current backoff factor</li> <li>
<code>"growth_interval"</code> - a Python int containing the current growth interval</li> <li>
<code>"_growth_tracker"</code> - a Python int containing the number of recent consecutive unskipped steps.</li> </ul> <p>If this instance is not enabled, returns an empty dict.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you wish to checkpoint the scaler’s state after a particular iteration, <a class="reference internal" href="#torch.cuda.amp.GradScaler.state_dict" title="torch.cuda.amp.GradScaler.state_dict"><code>state_dict()</code></a> should be called after <a class="reference internal" href="#torch.cuda.amp.GradScaler.update" title="torch.cuda.amp.GradScaler.update"><code>update()</code></a>.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.cuda.amp.GradScaler.step">
<code>step(optimizer, *args, **kwargs)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/cuda/amp/grad_scaler.html#GradScaler.step"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><a class="reference internal" href="#torch.cuda.amp.GradScaler.step" title="torch.cuda.amp.GradScaler.step"><code>step()</code></a> carries out the following two operations:</p> <ol class="arabic simple"> <li>Internally invokes <code>unscale_(optimizer)</code> (unless <a class="reference internal" href="#torch.cuda.amp.GradScaler.unscale_" title="torch.cuda.amp.GradScaler.unscale_"><code>unscale_()</code></a> was explicitly called for <code>optimizer</code> earlier in the iteration). As part of the <a class="reference internal" href="#torch.cuda.amp.GradScaler.unscale_" title="torch.cuda.amp.GradScaler.unscale_"><code>unscale_()</code></a>, gradients are checked for infs/NaNs.</li> <li>If no inf/NaN gradients are found, invokes <code>optimizer.step()</code> using the unscaled gradients. Otherwise, <code>optimizer.step()</code> is skipped to avoid corrupting the params.</li> </ol> <p><code>*args</code> and <code>**kwargs</code> are forwarded to <code>optimizer.step()</code>.</p> <p>Returns the return value of <code>optimizer.step(*args, **kwargs)</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>optimizer</strong> (<a class="reference internal" href="optim#torch.optim.Optimizer" title="torch.optim.Optimizer">torch.optim.Optimizer</a>) – Optimizer that applies the gradients.</li> <li>
<strong>args</strong> – Any arguments.</li> <li>
<strong>kwargs</strong> – Any keyword arguments.</li> </ul> </dd> </dl> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Closure use is not currently supported.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.cuda.amp.GradScaler.unscale_">
<code>unscale_(optimizer)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/cuda/amp/grad_scaler.html#GradScaler.unscale_"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Divides (“unscales”) the optimizer’s gradient tensors by the scale factor.</p> <p><a class="reference internal" href="#torch.cuda.amp.GradScaler.unscale_" title="torch.cuda.amp.GradScaler.unscale_"><code>unscale_()</code></a> is optional, serving cases where you need to <a class="reference internal" href="https://pytorch.org/docs/2.1/notes/amp_examples.html#working-with-unscaled-gradients"><span class="std std-ref">modify or inspect gradients</span></a> between the backward pass(es) and <a class="reference internal" href="#torch.cuda.amp.GradScaler.step" title="torch.cuda.amp.GradScaler.step"><code>step()</code></a>. If <a class="reference internal" href="#torch.cuda.amp.GradScaler.unscale_" title="torch.cuda.amp.GradScaler.unscale_"><code>unscale_()</code></a> is not called explicitly, gradients will be unscaled automatically during <a class="reference internal" href="#torch.cuda.amp.GradScaler.step" title="torch.cuda.amp.GradScaler.step"><code>step()</code></a>.</p> <p>Simple example, using <a class="reference internal" href="#torch.cuda.amp.GradScaler.unscale_" title="torch.cuda.amp.GradScaler.unscale_"><code>unscale_()</code></a> to enable clipping of unscaled gradients:</p> <pre data-language="python">...
scaler.scale(loss).backward()
scaler.unscale_(optimizer)
torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm)
scaler.step(optimizer)
scaler.update()
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>optimizer</strong> (<a class="reference internal" href="optim#torch.optim.Optimizer" title="torch.optim.Optimizer">torch.optim.Optimizer</a>) – Optimizer that owns the gradients to be unscaled.</p> </dd> </dl> <div class="admonition note"> <p class="admonition-title">Note</p> <p><a class="reference internal" href="#torch.cuda.amp.GradScaler.unscale_" title="torch.cuda.amp.GradScaler.unscale_"><code>unscale_()</code></a> does not incur a CPU-GPU sync.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><a class="reference internal" href="#torch.cuda.amp.GradScaler.unscale_" title="torch.cuda.amp.GradScaler.unscale_"><code>unscale_()</code></a> should only be called once per optimizer per <a class="reference internal" href="#torch.cuda.amp.GradScaler.step" title="torch.cuda.amp.GradScaler.step"><code>step()</code></a> call, and only after all gradients for that optimizer’s assigned parameters have been accumulated. Calling <a class="reference internal" href="#torch.cuda.amp.GradScaler.unscale_" title="torch.cuda.amp.GradScaler.unscale_"><code>unscale_()</code></a> twice for a given optimizer between each <a class="reference internal" href="#torch.cuda.amp.GradScaler.step" title="torch.cuda.amp.GradScaler.step"><code>step()</code></a> triggers a RuntimeError.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><a class="reference internal" href="#torch.cuda.amp.GradScaler.unscale_" title="torch.cuda.amp.GradScaler.unscale_"><code>unscale_()</code></a> may unscale sparse gradients out of place, replacing the <code>.grad</code> attribute.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.cuda.amp.GradScaler.update">
<code>update(new_scale=None)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/cuda/amp/grad_scaler.html#GradScaler.update"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Updates the scale factor.</p> <p>If any optimizer steps were skipped the scale is multiplied by <code>backoff_factor</code> to reduce it. If <code>growth_interval</code> unskipped iterations occurred consecutively, the scale is multiplied by <code>growth_factor</code> to increase it.</p> <p>Passing <code>new_scale</code> sets the new scale value manually. (<code>new_scale</code> is not used directly, it’s used to fill GradScaler’s internal scale tensor. So if <code>new_scale</code> was a tensor, later in-place changes to that tensor will not further affect the scale GradScaler uses internally.)</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>new_scale</strong> (float or <code>torch.cuda.FloatTensor</code>, optional, default=None) – New scale factor.</p> </dd> </dl> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><a class="reference internal" href="#torch.cuda.amp.GradScaler.update" title="torch.cuda.amp.GradScaler.update"><code>update()</code></a> should only be called at the end of the iteration, after <code>scaler.step(optimizer)</code> has been invoked for all optimizers used this iteration.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>For performance reasons, we do not check the scale factor value to avoid synchronizations, so the scale factor is not guaranteed to be above 1. If the scale falls below 1 and/or you are seeing NaNs in your gradients or loss, something is likely wrong. For example, bf16-pretrained models are often incompatible with AMP/fp16 due to differing dynamic ranges.</p> </div> </dd>
</dl> </dd>
</dl>   <h2 id="id3">Autocast Op Reference</h2>  <h3 id="autocast-eligibility">Op Eligibility</h3> <p id="autocast-op-reference">Ops that run in <code>float64</code> or non-floating-point dtypes are not eligible, and will run in these types whether or not autocast is enabled.</p> <p>Only out-of-place ops and Tensor methods are eligible. In-place variants and calls that explicitly supply an <code>out=...</code> Tensor are allowed in autocast-enabled regions, but won’t go through autocasting. For example, in an autocast-enabled region <code>a.addmm(b, c)</code> can autocast, but <code>a.addmm_(b, c)</code> and <code>a.addmm(b, c, out=d)</code> cannot. For best performance and stability, prefer out-of-place ops in autocast-enabled regions.</p> <p>Ops called with an explicit <code>dtype=...</code> argument are not eligible, and will produce output that respects the <code>dtype</code> argument.</p>   <h3 id="autocast-cuda-op-reference">CUDA Op-Specific Behavior</h3> <p id="cuda-op-specific-behavior">The following lists describe the behavior of eligible ops in autocast-enabled regions. These ops always go through autocasting whether they are invoked as part of a <a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module"><code>torch.nn.Module</code></a>, as a function, or as a <a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor"><code>torch.Tensor</code></a> method. If functions are exposed in multiple namespaces, they go through autocasting regardless of the namespace.</p> <p>Ops not listed below do not go through autocasting. They run in the type defined by their inputs. However, autocasting may still change the type in which unlisted ops run if they’re downstream from autocasted ops.</p> <p>If an op is unlisted, we assume it’s numerically stable in <code>float16</code>. If you believe an unlisted op is numerically unstable in <code>float16</code>, please file an issue.</p>  <h4 id="cuda-ops-that-can-autocast-to-float16">CUDA Ops that can autocast to <code>float16</code>
</h4> <p><code>__matmul__</code>, <code>addbmm</code>, <code>addmm</code>, <code>addmv</code>, <code>addr</code>, <code>baddbmm</code>, <code>bmm</code>, <code>chain_matmul</code>, <code>multi_dot</code>, <code>conv1d</code>, <code>conv2d</code>, <code>conv3d</code>, <code>conv_transpose1d</code>, <code>conv_transpose2d</code>, <code>conv_transpose3d</code>, <code>GRUCell</code>, <code>linear</code>, <code>LSTMCell</code>, <code>matmul</code>, <code>mm</code>, <code>mv</code>, <code>prelu</code>, <code>RNNCell</code></p>   <h4 id="cuda-ops-that-can-autocast-to-float32">CUDA Ops that can autocast to <code>float32</code>
</h4> <p><code>__pow__</code>, <code>__rdiv__</code>, <code>__rpow__</code>, <code>__rtruediv__</code>, <code>acos</code>, <code>asin</code>, <code>binary_cross_entropy_with_logits</code>, <code>cosh</code>, <code>cosine_embedding_loss</code>, <code>cdist</code>, <code>cosine_similarity</code>, <code>cross_entropy</code>, <code>cumprod</code>, <code>cumsum</code>, <code>dist</code>, <code>erfinv</code>, <code>exp</code>, <code>expm1</code>, <code>group_norm</code>, <code>hinge_embedding_loss</code>, <code>kl_div</code>, <code>l1_loss</code>, <code>layer_norm</code>, <code>log</code>, <code>log_softmax</code>, <code>log10</code>, <code>log1p</code>, <code>log2</code>, <code>margin_ranking_loss</code>, <code>mse_loss</code>, <code>multilabel_margin_loss</code>, <code>multi_margin_loss</code>, <code>nll_loss</code>, <code>norm</code>, <code>normalize</code>, <code>pdist</code>, <code>poisson_nll_loss</code>, <code>pow</code>, <code>prod</code>, <code>reciprocal</code>, <code>rsqrt</code>, <code>sinh</code>, <code>smooth_l1_loss</code>, <code>soft_margin_loss</code>, <code>softmax</code>, <code>softmin</code>, <code>softplus</code>, <code>sum</code>, <code>renorm</code>, <code>tan</code>, <code>triplet_margin_loss</code></p>   <h4 id="cuda-ops-that-promote-to-the-widest-input-type">CUDA Ops that promote to the widest input type</h4> <p>These ops don’t require a particular dtype for stability, but take multiple inputs and require that the inputs’ dtypes match. If all of the inputs are <code>float16</code>, the op runs in <code>float16</code>. If any of the inputs is <code>float32</code>, autocast casts all inputs to <code>float32</code> and runs the op in <code>float32</code>.</p> <p><code>addcdiv</code>, <code>addcmul</code>, <code>atan2</code>, <code>bilinear</code>, <code>cross</code>, <code>dot</code>, <code>grid_sample</code>, <code>index_put</code>, <code>scatter_add</code>, <code>tensordot</code></p> <p>Some ops not listed here (e.g., binary ops like <code>add</code>) natively promote inputs without autocasting’s intervention. If inputs are a mixture of <code>float16</code> and <code>float32</code>, these ops run in <code>float32</code> and produce <code>float32</code> output, regardless of whether autocast is enabled.</p>   <h4 id="prefer-binary-cross-entropy-with-logits-over-binary-cross-entropy">Prefer <code>binary_cross_entropy_with_logits</code> over <code>binary_cross_entropy</code>
</h4> <p>The backward passes of <a class="reference internal" href="generated/torch.nn.functional.binary_cross_entropy#torch.nn.functional.binary_cross_entropy" title="torch.nn.functional.binary_cross_entropy"><code>torch.nn.functional.binary_cross_entropy()</code></a> (and <a class="reference internal" href="generated/torch.nn.bceloss#torch.nn.BCELoss" title="torch.nn.BCELoss"><code>torch.nn.BCELoss</code></a>, which wraps it) can produce gradients that aren’t representable in <code>float16</code>. In autocast-enabled regions, the forward input may be <code>float16</code>, which means the backward gradient must be representable in <code>float16</code> (autocasting <code>float16</code> forward inputs to <code>float32</code> doesn’t help, because that cast must be reversed in backward). Therefore, <code>binary_cross_entropy</code> and <code>BCELoss</code> raise an error in autocast-enabled regions.</p> <p>Many models use a sigmoid layer right before the binary cross entropy layer. In this case, combine the two layers using <a class="reference internal" href="generated/torch.nn.functional.binary_cross_entropy_with_logits#torch.nn.functional.binary_cross_entropy_with_logits" title="torch.nn.functional.binary_cross_entropy_with_logits"><code>torch.nn.functional.binary_cross_entropy_with_logits()</code></a> or <a class="reference internal" href="generated/torch.nn.bcewithlogitsloss#torch.nn.BCEWithLogitsLoss" title="torch.nn.BCEWithLogitsLoss"><code>torch.nn.BCEWithLogitsLoss</code></a>. <code>binary_cross_entropy_with_logits</code> and <code>BCEWithLogits</code> are safe to autocast.</p>    <h3 id="autocast-cpu-op-reference">CPU Op-Specific Behavior</h3> <p id="cpu-op-specific-behavior">The following lists describe the behavior of eligible ops in autocast-enabled regions. These ops always go through autocasting whether they are invoked as part of a <a class="reference internal" href="generated/torch.nn.module#torch.nn.Module" title="torch.nn.Module"><code>torch.nn.Module</code></a>, as a function, or as a <a class="reference internal" href="tensors#torch.Tensor" title="torch.Tensor"><code>torch.Tensor</code></a> method. If functions are exposed in multiple namespaces, they go through autocasting regardless of the namespace.</p> <p>Ops not listed below do not go through autocasting. They run in the type defined by their inputs. However, autocasting may still change the type in which unlisted ops run if they’re downstream from autocasted ops.</p> <p>If an op is unlisted, we assume it’s numerically stable in <code>bfloat16</code>. If you believe an unlisted op is numerically unstable in <code>bfloat16</code>, please file an issue.</p>  <h4 id="cpu-ops-that-can-autocast-to-bfloat16">CPU Ops that can autocast to <code>bfloat16</code>
</h4> <p><code>conv1d</code>, <code>conv2d</code>, <code>conv3d</code>, <code>bmm</code>, <code>mm</code>, <code>baddbmm</code>, <code>addmm</code>, <code>addbmm</code>, <code>linear</code>, <code>matmul</code>, <code>_convolution</code></p>   <h4 id="cpu-ops-that-can-autocast-to-float32">CPU Ops that can autocast to <code>float32</code>
</h4> <p><code>conv_transpose1d</code>, <code>conv_transpose2d</code>, <code>conv_transpose3d</code>, <code>avg_pool3d</code>, <code>binary_cross_entropy</code>, <code>grid_sampler</code>, <code>grid_sampler_2d</code>, <code>_grid_sampler_2d_cpu_fallback</code>, <code>grid_sampler_3d</code>, <code>polar</code>, <code>prod</code>, <code>quantile</code>, <code>nanquantile</code>, <code>stft</code>, <code>cdist</code>, <code>trace</code>, <code>view_as_complex</code>, <code>cholesky</code>, <code>cholesky_inverse</code>, <code>cholesky_solve</code>, <code>inverse</code>, <code>lu_solve</code>, <code>orgqr</code>, <code>inverse</code>, <code>ormqr</code>, <code>pinverse</code>, <code>max_pool3d</code>, <code>max_unpool2d</code>, <code>max_unpool3d</code>, <code>adaptive_avg_pool3d</code>, <code>reflection_pad1d</code>, <code>reflection_pad2d</code>, <code>replication_pad1d</code>, <code>replication_pad2d</code>, <code>replication_pad3d</code>, <code>mse_loss</code>, <code>ctc_loss</code>, <code>kl_div</code>, <code>multilabel_margin_loss</code>, <code>fft_fft</code>, <code>fft_ifft</code>, <code>fft_fft2</code>, <code>fft_ifft2</code>, <code>fft_fftn</code>, <code>fft_ifftn</code>, <code>fft_rfft</code>, <code>fft_irfft</code>, <code>fft_rfft2</code>, <code>fft_irfft2</code>, <code>fft_rfftn</code>, <code>fft_irfftn</code>, <code>fft_hfft</code>, <code>fft_ihfft</code>, <code>linalg_matrix_norm</code>, <code>linalg_cond</code>, <code>linalg_matrix_rank</code>, <code>linalg_solve</code>, <code>linalg_cholesky</code>, <code>linalg_svdvals</code>, <code>linalg_eigvals</code>, <code>linalg_eigvalsh</code>, <code>linalg_inv</code>, <code>linalg_householder_product</code>, <code>linalg_tensorinv</code>, <code>linalg_tensorsolve</code>, <code>fake_quantize_per_tensor_affine</code>, <code>eig</code>, <code>geqrf</code>, <code>lstsq</code>, <code>_lu_with_info</code>, <code>qr</code>, <code>solve</code>, <code>svd</code>, <code>symeig</code>, <code>triangular_solve</code>, <code>fractional_max_pool2d</code>, <code>fractional_max_pool3d</code>, <code>adaptive_max_pool3d</code>, <code>multilabel_margin_loss_forward</code>, <code>linalg_qr</code>, <code>linalg_cholesky_ex</code>, <code>linalg_svd</code>, <code>linalg_eig</code>, <code>linalg_eigh</code>, <code>linalg_lstsq</code>, <code>linalg_inv_ex</code></p>   <h4 id="cpu-ops-that-promote-to-the-widest-input-type">CPU Ops that promote to the widest input type</h4> <p>These ops don’t require a particular dtype for stability, but take multiple inputs and require that the inputs’ dtypes match. If all of the inputs are <code>bfloat16</code>, the op runs in <code>bfloat16</code>. If any of the inputs is <code>float32</code>, autocast casts all inputs to <code>float32</code> and runs the op in <code>float32</code>.</p> <p><code>cat</code>, <code>stack</code>, <code>index_copy</code></p> <p>Some ops not listed here (e.g., binary ops like <code>add</code>) natively promote inputs without autocasting’s intervention. If inputs are a mixture of <code>bfloat16</code> and <code>float32</code>, these ops run in <code>float32</code> and produce <code>float32</code> output, regardless of whether autocast is enabled.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2024, PyTorch Contributors<br>PyTorch has a BSD-style license, as found in the <a href="https://github.com/pytorch/pytorch/blob/main/LICENSE">LICENSE</a> file.<br>
    <a href="https://pytorch.org/docs/2.1/amp.html" class="_attribution-link">https://pytorch.org/docs/2.1/amp.html</a>
  </p>
</div>
