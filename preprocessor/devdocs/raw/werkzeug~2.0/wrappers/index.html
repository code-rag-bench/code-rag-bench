<h1 id="request-response-objects">Request / Response Objects</h1> <p>The request and response objects wrap the WSGI environment or the return value from a WSGI application so that it is another WSGI application (wraps a whole application).</p> <section id="how-they-work"> <h2>How they Work</h2> <p>Your WSGI application is always passed two arguments. The WSGI “environment” and the WSGI <code>start_response</code> function that is used to start the response phase. The <a class="reference internal" href="#werkzeug.wrappers.Request" title="werkzeug.wrappers.Request"><code>Request</code></a> class wraps the <code>environ</code> for easier access to request variables (form data, request headers etc.).</p> <p>The <a class="reference internal" href="#werkzeug.wrappers.Response" title="werkzeug.wrappers.Response"><code>Response</code></a> on the other hand is a standard WSGI application that you can create. The simple hello world in Werkzeug looks like this:</p> <pre data-language="python">from werkzeug.wrappers import Response
application = Response('Hello World!')
</pre> <p>To make it more useful you can replace it with a function and do some processing:</p> <pre data-language="python">from werkzeug.wrappers import Request, Response

def application(environ, start_response):
    request = Request(environ)
    response = Response(f"Hello {request.args.get('name', 'World!')}!")
    return response(environ, start_response)
</pre> <p>Because this is a very common task the <a class="reference internal" href="#werkzeug.wrappers.Request" title="werkzeug.wrappers.Request"><code>Request</code></a> object provides a helper for that. The above code can be rewritten like this:</p> <pre data-language="python">from werkzeug.wrappers import Request, Response

@Request.application
def application(request):
    return Response(f"Hello {request.args.get('name', 'World!')}!")
</pre> <p>The <code>application</code> is still a valid WSGI application that accepts the environment and <code>start_response</code> callable.</p> </section> <section id="mutability-and-reusability-of-wrappers"> <h2>Mutability and Reusability of Wrappers</h2> <p>The implementation of the Werkzeug request and response objects are trying to guard you from common pitfalls by disallowing certain things as much as possible. This serves two purposes: high performance and avoiding of pitfalls.</p> <p>For the request object the following rules apply:</p> <ol class="arabic simple"> <li>The request object is immutable. Modifications are not supported by default, you may however replace the immutable attributes with mutable attributes if you need to modify it.</li> <li>The request object may be shared in the same thread, but is not thread safe itself. If you need to access it from multiple threads, use locks around calls.</li> <li>It’s not possible to pickle the request object.</li> </ol> <p>For the response object the following rules apply:</p> <ol class="arabic simple"> <li>The response object is mutable</li> <li>The response object can be pickled or copied after <code>freeze()</code> was called.</li> <li>Since Werkzeug 0.6 it’s safe to use the same response object for multiple WSGI responses.</li> <li>It’s possible to create copies using <code>copy.deepcopy</code>.</li> </ol> </section> <section id="wrapper-classes"> <h2>Wrapper Classes</h2> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request">
<code>class werkzeug.wrappers.Request(environ, populate_request=True, shallow=False)</code> </dt> <dd>
<p>Represents an incoming WSGI HTTP request, with headers and body taken from the WSGI environment. Has properties and methods for using the functionality defined by various HTTP specs. The data in requests object is read-only.</p> <p>Text data is assumed to use UTF-8 encoding, which should be true for the vast majority of modern clients. Using an encoding set by the client is unsafe in Python due to extra encodings it provides, such as <code>zip</code>. To change the assumed encoding, subclass and replace <code>charset</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>environ</strong> (<em>WSGIEnvironment</em>) – The WSGI environ is generated by the WSGI server and contains information about the server configuration and client request.</li> <li>
<strong>populate_request</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – Add this request object to the WSGI environ as <code>environ['werkzeug.request']</code>. Can be useful when debugging.</li> <li>
<strong>shallow</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – Makes reading from <a class="reference internal" href="#werkzeug.wrappers.Request.stream" title="werkzeug.wrappers.Request.stream"><code>stream</code></a> (and any method that would read from it) raise a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.9)"><code>RuntimeError</code></a>. Useful to prevent consuming the form data in middleware, which would make it unavailable to the final application.</li> </ul> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a></p> </dd> </dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.0: </span>Combine <code>BaseRequest</code> and mixins into a single <code>Request</code> class. Using the old classes is deprecated and will be removed in Werkzeug 2.1.</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.5: </span>Read-only mode is enforced with immutable classes for all data.</p> </div> </details><dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request._get_file_stream">
<code>_get_file_stream(total_content_length, content_type, filename=None, content_length=None)</code> </dt> <dd>
<p>Called to get a stream for the file upload.</p> <p>This must provide a file-like class with <code>read()</code>, <code>readline()</code> and <code>seek()</code> methods that is both writeable and readable.</p> <p>The default implementation returns a temporary file if the total content length is higher than 500KB. Because many browsers do not provide a content length for the files only the total content length matters.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>total_content_length</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em>) – the total content length of all the data in the request combined. This value is guaranteed to be there.</li> <li>
<strong>content_type</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>]</em>) – the mimetype of the uploaded file.</li> <li>
<strong>filename</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>]</em>) – the filename of the uploaded file. May be <code>None</code>.</li> <li>
<strong>content_length</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em>) – the length of this file. This value is usually not provided because webbrowsers do not provide this value.</li> </ul> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p>BinaryIO</p> </dd> </dl> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.accept_charsets">
<code>property accept_charsets: werkzeug.datastructures.CharsetAccept</code> </dt> <dd>
<p>List of charsets this client supports as <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.CharsetAccept" title="werkzeug.datastructures.CharsetAccept"><code>CharsetAccept</code></a> object.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.accept_encodings">
<code>property accept_encodings: werkzeug.datastructures.Accept</code> </dt> <dd>
<p>List of encodings this client accepts. Encodings in a HTTP term are compression encodings such as gzip. For charsets have a look at <code>accept_charset</code>.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.accept_languages">
<code>property accept_languages: werkzeug.datastructures.LanguageAccept</code> </dt> <dd>
<p>List of languages this client accepts as <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.LanguageAccept" title="werkzeug.datastructures.LanguageAccept"><code>LanguageAccept</code></a> object.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.accept_mimetypes">
<code>property accept_mimetypes: werkzeug.datastructures.MIMEAccept</code> </dt> <dd>
<p>List of mimetypes this client supports as <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.MIMEAccept" title="werkzeug.datastructures.MIMEAccept"><code>MIMEAccept</code></a> object.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.access_control_request_headers">
<code>access_control_request_headers</code> </dt> <dd>
<p>Sent with a preflight request to indicate which headers will be sent with the cross origin request. Set <code>access_control_allow_headers</code> on the response to indicate which headers are allowed.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.access_control_request_method">
<code>access_control_request_method</code> </dt> <dd>
<p>Sent with a preflight request to indicate which method will be used for the cross origin request. Set <code>access_control_allow_methods</code> on the response to indicate which methods are allowed.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.access_route">
<code>property access_route: List[str]</code> </dt> <dd>
<p>If a forwarded header exists this is a list of all ip addresses from the client ip to the last proxy server.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.application">
<code>classmethod application(f)</code> </dt> <dd>
<p>Decorate a function as responder that accepts the request as the last argument. This works like the <code>responder()</code> decorator but the function is passed the request object as the last argument and the request object will be closed automatically:</p> <pre data-language="python">@Request.application
def my_wsgi_app(request):
    return Response('Hello World!')
</pre> <p>As of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to responses instead of failing.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>f</strong> (<em>Callable</em><em>[</em><em>[</em><a class="reference internal" href="#werkzeug.wrappers.Request" title="werkzeug.wrappers.Request">Request</a><em>]</em><em>, </em><em>WSGIApplication</em><em>]</em>) – the WSGI callable to decorate</p> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>a new WSGI callable</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p>WSGIApplication</p> </dd> </dl> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.args">
<code>property args: MultiDict[str, str]</code> </dt> <dd>
<p>The parsed URL parameters (the part in the URL after the question mark).</p> <p>By default an <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.ImmutableMultiDict" title="werkzeug.datastructures.ImmutableMultiDict"><code>ImmutableMultiDict</code></a> is returned from this function. This can be changed by setting <a class="reference internal" href="#werkzeug.wrappers.Request.parameter_storage_class" title="werkzeug.wrappers.Request.parameter_storage_class"><code>parameter_storage_class</code></a> to a different type. This might be necessary if the order of the form data is important.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.authorization">
<code>property authorization: Optional[werkzeug.datastructures.Authorization]</code> </dt> <dd>
<p>The <code>Authorization</code> object in parsed form.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.base_url">
<code>property base_url: str</code> </dt> <dd>
<p>Like <a class="reference internal" href="#werkzeug.wrappers.Request.url" title="werkzeug.wrappers.Request.url"><code>url</code></a> but without the query string.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.cache_control">
<code>property cache_control: werkzeug.datastructures.RequestCacheControl</code> </dt> <dd>
<p>A <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.RequestCacheControl" title="werkzeug.datastructures.RequestCacheControl"><code>RequestCacheControl</code></a> object for the incoming cache control headers.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.close">
<code>close()</code> </dt> <dd>
<p>Closes associated resources of this request object. This closes all file handles explicitly. You can also use the request object in a with statement which will automatically close it.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a></p> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.content_encoding">
<code>content_encoding</code> </dt> <dd>
<p>The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details>
</dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.content_length">
<code>property content_length: Optional[int]</code> </dt> <dd>
<p>The Content-Length entity-header field indicates the size of the entity-body in bytes or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.content_md5">
<code>content_md5</code> </dt> <dd>
<p>The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details>
</dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.content_type">
<code>content_type</code> </dt> <dd>
<p>The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.cookies">
<code>property cookies: ImmutableMultiDict[str, str]</code> </dt> <dd>
<p>A <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><code>dict</code></a> with the contents of all cookies transmitted with the request.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.data">
<code>property data: bytes</code> </dt> <dd>
<p>Contains the incoming request data as string in case it came with a mimetype Werkzeug does not handle.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.date">
<code>date</code> </dt> <dd>
<p>The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.0: </span>The datetime object is timezone-aware.</p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.dict_storage_class">
<code>dict_storage_class</code> </dt> <dd>
<p>alias of <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.ImmutableMultiDict" title="werkzeug.datastructures.ImmutableMultiDict"><code>werkzeug.datastructures.ImmutableMultiDict</code></a></p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.disable_data_descriptor">
<code>disable_data_descriptor: Optional[bool] = None</code> </dt> <dd>
<p>Disable the <a class="reference internal" href="#werkzeug.wrappers.Request.data" title="werkzeug.wrappers.Request.data"><code>data</code></a> property to avoid reading from the input stream.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 2.0: </span>Will be removed in Werkzeug 2.1. Create the request with <code>shallow=True</code> instead.</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details>
</dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.environ">
<code>environ: WSGIEnvironment</code> </dt> <dd>
<p>The WSGI environment containing HTTP headers and information from the WSGI server.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.files">
<code>property files: ImmutableMultiDict[str, FileStorage]</code> </dt> <dd>
<p><a class="reference internal" href="../datastructures/index#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a> object containing all uploaded files. Each key in <a class="reference internal" href="#werkzeug.wrappers.Request.files" title="werkzeug.wrappers.Request.files"><code>files</code></a> is the name from the <code>&lt;input type="file" name=""&gt;</code>. Each value in <a class="reference internal" href="#werkzeug.wrappers.Request.files" title="werkzeug.wrappers.Request.files"><code>files</code></a> is a Werkzeug <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.FileStorage" title="werkzeug.datastructures.FileStorage"><code>FileStorage</code></a> object.</p> <p>It basically behaves like a standard file object you know from Python, with the difference that it also has a <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.FileStorage.save" title="werkzeug.datastructures.FileStorage.save"><code>save()</code></a> function that can store the file on the filesystem.</p> <p>Note that <a class="reference internal" href="#werkzeug.wrappers.Request.files" title="werkzeug.wrappers.Request.files"><code>files</code></a> will only contain data if the request method was POST, PUT or PATCH and the <code>&lt;form&gt;</code> that posted to the request had <code>enctype="multipart/form-data"</code>. It will be empty otherwise.</p> <p>See the <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a> / <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.FileStorage" title="werkzeug.datastructures.FileStorage"><code>FileStorage</code></a> documentation for more details about the used data structure.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.form">
<code>property form: ImmutableMultiDict[str, str]</code> </dt> <dd>
<p>The form parameters. By default an <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.ImmutableMultiDict" title="werkzeug.datastructures.ImmutableMultiDict"><code>ImmutableMultiDict</code></a> is returned from this function. This can be changed by setting <a class="reference internal" href="#werkzeug.wrappers.Request.parameter_storage_class" title="werkzeug.wrappers.Request.parameter_storage_class"><code>parameter_storage_class</code></a> to a different type. This might be necessary if the order of the form data is important.</p> <p>Please keep in mind that file uploads will not end up here, but instead in the <a class="reference internal" href="#werkzeug.wrappers.Request.files" title="werkzeug.wrappers.Request.files"><code>files</code></a> attribute.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.9: </span>Previous to Werkzeug 0.9 this would only contain form data for POST and PUT requests.</p> </div> </details>
</dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.form_data_parser_class">
<code>form_data_parser_class</code> </dt> <dd>
<p>alias of <a class="reference internal" href="../http/index#werkzeug.formparser.FormDataParser" title="werkzeug.formparser.FormDataParser"><code>werkzeug.formparser.FormDataParser</code></a></p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.from_values">
<code>classmethod from_values(*args, **kwargs)</code> </dt> <dd>
<p>Create a new request object based on the values provided. If environ is given missing values are filled from there. This method is useful for small scripts when you need to simulate a request from an URL. Do not use this method for unittesting, there is a full featured client object (<code>Client</code>) that allows to create multipart requests, support for cookies etc.</p> <p>This accepts the same options as the <a class="reference internal" href="../test/index#werkzeug.test.EnvironBuilder" title="werkzeug.test.EnvironBuilder"><code>EnvironBuilder</code></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.5: </span>This method now accepts the same arguments as <a class="reference internal" href="../test/index#werkzeug.test.EnvironBuilder" title="werkzeug.test.EnvironBuilder"><code>EnvironBuilder</code></a>. Because of this the <code>environ</code> parameter is now called <code>environ_overrides</code>.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Returns</dt> <dd class="field-odd">
<p>request object</p> </dd> <dt class="field-even">Parameters</dt> <dd class="field-even">
<ul class="simple"> <li>
<strong>args</strong> (<em>Any</em>) – </li> <li>
<strong>kwargs</strong> (<em>Any</em>) – </li> </ul> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#werkzeug.wrappers.Request" title="werkzeug.wrappers.request.Request">werkzeug.wrappers.request.Request</a></p> </dd> </dl> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.full_path">
<code>property full_path: str</code> </dt> <dd>
<p>Requested path, including the query string.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.get_data">
<code>get_data(cache=True, as_text=False, parse_form_data=False)</code> </dt> <dd>
<p>This reads the buffered incoming data from the client into one bytes object. By default this is cached but that behavior can be changed by setting <code>cache</code> to <code>False</code>.</p> <p>Usually it’s a bad idea to call this method without checking the content length first as a client could send dozens of megabytes or more to cause memory problems on the server.</p> <p>Note that if the form data was already parsed this method will not return anything as form data parsing does not cache the data like this method does. To implicitly invoke form data parsing function set <code>parse_form_data</code> to <code>True</code>. When this is done the return value of this method will be an empty string if the form parser handles the data. This generally is not necessary as if the whole data is cached (which is the default) the form parser will used the cached data to parse the form data. Please be generally aware of checking the content length first in any case before calling this method to avoid exhausting server memory.</p> <p>If <code>as_text</code> is set to <code>True</code> the return value will be a decoded string.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>cache</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – </li> <li>
<strong>as_text</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – </li> <li>
<strong>parse_form_data</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – </li> </ul> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p>Union[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.9)">bytes</a>, <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.get_json">
<code>get_json(force=False, silent=False, cache=True)</code> </dt> <dd>
<p>Parse <a class="reference internal" href="#werkzeug.wrappers.Request.data" title="werkzeug.wrappers.Request.data"><code>data</code></a> as JSON.</p> <p>If the mimetype does not indicate JSON (<em class="mimetype">application/json</em>, see <a class="reference internal" href="#werkzeug.wrappers.Request.is_json" title="werkzeug.wrappers.Request.is_json"><code>is_json()</code></a>), this returns <code>None</code>.</p> <p>If parsing fails, <a class="reference internal" href="#werkzeug.wrappers.Request.on_json_loading_failed" title="werkzeug.wrappers.Request.on_json_loading_failed"><code>on_json_loading_failed()</code></a> is called and its return value is used as the return value.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>force</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – Ignore the mimetype and always try to parse JSON.</li> <li>
<strong>silent</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – Silence parsing errors and return <code>None</code> instead.</li> <li>
<strong>cache</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – Store the parsed JSON to return for subsequent calls.</li> </ul> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p>Optional[Any]</p> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.headers">
<code>headers</code> </dt> <dd>
<p>The headers received with the request.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.host">
<code>property host: str</code> </dt> <dd>
<p>The host name the request was made to, including the port if it’s non-standard. Validated with <code>trusted_hosts</code>.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.host_url">
<code>property host_url: str</code> </dt> <dd>
<p>The request URL scheme and host only.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.if_match">
<code>property if_match: werkzeug.datastructures.ETags</code> </dt> <dd>
<p>An object containing all the etags in the <code>If-Match</code> header.</p> <dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference internal" href="../datastructures/index#werkzeug.datastructures.ETags" title="werkzeug.datastructures.ETags"><code>ETags</code></a></p> </dd> </dl> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.if_modified_since">
<code>property if_modified_since: Optional[datetime.datetime]</code> </dt> <dd>
<p>The parsed <code>If-Modified-Since</code> header as a datetime object.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.0: </span>The datetime object is timezone-aware.</p> </div> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.if_none_match">
<code>property if_none_match: werkzeug.datastructures.ETags</code> </dt> <dd>
<p>An object containing all the etags in the <code>If-None-Match</code> header.</p> <dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference internal" href="../datastructures/index#werkzeug.datastructures.ETags" title="werkzeug.datastructures.ETags"><code>ETags</code></a></p> </dd> </dl> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.if_range">
<code>property if_range: werkzeug.datastructures.IfRange</code> </dt> <dd>
<p>The parsed <code>If-Range</code> header.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.0: </span><code>IfRange.date</code> is timezone-aware.</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.if_unmodified_since">
<code>property if_unmodified_since: Optional[datetime.datetime]</code> </dt> <dd>
<p>The parsed <code>If-Unmodified-Since</code> header as a datetime object.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.0: </span>The datetime object is timezone-aware.</p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.input_stream">
<code>input_stream</code> </dt> <dd>
<p>The WSGI input stream.</p> <p>In general it’s a bad idea to use this one because you can easily read past the boundary. Use the <a class="reference internal" href="#werkzeug.wrappers.Request.stream" title="werkzeug.wrappers.Request.stream"><code>stream</code></a> instead.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.is_json">
<code>property is_json: bool</code> </dt> <dd>
<p>Check if the mimetype indicates JSON data, either <em class="mimetype">application/json</em> or <em class="mimetype">application/*+json</em>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.is_multiprocess">
<code>is_multiprocess</code> </dt> <dd>
<p>boolean that is <code>True</code> if the application is served by a WSGI server that spawns multiple processes.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.is_multithread">
<code>is_multithread</code> </dt> <dd>
<p>boolean that is <code>True</code> if the application is served by a multithreaded WSGI server.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.is_run_once">
<code>is_run_once</code> </dt> <dd>
<p>boolean that is <code>True</code> if the application will be executed only once in a process lifetime. This is the case for CGI for example, but it’s not guaranteed that the execution only happens one time.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.is_secure">
<code>property is_secure: bool</code> </dt> <dd>
<p><code>True</code> if the request was made with a secure protocol (HTTPS or WSS).</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.json">
<code>property json: Optional[Any]</code> </dt> <dd>
<p>The parsed JSON data if <a class="reference internal" href="#werkzeug.wrappers.Request.mimetype" title="werkzeug.wrappers.Request.mimetype"><code>mimetype</code></a> indicates JSON (<em class="mimetype">application/json</em>, see <a class="reference internal" href="#werkzeug.wrappers.Request.is_json" title="werkzeug.wrappers.Request.is_json"><code>is_json()</code></a>).</p> <p>Calls <a class="reference internal" href="#werkzeug.wrappers.Request.get_json" title="werkzeug.wrappers.Request.get_json"><code>get_json()</code></a> with default arguments.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.json_module">
<code>json_module = &lt;module 'json' from '/home/docs/.pyenv/versions/3.7.9/lib/python3.7/json/__init__.py'&gt;</code> </dt> <dd>
<p>A module or other object that has <code>dumps</code> and <code>loads</code> functions that match the API of the built-in <a class="reference external" href="https://docs.python.org/3/library/json.html#module-json" title="(in Python v3.9)"><code>json</code></a> module.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.list_storage_class">
<code>list_storage_class</code> </dt> <dd>
<p>alias of <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.ImmutableList" title="werkzeug.datastructures.ImmutableList"><code>werkzeug.datastructures.ImmutableList</code></a></p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.make_form_data_parser">
<code>make_form_data_parser()</code> </dt> <dd>
<p>Creates the form data parser. Instantiates the <a class="reference internal" href="#werkzeug.wrappers.Request.form_data_parser_class" title="werkzeug.wrappers.Request.form_data_parser_class"><code>form_data_parser_class</code></a> with some parameters.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference internal" href="../http/index#werkzeug.formparser.FormDataParser" title="werkzeug.formparser.FormDataParser">werkzeug.formparser.FormDataParser</a></p> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.max_content_length">
<code>max_content_length: Optional[int] = None</code> </dt> <dd>
<p>the maximum content length. This is forwarded to the form data parsing function (<code>parse_form_data()</code>). When set and the <a class="reference internal" href="#werkzeug.wrappers.Request.form" title="werkzeug.wrappers.Request.form"><code>form</code></a> or <a class="reference internal" href="#werkzeug.wrappers.Request.files" title="werkzeug.wrappers.Request.files"><code>files</code></a> attribute is accessed and the parsing fails because more than the specified value is transmitted a <a class="reference internal" href="../exceptions/index#werkzeug.exceptions.RequestEntityTooLarge" title="werkzeug.exceptions.RequestEntityTooLarge"><code>RequestEntityTooLarge</code></a> exception is raised.</p> <p>Have a look at <a class="reference internal" href="../request_data/index"><span class="doc">Dealing with Request Data</span></a> for more details.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.5.</span></p> </div> </details>
</dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.max_form_memory_size">
<code>max_form_memory_size: Optional[int] = None</code> </dt> <dd>
<p>the maximum form field size. This is forwarded to the form data parsing function (<code>parse_form_data()</code>). When set and the <a class="reference internal" href="#werkzeug.wrappers.Request.form" title="werkzeug.wrappers.Request.form"><code>form</code></a> or <a class="reference internal" href="#werkzeug.wrappers.Request.files" title="werkzeug.wrappers.Request.files"><code>files</code></a> attribute is accessed and the data in memory for post data is longer than the specified value a <a class="reference internal" href="../exceptions/index#werkzeug.exceptions.RequestEntityTooLarge" title="werkzeug.exceptions.RequestEntityTooLarge"><code>RequestEntityTooLarge</code></a> exception is raised.</p> <p>Have a look at <a class="reference internal" href="../request_data/index"><span class="doc">Dealing with Request Data</span></a> for more details.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.5.</span></p> </div> </details>
</dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.max_forwards">
<code>max_forwards</code> </dt> <dd>
<p>The Max-Forwards request-header field provides a mechanism with the TRACE and OPTIONS methods to limit the number of proxies or gateways that can forward the request to the next inbound server.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.method">
<code>method</code> </dt> <dd>
<p>The method the request was made with, such as <code>GET</code>.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.mimetype">
<code>property mimetype: str</code> </dt> <dd>
<p>Like <a class="reference internal" href="#werkzeug.wrappers.Request.content_type" title="werkzeug.wrappers.Request.content_type"><code>content_type</code></a>, but without parameters (eg, without charset, type etc.) and always lowercase. For example if the content type is <code>text/HTML; charset=utf-8</code> the mimetype would be <code>'text/html'</code>.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.mimetype_params">
<code>property mimetype_params: Dict[str, str]</code> </dt> <dd>
<p>The mimetype parameters as dict. For example if the content type is <code>text/html; charset=utf-8</code> the params would be <code>{'charset': 'utf-8'}</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.on_json_loading_failed">
<code>on_json_loading_failed(e)</code> </dt> <dd>
<p>Called if <a class="reference internal" href="#werkzeug.wrappers.Request.get_json" title="werkzeug.wrappers.Request.get_json"><code>get_json()</code></a> parsing fails and isn’t silenced. If this method returns a value, it is used as the return value for <a class="reference internal" href="#werkzeug.wrappers.Request.get_json" title="werkzeug.wrappers.Request.get_json"><code>get_json()</code></a>. The default implementation raises <a class="reference internal" href="../exceptions/index#werkzeug.exceptions.BadRequest" title="werkzeug.exceptions.BadRequest"><code>BadRequest</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>e</strong> (<a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.9)">ValueError</a>) – </p> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p>Any</p> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.origin">
<code>origin</code> </dt> <dd>
<p>The host that the request originated from. Set <code>access_control_allow_origin</code> on the response to indicate which origins are allowed.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.parameter_storage_class">
<code>parameter_storage_class</code> </dt> <dd>
<p>alias of <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.ImmutableMultiDict" title="werkzeug.datastructures.ImmutableMultiDict"><code>werkzeug.datastructures.ImmutableMultiDict</code></a></p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.path">
<code>path</code> </dt> <dd>
<p>The path part of the URL after <a class="reference internal" href="#werkzeug.wrappers.Request.root_path" title="werkzeug.wrappers.Request.root_path"><code>root_path</code></a>. This is the path used for routing within the application.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.pragma">
<code>property pragma: werkzeug.datastructures.HeaderSet</code> </dt> <dd>
<p>The Pragma general-header field is used to include implementation-specific directives that might apply to any recipient along the request/response chain. All pragma directives specify optional behavior from the viewpoint of the protocol; however, some systems MAY require that behavior be consistent with the directives.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.query_string">
<code>query_string</code> </dt> <dd>
<p>The part of the URL after the “?”. This is the raw value, use <a class="reference internal" href="#werkzeug.wrappers.Request.args" title="werkzeug.wrappers.Request.args"><code>args</code></a> for the parsed values.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.range">
<code>property range: Optional[werkzeug.datastructures.Range]</code> </dt> <dd>
<p>The parsed <code>Range</code> header.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference internal" href="../datastructures/index#werkzeug.datastructures.Range" title="werkzeug.datastructures.Range"><code>Range</code></a></p> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.referrer">
<code>referrer</code> </dt> <dd>
<p>The Referer[sic] request-header field allows the client to specify, for the server’s benefit, the address (URI) of the resource from which the Request-URI was obtained (the “referrer”, although the header field is misspelled).</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.remote_addr">
<code>remote_addr</code> </dt> <dd>
<p>The address of the client sending the request.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.remote_user">
<code>remote_user</code> </dt> <dd>
<p>If the server supports user authentication, and the script is protected, this attribute contains the username the user has authenticated as.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.root_path">
<code>root_path</code> </dt> <dd>
<p>The prefix that the application is mounted under, without a trailing slash. <a class="reference internal" href="#werkzeug.wrappers.Request.path" title="werkzeug.wrappers.Request.path"><code>path</code></a> comes after this.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.root_url">
<code>property root_url: str</code> </dt> <dd>
<p>The request URL scheme, host, and root path. This is the root that the application is accessed from.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.scheme">
<code>scheme</code> </dt> <dd>
<p>The URL scheme of the protocol the request used, such as <code>https</code> or <code>wss</code>.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.script_root">
<code>property script_root: str</code> </dt> <dd>
<p>Alias for <code>self.root_path</code>. <code>environ["SCRIPT_ROOT"]</code> without a trailing slash.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.server">
<code>server</code> </dt> <dd>
<p>The address of the server. <code>(host, port)</code>, <code>(path, None)</code> for unix sockets, or <code>None</code> if not known.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.shallow">
<code>shallow: bool</code> </dt> <dd>
<p>Set when creating the request object. If <code>True</code>, reading from the request body will cause a <code>RuntimeException</code>. Useful to prevent modifying the stream from middleware.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.stream">
<code>property stream: BinaryIO</code> </dt> <dd>
<p>If the incoming form data was not encoded with a known mimetype the data is stored unmodified in this stream for consumption. Most of the time it is a better idea to use <a class="reference internal" href="#werkzeug.wrappers.Request.data" title="werkzeug.wrappers.Request.data"><code>data</code></a> which will give you that data as a string. The stream only returns the data once.</p> <p>Unlike <a class="reference internal" href="#werkzeug.wrappers.Request.input_stream" title="werkzeug.wrappers.Request.input_stream"><code>input_stream</code></a> this stream is properly guarded that you can’t accidentally read past the length of the input. Werkzeug will internally always refer to this stream to read data which makes it possible to wrap this object with a stream that does filtering.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.9: </span>This stream is now always available but might be consumed by the form parser later on. Previously the stream was only set if no parsing happened.</p> </div> </details>
</dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.url">
<code>property url: str</code> </dt> <dd>
<p>The full request URL with the scheme, host, root path, path, and query string.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.url_charset">
<code>property url_charset: str</code> </dt> <dd>
<p>The charset that is assumed for URLs. Defaults to the value of <code>charset</code>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.6.</span></p> </div> </details>
</dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.url_root">
<code>property url_root: str</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#werkzeug.wrappers.Request.root_url" title="werkzeug.wrappers.Request.root_url"><code>root_url</code></a>. The URL with scheme, host, and root path. For example, <code>https://example.com/app/</code>.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.user_agent">
<code>property user_agent: werkzeug.user_agent.UserAgent</code> </dt> <dd>
<p>The user agent. Use <code>user_agent.string</code> to get the header value. Set <a class="reference internal" href="#werkzeug.wrappers.Request.user_agent_class" title="werkzeug.wrappers.Request.user_agent_class"><code>user_agent_class</code></a> to a subclass of <a class="reference internal" href="../utils/index#werkzeug.user_agent.UserAgent" title="werkzeug.user_agent.UserAgent"><code>UserAgent</code></a> to provide parsing for the other properties or other extended data.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.0: </span>The built in parser is deprecated and will be removed in Werkzeug 2.1. A <code>UserAgent</code> subclass must be set to parse data from the string.</p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.user_agent_class">
<code>user_agent_class</code> </dt> <dd>
<p>alias of <code>werkzeug.useragents._UserAgent</code></p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.values">
<code>property values: CombinedMultiDict[str, str]</code> </dt> <dd>
<p>A <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.CombinedMultiDict" title="werkzeug.datastructures.CombinedMultiDict"><code>werkzeug.datastructures.CombinedMultiDict</code></a> that combines <a class="reference internal" href="#werkzeug.wrappers.Request.args" title="werkzeug.wrappers.Request.args"><code>args</code></a> and <a class="reference internal" href="#werkzeug.wrappers.Request.form" title="werkzeug.wrappers.Request.form"><code>form</code></a>.</p> <p>For GET requests, only <code>args</code> are present, not <code>form</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.0: </span>For GET requests, only <code>args</code> are present, not <code>form</code>.</p> </div> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Request.want_form_data_parsed">
<code>property want_form_data_parsed: bool</code> </dt> <dd>
<p><code>True</code> if the request method carries content. By default this is true if a <code>Content-Type</code> is sent.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> </details>
</dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response">
<code>class werkzeug.wrappers.Response(response=None, status=None, headers=None, mimetype=None, content_type=None, direct_passthrough=False)</code> </dt> <dd>
<p>Represents an outgoing WSGI HTTP response with body, status, and headers. Has properties and methods for using the functionality defined by various HTTP specs.</p> <p>The response body is flexible to support different use cases. The simple form is passing bytes, or a string which will be encoded as UTF-8. Passing an iterable of bytes or strings makes this a streaming response. A generator is particularly useful for building a CSV file in memory or using SSE (Server Sent Events). A file-like object is also iterable, although the <a class="reference internal" href="../utils/index#werkzeug.utils.send_file" title="werkzeug.utils.send_file"><code>send_file()</code></a> helper should be used in that case.</p> <p>The response object is itself a WSGI application callable. When called (<a class="reference internal" href="#werkzeug.wrappers.Response.__call__" title="werkzeug.wrappers.Response.__call__"><code>__call__()</code></a>) with <code>environ</code> and <code>start_response</code>, it will pass its status and headers to <code>start_response</code> then return its body as an iterable.</p> <pre data-language="python">from werkzeug.wrappers.response import Response

def index():
    return Response("Hello, World!")

def application(environ, start_response):
    path = environ.get("PATH_INFO") or "/"

    if path == "/":
        response = index()
    else:
        response = Response("Not Found", status=404)

    return response(environ, start_response)
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>response</strong> (<em>Union</em><em>[</em><em>Iterable</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>]</em><em>, </em><em>Iterable</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.9)">bytes</a><em>]</em><em>]</em>) – The data for the body of the response. A string or bytes, or tuple or list of strings or bytes, for a fixed-length response, or any other iterable of strings or bytes for a streaming response. Defaults to an empty body.</li> <li>
<strong>status</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/http.html#http.HTTPStatus" title="(in Python v3.9)">http.HTTPStatus</a><em>]</em><em>]</em>) – The status code for the response. Either an int, in which case the default status message is added, or a string in the form <code>{code} {message}</code>, like <code>404 Not Found</code>. Defaults to 200.</li> <li>
<strong>headers</strong> (<a class="reference internal" href="../datastructures/index#werkzeug.datastructures.Headers" title="werkzeug.datastructures.Headers">werkzeug.datastructures.Headers</a>) – A <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.Headers" title="werkzeug.datastructures.Headers"><code>Headers</code></a> object, or a list of <code>(key, value)</code> tuples that will be converted to a <code>Headers</code> object.</li> <li>
<strong>mimetype</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>]</em>) – The mime type (content type without charset or other parameters) of the response. If the value starts with <code>text/</code> (or matches some other special cases), the charset will be added to create the <code>content_type</code>.</li> <li>
<strong>content_type</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>]</em>) – The full content type of the response. Overrides building the value from <code>mimetype</code>.</li> <li>
<strong>direct_passthrough</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – Pass the response body directly through as the WSGI iterable. This can be used when the body is a binary file or other iterator of bytes, to skip some unnecessary checks. Use <a class="reference internal" href="../utils/index#werkzeug.utils.send_file" title="werkzeug.utils.send_file"><code>send_file()</code></a> instead of setting this manually.</li> </ul> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a></p> </dd> </dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.0: </span>Combine <code>BaseResponse</code> and mixins into a single <code>Response</code> class. Using the old classes is deprecated and will be removed in Werkzeug 2.1.</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.5: </span>The <code>direct_passthrough</code> parameter was added.</p> </div> </details><dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.__call__">
<code>__call__(environ, start_response)</code> </dt> <dd>
<p>Process this response as WSGI application.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>environ</strong> (<em>WSGIEnvironment</em>) – the WSGI environment.</li> <li>
<strong>start_response</strong> (<em>StartResponse</em>) – the response callable provided by the WSGI server.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>an application iterator</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p>Iterable[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.9)">bytes</a>]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response._ensure_sequence">
<code>_ensure_sequence(mutable=False)</code> </dt> <dd>
<p>This method can be called by methods that need a sequence. If <code>mutable</code> is true, it will also ensure that the response sequence is a standard Python list.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.6.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>mutable</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – </p> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a></p> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.accept_ranges">
<code>accept_ranges</code> </dt> <dd>
<p>The <code>Accept-Ranges</code> header. Even though the name would indicate that multiple values are supported, it must be one string token only.</p> <p>The values <code>'bytes'</code> and <code>'none'</code> are common.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.access_control_allow_credentials">
<code>property access_control_allow_credentials: bool</code> </dt> <dd>
<p>Whether credentials can be shared by the browser to JavaScript code. As part of the preflight request it indicates whether credentials can be used on the cross origin request.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.access_control_allow_headers">
<code>access_control_allow_headers</code> </dt> <dd>
<p>Which headers can be sent with the cross origin request.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.access_control_allow_methods">
<code>access_control_allow_methods</code> </dt> <dd>
<p>Which methods can be used for the cross origin request.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.access_control_allow_origin">
<code>access_control_allow_origin</code> </dt> <dd>
<p>The origin or ‘*’ for any origin that may make cross origin requests.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.access_control_expose_headers">
<code>access_control_expose_headers</code> </dt> <dd>
<p>Which headers can be shared by the browser to JavaScript code.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.access_control_max_age">
<code>access_control_max_age</code> </dt> <dd>
<p>The maximum age in seconds the access control settings can be cached for.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.add_etag">
<code>add_etag(overwrite=False, weak=False)</code> </dt> <dd>
<p>Add an etag for the current response if there is none yet.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.0: </span>SHA-1 is used to generate the value. MD5 may not be available in some environments.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>overwrite</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – </li> <li>
<strong>weak</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – </li> </ul> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a></p> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.age">
<code>age</code> </dt> <dd>
<p>The Age response-header field conveys the sender’s estimate of the amount of time since the response (or its revalidation) was generated at the origin server.</p> <p>Age values are non-negative decimal integers, representing time in seconds.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.allow">
<code>property allow: werkzeug.datastructures.HeaderSet</code> </dt> <dd>
<p>The Allow entity-header field lists the set of methods supported by the resource identified by the Request-URI. The purpose of this field is strictly to inform the recipient of valid methods associated with the resource. An Allow header field MUST be present in a 405 (Method Not Allowed) response.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.autocorrect_location_header">
<code>autocorrect_location_header = True</code> </dt> <dd>
<p>Should this response object correct the location header to be RFC conformant? This is true by default.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> </details>
</dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.automatically_set_content_length">
<code>automatically_set_content_length = True</code> </dt> <dd>
<p>Should this response object automatically set the content-length header if possible? This is true by default.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.8.</span></p> </div> </details>
</dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.cache_control">
<code>property cache_control: werkzeug.datastructures.ResponseCacheControl</code> </dt> <dd>
<p>The Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.calculate_content_length">
<code>calculate_content_length()</code> </dt> <dd>
<p>Returns the content length if available or <code>None</code> otherwise.</p> <dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p>Optional[<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.call_on_close">
<code>call_on_close(func)</code> </dt> <dd>
<p>Adds a function to the internal list of functions that should be called as part of closing down the response. Since 0.7 this function also returns the function that was passed so that this can be used as a decorator.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.6.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>func</strong> (<em>Callable</em><em>[</em><em>[</em><em>]</em><em>, </em><em>Any</em><em>]</em>) – </p> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p>Callable[[], Any]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.close">
<code>close()</code> </dt> <dd>
<p>Close the wrapped response if possible. You can also use the object in a with statement which will automatically close it.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9: </span>Can now be used in a with statement.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a></p> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.content_encoding">
<code>content_encoding</code> </dt> <dd>
<p>The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.content_language">
<code>property content_language: werkzeug.datastructures.HeaderSet</code> </dt> <dd>
<p>The Content-Language entity-header field describes the natural language(s) of the intended audience for the enclosed entity. Note that this might not be equivalent to all the languages used within the entity-body.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.content_length">
<code>content_length</code> </dt> <dd>
<p>The Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.content_location">
<code>content_location</code> </dt> <dd>
<p>The Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource’s URI.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.content_md5">
<code>content_md5</code> </dt> <dd>
<p>The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.content_range">
<code>property content_range: werkzeug.datastructures.ContentRange</code> </dt> <dd>
<p>The <code>Content-Range</code> header as a <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.ContentRange" title="werkzeug.datastructures.ContentRange"><code>ContentRange</code></a> object. Available even if the header is not set.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.content_security_policy">
<code>content_security_policy</code> </dt> <dd>
<p>The Content-Security-Policy header adds an additional layer of security to help detect and mitigate certain types of attacks.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.content_security_policy_report_only">
<code>content_security_policy_report_only</code> </dt> <dd>
<p>The Content-Security-Policy-Report-Only header adds a csp policy that is not enforced but is reported thereby helping detect certain types of attacks.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.content_type">
<code>content_type</code> </dt> <dd>
<p>The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.cross_origin_embedder_policy">
<code>cross_origin_embedder_policy</code> </dt> <dd>
<p>Prevents a document from loading any cross-origin resources that do not explicitly grant the document permission. Values must be a member of the <code>werkzeug.http.COEP</code> enum.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.cross_origin_opener_policy">
<code>cross_origin_opener_policy</code> </dt> <dd>
<p>Allows control over sharing of browsing context group with cross-origin documents. Values must be a member of the <code>werkzeug.http.COOP</code> enum.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.data">
<code>property data: Union[bytes, str]</code> </dt> <dd>
<p>A descriptor that calls <a class="reference internal" href="#werkzeug.wrappers.Response.get_data" title="werkzeug.wrappers.Response.get_data"><code>get_data()</code></a> and <a class="reference internal" href="#werkzeug.wrappers.Response.set_data" title="werkzeug.wrappers.Response.set_data"><code>set_data()</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.date">
<code>date</code> </dt> <dd>
<p>The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.0: </span>The datetime object is timezone-aware.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.delete_cookie">
<code>delete_cookie(key, path='/', domain=None, secure=False, httponly=False, samesite=None)</code> </dt> <dd>
<p>Delete a cookie. Fails silently if key doesn’t exist.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>key</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>) – the key (name) of the cookie to be deleted.</li> <li>
<strong>path</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>) – if the cookie that should be deleted was limited to a path, the path has to be defined here.</li> <li>
<strong>domain</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>]</em>) – if the cookie that should be deleted was limited to a domain, that domain has to be defined here.</li> <li>
<strong>secure</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – If <code>True</code>, the cookie will only be available via HTTPS.</li> <li>
<strong>httponly</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – Disallow JavaScript access to the cookie.</li> <li>
<strong>samesite</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>]</em>) – Limit the scope of the cookie to only be attached to requests that are “same-site”.</li> </ul> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a></p> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.direct_passthrough">
<code>direct_passthrough</code> </dt> <dd>
<p>Pass the response body directly through as the WSGI iterable. This can be used when the body is a binary file or other iterator of bytes, to skip some unnecessary checks. Use <a class="reference internal" href="../utils/index#werkzeug.utils.send_file" title="werkzeug.utils.send_file"><code>send_file()</code></a> instead of setting this manually.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.expires">
<code>expires</code> </dt> <dd>
<p>The Expires entity-header field gives the date/time after which the response is considered stale. A stale cache entry may not normally be returned by a cache.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.0: </span>The datetime object is timezone-aware.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.force_type">
<code>classmethod force_type(response, environ=None)</code> </dt> <dd>
<p>Enforce that the WSGI response is a response object of the current type. Werkzeug will use the <a class="reference internal" href="#werkzeug.wrappers.Response" title="werkzeug.wrappers.Response"><code>Response</code></a> internally in many situations like the exceptions. If you call <code>get_response()</code> on an exception you will get back a regular <a class="reference internal" href="#werkzeug.wrappers.Response" title="werkzeug.wrappers.Response"><code>Response</code></a> object, even if you are using a custom subclass.</p> <p>This method can enforce a given response type, and it will also convert arbitrary WSGI callables into response objects if an environ is provided:</p> <pre data-language="python"># convert a Werkzeug response object into an instance of the
# MyResponseClass subclass.
response = MyResponseClass.force_type(response)

# convert any WSGI application into a response object
response = MyResponseClass.force_type(response, environ)
</pre> <p>This is especially useful if you want to post-process responses in the main dispatcher and use functionality provided by your subclass.</p> <p>Keep in mind that this will modify response objects in place if possible!</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>response</strong> (<a class="reference internal" href="#werkzeug.wrappers.Response" title="werkzeug.wrappers.Response">Response</a>) – a response object or wsgi application.</li> <li>
<strong>environ</strong> (<em>Optional</em><em>[</em><em>WSGIEnvironment</em><em>]</em>) – a WSGI environment object.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>a response object.</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#werkzeug.wrappers.Response" title="werkzeug.wrappers.Response">Response</a></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.freeze">
<code>freeze(no_etag=None)</code> </dt> <dd>
<p>Make the response object ready to be pickled. Does the following:</p> <ul class="simple"> <li>Buffer the response into a list, ignoring <code>implicity_sequence_conversion</code> and <a class="reference internal" href="#werkzeug.wrappers.Response.direct_passthrough" title="werkzeug.wrappers.Response.direct_passthrough"><code>direct_passthrough</code></a>.</li> <li>Set the <code>Content-Length</code> header.</li> <li>Generate an <code>ETag</code> header if one is not already set.</li> </ul> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.0: </span>An <code>ETag</code> header is added, the <code>no_etag</code> parameter is deprecated and will be removed in Werkzeug 2.1.</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.6: </span>The <code>Content-Length</code> header is set.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>no_etag</strong> (<a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a>) – </p> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.from_app">
<code>classmethod from_app(app, environ, buffered=False)</code> </dt> <dd>
<p>Create a new response object from an application output. This works best if you pass it an application that returns a generator all the time. Sometimes applications may use the <code>write()</code> callable returned by the <code>start_response</code> function. This tries to resolve such edge cases automatically. But if you don’t get the expected output you should set <code>buffered</code> to <code>True</code> which enforces buffering.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>app</strong> (<em>WSGIApplication</em>) – the WSGI application to execute.</li> <li>
<strong>environ</strong> (<em>WSGIEnvironment</em>) – the WSGI environment to execute against.</li> <li>
<strong>buffered</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – set to <code>True</code> to enforce buffering.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>a response object.</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#werkzeug.wrappers.Response" title="werkzeug.wrappers.Response">Response</a></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.get_app_iter">
<code>get_app_iter(environ)</code> </dt> <dd>
<p>Returns the application iterator for the given environ. Depending on the request method and the current status code the return value might be an empty response rather than the one from the response.</p> <p>If the request method is <code>HEAD</code> or the status code is in a range where the HTTP specification requires an empty response, an empty iterable is returned.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.6.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>environ</strong> (<em>WSGIEnvironment</em>) – the WSGI environment of the request.</p> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>a response iterable.</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p>Iterable[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.9)">bytes</a>]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.get_data">
<code>get_data(as_text=False)</code> </dt> <dd>
<p>The string representation of the response body. Whenever you call this property the response iterable is encoded and flattened. This can lead to unwanted behavior if you stream big data.</p> <p>This behavior can be disabled by setting <a class="reference internal" href="#werkzeug.wrappers.Response.implicit_sequence_conversion" title="werkzeug.wrappers.Response.implicit_sequence_conversion"><code>implicit_sequence_conversion</code></a> to <code>False</code>.</p> <p>If <code>as_text</code> is set to <code>True</code> the return value will be a decoded string.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>as_text</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – </p> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p>Union[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.9)">bytes</a>, <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.get_etag">
<code>get_etag()</code> </dt> <dd>
<p>Return a tuple in the form <code>(etag, is_weak)</code>. If there is no ETag the return value is <code>(None, None)</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p>Union[Tuple[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>, <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>], Tuple[<a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a>, <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a>]]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.get_json">
<code>get_json(force=False, silent=False)</code> </dt> <dd>
<p>Parse <a class="reference internal" href="#werkzeug.wrappers.Response.data" title="werkzeug.wrappers.Response.data"><code>data</code></a> as JSON. Useful during testing.</p> <p>If the mimetype does not indicate JSON (<em class="mimetype">application/json</em>, see <a class="reference internal" href="#werkzeug.wrappers.Response.is_json" title="werkzeug.wrappers.Response.is_json"><code>is_json()</code></a>), this returns <code>None</code>.</p> <p>Unlike <a class="reference internal" href="#werkzeug.wrappers.Request.get_json" title="werkzeug.wrappers.Request.get_json"><code>Request.get_json()</code></a>, the result is not cached.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>force</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – Ignore the mimetype and always try to parse JSON.</li> <li>
<strong>silent</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – Silence parsing errors and return <code>None</code> instead.</li> </ul> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p>Optional[Any]</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.get_wsgi_headers">
<code>get_wsgi_headers(environ)</code> </dt> <dd>
<p>This is automatically called right before the response is started and returns headers modified for the given environment. It returns a copy of the headers from the response with some modifications applied if necessary.</p> <p>For example the location header (if present) is joined with the root URL of the environment. Also the content length is automatically set to zero here for certain status codes.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.6: </span>Previously that function was called <code>fix_headers</code> and modified the response object in place. Also since 0.6, IRIs in location and content-location headers are handled properly.</p> <p>Also starting with 0.6, Werkzeug will attempt to set the content length if it is able to figure it out on its own. This is the case if all the strings in the response iterable are already encoded and the iterable is buffered.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>environ</strong> (<em>WSGIEnvironment</em>) – the WSGI environment of the request.</p> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>returns a new <a class="reference internal" href="../datastructures/index#werkzeug.datastructures.Headers" title="werkzeug.datastructures.Headers"><code>Headers</code></a> object.</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference internal" href="../datastructures/index#werkzeug.datastructures.Headers" title="werkzeug.datastructures.Headers">werkzeug.datastructures.Headers</a></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.get_wsgi_response">
<code>get_wsgi_response(environ)</code> </dt> <dd>
<p>Returns the final WSGI response as tuple. The first item in the tuple is the application iterator, the second the status and the third the list of headers. The response returned is created specially for the given environment. For example if the request method in the WSGI environment is <code>'HEAD'</code> the response will be empty and only the headers and status code will be present.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.6.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>environ</strong> (<em>WSGIEnvironment</em>) – the WSGI environment of the request.</p> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>an <code>(app_iter, status, headers)</code> tuple.</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p>Tuple[Iterable[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.9)">bytes</a>], <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>, List[Tuple[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>, <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>]]]</p> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.implicit_sequence_conversion">
<code>implicit_sequence_conversion = True</code> </dt> <dd>
<p>if set to <code>False</code> accessing properties on the response object will not try to consume the response iterator and convert it into a list.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.6.2: </span>That attribute was previously called <code>implicit_seqence_conversion</code>. (Notice the typo). If you did use this feature, you have to adapt your code to the name change.</p> </div> </details>
</dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.is_json">
<code>property is_json: bool</code> </dt> <dd>
<p>Check if the mimetype indicates JSON data, either <em class="mimetype">application/json</em> or <em class="mimetype">application/*+json</em>.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.is_sequence">
<code>property is_sequence: bool</code> </dt> <dd>
<p>If the iterator is buffered, this property will be <code>True</code>. A response object will consider an iterator to be buffered if the response attribute is a list or tuple.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.6.</span></p> </div> </details>
</dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.is_streamed">
<code>property is_streamed: bool</code> </dt> <dd>
<p>If the response is streamed (the response is not an iterable with a length information) this property is <code>True</code>. In this case streamed means that there is no information about the number of iterations. This is usually <code>True</code> if a generator is passed to the response object.</p> <p>This is useful for checking before applying some sort of post filtering that should not take place for streamed responses.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.iter_encoded">
<code>iter_encoded()</code> </dt> <dd>
<p>Iter the response encoded with the encoding of the response. If the response object is invoked as WSGI application the return value of this method is used as application iterator unless <a class="reference internal" href="#werkzeug.wrappers.Response.direct_passthrough" title="werkzeug.wrappers.Response.direct_passthrough"><code>direct_passthrough</code></a> was activated.</p> <dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p>Iterator[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.9)">bytes</a>]</p> </dd> </dl> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.json">
<code>property json: Optional[Any]</code> </dt> <dd>
<p>The parsed JSON data if <a class="reference internal" href="#werkzeug.wrappers.Response.mimetype" title="werkzeug.wrappers.Response.mimetype"><code>mimetype</code></a> indicates JSON (<em class="mimetype">application/json</em>, see <a class="reference internal" href="#werkzeug.wrappers.Response.is_json" title="werkzeug.wrappers.Response.is_json"><code>is_json()</code></a>).</p> <p>Calls <a class="reference internal" href="#werkzeug.wrappers.Response.get_json" title="werkzeug.wrappers.Response.get_json"><code>get_json()</code></a> with default arguments.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.json_module">
<code>json_module = &lt;module 'json' from '/home/docs/.pyenv/versions/3.7.9/lib/python3.7/json/__init__.py'&gt;</code> </dt> <dd>
<p>A module or other object that has <code>dumps</code> and <code>loads</code> functions that match the API of the built-in <a class="reference external" href="https://docs.python.org/3/library/json.html#module-json" title="(in Python v3.9)"><code>json</code></a> module.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.last_modified">
<code>last_modified</code> </dt> <dd>
<p>The Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.0: </span>The datetime object is timezone-aware.</p> </div> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.location">
<code>location</code> </dt> <dd>
<p>The Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.make_conditional">
<code>make_conditional(request_or_environ, accept_ranges=False, complete_length=None)</code> </dt> <dd>
<p>Make the response conditional to the request. This method works best if an etag was defined for the response already. The <code>add_etag</code> method can be used to do that. If called without etag just the date header is set.</p> <p>This does nothing if the request method in the request or environ is anything but GET or HEAD.</p> <p>For optimal performance when handling range requests, it’s recommended that your response data object implements <code>seekable</code>, <code>seek</code> and <code>tell</code> methods as described by <a class="reference external" href="https://docs.python.org/3/library/io.html#io.IOBase" title="(in Python v3.9)"><code>io.IOBase</code></a>. Objects returned by <a class="reference internal" href="../wsgi/index#werkzeug.wsgi.wrap_file" title="werkzeug.wsgi.wrap_file"><code>wrap_file()</code></a> automatically implement those methods.</p> <p>It does not remove the body of the response because that’s something the <a class="reference internal" href="#werkzeug.wrappers.Response.__call__" title="werkzeug.wrappers.Response.__call__"><code>__call__()</code></a> function does for us automatically.</p> <p>Returns self so that you can do <code>return resp.make_conditional(req)</code> but modifies the object in-place.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>request_or_environ</strong> (<em>WSGIEnvironment</em>) – a request object or WSGI environment to be used to make the response conditional against.</li> <li>
<strong>accept_ranges</strong> (<em>Union</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>]</em>) – This parameter dictates the value of <code>Accept-Ranges</code> header. If <code>False</code> (default), the header is not set. If <code>True</code>, it will be set to <code>"bytes"</code>. If <code>None</code>, it will be set to <code>"none"</code>. If it’s a string, it will use this value.</li> <li>
<strong>complete_length</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em>) – Will be used only in valid Range Requests. It will set <code>Content-Range</code> complete length value and compute <code>Content-Length</code> real value. This parameter is mandatory for successful Range Requests completion.</li> </ul> </dd> <dt class="field-even">Raises</dt> <dd class="field-even">
<p><a class="reference internal" href="../exceptions/index#werkzeug.exceptions.RequestedRangeNotSatisfiable" title="werkzeug.exceptions.RequestedRangeNotSatisfiable"><code>RequestedRangeNotSatisfiable</code></a> if <code>Range</code> header could not be parsed or satisfied.</p> </dd> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference internal" href="#werkzeug.wrappers.Response" title="werkzeug.wrappers.Response">Response</a></p> </dd> </dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.0: </span>Range processing is skipped if length is 0 instead of raising a 416 Range Not Satisfiable error.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.make_sequence">
<code>make_sequence()</code> </dt> <dd>
<p>Converts the response iterator in a list. By default this happens automatically if required. If <code>implicit_sequence_conversion</code> is disabled, this method is not automatically called and some properties might raise exceptions. This also encodes all the items.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.6.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a></p> </dd> </dl> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.mimetype">
<code>property mimetype: Optional[str]</code> </dt> <dd>
<p>The mimetype (content type without charset etc.)</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.mimetype_params">
<code>property mimetype_params: Dict[str, str]</code> </dt> <dd>
<p>The mimetype parameters as dict. For example if the content type is <code>text/html; charset=utf-8</code> the params would be <code>{'charset': 'utf-8'}</code>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.5.</span></p> </div> </details>
</dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.response">
<code>response: Union[Iterable[str], Iterable[bytes]]</code> </dt> <dd>
<p>The response body to send as the WSGI iterable. A list of strings or bytes represents a fixed-length response, any other iterable is a streaming response. Strings are encoded to bytes as UTF-8.</p> <p>Do not set to a plain string or bytes, that will cause sending the response to be very inefficient as it will iterate one byte at a time.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.retry_after">
<code>property retry_after: Optional[datetime.datetime]</code> </dt> <dd>
<p>The Retry-After response-header field can be used with a 503 (Service Unavailable) response to indicate how long the service is expected to be unavailable to the requesting client.</p> <p>Time in seconds until expiration or date.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.0: </span>The datetime object is timezone-aware.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.set_cookie">
<code>set_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, samesite=None)</code> </dt> <dd>
<p>Sets a cookie.</p> <p>A warning is raised if the size of the cookie header exceeds <code>max_cookie_size</code>, but the header will still be set.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>key</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>) – the key (name) of the cookie to be set.</li> <li>
<strong>value</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>) – the value of the cookie.</li> <li>
<strong>max_age</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.timedelta" title="(in Python v3.9)">datetime.timedelta</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>]</em><em>]</em>) – should be a number of seconds, or <code>None</code> (default) if the cookie should last only as long as the client’s browser session.</li> <li>
<strong>expires</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime" title="(in Python v3.9)">datetime.datetime</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.9)">float</a><em>]</em><em>]</em>) – should be a <code>datetime</code> object or UNIX timestamp.</li> <li>
<strong>path</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>]</em>) – limits the cookie to a given path, per default it will span the whole domain.</li> <li>
<strong>domain</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>]</em>) – if you want to set a cross-domain cookie. For example, <code>domain=".example.com"</code> will set a cookie that is readable by the domain <code>www.example.com</code>, <code>foo.example.com</code> etc. Otherwise, a cookie will only be readable by the domain that set it.</li> <li>
<strong>secure</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – If <code>True</code>, the cookie will only be available via HTTPS.</li> <li>
<strong>httponly</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – Disallow JavaScript access to the cookie.</li> <li>
<strong>samesite</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>]</em>) – Limit the scope of the cookie to only be attached to requests that are “same-site”.</li> </ul> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.set_data">
<code>set_data(value)</code> </dt> <dd>
<p>Sets a new string as response. The value must be a string or bytes. If a string is set it’s encoded to the charset of the response (utf-8 by default).</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>value</strong> (<em>Union</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.9)">bytes</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>]</em>) – </p> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.set_etag">
<code>set_etag(etag, weak=False)</code> </dt> <dd>
<p>Set the etag, and override the old one if there was one.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>etag</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>) – </li> <li>
<strong>weak</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – </li> </ul> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a></p> </dd> </dl> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.status">
<code>property status: str</code> </dt> <dd>
<p>The HTTP status code as a string.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.status_code">
<code>property status_code: int</code> </dt> <dd>
<p>The HTTP status code as a number.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.stream">
<code>property stream: werkzeug.wrappers.response.ResponseStream</code> </dt> <dd>
<p>The response iterable as write-only stream.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.vary">
<code>property vary: werkzeug.datastructures.HeaderSet</code> </dt> <dd>
<p>The Vary field value indicates the set of request-header fields that fully determines, while the response is fresh, whether a cache is permitted to use the response to reply to a subsequent request without revalidation.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.wrappers.Response.www_authenticate">
<code>property www_authenticate: werkzeug.datastructures.WWWAuthenticate</code> </dt> <dd>
<p>The <code>WWW-Authenticate</code> header in a parsed form.</p> </dd>
</dl> </dd>
</dl> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2021 Pallets<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://werkzeug.palletsprojects.com/en/2.0.x/wrappers/" class="_attribution-link">https://werkzeug.palletsprojects.com/en/2.0.x/wrappers/</a>
  </p>
</div>
