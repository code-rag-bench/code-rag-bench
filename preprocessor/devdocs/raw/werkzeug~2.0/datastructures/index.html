<h1 id="data-structures">Data Structures</h1> <p>Werkzeug provides some subclasses of common Python objects to extend them with additional features. Some of them are used to make them immutable, others are used to change some semantics to better work with HTTP.</p> <section id="general-purpose"> <h2>General Purpose</h2> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.6: </span>The general purpose classes are now pickleable in each protocol as long as the contained objects are pickleable. This means that the <a class="reference internal" href="#werkzeug.datastructures.FileMultiDict" title="werkzeug.datastructures.FileMultiDict"><code>FileMultiDict</code></a> won’t be pickleable as soon as it contains a file.</p> </div> </details><dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.TypeConversionDict">
<code>class werkzeug.datastructures.TypeConversionDict</code> </dt> <dd>
<p>Works like a regular dict but the <a class="reference internal" href="#werkzeug.datastructures.TypeConversionDict.get" title="werkzeug.datastructures.TypeConversionDict.get"><code>get()</code></a> method can perform type conversions. <a class="reference internal" href="#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a> and <a class="reference internal" href="#werkzeug.datastructures.CombinedMultiDict" title="werkzeug.datastructures.CombinedMultiDict"><code>CombinedMultiDict</code></a> are subclasses of this class and provide the same feature.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.5.</span></p> </div> </details><dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.TypeConversionDict.get">
<code>get(key, default=None, type=None)</code> </dt> <dd>
<p>Return the default value if the requested data doesn’t exist. If <code>type</code> is provided and is a callable it should convert the value, return it or raise a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.9)"><code>ValueError</code></a> if that is not possible. In this case the function will return the default as if the value was not found:</p> <pre data-language="python">&gt;&gt;&gt; d = TypeConversionDict(foo='42', bar='blub')
&gt;&gt;&gt; d.get('foo', type=int)
42
&gt;&gt;&gt; d.get('bar', -1, type=int)
-1
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>key</strong> – The key to be looked up.</li> <li>
<strong>default</strong> – The default value to be returned if the key can’t be looked up. If not further specified <code>None</code> is returned.</li> <li>
<strong>type</strong> – A callable that is used to cast the value in the <a class="reference internal" href="#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a>. If a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.9)"><code>ValueError</code></a> is raised by this callable the default value is returned.</li> </ul> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.ImmutableTypeConversionDict">
<code>class werkzeug.datastructures.ImmutableTypeConversionDict</code> </dt> <dd>
<p>Works like a <a class="reference internal" href="#werkzeug.datastructures.TypeConversionDict" title="werkzeug.datastructures.TypeConversionDict"><code>TypeConversionDict</code></a> but does not support modifications.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.5.</span></p> </div> </details><dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.ImmutableTypeConversionDict.copy">
<code>copy()</code> </dt> <dd>
<p>Return a shallow mutable copy of this object. Keep in mind that the standard library’s <a class="reference internal" href="#werkzeug.datastructures.ImmutableTypeConversionDict.copy" title="werkzeug.datastructures.ImmutableTypeConversionDict.copy"><code>copy()</code></a> function is a no-op for this class like for any other python immutable type (eg: <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.9)"><code>tuple</code></a>).</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict">
<code>class werkzeug.datastructures.MultiDict(mapping=None)</code> </dt> <dd>
<p>A <a class="reference internal" href="#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a> is a dictionary subclass customized to deal with multiple values for the same key which is for example used by the parsing functions in the wrappers. This is necessary because some HTML form elements pass multiple values for the same key.</p> <p><a class="reference internal" href="#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a> implements all standard dictionary methods. Internally, it saves all values for a key as a list, but the standard dict access methods will only return the first value for a key. If you want to gain access to the other values, too, you have to use the <code>list</code> methods as explained below.</p> <p>Basic Usage:</p> <pre data-language="python">&gt;&gt;&gt; d = MultiDict([('a', 'b'), ('a', 'c')])
&gt;&gt;&gt; d
MultiDict([('a', 'b'), ('a', 'c')])
&gt;&gt;&gt; d['a']
'b'
&gt;&gt;&gt; d.getlist('a')
['b', 'c']
&gt;&gt;&gt; 'a' in d
True
</pre> <p>It behaves like a normal dict thus all dict functions will only return the first value when multiple values for one key are found.</p> <p>From Werkzeug 0.3 onwards, the <code>KeyError</code> raised by this class is also a subclass of the <code>BadRequest</code> HTTP exception and will render a page for a <code>400 BAD REQUEST</code> if caught in a catch-all for HTTP exceptions.</p> <p>A <a class="reference internal" href="#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a> can be constructed from an iterable of <code>(key, value)</code> tuples, a dict, a <a class="reference internal" href="#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a> or from Werkzeug 0.2 onwards some keyword parameters.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>mapping</strong> – the initial value for the <a class="reference internal" href="#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a>. Either a regular dict, an iterable of <code>(key, value)</code> tuples or <code>None</code>.</p> </dd> </dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.add">
<code>add(key, value)</code> </dt> <dd>
<p>Adds a new value for the key.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.6.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>key</strong> – the key for the value.</li> <li>
<strong>value</strong> – the value to add.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.clear">
<code>clear() → None. Remove all items from D.</code> </dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.copy">
<code>copy()</code> </dt> <dd>
<p>Return a shallow copy of this object.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.deepcopy">
<code>deepcopy(memo=None)</code> </dt> <dd>
<p>Return a deep copy of this object.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.fromkeys">
<code>fromkeys(value=None, /)</code> </dt> <dd>
<p>Create a new dictionary with keys from iterable and values set to value.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.get">
<code>get(key, default=None, type=None)</code> </dt> <dd>
<p>Return the default value if the requested data doesn’t exist. If <code>type</code> is provided and is a callable it should convert the value, return it or raise a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.9)"><code>ValueError</code></a> if that is not possible. In this case the function will return the default as if the value was not found:</p> <pre data-language="python">&gt;&gt;&gt; d = TypeConversionDict(foo='42', bar='blub')
&gt;&gt;&gt; d.get('foo', type=int)
42
&gt;&gt;&gt; d.get('bar', -1, type=int)
-1
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>key</strong> – The key to be looked up.</li> <li>
<strong>default</strong> – The default value to be returned if the key can’t be looked up. If not further specified <code>None</code> is returned.</li> <li>
<strong>type</strong> – A callable that is used to cast the value in the <a class="reference internal" href="#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a>. If a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.9)"><code>ValueError</code></a> is raised by this callable the default value is returned.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.getlist">
<code>getlist(key, type=None)</code> </dt> <dd>
<p>Return the list of items for a given key. If that key is not in the <code>MultiDict</code>, the return value will be an empty list. Just like <code>get</code>, <code>getlist</code> accepts a <code>type</code> parameter. All items will be converted with the callable defined there.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>key</strong> – The key to be looked up.</li> <li>
<strong>type</strong> – A callable that is used to cast the value in the <a class="reference internal" href="#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a>. If a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.9)"><code>ValueError</code></a> is raised by this callable the value will be removed from the list.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><code>list</code></a> of all the values for the key.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.items">
<code>items(multi=False)</code> </dt> <dd>
<p>Return an iterator of <code>(key, value)</code> pairs.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>multi</strong> – If set to <code>True</code> the iterator returned will have a pair for each value of each key. Otherwise it will only contain pairs for the first value of each key.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.keys">
<code>keys() → a set-like object providing a view on D’s keys</code> </dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.lists">
<code>lists()</code> </dt> <dd>
<p>Return a iterator of <code>(key, values)</code> pairs, where values is the list of all values associated with the key.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.listvalues">
<code>listvalues()</code> </dt> <dd>
<p>Return an iterator of all values associated with a key. Zipping <a class="reference internal" href="#werkzeug.datastructures.MultiDict.keys" title="werkzeug.datastructures.MultiDict.keys"><code>keys()</code></a> and this is the same as calling <a class="reference internal" href="#werkzeug.datastructures.MultiDict.lists" title="werkzeug.datastructures.MultiDict.lists"><code>lists()</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; d = MultiDict({"foo": [1, 2, 3]})
&gt;&gt;&gt; zip(d.keys(), d.listvalues()) == d.lists()
True
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.pop">
<code>pop(key, default=no value)</code> </dt> <dd>
<p>Pop the first item for a list on the dict. Afterwards the key is removed from the dict, so additional values are discarded:</p> <pre data-language="python">&gt;&gt;&gt; d = MultiDict({"foo": [1, 2, 3]})
&gt;&gt;&gt; d.pop("foo")
1
&gt;&gt;&gt; "foo" in d
False
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>key</strong> – the key to pop.</li> <li>
<strong>default</strong> – if provided the value to return if the key was not in the dictionary.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.popitem">
<code>popitem()</code> </dt> <dd>
<p>Pop an item from the dict.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.popitemlist">
<code>popitemlist()</code> </dt> <dd>
<p>Pop a <code>(key, list)</code> tuple from the dict.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.poplist">
<code>poplist(key)</code> </dt> <dd>
<p>Pop the list for a key from the dict. If the key is not in the dict an empty list is returned.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.5: </span>If the key does no longer exist a list is returned instead of raising an error.</p> </div> </details>
</dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.setdefault">
<code>setdefault(key, default=None)</code> </dt> <dd>
<p>Returns the value for the key if it is in the dict, otherwise it returns <code>default</code> and sets that value for <code>key</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>key</strong> – The key to be looked up.</li> <li>
<strong>default</strong> – The default value to be returned if the key is not in the dict. If not further specified it’s <code>None</code>.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.setlist">
<code>setlist(key, new_list)</code> </dt> <dd>
<p>Remove the old values for a key and add new ones. Note that the list you pass the values in will be shallow-copied before it is inserted in the dictionary.</p> <pre data-language="python">&gt;&gt;&gt; d = MultiDict()
&gt;&gt;&gt; d.setlist('foo', ['1', '2'])
&gt;&gt;&gt; d['foo']
'1'
&gt;&gt;&gt; d.getlist('foo')
['1', '2']
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>key</strong> – The key for which the values are set.</li> <li>
<strong>new_list</strong> – An iterable with the new values for the key. Old values are removed first.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.setlistdefault">
<code>setlistdefault(key, default_list=None)</code> </dt> <dd>
<p>Like <code>setdefault</code> but sets multiple values. The list returned is not a copy, but the list that is actually used internally. This means that you can put new values into the dict by appending items to the list:</p> <pre data-language="python">&gt;&gt;&gt; d = MultiDict({"foo": 1})
&gt;&gt;&gt; d.setlistdefault("foo").extend([2, 3])
&gt;&gt;&gt; d.getlist("foo")
[1, 2, 3]
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>key</strong> – The key to be looked up.</li> <li>
<strong>default_list</strong> – An iterable of default values. It is either copied (in case it was a list) or converted into a list before returned.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><code>list</code></a></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.to_dict">
<code>to_dict(flat=True)</code> </dt> <dd>
<p>Return the contents as regular dict. If <code>flat</code> is <code>True</code> the returned dict will only have the first item present, if <code>flat</code> is <code>False</code> all values will be returned as lists.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>flat</strong> – If set to <code>False</code> the dict returned will have lists with all the values in it. Otherwise it will only contain the first value for each key.</p> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><code>dict</code></a></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.update">
<code>update(mapping)</code> </dt> <dd>
<p>update() extends rather than replaces existing key lists:</p> <pre data-language="python">&gt;&gt;&gt; a = MultiDict({'x': 1})
&gt;&gt;&gt; b = MultiDict({'x': 2, 'y': 3})
&gt;&gt;&gt; a.update(b)
&gt;&gt;&gt; a
MultiDict([('y', 3), ('x', 1), ('x', 2)])
</pre> <p>If the value list for a key in <code>other_dict</code> is empty, no new values will be added to the dict and the key will not be created:</p> <pre data-language="python">&gt;&gt;&gt; x = {'empty_list': []}
&gt;&gt;&gt; y = MultiDict()
&gt;&gt;&gt; y.update(x)
&gt;&gt;&gt; y
MultiDict([])
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.MultiDict.values">
<code>values()</code> </dt> <dd>
<p>Returns an iterator of the first value on every key’s value list.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.OrderedMultiDict">
<code>class werkzeug.datastructures.OrderedMultiDict(mapping=None)</code> </dt> <dd>
<p>Works like a regular <a class="reference internal" href="#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a> but preserves the order of the fields. To convert the ordered multi dict into a list you can use the <code>items()</code> method and pass it <code>multi=True</code>.</p> <p>In general an <a class="reference internal" href="#werkzeug.datastructures.OrderedMultiDict" title="werkzeug.datastructures.OrderedMultiDict"><code>OrderedMultiDict</code></a> is an order of magnitude slower than a <a class="reference internal" href="#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a>.</p> <div class="admonition-note admonition"> <p class="admonition-title">note</p> <p>Due to a limitation in Python you cannot convert an ordered multi dict into a regular dict by using <code>dict(multidict)</code>. Instead you have to use the <code>to_dict()</code> method, otherwise the internal bucket objects are exposed.</p> </div> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.ImmutableMultiDict">
<code>class werkzeug.datastructures.ImmutableMultiDict(mapping=None)</code> </dt> <dd>
<p>An immutable <a class="reference internal" href="#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.5.</span></p> </div> </details><dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.ImmutableMultiDict.copy">
<code>copy()</code> </dt> <dd>
<p>Return a shallow mutable copy of this object. Keep in mind that the standard library’s <a class="reference internal" href="#werkzeug.datastructures.ImmutableMultiDict.copy" title="werkzeug.datastructures.ImmutableMultiDict.copy"><code>copy()</code></a> function is a no-op for this class like for any other python immutable type (eg: <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.9)"><code>tuple</code></a>).</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.ImmutableOrderedMultiDict">
<code>class werkzeug.datastructures.ImmutableOrderedMultiDict(mapping=None)</code> </dt> <dd>
<p>An immutable <a class="reference internal" href="#werkzeug.datastructures.OrderedMultiDict" title="werkzeug.datastructures.OrderedMultiDict"><code>OrderedMultiDict</code></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.6.</span></p> </div> </details><dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.ImmutableOrderedMultiDict.copy">
<code>copy()</code> </dt> <dd>
<p>Return a shallow mutable copy of this object. Keep in mind that the standard library’s <a class="reference internal" href="#werkzeug.datastructures.ImmutableOrderedMultiDict.copy" title="werkzeug.datastructures.ImmutableOrderedMultiDict.copy"><code>copy()</code></a> function is a no-op for this class like for any other python immutable type (eg: <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.9)"><code>tuple</code></a>).</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.CombinedMultiDict">
<code>class werkzeug.datastructures.CombinedMultiDict(dicts=None)</code> </dt> <dd>
<p>A read only <a class="reference internal" href="#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a> that you can pass multiple <a class="reference internal" href="#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a> instances as sequence and it will combine the return values of all wrapped dicts:</p> <pre data-language="python">&gt;&gt;&gt; from werkzeug.datastructures import CombinedMultiDict, MultiDict
&gt;&gt;&gt; post = MultiDict([('foo', 'bar')])
&gt;&gt;&gt; get = MultiDict([('blub', 'blah')])
&gt;&gt;&gt; combined = CombinedMultiDict([get, post])
&gt;&gt;&gt; combined['foo']
'bar'
&gt;&gt;&gt; combined['blub']
'blah'
</pre> <p>This works for all read operations and will raise a <code>TypeError</code> for methods that usually change data which isn’t possible.</p> <p>From Werkzeug 0.3 onwards, the <code>KeyError</code> raised by this class is also a subclass of the <code>BadRequest</code> HTTP exception and will render a page for a <code>400 BAD REQUEST</code> if caught in a catch-all for HTTP exceptions.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.ImmutableDict">
<code>class werkzeug.datastructures.ImmutableDict</code> </dt> <dd>
<p>An immutable <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><code>dict</code></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.5.</span></p> </div> </details><dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.ImmutableDict.copy">
<code>copy()</code> </dt> <dd>
<p>Return a shallow mutable copy of this object. Keep in mind that the standard library’s <a class="reference internal" href="#werkzeug.datastructures.ImmutableDict.copy" title="werkzeug.datastructures.ImmutableDict.copy"><code>copy()</code></a> function is a no-op for this class like for any other python immutable type (eg: <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.9)"><code>tuple</code></a>).</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.ImmutableList">
<code>class werkzeug.datastructures.ImmutableList(iterable=(), /)</code> </dt> <dd>
<p>An immutable <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><code>list</code></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.5.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Private</dt>  </dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.FileMultiDict">
<code>class werkzeug.datastructures.FileMultiDict(mapping=None)</code> </dt> <dd>
<p>A special <a class="reference internal" href="#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a> that has convenience methods to add files to it. This is used for <code>EnvironBuilder</code> and generally useful for unittesting.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.5.</span></p> </div> </details><dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.FileMultiDict.add_file">
<code>add_file(name, file, filename=None, content_type=None)</code> </dt> <dd>
<p>Adds a new file to the dict. <code>file</code> can be a file name or a <code>file</code>-like or a <a class="reference internal" href="#werkzeug.datastructures.FileStorage" title="werkzeug.datastructures.FileStorage"><code>FileStorage</code></a> object.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>name</strong> – the name of the field.</li> <li>
<strong>file</strong> – a filename or <code>file</code>-like object</li> <li>
<strong>filename</strong> – an optional filename</li> <li>
<strong>content_type</strong> – an optional content type</li> </ul> </dd> </dl> </dd>
</dl> </dd>
</dl> </section> <section id="http-related"> <h2 id="http-datastructures">HTTP Related</h2> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.Headers">
<code>class werkzeug.datastructures.Headers([defaults])</code> </dt> <dd>
<p>An object that stores some headers. It has a dict-like interface, but is ordered, can store the same key multiple times, and iterating yields <code>(key, value)</code> pairs instead of only keys.</p> <p>This data structure is useful if you want a nicer way to handle WSGI headers which are stored as tuples in a list.</p> <p>From Werkzeug 0.3 onwards, the <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.9)"><code>KeyError</code></a> raised by this class is also a subclass of the <code>BadRequest</code> HTTP exception and will render a page for a <code>400 BAD REQUEST</code> if caught in a catch-all for HTTP exceptions.</p> <p>Headers is mostly compatible with the Python <a class="reference external" href="https://docs.python.org/3/library/wsgiref.html#wsgiref.headers.Headers" title="(in Python v3.9)"><code>wsgiref.headers.Headers</code></a> class, with the exception of <code>__getitem__</code>. <a class="reference external" href="https://docs.python.org/3/library/wsgiref.html#module-wsgiref" title="(in Python v3.9)"><code>wsgiref</code></a> will return <code>None</code> for <code>headers['missing']</code>, whereas <a class="reference internal" href="#werkzeug.datastructures.Headers" title="werkzeug.datastructures.Headers"><code>Headers</code></a> will raise a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.9)"><code>KeyError</code></a>.</p> <p>To create a new <a class="reference internal" href="#werkzeug.datastructures.Headers" title="werkzeug.datastructures.Headers"><code>Headers</code></a> object pass it a list or dict of headers which are used as default values. This does not reuse the list passed to the constructor for internal usage.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>defaults</strong> – The list of default values for the <a class="reference internal" href="#werkzeug.datastructures.Headers" title="werkzeug.datastructures.Headers"><code>Headers</code></a>.</p> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.9: </span>This data structure now stores unicode values similar to how the multi dicts do it. The main difference is that bytes can be set as well which will automatically be latin1 decoded.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.9: </span>The <code>linked()</code> function was removed without replacement as it was an API that does not support the changes to the encoding model.</p> </div> </details><dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Headers.add">
<code>add(_key, _value, **kw)</code> </dt> <dd>
<p>Add a new header tuple to the list.</p> <p>Keyword arguments can specify additional parameters for the header value, with underscores converted to dashes:</p> <pre data-language="python">&gt;&gt;&gt; d = Headers()
&gt;&gt;&gt; d.add('Content-Type', 'text/plain')
&gt;&gt;&gt; d.add('Content-Disposition', 'attachment', filename='foo.png')
</pre> <p>The keyword argument dumping uses <code>dump_options_header()</code> behind the scenes.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.4.1: </span>keyword arguments were added for <a class="reference external" href="https://docs.python.org/3/library/wsgiref.html#module-wsgiref" title="(in Python v3.9)"><code>wsgiref</code></a> compatibility.</p> </div> </details>
</dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Headers.add_header">
<code>add_header(_key, _value, **_kw)</code> </dt> <dd>
<p>Add a new header tuple to the list.</p> <p>An alias for <a class="reference internal" href="#werkzeug.datastructures.Headers.add" title="werkzeug.datastructures.Headers.add"><code>add()</code></a> for compatibility with the <a class="reference external" href="https://docs.python.org/3/library/wsgiref.html#module-wsgiref" title="(in Python v3.9)"><code>wsgiref</code></a> <a class="reference external" href="https://docs.python.org/3/library/wsgiref.html#wsgiref.headers.Headers.add_header" title="(in Python v3.9)"><code>add_header()</code></a> method.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Headers.clear">
<code>clear()</code> </dt> <dd>
<p>Clears all headers.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Headers.extend">
<code>extend(*args, **kwargs)</code> </dt> <dd>
<p>Extend headers in this object with items from another object containing header items as well as keyword arguments.</p> <p>To replace existing keys instead of extending, use <a class="reference internal" href="#werkzeug.datastructures.Headers.update" title="werkzeug.datastructures.Headers.update"><code>update()</code></a> instead.</p> <p>If provided, the first argument can be another <a class="reference internal" href="#werkzeug.datastructures.Headers" title="werkzeug.datastructures.Headers"><code>Headers</code></a> object, a <a class="reference internal" href="#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a>, <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><code>dict</code></a>, or iterable of pairs.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.0: </span>Support <a class="reference internal" href="#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a>. Allow passing <code>kwargs</code>.</p> </div> </details>
</dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Headers.get">
<code>get(key, default=None, type=None, as_bytes=False)</code> </dt> <dd>
<p>Return the default value if the requested data doesn’t exist. If <code>type</code> is provided and is a callable it should convert the value, return it or raise a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.9)"><code>ValueError</code></a> if that is not possible. In this case the function will return the default as if the value was not found:</p> <pre data-language="python">&gt;&gt;&gt; d = Headers([('Content-Length', '42')])
&gt;&gt;&gt; d.get('Content-Length', type=int)
42
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9: </span>Added support for <code>as_bytes</code>.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>key</strong> – The key to be looked up.</li> <li>
<strong>default</strong> – The default value to be returned if the key can’t be looked up. If not further specified <code>None</code> is returned.</li> <li>
<strong>type</strong> – A callable that is used to cast the value in the <a class="reference internal" href="#werkzeug.datastructures.Headers" title="werkzeug.datastructures.Headers"><code>Headers</code></a>. If a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.9)"><code>ValueError</code></a> is raised by this callable the default value is returned.</li> <li>
<strong>as_bytes</strong> – return bytes instead of strings.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Headers.get_all">
<code>get_all(name)</code> </dt> <dd>
<p>Return a list of all the values for the named field.</p> <p>This method is compatible with the <a class="reference external" href="https://docs.python.org/3/library/wsgiref.html#module-wsgiref" title="(in Python v3.9)"><code>wsgiref</code></a> <a class="reference external" href="https://docs.python.org/3/library/wsgiref.html#wsgiref.headers.Headers.get_all" title="(in Python v3.9)"><code>get_all()</code></a> method.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Headers.getlist">
<code>getlist(key, type=None, as_bytes=False)</code> </dt> <dd>
<p>Return the list of items for a given key. If that key is not in the <a class="reference internal" href="#werkzeug.datastructures.Headers" title="werkzeug.datastructures.Headers"><code>Headers</code></a>, the return value will be an empty list. Just like <a class="reference internal" href="#werkzeug.datastructures.Headers.get" title="werkzeug.datastructures.Headers.get"><code>get()</code></a>, <a class="reference internal" href="#werkzeug.datastructures.Headers.getlist" title="werkzeug.datastructures.Headers.getlist"><code>getlist()</code></a> accepts a <code>type</code> parameter. All items will be converted with the callable defined there.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9: </span>Added support for <code>as_bytes</code>.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>key</strong> – The key to be looked up.</li> <li>
<strong>type</strong> – A callable that is used to cast the value in the <a class="reference internal" href="#werkzeug.datastructures.Headers" title="werkzeug.datastructures.Headers"><code>Headers</code></a>. If a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.9)"><code>ValueError</code></a> is raised by this callable the value will be removed from the list.</li> <li>
<strong>as_bytes</strong> – return bytes instead of strings.</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.9)"><code>list</code></a> of all the values for the key.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Headers.has_key">
<code>has_key(key)</code> </dt> <dd>
<div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 2.0: </span>Will be removed in Werkzeug 2.1. Use <code>key in data</code> instead.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Headers.pop">
<code>pop(key=None, default=no value)</code> </dt> <dd>
<p>Removes and returns a key or index.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>key</strong> – The key to be popped. If this is an integer the item at that position is removed, if it’s a string the value for that key is. If the key is omitted or <code>None</code> the last item is removed.</p> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>an item.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Headers.popitem">
<code>popitem()</code> </dt> <dd>
<p>Removes a key or index and returns a (key, value) item.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Headers.remove">
<code>remove(key)</code> </dt> <dd>
<p>Remove a key.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>key</strong> – The key to be removed.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Headers.set">
<code>set(_key, _value, **kw)</code> </dt> <dd>
<p>Remove all header tuples for <code>key</code> and add a new one. The newly added key either appears at the end of the list if there was no entry or replaces the first one.</p> <p>Keyword arguments can specify additional parameters for the header value, with underscores converted to dashes. See <a class="reference internal" href="#werkzeug.datastructures.Headers.add" title="werkzeug.datastructures.Headers.add"><code>add()</code></a> for more information.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.6.1: </span><a class="reference internal" href="#werkzeug.datastructures.Headers.set" title="werkzeug.datastructures.Headers.set"><code>set()</code></a> now accepts the same arguments as <a class="reference internal" href="#werkzeug.datastructures.Headers.add" title="werkzeug.datastructures.Headers.add"><code>add()</code></a>.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>key</strong> – The key to be inserted.</li> <li>
<strong>value</strong> – The value to be inserted.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Headers.setdefault">
<code>setdefault(key, default)</code> </dt> <dd>
<p>Return the first value for the key if it is in the headers, otherwise set the header to the value given by <code>default</code> and return that.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>key</strong> – The header key to get.</li> <li>
<strong>default</strong> – The value to set for the key if it is not in the headers.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Headers.setlist">
<code>setlist(key, values)</code> </dt> <dd>
<p>Remove any existing values for a header and add new ones.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>key</strong> – The header key to set.</li> <li>
<strong>values</strong> – An iterable of values to set for the key.</li> </ul> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 1.0.</span></p> </div> </details>
</dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Headers.setlistdefault">
<code>setlistdefault(key, default)</code> </dt> <dd>
<p>Return the list of values for the key if it is in the headers, otherwise set the header to the list of values given by <code>default</code> and return that.</p> <p>Unlike <a class="reference internal" href="#werkzeug.datastructures.MultiDict.setlistdefault" title="werkzeug.datastructures.MultiDict.setlistdefault"><code>MultiDict.setlistdefault()</code></a>, modifying the returned list will not affect the headers.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>key</strong> – The header key to get.</li> <li>
<strong>default</strong> – An iterable of values to set for the key if it is not in the headers.</li> </ul> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 1.0.</span></p> </div> </details>
</dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Headers.to_wsgi_list">
<code>to_wsgi_list()</code> </dt> <dd>
<p>Convert the headers into a list suitable for WSGI.</p> <dl class="field-list simple"> <dt class="field-odd">Returns</dt> <dd class="field-odd">
<p>list</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Headers.update">
<code>update(*args, **kwargs)</code> </dt> <dd>
<p>Replace headers in this object with items from another headers object and keyword arguments.</p> <p>To extend existing keys instead of replacing, use <a class="reference internal" href="#werkzeug.datastructures.Headers.extend" title="werkzeug.datastructures.Headers.extend"><code>extend()</code></a> instead.</p> <p>If provided, the first argument can be another <a class="reference internal" href="#werkzeug.datastructures.Headers" title="werkzeug.datastructures.Headers"><code>Headers</code></a> object, a <a class="reference internal" href="#werkzeug.datastructures.MultiDict" title="werkzeug.datastructures.MultiDict"><code>MultiDict</code></a>, <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.9)"><code>dict</code></a>, or iterable of pairs.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 1.0.</span></p> </div> </details>
</dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.EnvironHeaders">
<code>class werkzeug.datastructures.EnvironHeaders(environ)</code> </dt> <dd>
<p>Read only version of the headers from a WSGI environment. This provides the same interface as <code>Headers</code> and is constructed from a WSGI environment.</p> <p>From Werkzeug 0.3 onwards, the <code>KeyError</code> raised by this class is also a subclass of the <code>BadRequest</code> HTTP exception and will render a page for a <code>400 BAD REQUEST</code> if caught in a catch-all for HTTP exceptions.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.HeaderSet">
<code>class werkzeug.datastructures.HeaderSet(headers=None, on_update=None)</code> </dt> <dd>
<p>Similar to the <a class="reference internal" href="#werkzeug.datastructures.ETags" title="werkzeug.datastructures.ETags"><code>ETags</code></a> class this implements a set-like structure. Unlike <a class="reference internal" href="#werkzeug.datastructures.ETags" title="werkzeug.datastructures.ETags"><code>ETags</code></a> this is case insensitive and used for vary, allow, and content-language headers.</p> <p>If not constructed using the <code>parse_set_header()</code> function the instantiation works like this:</p> <pre data-language="python">&gt;&gt;&gt; hs = HeaderSet(['foo', 'bar', 'baz'])
&gt;&gt;&gt; hs
HeaderSet(['foo', 'bar', 'baz'])
</pre> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.HeaderSet.add">
<code>add(header)</code> </dt> <dd>
<p>Add a new header to the set.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.HeaderSet.as_set">
<code>as_set(preserve_casing=False)</code> </dt> <dd>
<p>Return the set as real python set type. When calling this, all the items are converted to lowercase and the ordering is lost.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>preserve_casing</strong> – if set to <code>True</code> the items in the set returned will have the original case like in the <a class="reference internal" href="#werkzeug.datastructures.HeaderSet" title="werkzeug.datastructures.HeaderSet"><code>HeaderSet</code></a>, otherwise they will be lowercase.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.HeaderSet.clear">
<code>clear()</code> </dt> <dd>
<p>Clear the set.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.HeaderSet.discard">
<code>discard(header)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#werkzeug.datastructures.HeaderSet.remove" title="werkzeug.datastructures.HeaderSet.remove"><code>remove()</code></a> but ignores errors.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>header</strong> – the header to be discarded.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.HeaderSet.find">
<code>find(header)</code> </dt> <dd>
<p>Return the index of the header in the set or return -1 if not found.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>header</strong> – the header to be looked up.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.HeaderSet.index">
<code>index(header)</code> </dt> <dd>
<p>Return the index of the header in the set or raise an <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#IndexError" title="(in Python v3.9)"><code>IndexError</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>header</strong> – the header to be looked up.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.HeaderSet.remove">
<code>remove(header)</code> </dt> <dd>
<p>Remove a header from the set. This raises an <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.9)"><code>KeyError</code></a> if the header is not in the set.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.5: </span>In older versions a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#IndexError" title="(in Python v3.9)"><code>IndexError</code></a> was raised instead of a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.9)"><code>KeyError</code></a> if the object was missing.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>header</strong> – the header to be removed.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.HeaderSet.to_header">
<code>to_header()</code> </dt> <dd>
<p>Convert the header set into an HTTP header string.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.HeaderSet.update">
<code>update(iterable)</code> </dt> <dd>
<p>Add all the headers from the iterable to the set.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>iterable</strong> – updates the set with the items from the iterable.</p> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.Accept">
<code>class werkzeug.datastructures.Accept(values=())</code> </dt> <dd>
<p>An <a class="reference internal" href="#werkzeug.datastructures.Accept" title="werkzeug.datastructures.Accept"><code>Accept</code></a> object is just a list subclass for lists of <code>(value, quality)</code> tuples. It is automatically sorted by specificity and quality.</p> <p>All <a class="reference internal" href="#werkzeug.datastructures.Accept" title="werkzeug.datastructures.Accept"><code>Accept</code></a> objects work similar to a list but provide extra functionality for working with the data. Containment checks are normalized to the rules of that header:</p> <pre data-language="python">&gt;&gt;&gt; a = CharsetAccept([('ISO-8859-1', 1), ('utf-8', 0.7)])
&gt;&gt;&gt; a.best
'ISO-8859-1'
&gt;&gt;&gt; 'iso-8859-1' in a
True
&gt;&gt;&gt; 'UTF8' in a
True
&gt;&gt;&gt; 'utf7' in a
False
</pre> <p>To get the quality for an item you can use normal item lookup:</p> <pre data-language="python">&gt;&gt;&gt; print a['utf-8']
0.7
&gt;&gt;&gt; a['utf7']
0
</pre> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.0.0: </span><a class="reference internal" href="#werkzeug.datastructures.Accept" title="werkzeug.datastructures.Accept"><code>Accept</code></a> internal values are no longer ordered alphabetically for equal quality tags. Instead the initial order is preserved.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.5: </span><a class="reference internal" href="#werkzeug.datastructures.Accept" title="werkzeug.datastructures.Accept"><code>Accept</code></a> objects are forced immutable now.</p> </div> </details><dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.Accept.best">
<code>property best</code> </dt> <dd>
<p>The best match as value.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Accept.best_match">
<code>best_match(matches, default=None)</code> </dt> <dd>
<p>Returns the best match from a list of possible matches based on the specificity and quality of the client. If two items have the same quality and specificity, the one is returned that comes first.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>matches</strong> – a list of matches to check for</li> <li>
<strong>default</strong> – the value that is returned if none match</li> </ul> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Accept.find">
<code>find(key)</code> </dt> <dd>
<p>Get the position of an entry or return -1.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>key</strong> – The key to be looked up.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Accept.index">
<code>index(key)</code> </dt> <dd>
<p>Get the position of an entry or raise <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.9)"><code>ValueError</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>key</strong> – The key to be looked up.</p> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.5: </span>This used to raise <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#IndexError" title="(in Python v3.9)"><code>IndexError</code></a>, which was inconsistent with the list API.</p> </div> </details>
</dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Accept.quality">
<code>quality(key)</code> </dt> <dd>
<p>Returns the quality of the key.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.6: </span>In previous versions you had to use the item-lookup syntax (eg: <code>obj[key]</code> instead of <code>obj.quality(key)</code>)</p> </div> </details>
</dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Accept.to_header">
<code>to_header()</code> </dt> <dd>
<p>Convert the header set into an HTTP header string.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Accept.values">
<code>values()</code> </dt> <dd>
<p>Iterate over all values.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.MIMEAccept">
<code>class werkzeug.datastructures.MIMEAccept(values=())</code> </dt> <dd>
<p>Like <a class="reference internal" href="#werkzeug.datastructures.Accept" title="werkzeug.datastructures.Accept"><code>Accept</code></a> but with special methods and behavior for mimetypes.</p> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.MIMEAccept.accept_html">
<code>property accept_html</code> </dt> <dd>
<p>True if this object accepts HTML.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.MIMEAccept.accept_json">
<code>property accept_json</code> </dt> <dd>
<p>True if this object accepts JSON.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.MIMEAccept.accept_xhtml">
<code>property accept_xhtml</code> </dt> <dd>
<p>True if this object accepts XHTML.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.CharsetAccept">
<code>class werkzeug.datastructures.CharsetAccept(values=())</code> </dt> <dd>
<p>Like <a class="reference internal" href="#werkzeug.datastructures.Accept" title="werkzeug.datastructures.Accept"><code>Accept</code></a> but with normalization for charsets.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.LanguageAccept">
<code>class werkzeug.datastructures.LanguageAccept(values=())</code> </dt> <dd>
<p>Like <a class="reference internal" href="#werkzeug.datastructures.Accept" title="werkzeug.datastructures.Accept"><code>Accept</code></a> but with normalization for language tags.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.RequestCacheControl">
<code>class werkzeug.datastructures.RequestCacheControl(values=(), on_update=None)</code> </dt> <dd>
<p>A cache control for requests. This is immutable and gives access to all the request-relevant cache control headers.</p> <p>To get a header of the <a class="reference internal" href="#werkzeug.datastructures.RequestCacheControl" title="werkzeug.datastructures.RequestCacheControl"><code>RequestCacheControl</code></a> object again you can convert the object into a string or call the <code>to_header()</code> method. If you plan to subclass it and add your own items have a look at the sourcecode for that class.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.5: </span>In previous versions a <code>CacheControl</code> class existed that was used both for request and response.</p> </div> </details><dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.datastructures.RequestCacheControl.no_cache">
<code>no_cache</code> </dt> <dd>
<p>accessor for ‘no-cache’</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.datastructures.RequestCacheControl.no_store">
<code>no_store</code> </dt> <dd>
<p>accessor for ‘no-store’</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.datastructures.RequestCacheControl.max_age">
<code>max_age</code> </dt> <dd>
<p>accessor for ‘max-age’</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.datastructures.RequestCacheControl.no_transform">
<code>no_transform</code> </dt> <dd>
<p>accessor for ‘no-transform’</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.RequestCacheControl.max_stale">
<code>property max_stale</code> </dt> <dd>
<p>accessor for ‘max-stale’</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.RequestCacheControl.min_fresh">
<code>property min_fresh</code> </dt> <dd>
<p>accessor for ‘min-fresh’</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.RequestCacheControl.only_if_cached">
<code>property only_if_cached</code> </dt> <dd>
<p>accessor for ‘only-if-cached’</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.ResponseCacheControl">
<code>class werkzeug.datastructures.ResponseCacheControl(values=(), on_update=None)</code> </dt> <dd>
<p>A cache control for responses. Unlike <a class="reference internal" href="#werkzeug.datastructures.RequestCacheControl" title="werkzeug.datastructures.RequestCacheControl"><code>RequestCacheControl</code></a> this is mutable and gives access to response-relevant cache control headers.</p> <p>To get a header of the <a class="reference internal" href="#werkzeug.datastructures.ResponseCacheControl" title="werkzeug.datastructures.ResponseCacheControl"><code>ResponseCacheControl</code></a> object again you can convert the object into a string or call the <code>to_header()</code> method. If you plan to subclass it and add your own items have a look at the sourcecode for that class.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.5: </span>In previous versions a <code>CacheControl</code> class existed that was used both for request and response.</p> </div> </details><dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.datastructures.ResponseCacheControl.no_cache">
<code>no_cache</code> </dt> <dd>
<p>accessor for ‘no-cache’</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.datastructures.ResponseCacheControl.no_store">
<code>no_store</code> </dt> <dd>
<p>accessor for ‘no-store’</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.datastructures.ResponseCacheControl.max_age">
<code>max_age</code> </dt> <dd>
<p>accessor for ‘max-age’</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.datastructures.ResponseCacheControl.no_transform">
<code>no_transform</code> </dt> <dd>
<p>accessor for ‘no-transform’</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.ResponseCacheControl.immutable">
<code>property immutable</code> </dt> <dd>
<p>accessor for ‘immutable’</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.ResponseCacheControl.must_revalidate">
<code>property must_revalidate</code> </dt> <dd>
<p>accessor for ‘must-revalidate’</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.ResponseCacheControl.private">
<code>property private</code> </dt> <dd>
<p>accessor for ‘private’</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.ResponseCacheControl.proxy_revalidate">
<code>property proxy_revalidate</code> </dt> <dd>
<p>accessor for ‘proxy-revalidate’</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.ResponseCacheControl.public">
<code>property public</code> </dt> <dd>
<p>accessor for ‘public’</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.ResponseCacheControl.s_maxage">
<code>property s_maxage</code> </dt> <dd>
<p>accessor for ‘s-maxage’</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.ETags">
<code>class werkzeug.datastructures.ETags(strong_etags=None, weak_etags=None, star_tag=False)</code> </dt> <dd>
<p>A set that can be used to check if one etag is present in a collection of etags.</p> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.ETags.as_set">
<code>as_set(include_weak=False)</code> </dt> <dd>
<p>Convert the <code>ETags</code> object into a python set. Per default all the weak etags are not part of this set.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.ETags.contains">
<code>contains(etag)</code> </dt> <dd>
<p>Check if an etag is part of the set ignoring weak tags. It is also possible to use the <code>in</code> operator.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.ETags.contains_raw">
<code>contains_raw(etag)</code> </dt> <dd>
<p>When passed a quoted tag it will check if this tag is part of the set. If the tag is weak it is checked against weak and strong tags, otherwise strong only.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.ETags.contains_weak">
<code>contains_weak(etag)</code> </dt> <dd>
<p>Check if an etag is part of the set including weak and strong tags.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.ETags.is_strong">
<code>is_strong(etag)</code> </dt> <dd>
<p>Check if an etag is strong.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.ETags.is_weak">
<code>is_weak(etag)</code> </dt> <dd>
<p>Check if an etag is weak.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.ETags.to_header">
<code>to_header()</code> </dt> <dd>
<p>Convert the etags set into a HTTP header string.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.Authorization">
<code>class werkzeug.datastructures.Authorization(auth_type, data=None)</code> </dt> <dd>
<p>Represents an <code>Authorization</code> header sent by the client.</p> <p>This is returned by <a class="reference internal" href="../http/index#werkzeug.http.parse_authorization_header" title="werkzeug.http.parse_authorization_header"><code>parse_authorization_header()</code></a>. It can be useful to create the object manually to pass to the test <a class="reference internal" href="../test/index#werkzeug.test.Client" title="werkzeug.test.Client"><code>Client</code></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.5: </span>This object became immutable.</p> </div> </details><dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.Authorization.cnonce">
<code>property cnonce</code> </dt> <dd>
<p>If the server sent a qop-header in the <code>WWW-Authenticate</code> header, the client has to provide this value for HTTP digest auth. See the RFC for more details.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.Authorization.nc">
<code>property nc</code> </dt> <dd>
<p>The nonce count value transmitted by clients if a qop-header is also transmitted. HTTP digest auth only.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.Authorization.nonce">
<code>property nonce</code> </dt> <dd>
<p>The nonce the server sent for digest auth, sent back by the client. A nonce should be unique for every 401 response for HTTP digest auth.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.Authorization.opaque">
<code>property opaque</code> </dt> <dd>
<p>The opaque header from the server returned unchanged by the client. It is recommended that this string be base64 or hexadecimal data. Digest auth only.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.Authorization.password">
<code>property password</code> </dt> <dd>
<p>When the authentication type is basic this is the password transmitted by the client, else <code>None</code>.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.Authorization.qop">
<code>property qop</code> </dt> <dd>
<p>Indicates what “quality of protection” the client has applied to the message for HTTP digest auth. Note that this is a single token, not a quoted list of alternatives as in WWW-Authenticate.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.Authorization.realm">
<code>property realm</code> </dt> <dd>
<p>This is the server realm sent back for HTTP digest auth.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.Authorization.response">
<code>property response</code> </dt> <dd>
<p>A string of 32 hex digits computed as defined in RFC 2617, which proves that the user knows a password. Digest auth only.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Authorization.to_header">
<code>to_header()</code> </dt> <dd>
<p>Convert to a string value for an <code>Authorization</code> header.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.0: </span>Added to support passing authorization to the test client.</p> </div> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.Authorization.uri">
<code>property uri</code> </dt> <dd>
<p>The URI from Request-URI of the Request-Line; duplicated because proxies are allowed to change the Request-Line in transit. HTTP digest auth only.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.Authorization.username">
<code>property username</code> </dt> <dd>
<p>The username transmitted. This is set for both basic and digest auth all the time.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.WWWAuthenticate">
<code>class werkzeug.datastructures.WWWAuthenticate(auth_type=None, values=None, on_update=None)</code> </dt> <dd>
<p>Provides simple access to <code>WWW-Authenticate</code> headers.</p> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.WWWAuthenticate.algorithm">
<code>property algorithm</code> </dt> <dd>
<p>A string indicating a pair of algorithms used to produce the digest and a checksum. If this is not present it is assumed to be “MD5”. If the algorithm is not understood, the challenge should be ignored (and a different one used, if there is more than one).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.WWWAuthenticate.auth_property">
<code>static auth_property(name, doc=None)</code> </dt> <dd>
<p>A static helper function for Authentication subclasses to add extra authentication system properties onto a class:</p> <pre data-language="python">class FooAuthenticate(WWWAuthenticate):
    special_realm = auth_property('special_realm')
</pre> <p>For more information have a look at the sourcecode to see how the regular properties (<a class="reference internal" href="#werkzeug.datastructures.WWWAuthenticate.realm" title="werkzeug.datastructures.WWWAuthenticate.realm"><code>realm</code></a> etc.) are implemented.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.WWWAuthenticate.domain">
<code>property domain</code> </dt> <dd>
<p>A list of URIs that define the protection space. If a URI is an absolute path, it is relative to the canonical root URL of the server being accessed.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.WWWAuthenticate.nonce">
<code>property nonce</code> </dt> <dd>
<p>A server-specified data string which should be uniquely generated each time a 401 response is made. It is recommended that this string be base64 or hexadecimal data.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.WWWAuthenticate.opaque">
<code>property opaque</code> </dt> <dd>
<p>A string of data, specified by the server, which should be returned by the client unchanged in the Authorization header of subsequent requests with URIs in the same protection space. It is recommended that this string be base64 or hexadecimal data.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.WWWAuthenticate.qop">
<code>property qop</code> </dt> <dd>
<p>A set of quality-of-privacy directives such as auth and auth-int.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.WWWAuthenticate.realm">
<code>property realm</code> </dt> <dd>
<p>A string to be displayed to users so they know which username and password to use. This string should contain at least the name of the host performing the authentication and might additionally indicate the collection of users who might have access.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.WWWAuthenticate.set_basic">
<code>set_basic(realm='authentication required')</code> </dt> <dd>
<p>Clear the auth info and enable basic auth.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.WWWAuthenticate.set_digest">
<code>set_digest(realm, nonce, qop=('auth'), opaque=None, algorithm=None, stale=False)</code> </dt> <dd>
<p>Clear the auth info and enable digest auth.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.WWWAuthenticate.stale">
<code>property stale</code> </dt> <dd>
<p>A flag, indicating that the previous request from the client was rejected because the nonce value was stale.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.WWWAuthenticate.to_header">
<code>to_header()</code> </dt> <dd>
<p>Convert the stored values into a WWW-Authenticate header.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.WWWAuthenticate.type">
<code>property type</code> </dt> <dd>
<p>The type of the auth mechanism. HTTP currently specifies <code>Basic</code> and <code>Digest</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.IfRange">
<code>class werkzeug.datastructures.IfRange(etag=None, date=None)</code> </dt> <dd>
<p>Very simple object that represents the <code>If-Range</code> header in parsed form. It will either have neither a etag or date or one of either but never both.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details><dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.datastructures.IfRange.date">
<code>date</code> </dt> <dd>
<p>The date in parsed format or <code>None</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.datastructures.IfRange.etag">
<code>etag</code> </dt> <dd>
<p>The etag parsed and unquoted. Ranges always operate on strong etags so the weakness information is not necessary.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.IfRange.to_header">
<code>to_header()</code> </dt> <dd>
<p>Converts the object back into an HTTP header.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.Range">
<code>class werkzeug.datastructures.Range(units, ranges)</code> </dt> <dd>
<p>Represents a <code>Range</code> header. All methods only support only bytes as the unit. Stores a list of ranges if given, but the methods only work if only one range is provided.</p> <dl class="field-list simple"> <dt class="field-odd">Raises</dt> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.9)"><strong>ValueError</strong></a> – If the ranges provided are invalid.</p> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.15: </span>The ranges passed in are validated.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details><dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Range.make_content_range">
<code>make_content_range(length)</code> </dt> <dd>
<p>Creates a <a class="reference internal" href="#werkzeug.datastructures.ContentRange" title="werkzeug.datastructures.ContentRange"><code>ContentRange</code></a> object from the current range and given content length.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Range.range_for_length">
<code>range_for_length(length)</code> </dt> <dd>
<p>If the range is for bytes, the length is not None and there is exactly one range and it is satisfiable it returns a <code>(start, stop)</code> tuple, otherwise <code>None</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.datastructures.Range.ranges">
<code>ranges</code> </dt> <dd>
<p>A list of <code>(begin, end)</code> tuples for the range header provided. The ranges are non-inclusive.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Range.to_content_range_header">
<code>to_content_range_header(length)</code> </dt> <dd>
<p>Converts the object into <code>Content-Range</code> HTTP header, based on given length</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.Range.to_header">
<code>to_header()</code> </dt> <dd>
<p>Converts the object back into an HTTP header.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.datastructures.Range.units">
<code>units</code> </dt> <dd>
<p>The units of this range. Usually “bytes”.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.ContentRange">
<code>class werkzeug.datastructures.ContentRange(units, start, stop, length=None, on_update=None)</code> </dt> <dd>
<p>Represents the content range header.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details><dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.ContentRange.length">
<code>property length</code> </dt> <dd>
<p>The length of the range or <code>None</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.ContentRange.set">
<code>set(start, stop, length=None, units='bytes')</code> </dt> <dd>
<p>Simple method to update the ranges.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.ContentRange.start">
<code>property start</code> </dt> <dd>
<p>The start point of the range or <code>None</code>.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.ContentRange.stop">
<code>property stop</code> </dt> <dd>
<p>The stop point of the range (non-inclusive) or <code>None</code>. Can only be <code>None</code> if also start is <code>None</code>.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.ContentRange.units">
<code>property units</code> </dt> <dd>
<p>The units to use, usually “bytes”</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.ContentRange.unset">
<code>unset()</code> </dt> <dd>
<p>Sets the units to <code>None</code> which indicates that the header should no longer be used.</p> </dd>
</dl> </dd>
</dl> </section> <section id="others"> <h2>Others</h2> <dl class="py class"> <dt class="sig sig-object py" id="werkzeug.datastructures.FileStorage">
<code>class werkzeug.datastructures.FileStorage(stream=None, filename=None, name=None, content_type=None, content_length=None, headers=None)</code> </dt> <dd>
<p>The <a class="reference internal" href="#werkzeug.datastructures.FileStorage" title="werkzeug.datastructures.FileStorage"><code>FileStorage</code></a> class is a thin wrapper over incoming files. It is used by the request object to represent uploaded files. All the attributes of the wrapper stream are proxied by the file storage so it’s possible to do <code>storage.read()</code> instead of the long form <code>storage.stream.read()</code>.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.datastructures.FileStorage.stream">
<code>stream</code> </dt> <dd>
<p>The input stream for the uploaded file. This usually points to an open temporary file.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.datastructures.FileStorage.filename">
<code>filename</code> </dt> <dd>
<p>The filename of the file on the client.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.datastructures.FileStorage.name">
<code>name</code> </dt> <dd>
<p>The name of the form field.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="werkzeug.datastructures.FileStorage.headers">
<code>headers</code> </dt> <dd>
<p>The multipart headers as <a class="reference internal" href="#werkzeug.datastructures.Headers" title="werkzeug.datastructures.Headers"><code>Headers</code></a> object. This usually contains irrelevant information but in combination with custom multipart requests the raw headers might be interesting.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.6.</span></p> </div> </details>
</dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.FileStorage.close">
<code>close()</code> </dt> <dd>
<p>Close the underlying file if possible.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.FileStorage.content_length">
<code>property content_length</code> </dt> <dd>
<p>The content-length sent in the header. Usually not available</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.FileStorage.content_type">
<code>property content_type</code> </dt> <dd>
<p>The content-type sent in the header. Usually not available</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.FileStorage.mimetype">
<code>property mimetype</code> </dt> <dd>
<p>Like <a class="reference internal" href="#werkzeug.datastructures.FileStorage.content_type" title="werkzeug.datastructures.FileStorage.content_type"><code>content_type</code></a>, but without parameters (eg, without charset, type etc.) and always lowercase. For example if the content type is <code>text/HTML; charset=utf-8</code> the mimetype would be <code>'text/html'</code>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="werkzeug.datastructures.FileStorage.mimetype_params">
<code>property mimetype_params</code> </dt> <dd>
<p>The mimetype parameters as dict. For example if the content type is <code>text/html; charset=utf-8</code> the params would be <code>{'charset': 'utf-8'}</code>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details>
</dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="werkzeug.datastructures.FileStorage.save">
<code>save(dst, buffer_size=16384)</code> </dt> <dd>
<p>Save the file to a destination path or file object. If the destination is a file object you have to close it yourself after the call. The buffer size is the number of bytes held in memory during the copy process. It defaults to 16KB.</p> <p>For secure file saving also have a look at <code>secure_filename()</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>dst</strong> – a filename, <a class="reference external" href="https://docs.python.org/3/library/os.html#os.PathLike" title="(in Python v3.9)"><code>os.PathLike</code></a>, or open file object to write to.</li> <li>
<strong>buffer_size</strong> – Passed as the <code>length</code> parameter of <a class="reference external" href="https://docs.python.org/3/library/shutil.html#shutil.copyfileobj" title="(in Python v3.9)"><code>shutil.copyfileobj()</code></a>.</li> </ul> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.0: </span>Supports <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#module-pathlib" title="(in Python v3.9)"><code>pathlib</code></a>.</p> </div> </details>
</dd>
</dl> </dd>
</dl> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2021 Pallets<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://werkzeug.palletsprojects.com/en/2.0.x/datastructures/" class="_attribution-link">https://werkzeug.palletsprojects.com/en/2.0.x/datastructures/</a>
  </p>
</div>
