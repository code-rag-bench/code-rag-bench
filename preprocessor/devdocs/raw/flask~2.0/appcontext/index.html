<h1>The Application Context</h1> <p>The application context keeps track of the application-level data during a request, CLI command, or other activity. Rather than passing the application around to each function, the <a class="reference internal" href="../api/index#flask.current_app" title="flask.current_app"><code>current_app</code></a> and <a class="reference internal" href="../api/index#flask.g" title="flask.g"><code>g</code></a> proxies are accessed instead.</p> <p>This is similar to the <a class="reference internal" href="../reqcontext/index"><span class="doc">The Request Context</span></a>, which keeps track of request-level data during a request. A corresponding application context is pushed when a request context is pushed.</p>  <h2 id="purpose-of-the-context">Purpose of the Context</h2> <p>The <a class="reference internal" href="../api/index#flask.Flask" title="flask.Flask"><code>Flask</code></a> application object has attributes, such as <a class="reference internal" href="../api/index#flask.Flask.config" title="flask.Flask.config"><code>config</code></a>, that are useful to access within views and <a class="reference internal" href="../cli/index"><span class="doc">CLI commands</span></a>. However, importing the <code>app</code> instance within the modules in your project is prone to circular import issues. When using the <a class="reference internal" href="../patterns/appfactories/index"><span class="doc">app factory pattern</span></a> or writing reusable <a class="reference internal" href="../blueprints/index"><span class="doc">blueprints</span></a> or <a class="reference internal" href="../extensions/index"><span class="doc">extensions</span></a> there won’t be an <code>app</code> instance to import at all.</p> <p>Flask solves this issue with the <em>application context</em>. Rather than referring to an <code>app</code> directly, you use the <a class="reference internal" href="../api/index#flask.current_app" title="flask.current_app"><code>current_app</code></a> proxy, which points to the application handling the current activity.</p> <p>Flask automatically <em>pushes</em> an application context when handling a request. View functions, error handlers, and other functions that run during a request will have access to <a class="reference internal" href="../api/index#flask.current_app" title="flask.current_app"><code>current_app</code></a>.</p> <p>Flask will also automatically push an app context when running CLI commands registered with <a class="reference internal" href="../api/index#flask.Flask.cli" title="flask.Flask.cli"><code>Flask.cli</code></a> using <code>@app.cli.command()</code>.</p>   <h2 id="lifetime-of-the-context">Lifetime of the Context</h2> <p>The application context is created and destroyed as necessary. When a Flask application begins handling a request, it pushes an application context and a <a class="reference internal" href="../reqcontext/index"><span class="doc">request context</span></a>. When the request ends it pops the request context then the application context. Typically, an application context will have the same lifetime as a request.</p> <p>See <a class="reference internal" href="../reqcontext/index"><span class="doc">The Request Context</span></a> for more information about how the contexts work and the full life cycle of a request.</p>   <h2 id="manually-push-a-context">Manually Push a Context</h2> <p>If you try to access <a class="reference internal" href="../api/index#flask.current_app" title="flask.current_app"><code>current_app</code></a>, or anything that uses it, outside an application context, you’ll get this error message:</p> <pre data-language="pytb">RuntimeError: Working outside of application context.

This typically means that you attempted to use functionality that
needed to interface with the current application object in some way.
To solve this, set up an application context with app.app_context().
</pre> <p>If you see that error while configuring your application, such as when initializing an extension, you can push a context manually since you have direct access to the <code>app</code>. Use <a class="reference internal" href="../api/index#flask.Flask.app_context" title="flask.Flask.app_context"><code>app_context()</code></a> in a <code>with</code> block, and everything that runs in the block will have access to <a class="reference internal" href="../api/index#flask.current_app" title="flask.current_app"><code>current_app</code></a>.</p> <pre data-language="python">def create_app():
    app = Flask(__name__)

    with app.app_context():
        init_db()

    return app
</pre> <p>If you see that error somewhere else in your code not related to configuring the application, it most likely indicates that you should move that code into a view function or CLI command.</p>   <h2 id="storing-data">Storing Data</h2> <p>The application context is a good place to store common data during a request or CLI command. Flask provides the <a class="reference internal" href="../api/index#flask.g" title="flask.g"><code>g object</code></a> for this purpose. It is a simple namespace object that has the same lifetime as an application context.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <code>g</code> name stands for “global”, but that is referring to the data being global <em>within a context</em>. The data on <code>g</code> is lost after the context ends, and it is not an appropriate place to store data between requests. Use the <a class="reference internal" href="../api/index#flask.session" title="flask.session"><code>session</code></a> or a database to store data across requests.</p> </div> <p>A common use for <a class="reference internal" href="../api/index#flask.g" title="flask.g"><code>g</code></a> is to manage resources during a request.</p> <ol class="arabic simple"> <li>
<code>get_X()</code> creates resource <code>X</code> if it does not exist, caching it as <code>g.X</code>.</li> <li>
<code>teardown_X()</code> closes or otherwise deallocates the resource if it exists. It is registered as a <a class="reference internal" href="../api/index#flask.Flask.teardown_appcontext" title="flask.Flask.teardown_appcontext"><code>teardown_appcontext()</code></a> handler.</li> </ol> <p>For example, you can manage a database connection using this pattern:</p> <pre data-language="python">from flask import g

def get_db():
    if 'db' not in g:
        g.db = connect_to_database()

    return g.db

@app.teardown_appcontext
def teardown_db(exception):
    db = g.pop('db', None)

    if db is not None:
        db.close()
</pre> <p>During a request, every call to <code>get_db()</code> will return the same connection, and it will be closed automatically at the end of the request.</p> <p>You can use <a class="reference external" href="https://werkzeug.palletsprojects.com/en/2.0.x/local/#werkzeug.local.LocalProxy" title="(in Werkzeug v2.0.x)"><code>LocalProxy</code></a> to make a new context local from <code>get_db()</code>:</p> <pre data-language="python">from werkzeug.local import LocalProxy
db = LocalProxy(get_db)
</pre> <p>Accessing <code>db</code> will call <code>get_db</code> internally, in the same way that <a class="reference internal" href="../api/index#flask.current_app" title="flask.current_app"><code>current_app</code></a> works.</p>  <p>If you’re writing an extension, <a class="reference internal" href="../api/index#flask.g" title="flask.g"><code>g</code></a> should be reserved for user code. You may store internal data on the context itself, but be sure to use a sufficiently unique name. The current context is accessed with <a class="reference internal" href="../api/index#flask._app_ctx_stack" title="flask._app_ctx_stack"><code>_app_ctx_stack.top</code></a>. For more information see <a class="reference internal" href="https://flask.palletsprojects.com/en/2.0.x/extensiondev/"><span class="doc">Flask Extension Development</span></a>.</p>   <h2 id="events-and-signals">Events and Signals</h2> <p>The application will call functions registered with <a class="reference internal" href="../api/index#flask.Flask.teardown_appcontext" title="flask.Flask.teardown_appcontext"><code>teardown_appcontext()</code></a> when the application context is popped.</p> <p>If <a class="reference internal" href="../api/index#flask.signals.signals_available" title="flask.signals.signals_available"><code>signals_available</code></a> is true, the following signals are sent: <a class="reference internal" href="../api/index#flask.appcontext_pushed" title="flask.appcontext_pushed"><code>appcontext_pushed</code></a>, <a class="reference internal" href="../api/index#flask.appcontext_tearing_down" title="flask.appcontext_tearing_down"><code>appcontext_tearing_down</code></a>, and <a class="reference internal" href="../api/index#flask.appcontext_popped" title="flask.appcontext_popped"><code>appcontext_popped</code></a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2021 Pallets<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://flask.palletsprojects.com/en/2.0.x/appcontext/" class="_attribution-link">https://flask.palletsprojects.com/en/2.0.x/appcontext/</a>
  </p>
</div>
