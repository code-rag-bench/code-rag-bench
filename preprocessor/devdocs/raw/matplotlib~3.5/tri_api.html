<h1 id="matplotlib-tri">matplotlib.tri</h1> <p>Unstructured triangular grid functions.</p> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.tri.Triangulation"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.tri.</span><span class="sig-name descname">Triangulation</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">triangles</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mask</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/triangulation.py#L4-L220"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>An unstructured triangular grid consisting of npoints points and ntri triangles. The triangles can either be specified by the user or automatically generated using a Delaunay triangulation.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>x, y</strong><span class="classifier">(npoints,) array-like</span>
</dt>
<dd>
<p>Coordinates of grid points.</p> </dd> <dt>
<strong>triangles</strong><span class="classifier">(ntri, 3) array-like of int, optional</span>
</dt>
<dd>
<p>For each triangle, the indices of the three points that make up the triangle, ordered in an anticlockwise manner. If not specified, the Delaunay triangulation is calculated.</p> </dd> <dt>
<strong>mask</strong><span class="classifier">(ntri,) array-like of bool, optional</span>
</dt>
<dd>
<p>Which triangles are masked out.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>For a Triangulation to be valid it must not have duplicate points, triangles formed from colinear points, or overlapping triangles.</p> <dl class="field-list simple"> <dt class="field-odd">Attributes</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>triangles</strong><span class="classifier">(ntri, 3) array of int</span>
</dt>
<dd>
<p>For each triangle, the indices of the three points that make up the triangle, ordered in an anticlockwise manner. If you want to take the <em>mask</em> into account, use <a class="reference internal" href="#matplotlib.tri.Triangulation.get_masked_triangles" title="matplotlib.tri.Triangulation.get_masked_triangles"><code>get_masked_triangles</code></a> instead.</p> </dd> <dt>
<strong>mask</strong><span class="classifier">(ntri, 3) array of bool</span>
</dt>
<dd>
<p>Masked out triangles.</p> </dd> <dt>
<strong>is_delaunay</strong><span class="classifier">bool</span>
</dt>
<dd>
<p>Whether the Triangulation is a calculated Delaunay triangulation (where <em>triangles</em> was not specified) or not.</p> </dd> </dl> </dd> </dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.tri.Triangulation.calculate_plane_coefficients"> <span class="sig-name descname">calculate_plane_coefficients</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">z</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/triangulation.py#L79-L87"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculate plane equation coefficients for all unmasked triangles from the point (x, y) coordinates and specified z-array of shape (npoints). The returned array has shape (npoints, 3) and allows z-value at (x, y) position in triangle tri to be calculated using <code>z = array[tri, 0] * xÂ  + array[tri, 1] * y + array[tri, 2]</code>.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.tri.Triangulation.edges"> <em class="property">property</em><span class="sig-name descname">edges</span>
</dt> <dd>
<p>Return integer array of shape (nedges, 2) containing all edges of non-masked triangles.</p> <p>Each row defines an edge by it's start point index and end point index. Each edge appears only once, i.e. for an edge between points <em>i</em> and <em>j</em>, there will only be either <em>(i, j)</em> or <em>(j, i)</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.tri.Triangulation.get_cpp_triangulation"> <span class="sig-name descname">get_cpp_triangulation</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/triangulation.py#L103-L113"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the underlying C++ Triangulation object, creating it if necessary.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.tri.Triangulation.get_from_args_and_kwargs"> <em class="property">static</em><span class="sig-name descname">get_from_args_and_kwargs</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/triangulation.py#L124-L165"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a Triangulation object from the args and kwargs, and the remaining args and kwargs with the consumed values removed.</p> <p>There are two alternatives: either the first argument is a Triangulation object, in which case it is returned, or the args and kwargs are sufficient to create a new Triangulation to return. In the latter case, see Triangulation.__init__ for the possible args and kwargs.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.tri.Triangulation.get_masked_triangles"> <span class="sig-name descname">get_masked_triangles</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/triangulation.py#L115-L122"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return an array of triangles that are not masked.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.tri.Triangulation.get_trifinder"> <span class="sig-name descname">get_trifinder</span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/triangulation.py#L167-L177"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the default <a class="reference internal" href="#matplotlib.tri.TriFinder" title="matplotlib.tri.TriFinder"><code>matplotlib.tri.TriFinder</code></a> of this triangulation, creating it if necessary. This allows the same TriFinder object to be easily shared.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.tri.Triangulation.neighbors"> <em class="property">property</em><span class="sig-name descname">neighbors</span>
</dt> <dd>
<p>Return integer array of shape (ntri, 3) containing neighbor triangles.</p> <p>For each triangle, the indices of the three triangles that share the same edges, or -1 if there is no such neighboring triangle. <code>neighbors[i, j]</code> is the triangle that is the neighbor to the edge from point index <code>triangles[i, j]</code> to point index <code>triangles[i, (j+1)%3]</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.tri.Triangulation.set_mask"> <span class="sig-name descname">set_mask</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">mask</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/triangulation.py#L194-L220"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set or clear the mask array.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>mask</strong><span class="classifier">None or bool array of length ntri</span>
</dt>
 </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.tri.TriContourSet"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.tri.</span><span class="sig-name descname">TriContourSet</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">ax</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/tricontour.py#L8-L81"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="contour_api#matplotlib.contour.ContourSet" title="matplotlib.contour.ContourSet"><code>matplotlib.contour.ContourSet</code></a></p> <p>Create and store a set of contour lines or filled regions for a triangular grid.</p> <p>This class is typically not instantiated directly by the user but by <a class="reference internal" href="_as_gen/matplotlib.axes.axes.tricontour#matplotlib.axes.Axes.tricontour" title="matplotlib.axes.Axes.tricontour"><code>tricontour</code></a> and <a class="reference internal" href="_as_gen/matplotlib.axes.axes.tricontourf#matplotlib.axes.Axes.tricontourf" title="matplotlib.axes.Axes.tricontourf"><code>tricontourf</code></a>.</p> <dl class="field-list"> <dt class="field-odd">Attributes</dt> <dd class="field-odd">
<dl> <dt>
<strong>ax</strong><span class="classifier"><a class="reference internal" href="axes_api#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code>Axes</code></a></span>
</dt>
<dd>
<p>The Axes object in which the contours are drawn.</p> </dd> <dt>
<strong>collections</strong><span class="classifier"><a class="reference internal" href="cbook_api#matplotlib.cbook.silent_list" title="matplotlib.cbook.silent_list"><code>silent_list</code></a> of <a class="reference internal" href="collections_api#matplotlib.collections.PathCollection" title="matplotlib.collections.PathCollection"><code>PathCollection</code></a>s</span>
</dt>
<dd>
<p>The <a class="reference internal" href="artist_api#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code>Artist</code></a>s representing the contour. This is a list of <a class="reference internal" href="collections_api#matplotlib.collections.PathCollection" title="matplotlib.collections.PathCollection"><code>PathCollection</code></a>s for both line and filled contours.</p> </dd> <dt>
<strong>levels</strong><span class="classifier">array</span>
</dt>
<dd>
<p>The values of the contour levels.</p> </dd> <dt>
<strong>layers</strong><span class="classifier">array</span>
</dt>
<dd>
<p>Same as levels for line contours; half-way between levels for filled contours. See <code>ContourSet._process_colors</code>.</p> </dd> </dl> </dd> </dl> <p>Draw triangular grid contour lines or filled regions, depending on whether keyword arg 'filled' is False (default) or True.</p> <p>The first argument of the initializer must be an axes object. The remaining arguments and keyword arguments are described in the docstring of <a class="reference internal" href="_as_gen/matplotlib.axes.axes.tricontour#matplotlib.axes.Axes.tricontour" title="matplotlib.axes.Axes.tricontour"><code>tricontour</code></a>.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.tri.TriFinder"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.tri.</span><span class="sig-name descname">TriFinder</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">triangulation</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/trifinder.py#L7-L21"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Abstract base class for classes used to find the triangles of a Triangulation in which (x, y) points lie.</p> <p>Rather than instantiate an object of a class derived from TriFinder, it is usually better to use the function <a class="reference internal" href="#matplotlib.tri.Triangulation.get_trifinder" title="matplotlib.tri.Triangulation.get_trifinder"><code>Triangulation.get_trifinder</code></a>.</p> <p>Derived classes implement __call__(x, y) where x and y are array-like point coordinates of the same shape.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.tri.TrapezoidMapTriFinder"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.tri.</span><span class="sig-name descname">TrapezoidMapTriFinder</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">triangulation</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/trifinder.py#L24-L93"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.tri.TriFinder" title="matplotlib.tri.trifinder.TriFinder"><code>matplotlib.tri.trifinder.TriFinder</code></a></p> <p><a class="reference internal" href="#matplotlib.tri.TriFinder" title="matplotlib.tri.TriFinder"><code>TriFinder</code></a> class implemented using the trapezoid map algorithm from the book "Computational Geometry, Algorithms and Applications", second edition, by M. de Berg, M. van Kreveld, M. Overmars and O. Schwarzkopf.</p> <p>The triangulation must be valid, i.e. it must not have duplicate points, triangles formed from colinear points, or overlapping triangles. The algorithm has some tolerance to triangles formed from colinear points, but this should not be relied upon.</p> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.tri.TriInterpolator"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.tri.</span><span class="sig-name descname">TriInterpolator</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">triangulation</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">trifinder</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/triinterpolate.py#L15-L229"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Abstract base class for classes used to interpolate on a triangular grid.</p> <p>Derived classes implement the following methods:</p> <ul class="simple"> <li>
<code>__call__(x, y)</code>, where x, y are array-like point coordinates of the same shape, and that returns a masked array of the same shape containing the interpolated z-values.</li> <li>
<code>gradient(x, y)</code>, where x, y are array-like point coordinates of the same shape, and that returns a list of 2 masked arrays of the same shape containing the 2 derivatives of the interpolator (derivatives of interpolated z values with respect to x and y).</li> </ul> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.tri.LinearTriInterpolator"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.tri.</span><span class="sig-name descname">LinearTriInterpolator</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">triangulation</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">trifinder</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/triinterpolate.py#L232-L284"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.tri.TriInterpolator" title="matplotlib.tri.triinterpolate.TriInterpolator"><code>matplotlib.tri.triinterpolate.TriInterpolator</code></a></p> <p>Linear interpolator on a triangular grid.</p> <p>Each triangle is represented by a plane so that an interpolated value at point (x, y) lies on the plane of the triangle containing (x, y). Interpolated values are therefore continuous across the triangulation, but their first derivatives are discontinuous at edges between triangles.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>triangulation</strong><span class="classifier"><a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code>Triangulation</code></a></span>
</dt>
<dd>
<p>The triangulation to interpolate over.</p> </dd> <dt>
<strong>z</strong><span class="classifier">(npoints,) array-like</span>
</dt>
<dd>
<p>Array of values, defined at grid points, to interpolate between.</p> </dd> <dt>
<strong>trifinder</strong><span class="classifier"><a class="reference internal" href="#matplotlib.tri.TriFinder" title="matplotlib.tri.TriFinder"><code>TriFinder</code></a>, optional</span>
</dt>
<dd>
<p>If this is not specified, the Triangulation's default TriFinder will be used by calling <a class="reference internal" href="#matplotlib.tri.Triangulation.get_trifinder" title="matplotlib.tri.Triangulation.get_trifinder"><code>Triangulation.get_trifinder</code></a>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Methods</h4> <table class="table">   <tr>
<td><p><strong>`__call__` (x, y)</strong></p></td> <td><p>(Returns interpolated values at (x, y) points.)</p></td> </tr> <tr>
<td><p><strong>`gradient` (x, y)</strong></p></td> <td><p>(Returns interpolated derivatives at (x, y) points.)</p></td> </tr>  </table> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.tri.LinearTriInterpolator.gradient"> <span class="sig-name descname">gradient</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/triinterpolate.py#L269-L271"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a list of 2 masked arrays containing interpolated derivatives at the specified (x, y) points.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>x, y</strong><span class="classifier">array-like</span>
</dt>
<dd>
<p>x and y coordinates of the same shape and any number of dimensions.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>dzdx, dzdy</strong><span class="classifier">np.ma.array</span>
</dt>
<dd>
<p>2 masked arrays of the same shape as <em>x</em> and <em>y</em>; values corresponding to (x, y) points outside of the triangulation are masked out. The first returned array contains the values of <span class="math notranslate nohighlight">\(\frac{\partial z}{\partial x}\)</span> and the second those of <span class="math notranslate nohighlight">\(\frac{\partial z}{\partial y}\)</span>.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.tri.CubicTriInterpolator"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.tri.</span><span class="sig-name descname">CubicTriInterpolator</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">triangulation</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">kind</span><span class="o">=</span><span class="default_value">'min_E'</span></em>, <em class="sig-param"><span class="n">trifinder</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dz</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/triinterpolate.py#L287-L576"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.tri.TriInterpolator" title="matplotlib.tri.triinterpolate.TriInterpolator"><code>matplotlib.tri.triinterpolate.TriInterpolator</code></a></p> <p>Cubic interpolator on a triangular grid.</p> <p>In one-dimension - on a segment - a cubic interpolating function is defined by the values of the function and its derivative at both ends. This is almost the same in 2D inside a triangle, except that the values of the function and its 2 derivatives have to be defined at each triangle node.</p> <p>The CubicTriInterpolator takes the value of the function at each node - provided by the user - and internally computes the value of the derivatives, resulting in a smooth interpolation. (As a special feature, the user can also impose the value of the derivatives at each node, but this is not supposed to be the common usage.)</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>triangulation</strong><span class="classifier"><a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code>Triangulation</code></a></span>
</dt>
<dd>
<p>The triangulation to interpolate over.</p> </dd> <dt>
<strong>z</strong><span class="classifier">(npoints,) array-like</span>
</dt>
<dd>
<p>Array of values, defined at grid points, to interpolate between.</p> </dd> <dt>
<strong>kind</strong><span class="classifier">{'min_E', 'geom', 'user'}, optional</span>
</dt>
<dd>
<p>Choice of the smoothing algorithm, in order to compute the interpolant derivatives (defaults to 'min_E'):</p> <ul class="simple"> <li>if 'min_E': (default) The derivatives at each node is computed to minimize a bending energy.</li> <li>if 'geom': The derivatives at each node is computed as a weighted average of relevant triangle normals. To be used for speed optimization (large grids).</li> <li>if 'user': The user provides the argument <em>dz</em>, no computation is hence needed.</li> </ul> </dd> <dt>
<strong>trifinder</strong><span class="classifier"><a class="reference internal" href="#matplotlib.tri.TriFinder" title="matplotlib.tri.TriFinder"><code>TriFinder</code></a>, optional</span>
</dt>
<dd>
<p>If not specified, the Triangulation's default TriFinder will be used by calling <a class="reference internal" href="#matplotlib.tri.Triangulation.get_trifinder" title="matplotlib.tri.Triangulation.get_trifinder"><code>Triangulation.get_trifinder</code></a>.</p> </dd> <dt>
<strong>dz</strong><span class="classifier">tuple of array-likes (dzdx, dzdy), optional</span>
</dt>
<dd>
<p>Used only if <em>kind</em> ='user'. In this case <em>dz</em> must be provided as (dzdx, dzdy) where dzdx, dzdy are arrays of the same shape as <em>z</em> and are the interpolant first derivatives at the <em>triangulation</em> points.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This note is a bit technical and details how the cubic interpolation is computed.</p> <p>The interpolation is based on a Clough-Tocher subdivision scheme of the <em>triangulation</em> mesh (to make it clearer, each triangle of the grid will be divided in 3 child-triangles, and on each child triangle the interpolated function is a cubic polynomial of the 2 coordinates). This technique originates from FEM (Finite Element Method) analysis; the element used is a reduced Hsieh-Clough-Tocher (HCT) element. Its shape functions are described in <a class="reference internal" href="#r0be0c58fd53f-1" id="id1">[1]</a>. The assembled function is guaranteed to be C1-smooth, i.e. it is continuous and its first derivatives are also continuous (this is easy to show inside the triangles but is also true when crossing the edges).</p> <p>In the default case (<em>kind</em> ='min_E'), the interpolant minimizes a curvature energy on the functional space generated by the HCT element shape functions - with imposed values but arbitrary derivatives at each node. The minimized functional is the integral of the so-called total curvature (implementation based on an algorithm from <a class="reference internal" href="#r0be0c58fd53f-2" id="id2">[2]</a> - PCG sparse solver):</p>  <div class="math notranslate nohighlight"> \[E(z) = \frac{1}{2} \int_{\Omega} \left( \left( \frac{\partial^2{z}}{\partial{x}^2} \right)^2 + \left( \frac{\partial^2{z}}{\partial{y}^2} \right)^2 + 2\left( \frac{\partial^2{z}}{\partial{y}\partial{x}} \right)^2 \right) dx\,dy\]</div>  <p>If the case <em>kind</em> ='geom' is chosen by the user, a simple geometric approximation is used (weighted average of the triangle normal vectors), which could improve speed on very large grids.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r0be0c58fd53f-1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt> <dd>
<p>Michel Bernadou, Kamal Hassan, "Basis functions for general Hsieh-Clough-Tocher triangles, complete or reduced.", International Journal for Numerical Methods in Engineering, 17(5):784 - 789. 2.01.</p> </dd> <dt class="label" id="r0be0c58fd53f-2"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt> <dd>
<p>C.T. Kelley, "Iterative Methods for Optimization".</p> </dd> </dl> <h4 class="rubric">Methods</h4> <table class="table">   <tr>
<td><p><strong>`__call__` (x, y)</strong></p></td> <td><p>(Returns interpolated values at (x, y) points.)</p></td> </tr> <tr>
<td><p><strong>`gradient` (x, y)</strong></p></td> <td><p>(Returns interpolated derivatives at (x, y) points.)</p></td> </tr>  </table> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.tri.CubicTriInterpolator.gradient"> <span class="sig-name descname">gradient</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/triinterpolate.py#L425-L427"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a list of 2 masked arrays containing interpolated derivatives at the specified (x, y) points.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>x, y</strong><span class="classifier">array-like</span>
</dt>
<dd>
<p>x and y coordinates of the same shape and any number of dimensions.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>dzdx, dzdy</strong><span class="classifier">np.ma.array</span>
</dt>
<dd>
<p>2 masked arrays of the same shape as <em>x</em> and <em>y</em>; values corresponding to (x, y) points outside of the triangulation are masked out. The first returned array contains the values of <span class="math notranslate nohighlight">\(\frac{\partial z}{\partial x}\)</span> and the second those of <span class="math notranslate nohighlight">\(\frac{\partial z}{\partial y}\)</span>.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.tri.TriRefiner"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.tri.</span><span class="sig-name descname">TriRefiner</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">triangulation</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/trirefine.py#L12-L44"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Abstract base class for classes implementing mesh refinement.</p> <p>A TriRefiner encapsulates a Triangulation object and provides tools for mesh refinement and interpolation.</p> <p>Derived classes must implement:</p> <ul> <li>
<p><code>refine_triangulation(return_tri_index=False, **kwargs)</code> , where the optional keyword arguments <em>kwargs</em> are defined in each TriRefiner concrete implementation, and which returns:</p> <ul class="simple"> <li>a refined triangulation,</li> <li>optionally (depending on <em>return_tri_index</em>), for each point of the refined triangulation: the index of the initial triangulation triangle to which it belongs.</li> </ul> </li> <li>
<p><code>refine_field(z, triinterpolator=None, **kwargs)</code>, where:</p> <ul class="simple"> <li>
<em>z</em> array of field values (to refine) defined at the base triangulation nodes,</li> <li>
<em>triinterpolator</em> is an optional <a class="reference internal" href="#matplotlib.tri.TriInterpolator" title="matplotlib.tri.TriInterpolator"><code>TriInterpolator</code></a>,</li> <li>the other optional keyword arguments <em>kwargs</em> are defined in each TriRefiner concrete implementation;</li> </ul> <p>and which returns (as a tuple) a refined triangular mesh and the interpolated values of the field at the refined triangulation nodes.</p> </li> </ul> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.tri.UniformTriRefiner"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.tri.</span><span class="sig-name descname">UniformTriRefiner</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">triangulation</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/trirefine.py#L47-L307"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference internal" href="#matplotlib.tri.TriRefiner" title="matplotlib.tri.trirefine.TriRefiner"><code>matplotlib.tri.trirefine.TriRefiner</code></a></p> <p>Uniform mesh refinement by recursive subdivisions.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>triangulation</strong><span class="classifier"><a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code>Triangulation</code></a></span>
</dt>
<dd>
<p>The encapsulated triangulation (to be refined)</p> </dd> </dl> </dd> </dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.tri.UniformTriRefiner.refine_field"> <span class="sig-name descname">refine_field</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">triinterpolator</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">subdiv</span><span class="o">=</span><span class="default_value">3</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/trirefine.py#L133-L169"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Refine a field defined on the encapsulated triangulation.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>z</strong><span class="classifier">(npoints,) array-like</span>
</dt>
<dd>
<p>Values of the field to refine, defined at the nodes of the encapsulated triangulation. (<code>n_points</code> is the number of points in the initial triangulation)</p> </dd> <dt>
<strong>triinterpolator</strong><span class="classifier"><a class="reference internal" href="#matplotlib.tri.TriInterpolator" title="matplotlib.tri.TriInterpolator"><code>TriInterpolator</code></a>, optional</span>
</dt>
<dd>
<p>Interpolator used for field interpolation. If not specified, a <a class="reference internal" href="#matplotlib.tri.CubicTriInterpolator" title="matplotlib.tri.CubicTriInterpolator"><code>CubicTriInterpolator</code></a> will be used.</p> </dd> <dt>
<strong>subdiv</strong><span class="classifier">int, default: 3</span>
</dt>
<dd>
<p>Recursion level for the subdivision. Each triangle is divided into <code>4**subdiv</code> child triangles.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<strong>refi_tri</strong><span class="classifier"><a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code>Triangulation</code></a></span>
</dt>
<dd>
<p>The returned refined triangulation.</p> </dd> <dt>
<strong>refi_z</strong><span class="classifier">1D array of length: <em>refi_tri</em> node count.</span>
</dt>
<dd>
<p>The returned interpolated field (at <em>refi_tri</em> nodes).</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.tri.UniformTriRefiner.refine_triangulation"> <span class="sig-name descname">refine_triangulation</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">return_tri_index</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">subdiv</span><span class="o">=</span><span class="default_value">3</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/trirefine.py#L64-L131"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute an uniformly refined triangulation <em>refi_triangulation</em> of the encapsulated <code>triangulation</code>.</p> <p>This function refines the encapsulated triangulation by splitting each father triangle into 4 child sub-triangles built on the edges midside nodes, recursing <em>subdiv</em> times. In the end, each triangle is hence divided into <code>4**subdiv</code> child triangles.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>return_tri_index</strong><span class="classifier">bool, default: False</span>
</dt>
<dd>
<p>Whether an index table indicating the father triangle index of each point is returned.</p> </dd> <dt>
<strong>subdiv</strong><span class="classifier">int, default: 3</span>
</dt>
<dd>
<p>Recursion level for the subdivision. Each triangle is divided into <code>4**subdiv</code> child triangles; hence, the default results in 64 refined subtriangles for each triangle of the initial triangulation.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<strong>refi_triangulation</strong><span class="classifier"><a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code>Triangulation</code></a></span>
</dt>
<dd>
<p>The refined triangulation.</p> </dd> <dt>
<strong>found_index</strong><span class="classifier">int array</span>
</dt>
<dd>
<p>Index of the initial triangulation containing triangle, for each point of <em>refi_triangulation</em>. Returned only if <em>return_tri_index</em> is set to True.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="matplotlib.tri.TriAnalyzer"> <em class="property">class</em><span class="sig-prename descclassname">matplotlib.tri.</span><span class="sig-name descname">TriAnalyzer</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">triangulation</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/tritools.py#L11-L263"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Define basic tools for triangular mesh analysis and improvement.</p> <p>A TriAnalyzer encapsulates a <a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code>Triangulation</code></a> object and provides basic tools for mesh analysis and mesh improvement.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>triangulation</strong><span class="classifier"><a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code>Triangulation</code></a></span>
</dt>
<dd>
<p>The encapsulated triangulation to analyze.</p> </dd> </dl> </dd> <dt class="field-even">Attributes</dt> <dd class="field-even">
<dl class="simple"> <dt><a class="reference internal" href="#matplotlib.tri.TriAnalyzer.scale_factors" title="matplotlib.tri.TriAnalyzer.scale_factors"><code>scale_factors</code></a></dt>
<dd>
<p>Factors to rescale the triangulation into a unit square.</p> </dd> </dl> </dd> </dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.tri.TriAnalyzer.circle_ratios"> <span class="sig-name descname">circle_ratios</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">rescale</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/tritools.py#L50-L115"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a measure of the triangulation triangles flatness.</p> <p>The ratio of the incircle radius over the circumcircle radius is a widely used indicator of a triangle flatness. It is always <code>&lt;= 0.5</code> and <code>== 0.5</code> only for equilateral triangles. Circle ratios below 0.01 denote very flat triangles.</p> <p>To avoid unduly low values due to a difference of scale between the 2 axis, the triangular mesh can first be rescaled to fit inside a unit square with <a class="reference internal" href="#matplotlib.tri.TriAnalyzer.scale_factors" title="matplotlib.tri.TriAnalyzer.scale_factors"><code>scale_factors</code></a> (Only if <em>rescale</em> is True, which is its default value).</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>rescale</strong><span class="classifier">bool, default: True</span>
</dt>
<dd>
<p>If True, internally rescale (based on <a class="reference internal" href="#matplotlib.tri.TriAnalyzer.scale_factors" title="matplotlib.tri.TriAnalyzer.scale_factors"><code>scale_factors</code></a>), so that the (unmasked) triangles fit exactly inside a unit square mesh.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>masked array</dt>
<dd>
<p>Ratio of the incircle radius over the circumcircle radius, for each 'rescaled' triangle of the encapsulated triangulation. Values corresponding to masked triangles are masked out.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="matplotlib.tri.TriAnalyzer.get_flat_tri_mask"> <span class="sig-name descname">get_flat_tri_mask</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">min_circle_ratio</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">rescale</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/v3.5.1/lib/matplotlib/tri/tritools.py#L117-L190"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Eliminate excessively flat border triangles from the triangulation.</p> <p>Returns a mask <em>new_mask</em> which allows to clean the encapsulated triangulation from its border-located flat triangles (according to their <a class="reference internal" href="#matplotlib.tri.TriAnalyzer.circle_ratios" title="matplotlib.tri.TriAnalyzer.circle_ratios"><code>circle_ratios()</code></a>). This mask is meant to be subsequently applied to the triangulation using <a class="reference internal" href="#matplotlib.tri.Triangulation.set_mask" title="matplotlib.tri.Triangulation.set_mask"><code>Triangulation.set_mask</code></a>. <em>new_mask</em> is an extension of the initial triangulation mask in the sense that an initially masked triangle will remain masked.</p> <p>The <em>new_mask</em> array is computed recursively; at each step flat triangles are removed only if they share a side with the current mesh border. Thus no new holes in the triangulated domain will be created.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>min_circle_ratio</strong><span class="classifier">float, default: 0.01</span>
</dt>
<dd>
<p>Border triangles with incircle/circumcircle radii ratio r/R will be removed if r/R &lt; <em>min_circle_ratio</em>.</p> </dd> <dt>
<strong>rescale</strong><span class="classifier">bool, default: True</span>
</dt>
<dd>
<p>If True, first, internally rescale (based on <a class="reference internal" href="#matplotlib.tri.TriAnalyzer.scale_factors" title="matplotlib.tri.TriAnalyzer.scale_factors"><code>scale_factors</code></a>) so that the (unmasked) triangles fit exactly inside a unit square mesh. This rescaling accounts for the difference of scale which might exist between the 2 axis.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>array of bool</dt>
<dd>
<p>Mask to apply to encapsulated triangulation. All the initially masked triangles remain masked in the <em>new_mask</em>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The rationale behind this function is that a Delaunay triangulation - of an unstructured set of points - sometimes contains almost flat triangles at its border, leading to artifacts in plots (especially for high-resolution contouring). Masked with computed <em>new_mask</em>, the encapsulated triangulation would contain no more unmasked border triangles with a circle ratio below <em>min_circle_ratio</em>, thus improving the mesh quality for subsequent plots or interpolation.</p> </dd>
</dl> <dl class="py property"> <dt class="sig sig-object py" id="matplotlib.tri.TriAnalyzer.scale_factors"> <em class="property">property</em><span class="sig-name descname">scale_factors</span>
</dt> <dd>
<p>Factors to rescale the triangulation into a unit square.</p> <dl class="field-list simple"> <dt class="field-odd">Returns</dt> <dd class="field-odd">
<dl class="simple"> <dt>(float, float)</dt>
<dd>
<p>Scaling factors (kx, ky) so that the triangulation <code>[triangulation.x * kx, triangulation.y * ky]</code> fits exactly inside a unit square.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2021 Matplotlib Development Team. All rights reserved.<br>Licensed under the Matplotlib License Agreement.<br>
    <a href="https://matplotlib.org/3.5.1/api/tri_api.html" class="_attribution-link">https://matplotlib.org/3.5.1/api/tri_api.html</a>
  </p>
</div>
