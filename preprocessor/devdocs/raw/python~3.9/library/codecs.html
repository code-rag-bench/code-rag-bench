<h1 id="codecs-codec-registry-and-base-classes">codecs — Codec registry and base classes</h1> <p id="module-codecs"><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/codecs.py">Lib/codecs.py</a></p>  <p>This module defines base classes for standard Python codecs (encoders and decoders) and provides access to the internal Python codec registry, which manages the codec and error handling lookup process. Most standard codecs are <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a>, which encode text to bytes, but there are also codecs provided that encode text to text, and bytes to bytes. Custom codecs may encode and decode between arbitrary types, but some module features are restricted to use specifically with <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a>, or with codecs that encode to <a class="reference internal" href="stdtypes#bytes" title="bytes"><code>bytes</code></a>.</p> <p>The module defines the following functions for encoding and decoding with any codec:</p> <dl class="function"> <dt id="codecs.encode">
<code>codecs.encode(obj, encoding='utf-8', errors='strict')</code> </dt> <dd>
<p>Encodes <em>obj</em> using the codec registered for <em>encoding</em>.</p> <p><em>Errors</em> may be given to set the desired error handling scheme. The default error handler is <code>'strict'</code> meaning that encoding errors raise <a class="reference internal" href="exceptions#ValueError" title="ValueError"><code>ValueError</code></a> (or a more codec specific subclass, such as <a class="reference internal" href="exceptions#UnicodeEncodeError" title="UnicodeEncodeError"><code>UnicodeEncodeError</code></a>). Refer to <a class="reference internal" href="#codec-base-classes"><span class="std std-ref">Codec Base Classes</span></a> for more information on codec error handling.</p> </dd>
</dl> <dl class="function"> <dt id="codecs.decode">
<code>codecs.decode(obj, encoding='utf-8', errors='strict')</code> </dt> <dd>
<p>Decodes <em>obj</em> using the codec registered for <em>encoding</em>.</p> <p><em>Errors</em> may be given to set the desired error handling scheme. The default error handler is <code>'strict'</code> meaning that decoding errors raise <a class="reference internal" href="exceptions#ValueError" title="ValueError"><code>ValueError</code></a> (or a more codec specific subclass, such as <a class="reference internal" href="exceptions#UnicodeDecodeError" title="UnicodeDecodeError"><code>UnicodeDecodeError</code></a>). Refer to <a class="reference internal" href="#codec-base-classes"><span class="std std-ref">Codec Base Classes</span></a> for more information on codec error handling.</p> </dd>
</dl> <p>The full details for each codec can also be looked up directly:</p> <dl class="function"> <dt id="codecs.lookup">
<code>codecs.lookup(encoding)</code> </dt> <dd>
<p>Looks up the codec info in the Python codec registry and returns a <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code>CodecInfo</code></a> object as defined below.</p> <p>Encodings are first looked up in the registry’s cache. If not found, the list of registered search functions is scanned. If no <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code>CodecInfo</code></a> object is found, a <a class="reference internal" href="exceptions#LookupError" title="LookupError"><code>LookupError</code></a> is raised. Otherwise, the <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code>CodecInfo</code></a> object is stored in the cache and returned to the caller.</p> </dd>
</dl> <dl class="class"> <dt id="codecs.CodecInfo">
<code>class codecs.CodecInfo(encode, decode, streamreader=None, streamwriter=None, incrementalencoder=None, incrementaldecoder=None, name=None)</code> </dt> <dd>
<p>Codec details when looking up the codec registry. The constructor arguments are stored in attributes of the same name:</p> <dl class="attribute"> <dt id="codecs.CodecInfo.name">
<code>name</code> </dt> <dd>
<p>The name of the encoding.</p> </dd>
</dl> <dl class="attribute"> <dt id="codecs.CodecInfo.encode">
<code>encode</code> </dt> <dt id="codecs.CodecInfo.decode">
<code>decode</code> </dt> <dd>
<p>The stateless encoding and decoding functions. These must be functions or methods which have the same interface as the <a class="reference internal" href="#codecs.Codec.encode" title="codecs.Codec.encode"><code>encode()</code></a> and <a class="reference internal" href="#codecs.Codec.decode" title="codecs.Codec.decode"><code>decode()</code></a> methods of Codec instances (see <a class="reference internal" href="#codec-objects"><span class="std std-ref">Codec Interface</span></a>). The functions or methods are expected to work in a stateless mode.</p> </dd>
</dl> <dl class="attribute"> <dt id="codecs.CodecInfo.incrementalencoder">
<code>incrementalencoder</code> </dt> <dt id="codecs.CodecInfo.incrementaldecoder">
<code>incrementaldecoder</code> </dt> <dd>
<p>Incremental encoder and decoder classes or factory functions. These have to provide the interface defined by the base classes <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code>IncrementalEncoder</code></a> and <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code>IncrementalDecoder</code></a>, respectively. Incremental codecs can maintain state.</p> </dd>
</dl> <dl class="attribute"> <dt id="codecs.CodecInfo.streamwriter">
<code>streamwriter</code> </dt> <dt id="codecs.CodecInfo.streamreader">
<code>streamreader</code> </dt> <dd>
<p>Stream writer and reader classes or factory functions. These have to provide the interface defined by the base classes <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code>StreamWriter</code></a> and <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code>StreamReader</code></a>, respectively. Stream codecs can maintain state.</p> </dd>
</dl> </dd>
</dl> <p>To simplify access to the various codec components, the module provides these additional functions which use <a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code>lookup()</code></a> for the codec lookup:</p> <dl class="function"> <dt id="codecs.getencoder">
<code>codecs.getencoder(encoding)</code> </dt> <dd>
<p>Look up the codec for the given encoding and return its encoder function.</p> <p>Raises a <a class="reference internal" href="exceptions#LookupError" title="LookupError"><code>LookupError</code></a> in case the encoding cannot be found.</p> </dd>
</dl> <dl class="function"> <dt id="codecs.getdecoder">
<code>codecs.getdecoder(encoding)</code> </dt> <dd>
<p>Look up the codec for the given encoding and return its decoder function.</p> <p>Raises a <a class="reference internal" href="exceptions#LookupError" title="LookupError"><code>LookupError</code></a> in case the encoding cannot be found.</p> </dd>
</dl> <dl class="function"> <dt id="codecs.getincrementalencoder">
<code>codecs.getincrementalencoder(encoding)</code> </dt> <dd>
<p>Look up the codec for the given encoding and return its incremental encoder class or factory function.</p> <p>Raises a <a class="reference internal" href="exceptions#LookupError" title="LookupError"><code>LookupError</code></a> in case the encoding cannot be found or the codec doesn’t support an incremental encoder.</p> </dd>
</dl> <dl class="function"> <dt id="codecs.getincrementaldecoder">
<code>codecs.getincrementaldecoder(encoding)</code> </dt> <dd>
<p>Look up the codec for the given encoding and return its incremental decoder class or factory function.</p> <p>Raises a <a class="reference internal" href="exceptions#LookupError" title="LookupError"><code>LookupError</code></a> in case the encoding cannot be found or the codec doesn’t support an incremental decoder.</p> </dd>
</dl> <dl class="function"> <dt id="codecs.getreader">
<code>codecs.getreader(encoding)</code> </dt> <dd>
<p>Look up the codec for the given encoding and return its <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code>StreamReader</code></a> class or factory function.</p> <p>Raises a <a class="reference internal" href="exceptions#LookupError" title="LookupError"><code>LookupError</code></a> in case the encoding cannot be found.</p> </dd>
</dl> <dl class="function"> <dt id="codecs.getwriter">
<code>codecs.getwriter(encoding)</code> </dt> <dd>
<p>Look up the codec for the given encoding and return its <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code>StreamWriter</code></a> class or factory function.</p> <p>Raises a <a class="reference internal" href="exceptions#LookupError" title="LookupError"><code>LookupError</code></a> in case the encoding cannot be found.</p> </dd>
</dl> <p>Custom codecs are made available by registering a suitable codec search function:</p> <dl class="function"> <dt id="codecs.register">
<code>codecs.register(search_function)</code> </dt> <dd>
<p>Register a codec search function. Search functions are expected to take one argument, being the encoding name in all lower case letters with hyphens and spaces converted to underscores, and return a <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code>CodecInfo</code></a> object. In case a search function cannot find a given encoding, it should return <code>None</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.9: </span>Hyphens and spaces are converted to underscore.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Search function registration is not currently reversible, which may cause problems in some cases, such as unit testing or module reloading.</p> </div> </dd>
</dl> <p>While the builtin <a class="reference internal" href="functions#open" title="open"><code>open()</code></a> and the associated <a class="reference internal" href="io#module-io" title="io: Core tools for working with streams."><code>io</code></a> module are the recommended approach for working with encoded text files, this module provides additional utility functions and classes that allow the use of a wider range of codecs when working with binary files:</p> <dl class="function"> <dt id="codecs.open">
<code>codecs.open(filename, mode='r', encoding=None, errors='strict', buffering=-1)</code> </dt> <dd>
<p>Open an encoded file using the given <em>mode</em> and return an instance of <a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code>StreamReaderWriter</code></a>, providing transparent encoding/decoding. The default file mode is <code>'r'</code>, meaning to open the file in read mode.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Underlying encoded files are always opened in binary mode. No automatic conversion of <code>'\n'</code> is done on reading and writing. The <em>mode</em> argument may be any binary mode acceptable to the built-in <a class="reference internal" href="functions#open" title="open"><code>open()</code></a> function; the <code>'b'</code> is automatically added.</p> </div> <p><em>encoding</em> specifies the encoding which is to be used for the file. Any encoding that encodes to and decodes from bytes is allowed, and the data types supported by the file methods depend on the codec used.</p> <p><em>errors</em> may be given to define the error handling. It defaults to <code>'strict'</code> which causes a <a class="reference internal" href="exceptions#ValueError" title="ValueError"><code>ValueError</code></a> to be raised in case an encoding error occurs.</p> <p><em>buffering</em> has the same meaning as for the built-in <a class="reference internal" href="functions#open" title="open"><code>open()</code></a> function. It defaults to -1 which means that the default buffer size will be used.</p> </dd>
</dl> <dl class="function"> <dt id="codecs.EncodedFile">
<code>codecs.EncodedFile(file, data_encoding, file_encoding=None, errors='strict')</code> </dt> <dd>
<p>Return a <a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code>StreamRecoder</code></a> instance, a wrapped version of <em>file</em> which provides transparent transcoding. The original file is closed when the wrapped version is closed.</p> <p>Data written to the wrapped file is decoded according to the given <em>data_encoding</em> and then written to the original file as bytes using <em>file_encoding</em>. Bytes read from the original file are decoded according to <em>file_encoding</em>, and the result is encoded using <em>data_encoding</em>.</p> <p>If <em>file_encoding</em> is not given, it defaults to <em>data_encoding</em>.</p> <p><em>errors</em> may be given to define the error handling. It defaults to <code>'strict'</code>, which causes <a class="reference internal" href="exceptions#ValueError" title="ValueError"><code>ValueError</code></a> to be raised in case an encoding error occurs.</p> </dd>
</dl> <dl class="function"> <dt id="codecs.iterencode">
<code>codecs.iterencode(iterator, encoding, errors='strict', **kwargs)</code> </dt> <dd>
<p>Uses an incremental encoder to iteratively encode the input provided by <em>iterator</em>. This function is a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-generator"><span class="xref std std-term">generator</span></a>. The <em>errors</em> argument (as well as any other keyword argument) is passed through to the incremental encoder.</p> <p>This function requires that the codec accept text <a class="reference internal" href="stdtypes#str" title="str"><code>str</code></a> objects to encode. Therefore it does not support bytes-to-bytes encoders such as <code>base64_codec</code>.</p> </dd>
</dl> <dl class="function"> <dt id="codecs.iterdecode">
<code>codecs.iterdecode(iterator, encoding, errors='strict', **kwargs)</code> </dt> <dd>
<p>Uses an incremental decoder to iteratively decode the input provided by <em>iterator</em>. This function is a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-generator"><span class="xref std std-term">generator</span></a>. The <em>errors</em> argument (as well as any other keyword argument) is passed through to the incremental decoder.</p> <p>This function requires that the codec accept <a class="reference internal" href="stdtypes#bytes" title="bytes"><code>bytes</code></a> objects to decode. Therefore it does not support text-to-text encoders such as <code>rot_13</code>, although <code>rot_13</code> may be used equivalently with <a class="reference internal" href="#codecs.iterencode" title="codecs.iterencode"><code>iterencode()</code></a>.</p> </dd>
</dl> <p>The module also provides the following constants which are useful for reading and writing to platform dependent files:</p> <dl class="data"> <dt id="codecs.BOM">
<code>codecs.BOM</code> </dt> <dt id="codecs.BOM_BE">
<code>codecs.BOM_BE</code> </dt> <dt id="codecs.BOM_LE">
<code>codecs.BOM_LE</code> </dt> <dt id="codecs.BOM_UTF8">
<code>codecs.BOM_UTF8</code> </dt> <dt id="codecs.BOM_UTF16">
<code>codecs.BOM_UTF16</code> </dt> <dt id="codecs.BOM_UTF16_BE">
<code>codecs.BOM_UTF16_BE</code> </dt> <dt id="codecs.BOM_UTF16_LE">
<code>codecs.BOM_UTF16_LE</code> </dt> <dt id="codecs.BOM_UTF32">
<code>codecs.BOM_UTF32</code> </dt> <dt id="codecs.BOM_UTF32_BE">
<code>codecs.BOM_UTF32_BE</code> </dt> <dt id="codecs.BOM_UTF32_LE">
<code>codecs.BOM_UTF32_LE</code> </dt> <dd>
<p>These constants define various byte sequences, being Unicode byte order marks (BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams to indicate the byte order used, and in UTF-8 as a Unicode signature. <a class="reference internal" href="#codecs.BOM_UTF16" title="codecs.BOM_UTF16"><code>BOM_UTF16</code></a> is either <a class="reference internal" href="#codecs.BOM_UTF16_BE" title="codecs.BOM_UTF16_BE"><code>BOM_UTF16_BE</code></a> or <a class="reference internal" href="#codecs.BOM_UTF16_LE" title="codecs.BOM_UTF16_LE"><code>BOM_UTF16_LE</code></a> depending on the platform’s native byte order, <a class="reference internal" href="#codecs.BOM" title="codecs.BOM"><code>BOM</code></a> is an alias for <a class="reference internal" href="#codecs.BOM_UTF16" title="codecs.BOM_UTF16"><code>BOM_UTF16</code></a>, <a class="reference internal" href="#codecs.BOM_LE" title="codecs.BOM_LE"><code>BOM_LE</code></a> for <a class="reference internal" href="#codecs.BOM_UTF16_LE" title="codecs.BOM_UTF16_LE"><code>BOM_UTF16_LE</code></a> and <a class="reference internal" href="#codecs.BOM_BE" title="codecs.BOM_BE"><code>BOM_BE</code></a> for <a class="reference internal" href="#codecs.BOM_UTF16_BE" title="codecs.BOM_UTF16_BE"><code>BOM_UTF16_BE</code></a>. The others represent the BOM in UTF-8 and UTF-32 encodings.</p> </dd>
</dl>  <h2 id="id1">Codec Base Classes</h2> <p id="codec-base-classes">The <a class="reference internal" href="#module-codecs" title="codecs: Encode and decode data and streams."><code>codecs</code></a> module defines a set of base classes which define the interfaces for working with codec objects, and can also be used as the basis for custom codec implementations.</p> <p>Each codec has to define four interfaces to make it usable as codec in Python: stateless encoder, stateless decoder, stream reader and stream writer. The stream reader and writers typically reuse the stateless encoder/decoder to implement the file protocols. Codec authors also need to define how the codec will handle encoding and decoding errors.</p>  <h3 id="id2">Error Handlers</h3> <p id="error-handlers">To simplify and standardize error handling, codecs may implement different error handling schemes by accepting the <em>errors</em> string argument. The following string values are defined and implemented by all standard Python codecs:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Value</p></th> <th class="head"><p>Meaning</p></th> </tr> </thead>  <tr>
<td><p><code>'strict'</code></p></td> <td><p>Raise <a class="reference internal" href="exceptions#UnicodeError" title="UnicodeError"><code>UnicodeError</code></a> (or a subclass); this is the default. Implemented in <a class="reference internal" href="#codecs.strict_errors" title="codecs.strict_errors"><code>strict_errors()</code></a>.</p></td> </tr> <tr>
<td><p><code>'ignore'</code></p></td> <td><p>Ignore the malformed data and continue without further notice. Implemented in <a class="reference internal" href="#codecs.ignore_errors" title="codecs.ignore_errors"><code>ignore_errors()</code></a>.</p></td> </tr>  </table> <p>The following error handlers are only applicable to <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a>:</p> <table class="docutils align-default" id="index-1">  <thead> <tr>
<th class="head"><p>Value</p></th> <th class="head"><p>Meaning</p></th> </tr> </thead>  <tr>
<td><p><code>'replace'</code></p></td> <td><p>Replace with a suitable replacement marker; Python will use the official <code>U+FFFD</code> REPLACEMENT CHARACTER for the built-in codecs on decoding, and ‘?’ on encoding. Implemented in <a class="reference internal" href="#codecs.replace_errors" title="codecs.replace_errors"><code>replace_errors()</code></a>.</p></td> </tr> <tr>
<td><p><code>'xmlcharrefreplace'</code></p></td> <td><p>Replace with the appropriate XML character reference (only for encoding). Implemented in <a class="reference internal" href="#codecs.xmlcharrefreplace_errors" title="codecs.xmlcharrefreplace_errors"><code>xmlcharrefreplace_errors()</code></a>.</p></td> </tr> <tr>
<td><p><code>'backslashreplace'</code></p></td> <td><p>Replace with backslashed escape sequences. Implemented in <a class="reference internal" href="#codecs.backslashreplace_errors" title="codecs.backslashreplace_errors"><code>backslashreplace_errors()</code></a>.</p></td> </tr> <tr>
<td><p><code>'namereplace'</code></p></td> <td><p>Replace with <code>\N{...}</code> escape sequences (only for encoding). Implemented in <a class="reference internal" href="#codecs.namereplace_errors" title="codecs.namereplace_errors"><code>namereplace_errors()</code></a>.</p></td> </tr> <tr>
<td><p><code>'surrogateescape'</code></p></td> <td><p>On decoding, replace byte with individual surrogate code ranging from <code>U+DC80</code> to <code>U+DCFF</code>. This code will then be turned back into the same byte when the <code>'surrogateescape'</code> error handler is used when encoding the data. (See <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0383" id="index-2"><strong>PEP 383</strong></a> for more.)</p></td> </tr>  </table> <p>In addition, the following error handler is specific to the given codecs:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Value</p></th> <th class="head"><p>Codecs</p></th> <th class="head"><p>Meaning</p></th> </tr> </thead>  <tr>
<td><p><code>'surrogatepass'</code></p></td> <td><p>utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le</p></td> <td><p>Allow encoding and decoding of surrogate codes. These codecs normally treat the presence of surrogates as an error.</p></td> </tr>  </table> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.1: </span>The <code>'surrogateescape'</code> and <code>'surrogatepass'</code> error handlers.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>The <code>'surrogatepass'</code> error handlers now works with utf-16* and utf-32* codecs.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5: </span>The <code>'namereplace'</code> error handler.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>The <code>'backslashreplace'</code> error handlers now works with decoding and translating.</p> </div> <p>The set of allowed values can be extended by registering a new named error handler:</p> <dl class="function"> <dt id="codecs.register_error">
<code>codecs.register_error(name, error_handler)</code> </dt> <dd>
<p>Register the error handling function <em>error_handler</em> under the name <em>name</em>. The <em>error_handler</em> argument will be called during encoding and decoding in case of an error, when <em>name</em> is specified as the errors parameter.</p> <p>For encoding, <em>error_handler</em> will be called with a <a class="reference internal" href="exceptions#UnicodeEncodeError" title="UnicodeEncodeError"><code>UnicodeEncodeError</code></a> instance, which contains information about the location of the error. The error handler must either raise this or a different exception, or return a tuple with a replacement for the unencodable part of the input and a position where encoding should continue. The replacement may be either <a class="reference internal" href="stdtypes#str" title="str"><code>str</code></a> or <a class="reference internal" href="stdtypes#bytes" title="bytes"><code>bytes</code></a>. If the replacement is bytes, the encoder will simply copy them into the output buffer. If the replacement is a string, the encoder will encode the replacement. Encoding continues on original input at the specified position. Negative position values will be treated as being relative to the end of the input string. If the resulting position is out of bound an <a class="reference internal" href="exceptions#IndexError" title="IndexError"><code>IndexError</code></a> will be raised.</p> <p>Decoding and translating works similarly, except <a class="reference internal" href="exceptions#UnicodeDecodeError" title="UnicodeDecodeError"><code>UnicodeDecodeError</code></a> or <a class="reference internal" href="exceptions#UnicodeTranslateError" title="UnicodeTranslateError"><code>UnicodeTranslateError</code></a> will be passed to the handler and that the replacement from the error handler will be put into the output directly.</p> </dd>
</dl> <p>Previously registered error handlers (including the standard error handlers) can be looked up by name:</p> <dl class="function"> <dt id="codecs.lookup_error">
<code>codecs.lookup_error(name)</code> </dt> <dd>
<p>Return the error handler previously registered under the name <em>name</em>.</p> <p>Raises a <a class="reference internal" href="exceptions#LookupError" title="LookupError"><code>LookupError</code></a> in case the handler cannot be found.</p> </dd>
</dl> <p>The following standard error handlers are also made available as module level functions:</p> <dl class="function"> <dt id="codecs.strict_errors">
<code>codecs.strict_errors(exception)</code> </dt> <dd>
<p>Implements the <code>'strict'</code> error handling: each encoding or decoding error raises a <a class="reference internal" href="exceptions#UnicodeError" title="UnicodeError"><code>UnicodeError</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="codecs.replace_errors">
<code>codecs.replace_errors(exception)</code> </dt> <dd>
<p>Implements the <code>'replace'</code> error handling (for <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a> only): substitutes <code>'?'</code> for encoding errors (to be encoded by the codec), and <code>'\ufffd'</code> (the Unicode replacement character) for decoding errors.</p> </dd>
</dl> <dl class="function"> <dt id="codecs.ignore_errors">
<code>codecs.ignore_errors(exception)</code> </dt> <dd>
<p>Implements the <code>'ignore'</code> error handling: malformed data is ignored and encoding or decoding is continued without further notice.</p> </dd>
</dl> <dl class="function"> <dt id="codecs.xmlcharrefreplace_errors">
<code>codecs.xmlcharrefreplace_errors(exception)</code> </dt> <dd>
<p>Implements the <code>'xmlcharrefreplace'</code> error handling (for encoding with <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a> only): the unencodable character is replaced by an appropriate XML character reference.</p> </dd>
</dl> <dl class="function"> <dt id="codecs.backslashreplace_errors">
<code>codecs.backslashreplace_errors(exception)</code> </dt> <dd>
<p>Implements the <code>'backslashreplace'</code> error handling (for <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a> only): malformed data is replaced by a backslashed escape sequence.</p> </dd>
</dl> <dl class="function"> <dt id="codecs.namereplace_errors">
<code>codecs.namereplace_errors(exception)</code> </dt> <dd>
<p>Implements the <code>'namereplace'</code> error handling (for encoding with <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a> only): the unencodable character is replaced by a <code>\N{...}</code> escape sequence.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl>   <h3 id="codec-objects">Stateless Encoding and Decoding</h3> <p id="stateless-encoding-and-decoding">The base <code>Codec</code> class defines these methods which also define the function interfaces of the stateless encoder and decoder:</p> <dl class="method"> <dt id="codecs.Codec.encode">
<code>Codec.encode(input[, errors])</code> </dt> <dd>
<p>Encodes the object <em>input</em> and returns a tuple (output object, length consumed). For instance, <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-text-encoding"><span class="xref std std-term">text encoding</span></a> converts a string object to a bytes object using a particular character set encoding (e.g., <code>cp1252</code> or <code>iso-8859-1</code>).</p> <p>The <em>errors</em> argument defines the error handling to apply. It defaults to <code>'strict'</code> handling.</p> <p>The method may not store state in the <code>Codec</code> instance. Use <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code>StreamWriter</code></a> for codecs which have to keep state in order to make encoding efficient.</p> <p>The encoder must be able to handle zero length input and return an empty object of the output object type in this situation.</p> </dd>
</dl> <dl class="method"> <dt id="codecs.Codec.decode">
<code>Codec.decode(input[, errors])</code> </dt> <dd>
<p>Decodes the object <em>input</em> and returns a tuple (output object, length consumed). For instance, for a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-text-encoding"><span class="xref std std-term">text encoding</span></a>, decoding converts a bytes object encoded using a particular character set encoding to a string object.</p> <p>For text encodings and bytes-to-bytes codecs, <em>input</em> must be a bytes object or one which provides the read-only buffer interface – for example, buffer objects and memory mapped files.</p> <p>The <em>errors</em> argument defines the error handling to apply. It defaults to <code>'strict'</code> handling.</p> <p>The method may not store state in the <code>Codec</code> instance. Use <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code>StreamReader</code></a> for codecs which have to keep state in order to make decoding efficient.</p> <p>The decoder must be able to handle zero length input and return an empty object of the output object type in this situation.</p> </dd>
</dl>   <h3 id="incremental-encoding-and-decoding">Incremental Encoding and Decoding</h3> <p>The <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code>IncrementalEncoder</code></a> and <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code>IncrementalDecoder</code></a> classes provide the basic interface for incremental encoding and decoding. Encoding/decoding the input isn’t done with one call to the stateless encoder/decoder function, but with multiple calls to the <a class="reference internal" href="#codecs.IncrementalEncoder.encode" title="codecs.IncrementalEncoder.encode"><code>encode()</code></a>/<a class="reference internal" href="#codecs.IncrementalDecoder.decode" title="codecs.IncrementalDecoder.decode"><code>decode()</code></a> method of the incremental encoder/decoder. The incremental encoder/decoder keeps track of the encoding/decoding process during method calls.</p> <p>The joined output of calls to the <a class="reference internal" href="#codecs.IncrementalEncoder.encode" title="codecs.IncrementalEncoder.encode"><code>encode()</code></a>/<a class="reference internal" href="#codecs.IncrementalDecoder.decode" title="codecs.IncrementalDecoder.decode"><code>decode()</code></a> method is the same as if all the single inputs were joined into one, and this input was encoded/decoded with the stateless encoder/decoder.</p>  <h4 id="incremental-encoder-objects">IncrementalEncoder Objects</h4> <p id="incrementalencoder-objects">The <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code>IncrementalEncoder</code></a> class is used for encoding an input in multiple steps. It defines the following methods which every incremental encoder must define in order to be compatible with the Python codec registry.</p> <dl class="class"> <dt id="codecs.IncrementalEncoder">
<code>class codecs.IncrementalEncoder(errors='strict')</code> </dt> <dd>
<p>Constructor for an <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code>IncrementalEncoder</code></a> instance.</p> <p>All incremental encoders must provide this constructor interface. They are free to add additional keyword arguments, but only the ones defined here are used by the Python codec registry.</p> <p>The <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code>IncrementalEncoder</code></a> may implement different error handling schemes by providing the <em>errors</em> keyword argument. See <a class="reference internal" href="#error-handlers"><span class="std std-ref">Error Handlers</span></a> for possible values.</p> <p>The <em>errors</em> argument will be assigned to an attribute of the same name. Assigning to this attribute makes it possible to switch between different error handling strategies during the lifetime of the <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code>IncrementalEncoder</code></a> object.</p> <dl class="method"> <dt id="codecs.IncrementalEncoder.encode">
<code>encode(object[, final])</code> </dt> <dd>
<p>Encodes <em>object</em> (taking the current state of the encoder into account) and returns the resulting encoded object. If this is the last call to <a class="reference internal" href="#codecs.encode" title="codecs.encode"><code>encode()</code></a> <em>final</em> must be true (the default is false).</p> </dd>
</dl> <dl class="method"> <dt id="codecs.IncrementalEncoder.reset">
<code>reset()</code> </dt> <dd>
<p>Reset the encoder to the initial state. The output is discarded: call <code>.encode(object, final=True)</code>, passing an empty byte or text string if necessary, to reset the encoder and to get the output.</p> </dd>
</dl> <dl class="method"> <dt id="codecs.IncrementalEncoder.getstate">
<code>getstate()</code> </dt> <dd>
<p>Return the current state of the encoder which must be an integer. The implementation should make sure that <code>0</code> is the most common state. (States that are more complicated than integers can be converted into an integer by marshaling/pickling the state and encoding the bytes of the resulting string into an integer.)</p> </dd>
</dl> <dl class="method"> <dt id="codecs.IncrementalEncoder.setstate">
<code>setstate(state)</code> </dt> <dd>
<p>Set the state of the encoder to <em>state</em>. <em>state</em> must be an encoder state returned by <a class="reference internal" href="#codecs.IncrementalEncoder.getstate" title="codecs.IncrementalEncoder.getstate"><code>getstate()</code></a>.</p> </dd>
</dl> </dd>
</dl>   <h4 id="incremental-decoder-objects">IncrementalDecoder Objects</h4> <p id="incrementaldecoder-objects">The <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code>IncrementalDecoder</code></a> class is used for decoding an input in multiple steps. It defines the following methods which every incremental decoder must define in order to be compatible with the Python codec registry.</p> <dl class="class"> <dt id="codecs.IncrementalDecoder">
<code>class codecs.IncrementalDecoder(errors='strict')</code> </dt> <dd>
<p>Constructor for an <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code>IncrementalDecoder</code></a> instance.</p> <p>All incremental decoders must provide this constructor interface. They are free to add additional keyword arguments, but only the ones defined here are used by the Python codec registry.</p> <p>The <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code>IncrementalDecoder</code></a> may implement different error handling schemes by providing the <em>errors</em> keyword argument. See <a class="reference internal" href="#error-handlers"><span class="std std-ref">Error Handlers</span></a> for possible values.</p> <p>The <em>errors</em> argument will be assigned to an attribute of the same name. Assigning to this attribute makes it possible to switch between different error handling strategies during the lifetime of the <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code>IncrementalDecoder</code></a> object.</p> <dl class="method"> <dt id="codecs.IncrementalDecoder.decode">
<code>decode(object[, final])</code> </dt> <dd>
<p>Decodes <em>object</em> (taking the current state of the decoder into account) and returns the resulting decoded object. If this is the last call to <a class="reference internal" href="#codecs.decode" title="codecs.decode"><code>decode()</code></a> <em>final</em> must be true (the default is false). If <em>final</em> is true the decoder must decode the input completely and must flush all buffers. If this isn’t possible (e.g. because of incomplete byte sequences at the end of the input) it must initiate error handling just like in the stateless case (which might raise an exception).</p> </dd>
</dl> <dl class="method"> <dt id="codecs.IncrementalDecoder.reset">
<code>reset()</code> </dt> <dd>
<p>Reset the decoder to the initial state.</p> </dd>
</dl> <dl class="method"> <dt id="codecs.IncrementalDecoder.getstate">
<code>getstate()</code> </dt> <dd>
<p>Return the current state of the decoder. This must be a tuple with two items, the first must be the buffer containing the still undecoded input. The second must be an integer and can be additional state info. (The implementation should make sure that <code>0</code> is the most common additional state info.) If this additional state info is <code>0</code> it must be possible to set the decoder to the state which has no input buffered and <code>0</code> as the additional state info, so that feeding the previously buffered input to the decoder returns it to the previous state without producing any output. (Additional state info that is more complicated than integers can be converted into an integer by marshaling/pickling the info and encoding the bytes of the resulting string into an integer.)</p> </dd>
</dl> <dl class="method"> <dt id="codecs.IncrementalDecoder.setstate">
<code>setstate(state)</code> </dt> <dd>
<p>Set the state of the decoder to <em>state</em>. <em>state</em> must be a decoder state returned by <a class="reference internal" href="#codecs.IncrementalDecoder.getstate" title="codecs.IncrementalDecoder.getstate"><code>getstate()</code></a>.</p> </dd>
</dl> </dd>
</dl>    <h3 id="stream-encoding-and-decoding">Stream Encoding and Decoding</h3> <p>The <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code>StreamWriter</code></a> and <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code>StreamReader</code></a> classes provide generic working interfaces which can be used to implement new encoding submodules very easily. See <code>encodings.utf_8</code> for an example of how this is done.</p>  <h4 id="stream-writer-objects">StreamWriter Objects</h4> <p id="streamwriter-objects">The <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code>StreamWriter</code></a> class is a subclass of <code>Codec</code> and defines the following methods which every stream writer must define in order to be compatible with the Python codec registry.</p> <dl class="class"> <dt id="codecs.StreamWriter">
<code>class codecs.StreamWriter(stream, errors='strict')</code> </dt> <dd>
<p>Constructor for a <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code>StreamWriter</code></a> instance.</p> <p>All stream writers must provide this constructor interface. They are free to add additional keyword arguments, but only the ones defined here are used by the Python codec registry.</p> <p>The <em>stream</em> argument must be a file-like object open for writing text or binary data, as appropriate for the specific codec.</p> <p>The <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code>StreamWriter</code></a> may implement different error handling schemes by providing the <em>errors</em> keyword argument. See <a class="reference internal" href="#error-handlers"><span class="std std-ref">Error Handlers</span></a> for the standard error handlers the underlying stream codec may support.</p> <p>The <em>errors</em> argument will be assigned to an attribute of the same name. Assigning to this attribute makes it possible to switch between different error handling strategies during the lifetime of the <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code>StreamWriter</code></a> object.</p> <dl class="method"> <dt id="codecs.StreamWriter.write">
<code>write(object)</code> </dt> <dd>
<p>Writes the object’s contents encoded to the stream.</p> </dd>
</dl> <dl class="method"> <dt id="codecs.StreamWriter.writelines">
<code>writelines(list)</code> </dt> <dd>
<p>Writes the concatenated list of strings to the stream (possibly by reusing the <a class="reference internal" href="#codecs.StreamWriter.write" title="codecs.StreamWriter.write"><code>write()</code></a> method). The standard bytes-to-bytes codecs do not support this method.</p> </dd>
</dl> <dl class="method"> <dt id="codecs.StreamWriter.reset">
<code>reset()</code> </dt> <dd>
<p>Resets the codec buffers used for keeping internal state.</p> <p>Calling this method should ensure that the data on the output is put into a clean state that allows appending of new fresh data without having to rescan the whole stream to recover state.</p> </dd>
</dl> </dd>
</dl> <p>In addition to the above methods, the <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code>StreamWriter</code></a> must also inherit all other methods and attributes from the underlying stream.</p>   <h4 id="stream-reader-objects">StreamReader Objects</h4> <p id="streamreader-objects">The <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code>StreamReader</code></a> class is a subclass of <code>Codec</code> and defines the following methods which every stream reader must define in order to be compatible with the Python codec registry.</p> <dl class="class"> <dt id="codecs.StreamReader">
<code>class codecs.StreamReader(stream, errors='strict')</code> </dt> <dd>
<p>Constructor for a <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code>StreamReader</code></a> instance.</p> <p>All stream readers must provide this constructor interface. They are free to add additional keyword arguments, but only the ones defined here are used by the Python codec registry.</p> <p>The <em>stream</em> argument must be a file-like object open for reading text or binary data, as appropriate for the specific codec.</p> <p>The <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code>StreamReader</code></a> may implement different error handling schemes by providing the <em>errors</em> keyword argument. See <a class="reference internal" href="#error-handlers"><span class="std std-ref">Error Handlers</span></a> for the standard error handlers the underlying stream codec may support.</p> <p>The <em>errors</em> argument will be assigned to an attribute of the same name. Assigning to this attribute makes it possible to switch between different error handling strategies during the lifetime of the <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code>StreamReader</code></a> object.</p> <p>The set of allowed values for the <em>errors</em> argument can be extended with <a class="reference internal" href="#codecs.register_error" title="codecs.register_error"><code>register_error()</code></a>.</p> <dl class="method"> <dt id="codecs.StreamReader.read">
<code>read([size[, chars[, firstline]]])</code> </dt> <dd>
<p>Decodes data from the stream and returns the resulting object.</p> <p>The <em>chars</em> argument indicates the number of decoded code points or bytes to return. The <a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code>read()</code></a> method will never return more data than requested, but it might return less, if there is not enough available.</p> <p>The <em>size</em> argument indicates the approximate maximum number of encoded bytes or code points to read for decoding. The decoder can modify this setting as appropriate. The default value -1 indicates to read and decode as much as possible. This parameter is intended to prevent having to decode huge files in one step.</p> <p>The <em>firstline</em> flag indicates that it would be sufficient to only return the first line, if there are decoding errors on later lines.</p> <p>The method should use a greedy read strategy meaning that it should read as much data as is allowed within the definition of the encoding and the given size, e.g. if optional encoding endings or state markers are available on the stream, these should be read too.</p> </dd>
</dl> <dl class="method"> <dt id="codecs.StreamReader.readline">
<code>readline([size[, keepends]])</code> </dt> <dd>
<p>Read one line from the input stream and return the decoded data.</p> <p><em>size</em>, if given, is passed as size argument to the stream’s <a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code>read()</code></a> method.</p> <p>If <em>keepends</em> is false line-endings will be stripped from the lines returned.</p> </dd>
</dl> <dl class="method"> <dt id="codecs.StreamReader.readlines">
<code>readlines([sizehint[, keepends]])</code> </dt> <dd>
<p>Read all lines available on the input stream and return them as a list of lines.</p> <p>Line-endings are implemented using the codec’s <a class="reference internal" href="#codecs.decode" title="codecs.decode"><code>decode()</code></a> method and are included in the list entries if <em>keepends</em> is true.</p> <p><em>sizehint</em>, if given, is passed as the <em>size</em> argument to the stream’s <a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code>read()</code></a> method.</p> </dd>
</dl> <dl class="method"> <dt id="codecs.StreamReader.reset">
<code>reset()</code> </dt> <dd>
<p>Resets the codec buffers used for keeping internal state.</p> <p>Note that no stream repositioning should take place. This method is primarily intended to be able to recover from decoding errors.</p> </dd>
</dl> </dd>
</dl> <p>In addition to the above methods, the <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code>StreamReader</code></a> must also inherit all other methods and attributes from the underlying stream.</p>   <h4 id="stream-reader-writer">StreamReaderWriter Objects</h4> <p id="streamreaderwriter-objects">The <a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code>StreamReaderWriter</code></a> is a convenience class that allows wrapping streams which work in both read and write modes.</p> <p>The design is such that one can use the factory functions returned by the <a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code>lookup()</code></a> function to construct the instance.</p> <dl class="class"> <dt id="codecs.StreamReaderWriter">
<code>class codecs.StreamReaderWriter(stream, Reader, Writer, errors='strict')</code> </dt> <dd>
<p>Creates a <a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code>StreamReaderWriter</code></a> instance. <em>stream</em> must be a file-like object. <em>Reader</em> and <em>Writer</em> must be factory functions or classes providing the <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code>StreamReader</code></a> and <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code>StreamWriter</code></a> interface resp. Error handling is done in the same way as defined for the stream readers and writers.</p> </dd>
</dl> <p><a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code>StreamReaderWriter</code></a> instances define the combined interfaces of <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code>StreamReader</code></a> and <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code>StreamWriter</code></a> classes. They inherit all other methods and attributes from the underlying stream.</p>   <h4 id="stream-recoder-objects">StreamRecoder Objects</h4> <p id="streamrecoder-objects">The <a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code>StreamRecoder</code></a> translates data from one encoding to another, which is sometimes useful when dealing with different encoding environments.</p> <p>The design is such that one can use the factory functions returned by the <a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code>lookup()</code></a> function to construct the instance.</p> <dl class="class"> <dt id="codecs.StreamRecoder">
<code>class codecs.StreamRecoder(stream, encode, decode, Reader, Writer, errors='strict')</code> </dt> <dd>
<p>Creates a <a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code>StreamRecoder</code></a> instance which implements a two-way conversion: <em>encode</em> and <em>decode</em> work on the frontend — the data visible to code calling <code>read()</code> and <code>write()</code>, while <em>Reader</em> and <em>Writer</em> work on the backend — the data in <em>stream</em>.</p> <p>You can use these objects to do transparent transcodings, e.g., from Latin-1 to UTF-8 and back.</p> <p>The <em>stream</em> argument must be a file-like object.</p> <p>The <em>encode</em> and <em>decode</em> arguments must adhere to the <code>Codec</code> interface. <em>Reader</em> and <em>Writer</em> must be factory functions or classes providing objects of the <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code>StreamReader</code></a> and <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code>StreamWriter</code></a> interface respectively.</p> <p>Error handling is done in the same way as defined for the stream readers and writers.</p> </dd>
</dl> <p><a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code>StreamRecoder</code></a> instances define the combined interfaces of <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code>StreamReader</code></a> and <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code>StreamWriter</code></a> classes. They inherit all other methods and attributes from the underlying stream.</p>     <h2 id="encodings-overview">Encodings and Unicode</h2> <p id="encodings-and-unicode">Strings are stored internally as sequences of code points in range <code>0x0</code>–<code>0x10FFFF</code>. (See <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0393" id="index-3"><strong>PEP 393</strong></a> for more details about the implementation.) Once a string object is used outside of CPU and memory, endianness and how these arrays are stored as bytes become an issue. As with other codecs, serialising a string into a sequence of bytes is known as <em>encoding</em>, and recreating the string from the sequence of bytes is known as <em>decoding</em>. There are a variety of different text serialisation codecs, which are collectivity referred to as <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a>.</p> <p>The simplest text encoding (called <code>'latin-1'</code> or <code>'iso-8859-1'</code>) maps the code points 0–255 to the bytes <code>0x0</code>–<code>0xff</code>, which means that a string object that contains code points above <code>U+00FF</code> can’t be encoded with this codec. Doing so will raise a <a class="reference internal" href="exceptions#UnicodeEncodeError" title="UnicodeEncodeError"><code>UnicodeEncodeError</code></a> that looks like the following (although the details of the error message may differ): <code>UnicodeEncodeError: 'latin-1' codec can't encode character '\u1234' in
position 3: ordinal not in range(256)</code>.</p> <p>There’s another group of encodings (the so called charmap encodings) that choose a different subset of all Unicode code points and how these code points are mapped to the bytes <code>0x0</code>–<code>0xff</code>. To see how this is done simply open e.g. <code>encodings/cp1252.py</code> (which is an encoding that is used primarily on Windows). There’s a string constant with 256 characters that shows you which character is mapped to which byte value.</p> <p>All of these encodings can only encode 256 of the 1114112 code points defined in Unicode. A simple and straightforward way that can store each Unicode code point, is to store each code point as four consecutive bytes. There are two possibilities: store the bytes in big endian or in little endian order. These two encodings are called <code>UTF-32-BE</code> and <code>UTF-32-LE</code> respectively. Their disadvantage is that if e.g. you use <code>UTF-32-BE</code> on a little endian machine you will always have to swap bytes on encoding and decoding. <code>UTF-32</code> avoids this problem: bytes will always be in natural endianness. When these bytes are read by a CPU with a different endianness, then bytes have to be swapped though. To be able to detect the endianness of a <code>UTF-16</code> or <code>UTF-32</code> byte sequence, there’s the so called BOM (“Byte Order Mark”). This is the Unicode character <code>U+FEFF</code>. This character can be prepended to every <code>UTF-16</code> or <code>UTF-32</code> byte sequence. The byte swapped version of this character (<code>0xFFFE</code>) is an illegal character that may not appear in a Unicode text. So when the first character in an <code>UTF-16</code> or <code>UTF-32</code> byte sequence appears to be a <code>U+FFFE</code> the bytes have to be swapped on decoding. Unfortunately the character <code>U+FEFF</code> had a second purpose as a <code>ZERO WIDTH NO-BREAK SPACE</code>: a character that has no width and doesn’t allow a word to be split. It can e.g. be used to give hints to a ligature algorithm. With Unicode 4.0 using <code>U+FEFF</code> as a <code>ZERO WIDTH NO-BREAK SPACE</code> has been deprecated (with <code>U+2060</code> (<code>WORD JOINER</code>) assuming this role). Nevertheless Unicode software still must be able to handle <code>U+FEFF</code> in both roles: as a BOM it’s a device to determine the storage layout of the encoded bytes, and vanishes once the byte sequence has been decoded into a string; as a <code>ZERO WIDTH
NO-BREAK SPACE</code> it’s a normal character that will be decoded like any other.</p> <p>There’s another encoding that is able to encoding the full range of Unicode characters: UTF-8. UTF-8 is an 8-bit encoding, which means there are no issues with byte order in UTF-8. Each byte in a UTF-8 byte sequence consists of two parts: marker bits (the most significant bits) and payload bits. The marker bits are a sequence of zero to four <code>1</code> bits followed by a <code>0</code> bit. Unicode characters are encoded like this (with x being payload bits, which when concatenated give the Unicode character):</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Range</p></th> <th class="head"><p>Encoding</p></th> </tr> </thead>  <tr>
<td><p><code>U-00000000</code> … <code>U-0000007F</code></p></td> <td><p>0xxxxxxx</p></td> </tr> <tr>
<td><p><code>U-00000080</code> … <code>U-000007FF</code></p></td> <td><p>110xxxxx 10xxxxxx</p></td> </tr> <tr>
<td><p><code>U-00000800</code> … <code>U-0000FFFF</code></p></td> <td><p>1110xxxx 10xxxxxx 10xxxxxx</p></td> </tr> <tr>
<td><p><code>U-00010000</code> … <code>U-0010FFFF</code></p></td> <td><p>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p></td> </tr>  </table> <p>The least significant bit of the Unicode character is the rightmost x bit.</p> <p>As UTF-8 is an 8-bit encoding no BOM is required and any <code>U+FEFF</code> character in the decoded string (even if it’s the first character) is treated as a <code>ZERO
WIDTH NO-BREAK SPACE</code>.</p> <p>Without external information it’s impossible to reliably determine which encoding was used for encoding a string. Each charmap encoding can decode any random byte sequence. However that’s not possible with UTF-8, as UTF-8 byte sequences have a structure that doesn’t allow arbitrary byte sequences. To increase the reliability with which a UTF-8 encoding can be detected, Microsoft invented a variant of UTF-8 (that Python 2.5 calls <code>"utf-8-sig"</code>) for its Notepad program: Before any of the Unicode characters is written to the file, a UTF-8 encoded BOM (which looks like this as a byte sequence: <code>0xef</code>, <code>0xbb</code>, <code>0xbf</code>) is written. As it’s rather improbable that any charmap encoded file starts with these byte values (which would e.g. map to</p>    <p>in iso-8859-1), this increases the probability that a <code>utf-8-sig</code> encoding can be correctly guessed from the byte sequence. So here the BOM is not used to be able to determine the byte order used for generating the byte sequence, but as a signature that helps in guessing the encoding. On encoding the utf-8-sig codec will write <code>0xef</code>, <code>0xbb</code>, <code>0xbf</code> as the first three bytes to the file. On decoding <code>utf-8-sig</code> will skip those three bytes if they appear as the first three bytes in the file. In UTF-8, the use of the BOM is discouraged and should generally be avoided.</p>   <h2 id="id3">Standard Encodings</h2> <p id="standard-encodings">Python comes with a number of codecs built-in, either implemented as C functions or with dictionaries as mapping tables. The following table lists the codecs by name, together with a few common aliases, and the languages for which the encoding is likely used. Neither the list of aliases nor the list of languages is meant to be exhaustive. Notice that spelling alternatives that only differ in case or use a hyphen instead of an underscore are also valid aliases; therefore, e.g. <code>'utf-8'</code> is a valid alias for the <code>'utf_8'</code> codec.</p> <div class="impl-detail compound"> <p class="compound-first"><strong>CPython implementation detail:</strong> Some common encodings can bypass the codecs lookup machinery to improve performance. These optimization opportunities are only recognized by CPython for a limited set of (case insensitive) aliases: utf-8, utf8, latin-1, latin1, iso-8859-1, iso8859-1, mbcs (Windows only), ascii, us-ascii, utf-16, utf16, utf-32, utf32, and the same using underscores instead of dashes. Using alternative aliases for these encodings may result in slower execution.</p> <div class="compound-last versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Optimization opportunity recognized for us-ascii.</p> </div> </div> <p>Many of the character sets support the same languages. They vary in individual characters (e.g. whether the EURO SIGN is supported or not), and in the assignment of characters to code positions. For the European languages in particular, the following variants typically exist:</p> <ul class="simple"> <li>an ISO 8859 codeset</li> <li>a Microsoft Windows code page, which is typically derived from an 8859 codeset, but replaces control characters with additional graphic characters</li> <li>an IBM EBCDIC code page</li> <li>an IBM PC code page, which is ASCII compatible</li> </ul> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Codec</p></th> <th class="head"><p>Aliases</p></th> <th class="head"><p>Languages</p></th> </tr> </thead>  <tr>
<td><p>ascii</p></td> <td><p>646, us-ascii</p></td> <td><p>English</p></td> </tr> <tr>
<td><p>big5</p></td> <td><p>big5-tw, csbig5</p></td> <td><p>Traditional Chinese</p></td> </tr> <tr>
<td><p>big5hkscs</p></td> <td><p>big5-hkscs, hkscs</p></td> <td><p>Traditional Chinese</p></td> </tr> <tr>
<td><p>cp037</p></td> <td><p>IBM037, IBM039</p></td> <td><p>English</p></td> </tr> <tr>
<td><p>cp273</p></td> <td><p>273, IBM273, csIBM273</p></td> <td>
<p>German</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> </td> </tr> <tr>
<td><p>cp424</p></td> <td><p>EBCDIC-CP-HE, IBM424</p></td> <td><p>Hebrew</p></td> </tr> <tr>
<td><p>cp437</p></td> <td><p>437, IBM437</p></td> <td><p>English</p></td> </tr> <tr>
<td><p>cp500</p></td> <td><p>EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500</p></td> <td><p>Western Europe</p></td> </tr> <tr>
<td><p>cp720</p></td> <td></td> <td><p>Arabic</p></td> </tr> <tr>
<td><p>cp737</p></td> <td></td> <td><p>Greek</p></td> </tr> <tr>
<td><p>cp775</p></td> <td><p>IBM775</p></td> <td><p>Baltic languages</p></td> </tr> <tr>
<td><p>cp850</p></td> <td><p>850, IBM850</p></td> <td><p>Western Europe</p></td> </tr> <tr>
<td><p>cp852</p></td> <td><p>852, IBM852</p></td> <td><p>Central and Eastern Europe</p></td> </tr> <tr>
<td><p>cp855</p></td> <td><p>855, IBM855</p></td> <td><p>Bulgarian, Byelorussian, Macedonian, Russian, Serbian</p></td> </tr> <tr>
<td><p>cp856</p></td> <td></td> <td><p>Hebrew</p></td> </tr> <tr>
<td><p>cp857</p></td> <td><p>857, IBM857</p></td> <td><p>Turkish</p></td> </tr> <tr>
<td><p>cp858</p></td> <td><p>858, IBM858</p></td> <td><p>Western Europe</p></td> </tr> <tr>
<td><p>cp860</p></td> <td><p>860, IBM860</p></td> <td><p>Portuguese</p></td> </tr> <tr>
<td><p>cp861</p></td> <td><p>861, CP-IS, IBM861</p></td> <td><p>Icelandic</p></td> </tr> <tr>
<td><p>cp862</p></td> <td><p>862, IBM862</p></td> <td><p>Hebrew</p></td> </tr> <tr>
<td><p>cp863</p></td> <td><p>863, IBM863</p></td> <td><p>Canadian</p></td> </tr> <tr>
<td><p>cp864</p></td> <td><p>IBM864</p></td> <td><p>Arabic</p></td> </tr> <tr>
<td><p>cp865</p></td> <td><p>865, IBM865</p></td> <td><p>Danish, Norwegian</p></td> </tr> <tr>
<td><p>cp866</p></td> <td><p>866, IBM866</p></td> <td><p>Russian</p></td> </tr> <tr>
<td><p>cp869</p></td> <td><p>869, CP-GR, IBM869</p></td> <td><p>Greek</p></td> </tr> <tr>
<td><p>cp874</p></td> <td></td> <td><p>Thai</p></td> </tr> <tr>
<td><p>cp875</p></td> <td></td> <td><p>Greek</p></td> </tr> <tr>
<td><p>cp932</p></td> <td><p>932, ms932, mskanji, ms-kanji</p></td> <td><p>Japanese</p></td> </tr> <tr>
<td><p>cp949</p></td> <td><p>949, ms949, uhc</p></td> <td><p>Korean</p></td> </tr> <tr>
<td><p>cp950</p></td> <td><p>950, ms950</p></td> <td><p>Traditional Chinese</p></td> </tr> <tr>
<td><p>cp1006</p></td> <td></td> <td><p>Urdu</p></td> </tr> <tr>
<td><p>cp1026</p></td> <td><p>ibm1026</p></td> <td><p>Turkish</p></td> </tr> <tr>
<td><p>cp1125</p></td> <td><p>1125, ibm1125, cp866u, ruscii</p></td> <td>
<p>Ukrainian</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> </td> </tr> <tr>
<td><p>cp1140</p></td> <td><p>ibm1140</p></td> <td><p>Western Europe</p></td> </tr> <tr>
<td><p>cp1250</p></td> <td><p>windows-1250</p></td> <td><p>Central and Eastern Europe</p></td> </tr> <tr>
<td><p>cp1251</p></td> <td><p>windows-1251</p></td> <td><p>Bulgarian, Byelorussian, Macedonian, Russian, Serbian</p></td> </tr> <tr>
<td><p>cp1252</p></td> <td><p>windows-1252</p></td> <td><p>Western Europe</p></td> </tr> <tr>
<td><p>cp1253</p></td> <td><p>windows-1253</p></td> <td><p>Greek</p></td> </tr> <tr>
<td><p>cp1254</p></td> <td><p>windows-1254</p></td> <td><p>Turkish</p></td> </tr> <tr>
<td><p>cp1255</p></td> <td><p>windows-1255</p></td> <td><p>Hebrew</p></td> </tr> <tr>
<td><p>cp1256</p></td> <td><p>windows-1256</p></td> <td><p>Arabic</p></td> </tr> <tr>
<td><p>cp1257</p></td> <td><p>windows-1257</p></td> <td><p>Baltic languages</p></td> </tr> <tr>
<td><p>cp1258</p></td> <td><p>windows-1258</p></td> <td><p>Vietnamese</p></td> </tr> <tr>
<td><p>euc_jp</p></td> <td><p>eucjp, ujis, u-jis</p></td> <td><p>Japanese</p></td> </tr> <tr>
<td><p>euc_jis_2004</p></td> <td><p>jisx0213, eucjis2004</p></td> <td><p>Japanese</p></td> </tr> <tr>
<td><p>euc_jisx0213</p></td> <td><p>eucjisx0213</p></td> <td><p>Japanese</p></td> </tr> <tr>
<td><p>euc_kr</p></td> <td><p>euckr, korean, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001</p></td> <td><p>Korean</p></td> </tr> <tr>
<td><p>gb2312</p></td> <td><p>chinese, csiso58gb231280, euc-cn, euccn, eucgb2312-cn, gb2312-1980, gb2312-80, iso-ir-58</p></td> <td><p>Simplified Chinese</p></td> </tr> <tr>
<td><p>gbk</p></td> <td><p>936, cp936, ms936</p></td> <td><p>Unified Chinese</p></td> </tr> <tr>
<td><p>gb18030</p></td> <td><p>gb18030-2000</p></td> <td><p>Unified Chinese</p></td> </tr> <tr>
<td><p>hz</p></td> <td><p>hzgb, hz-gb, hz-gb-2312</p></td> <td><p>Simplified Chinese</p></td> </tr> <tr>
<td><p>iso2022_jp</p></td> <td><p>csiso2022jp, iso2022jp, iso-2022-jp</p></td> <td><p>Japanese</p></td> </tr> <tr>
<td><p>iso2022_jp_1</p></td> <td><p>iso2022jp-1, iso-2022-jp-1</p></td> <td><p>Japanese</p></td> </tr> <tr>
<td><p>iso2022_jp_2</p></td> <td><p>iso2022jp-2, iso-2022-jp-2</p></td> <td><p>Japanese, Korean, Simplified Chinese, Western Europe, Greek</p></td> </tr> <tr>
<td><p>iso2022_jp_2004</p></td> <td><p>iso2022jp-2004, iso-2022-jp-2004</p></td> <td><p>Japanese</p></td> </tr> <tr>
<td><p>iso2022_jp_3</p></td> <td><p>iso2022jp-3, iso-2022-jp-3</p></td> <td><p>Japanese</p></td> </tr> <tr>
<td><p>iso2022_jp_ext</p></td> <td><p>iso2022jp-ext, iso-2022-jp-ext</p></td> <td><p>Japanese</p></td> </tr> <tr>
<td><p>iso2022_kr</p></td> <td><p>csiso2022kr, iso2022kr, iso-2022-kr</p></td> <td><p>Korean</p></td> </tr> <tr>
<td><p>latin_1</p></td> <td><p>iso-8859-1, iso8859-1, 8859, cp819, latin, latin1, L1</p></td> <td><p>Western Europe</p></td> </tr> <tr>
<td><p>iso8859_2</p></td> <td><p>iso-8859-2, latin2, L2</p></td> <td><p>Central and Eastern Europe</p></td> </tr> <tr>
<td><p>iso8859_3</p></td> <td><p>iso-8859-3, latin3, L3</p></td> <td><p>Esperanto, Maltese</p></td> </tr> <tr>
<td><p>iso8859_4</p></td> <td><p>iso-8859-4, latin4, L4</p></td> <td><p>Baltic languages</p></td> </tr> <tr>
<td><p>iso8859_5</p></td> <td><p>iso-8859-5, cyrillic</p></td> <td><p>Bulgarian, Byelorussian, Macedonian, Russian, Serbian</p></td> </tr> <tr>
<td><p>iso8859_6</p></td> <td><p>iso-8859-6, arabic</p></td> <td><p>Arabic</p></td> </tr> <tr>
<td><p>iso8859_7</p></td> <td><p>iso-8859-7, greek, greek8</p></td> <td><p>Greek</p></td> </tr> <tr>
<td><p>iso8859_8</p></td> <td><p>iso-8859-8, hebrew</p></td> <td><p>Hebrew</p></td> </tr> <tr>
<td><p>iso8859_9</p></td> <td><p>iso-8859-9, latin5, L5</p></td> <td><p>Turkish</p></td> </tr> <tr>
<td><p>iso8859_10</p></td> <td><p>iso-8859-10, latin6, L6</p></td> <td><p>Nordic languages</p></td> </tr> <tr>
<td><p>iso8859_11</p></td> <td><p>iso-8859-11, thai</p></td> <td><p>Thai languages</p></td> </tr> <tr>
<td><p>iso8859_13</p></td> <td><p>iso-8859-13, latin7, L7</p></td> <td><p>Baltic languages</p></td> </tr> <tr>
<td><p>iso8859_14</p></td> <td><p>iso-8859-14, latin8, L8</p></td> <td><p>Celtic languages</p></td> </tr> <tr>
<td><p>iso8859_15</p></td> <td><p>iso-8859-15, latin9, L9</p></td> <td><p>Western Europe</p></td> </tr> <tr>
<td><p>iso8859_16</p></td> <td><p>iso-8859-16, latin10, L10</p></td> <td><p>South-Eastern Europe</p></td> </tr> <tr>
<td><p>johab</p></td> <td><p>cp1361, ms1361</p></td> <td><p>Korean</p></td> </tr> <tr>
<td><p>koi8_r</p></td> <td></td> <td><p>Russian</p></td> </tr> <tr>
<td><p>koi8_t</p></td> <td></td> <td>
<p>Tajik</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </td> </tr> <tr>
<td><p>koi8_u</p></td> <td></td> <td><p>Ukrainian</p></td> </tr> <tr>
<td><p>kz1048</p></td> <td><p>kz_1048, strk1048_2002, rk1048</p></td> <td>
<p>Kazakh</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </td> </tr> <tr>
<td><p>mac_cyrillic</p></td> <td><p>maccyrillic</p></td> <td><p>Bulgarian, Byelorussian, Macedonian, Russian, Serbian</p></td> </tr> <tr>
<td><p>mac_greek</p></td> <td><p>macgreek</p></td> <td><p>Greek</p></td> </tr> <tr>
<td><p>mac_iceland</p></td> <td><p>maciceland</p></td> <td><p>Icelandic</p></td> </tr> <tr>
<td><p>mac_latin2</p></td> <td><p>maclatin2, maccentraleurope, mac_centeuro</p></td> <td><p>Central and Eastern Europe</p></td> </tr> <tr>
<td><p>mac_roman</p></td> <td><p>macroman, macintosh</p></td> <td><p>Western Europe</p></td> </tr> <tr>
<td><p>mac_turkish</p></td> <td><p>macturkish</p></td> <td><p>Turkish</p></td> </tr> <tr>
<td><p>ptcp154</p></td> <td><p>csptcp154, pt154, cp154, cyrillic-asian</p></td> <td><p>Kazakh</p></td> </tr> <tr>
<td><p>shift_jis</p></td> <td><p>csshiftjis, shiftjis, sjis, s_jis</p></td> <td><p>Japanese</p></td> </tr> <tr>
<td><p>shift_jis_2004</p></td> <td><p>shiftjis2004, sjis_2004, sjis2004</p></td> <td><p>Japanese</p></td> </tr> <tr>
<td><p>shift_jisx0213</p></td> <td><p>shiftjisx0213, sjisx0213, s_jisx0213</p></td> <td><p>Japanese</p></td> </tr> <tr>
<td><p>utf_32</p></td> <td><p>U32, utf32</p></td> <td><p>all languages</p></td> </tr> <tr>
<td><p>utf_32_be</p></td> <td><p>UTF-32BE</p></td> <td><p>all languages</p></td> </tr> <tr>
<td><p>utf_32_le</p></td> <td><p>UTF-32LE</p></td> <td><p>all languages</p></td> </tr> <tr>
<td><p>utf_16</p></td> <td><p>U16, utf16</p></td> <td><p>all languages</p></td> </tr> <tr>
<td><p>utf_16_be</p></td> <td><p>UTF-16BE</p></td> <td><p>all languages</p></td> </tr> <tr>
<td><p>utf_16_le</p></td> <td><p>UTF-16LE</p></td> <td><p>all languages</p></td> </tr> <tr>
<td><p>utf_7</p></td> <td><p>U7, unicode-1-1-utf-7</p></td> <td><p>all languages</p></td> </tr> <tr>
<td><p>utf_8</p></td> <td><p>U8, UTF, utf8, cp65001</p></td> <td><p>all languages</p></td> </tr> <tr>
<td><p>utf_8_sig</p></td> <td></td> <td><p>all languages</p></td> </tr>  </table> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>The utf-16* and utf-32* encoders no longer allow surrogate code points (<code>U+D800</code>–<code>U+DFFF</code>) to be encoded. The utf-32* decoders no longer decode byte sequences that correspond to surrogate code points.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span><code>cp65001</code> is now an alias to <code>utf_8</code>.</p> </div>   <h2 id="python-specific-encodings">Python Specific Encodings</h2> <p>A number of predefined codecs are specific to Python, so their codec names have no meaning outside Python. These are listed in the tables below based on the expected input and output types (note that while text encodings are the most common use case for codecs, the underlying codec infrastructure supports arbitrary data transforms rather than just text encodings). For asymmetric codecs, the stated meaning describes the encoding direction.</p>  <h3 id="text-encodings">Text Encodings</h3> <p>The following codecs provide <a class="reference internal" href="stdtypes#str" title="str"><code>str</code></a> to <a class="reference internal" href="stdtypes#bytes" title="bytes"><code>bytes</code></a> encoding and <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> to <a class="reference internal" href="stdtypes#str" title="str"><code>str</code></a> decoding, similar to the Unicode text encodings.</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Codec</p></th> <th class="head"><p>Aliases</p></th> <th class="head"><p>Meaning</p></th> </tr> </thead>  <tr>
<td><p>idna</p></td> <td></td> <td><p>Implement <a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html" id="index-4"><strong>RFC 3490</strong></a>, see also <a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code>encodings.idna</code></a>. Only <code>errors='strict'</code> is supported.</p></td> </tr> <tr>
<td><p>mbcs</p></td> <td><p>ansi, dbcs</p></td> <td><p>Windows only: Encode the operand according to the ANSI codepage (CP_ACP).</p></td> </tr> <tr>
<td><p>oem</p></td> <td></td> <td>
<p>Windows only: Encode the operand according to the OEM codepage (CP_OEMCP).</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </td> </tr> <tr>
<td><p>palmos</p></td> <td></td> <td><p>Encoding of PalmOS 3.5.</p></td> </tr> <tr>
<td><p>punycode</p></td> <td></td> <td><p>Implement <a class="rfc reference external" href="https://tools.ietf.org/html/rfc3492.html" id="index-5"><strong>RFC 3492</strong></a>. Stateful codecs are not supported.</p></td> </tr> <tr>
<td><p>raw_unicode_escape</p></td> <td></td> <td><p>Latin-1 encoding with <code>\uXXXX</code> and <code>\UXXXXXXXX</code> for other code points. Existing backslashes are not escaped in any way. It is used in the Python pickle protocol.</p></td> </tr> <tr>
<td><p>undefined</p></td> <td></td> <td><p>Raise an exception for all conversions, even empty strings. The error handler is ignored.</p></td> </tr> <tr>
<td><p>unicode_escape</p></td> <td></td> <td><p>Encoding suitable as the contents of a Unicode literal in ASCII-encoded Python source code, except that quotes are not escaped. Decode from Latin-1 source code. Beware that Python source code actually uses UTF-8 by default.</p></td> </tr>  </table> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>“unicode_internal” codec is removed.</p> </div>   <h3 id="id4">Binary Transforms</h3> <p id="binary-transforms">The following codecs provide binary transforms: <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> to <a class="reference internal" href="stdtypes#bytes" title="bytes"><code>bytes</code></a> mappings. They are not supported by <a class="reference internal" href="stdtypes#bytes.decode" title="bytes.decode"><code>bytes.decode()</code></a> (which only produces <a class="reference internal" href="stdtypes#str" title="str"><code>str</code></a> output).</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Codec</p></th> <th class="head"><p>Aliases</p></th> <th class="head"><p>Meaning</p></th> <th class="head"><p>Encoder / decoder</p></th> </tr> </thead>  <tr>
<td><p>base64_codec <a class="footnote-reference brackets" href="#b64" id="id5">1</a></p></td> <td><p>base64, base_64</p></td> <td>
<p>Convert the operand to multiline MIME base64 (the result always includes a trailing <code>'\n'</code>).</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>accepts any <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> as input for encoding and decoding</p> </div> </td> <td><p><a class="reference internal" href="base64#base64.encodebytes" title="base64.encodebytes"><code>base64.encodebytes()</code></a> / <a class="reference internal" href="base64#base64.decodebytes" title="base64.decodebytes"><code>base64.decodebytes()</code></a></p></td> </tr> <tr>
<td><p>bz2_codec</p></td> <td><p>bz2</p></td> <td><p>Compress the operand using bz2.</p></td> <td><p><a class="reference internal" href="bz2#bz2.compress" title="bz2.compress"><code>bz2.compress()</code></a> / <a class="reference internal" href="bz2#bz2.decompress" title="bz2.decompress"><code>bz2.decompress()</code></a></p></td> </tr> <tr>
<td><p>hex_codec</p></td> <td><p>hex</p></td> <td><p>Convert the operand to hexadecimal representation, with two digits per byte.</p></td> <td><p><a class="reference internal" href="binascii#binascii.b2a_hex" title="binascii.b2a_hex"><code>binascii.b2a_hex()</code></a> / <a class="reference internal" href="binascii#binascii.a2b_hex" title="binascii.a2b_hex"><code>binascii.a2b_hex()</code></a></p></td> </tr> <tr>
<td><p>quopri_codec</p></td> <td><p>quopri, quotedprintable, quoted_printable</p></td> <td><p>Convert the operand to MIME quoted printable.</p></td> <td><p><a class="reference internal" href="quopri#quopri.encode" title="quopri.encode"><code>quopri.encode()</code></a> with <code>quotetabs=True</code> / <a class="reference internal" href="quopri#quopri.decode" title="quopri.decode"><code>quopri.decode()</code></a></p></td> </tr> <tr>
<td><p>uu_codec</p></td> <td><p>uu</p></td> <td><p>Convert the operand using uuencode.</p></td> <td><p><a class="reference internal" href="uu#uu.encode" title="uu.encode"><code>uu.encode()</code></a> / <a class="reference internal" href="uu#uu.decode" title="uu.decode"><code>uu.decode()</code></a></p></td> </tr> <tr>
<td><p>zlib_codec</p></td> <td><p>zip, zlib</p></td> <td><p>Compress the operand using gzip.</p></td> <td><p><a class="reference internal" href="zlib#zlib.compress" title="zlib.compress"><code>zlib.compress()</code></a> / <a class="reference internal" href="zlib#zlib.decompress" title="zlib.decompress"><code>zlib.decompress()</code></a></p></td> </tr>  </table> <dl class="footnote brackets"> <dt class="label" id="b64">
<code>1</code> </dt> <dd>
<p>In addition to <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a>, <code>'base64_codec'</code> also accepts ASCII-only instances of <a class="reference internal" href="stdtypes#str" title="str"><code>str</code></a> for decoding</p> </dd> </dl> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2: </span>Restoration of the binary transforms.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Restoration of the aliases for the binary transforms.</p> </div>   <h3 id="id6">Text Transforms</h3> <p id="text-transforms">The following codec provides a text transform: a <a class="reference internal" href="stdtypes#str" title="str"><code>str</code></a> to <a class="reference internal" href="stdtypes#str" title="str"><code>str</code></a> mapping. It is not supported by <a class="reference internal" href="stdtypes#str.encode" title="str.encode"><code>str.encode()</code></a> (which only produces <a class="reference internal" href="stdtypes#bytes" title="bytes"><code>bytes</code></a> output).</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Codec</p></th> <th class="head"><p>Aliases</p></th> <th class="head"><p>Meaning</p></th> </tr> </thead>  <tr>
<td><p>rot_13</p></td> <td><p>rot13</p></td> <td><p>Return the Caesar-cypher encryption of the operand.</p></td> </tr>  </table> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2: </span>Restoration of the <code>rot_13</code> text transform.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Restoration of the <code>rot13</code> alias.</p> </div>    <h2 id="encodings-idna-internationalized-domain-names-in-applications">encodings.idna — Internationalized Domain Names in Applications</h2> <p id="module-encodings.idna">This module implements <a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html" id="index-6"><strong>RFC 3490</strong></a> (Internationalized Domain Names in Applications) and <a class="rfc reference external" href="https://tools.ietf.org/html/rfc3492.html" id="index-7"><strong>RFC 3492</strong></a> (Nameprep: A Stringprep Profile for Internationalized Domain Names (IDN)). It builds upon the <code>punycode</code> encoding and <a class="reference internal" href="stringprep#module-stringprep" title="stringprep: String preparation, as per RFC 3453"><code>stringprep</code></a>.</p> <p>If you need the IDNA 2008 standard from <a class="rfc reference external" href="https://tools.ietf.org/html/rfc5891.html" id="index-8"><strong>RFC 5891</strong></a> and <a class="rfc reference external" href="https://tools.ietf.org/html/rfc5895.html" id="index-9"><strong>RFC 5895</strong></a>, use the third-party <code>idna module &lt;https://pypi.org/project/idna/&gt;_</code>.</p> <p>These RFCs together define a protocol to support non-ASCII characters in domain names. A domain name containing non-ASCII characters (such as <code>www.Alliancefrançaise.nu</code>) is converted into an ASCII-compatible encoding (ACE, such as <code>www.xn--alliancefranaise-npb.nu</code>). The ACE form of the domain name is then used in all places where arbitrary characters are not allowed by the protocol, such as DNS queries, HTTP <em class="mailheader">Host</em> fields, and so on. This conversion is carried out in the application; if possible invisible to the user: The application should transparently convert Unicode domain labels to IDNA on the wire, and convert back ACE labels to Unicode before presenting them to the user.</p> <p>Python supports this conversion in several ways: the <code>idna</code> codec performs conversion between Unicode and ACE, separating an input string into labels based on the separator characters defined in <a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html#section-3.1" id="index-10"><strong>section 3.1 of RFC 3490</strong></a> and converting each label to ACE as required, and conversely separating an input byte string into labels based on the <code>.</code> separator and converting any ACE labels found into unicode. Furthermore, the <a class="reference internal" href="socket#module-socket" title="socket: Low-level networking interface."><code>socket</code></a> module transparently converts Unicode host names to ACE, so that applications need not be concerned about converting host names themselves when they pass them to the socket module. On top of that, modules that have host names as function parameters, such as <a class="reference internal" href="http.client#module-http.client" title="http.client: HTTP and HTTPS protocol client (requires sockets)."><code>http.client</code></a> and <a class="reference internal" href="ftplib#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code>ftplib</code></a>, accept Unicode host names (<a class="reference internal" href="http.client#module-http.client" title="http.client: HTTP and HTTPS protocol client (requires sockets)."><code>http.client</code></a> then also transparently sends an IDNA hostname in the <em class="mailheader">Host</em> field if it sends that field at all).</p> <p>When receiving host names from the wire (such as in reverse name lookup), no automatic conversion to Unicode is performed: applications wishing to present such host names to the user should decode them to Unicode.</p> <p>The module <a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code>encodings.idna</code></a> also implements the nameprep procedure, which performs certain normalizations on host names, to achieve case-insensitivity of international domain names, and to unify similar characters. The nameprep functions can be used directly if desired.</p> <dl class="function"> <dt id="encodings.idna.nameprep">
<code>encodings.idna.nameprep(label)</code> </dt> <dd>
<p>Return the nameprepped version of <em>label</em>. The implementation currently assumes query strings, so <code>AllowUnassigned</code> is true.</p> </dd>
</dl> <dl class="function"> <dt id="encodings.idna.ToASCII">
<code>encodings.idna.ToASCII(label)</code> </dt> <dd>
<p>Convert a label to ASCII, as specified in <a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html" id="index-11"><strong>RFC 3490</strong></a>. <code>UseSTD3ASCIIRules</code> is assumed to be false.</p> </dd>
</dl> <dl class="function"> <dt id="encodings.idna.ToUnicode">
<code>encodings.idna.ToUnicode(label)</code> </dt> <dd>
<p>Convert a label to Unicode, as specified in <a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html" id="index-12"><strong>RFC 3490</strong></a>.</p> </dd>
</dl>   <h2 id="encodings-mbcs-windows-ansi-codepage">encodings.mbcs — Windows ANSI codepage</h2> <p id="module-encodings.mbcs">This module implements the ANSI codepage (CP_ACP).</p> <p class="availability"><a class="reference internal" href="https://docs.python.org/3.9/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows only.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Support any error handler.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>Before 3.2, the <em>errors</em> argument was ignored; <code>'replace'</code> was always used to encode, and <code>'ignore'</code> to decode.</p> </div>   <h2 id="encodings-utf-8-sig-utf-8-codec-with-bom-signature">encodings.utf_8_sig — UTF-8 codec with BOM signature</h2> <p id="module-encodings.utf_8_sig">This module implements a variant of the UTF-8 codec. On encoding, a UTF-8 encoded BOM will be prepended to the UTF-8 encoded bytes. For the stateful encoder this is only done once (on the first write to the byte stream). On decoding, an optional UTF-8 encoded BOM at the start of the data will be skipped.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2021 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.9/library/codecs.html" class="_attribution-link">https://docs.python.org/3.9/library/codecs.html</a>
  </p>
</div>
