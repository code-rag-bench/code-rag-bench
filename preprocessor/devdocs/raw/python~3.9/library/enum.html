<h1 id="enum-support-for-enumerations">enum — Support for enumerations</h1> <div class="versionadded" id="module-enum"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/enum.py">Lib/enum.py</a></p>  <p>An enumeration is a set of symbolic names (members) bound to unique, constant values. Within an enumeration, the members can be compared by identity, and the enumeration itself can be iterated over.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Case of Enum Members</p> <p>Because Enums are used to represent constants we recommend using UPPER_CASE names for enum members, and will be using that style in our examples.</p> </div>  <h2 id="module-contents">Module Contents</h2> <p>This module defines four enumeration classes that can be used to define unique sets of names and values: <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a>, <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a>, <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a>, and <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a>. It also defines one decorator, <a class="reference internal" href="#enum.unique" title="enum.unique"><code>unique()</code></a>, and one helper, <a class="reference internal" href="#enum.auto" title="enum.auto"><code>auto</code></a>.</p> <dl class="class"> <dt id="enum.Enum">
<code>class enum.Enum</code> </dt> <dd>
<p>Base class for creating enumerated constants. See section <a class="reference internal" href="#functional-api">Functional API</a> for an alternate construction syntax.</p> </dd>
</dl> <dl class="class"> <dt id="enum.IntEnum">
<code>class enum.IntEnum</code> </dt> <dd>
<p>Base class for creating enumerated constants that are also subclasses of <a class="reference internal" href="functions#int" title="int"><code>int</code></a>.</p> </dd>
</dl> <dl class="class"> <dt id="enum.IntFlag">
<code>class enum.IntFlag</code> </dt> <dd>
<p>Base class for creating enumerated constants that can be combined using the bitwise operators without losing their <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> membership. <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> members are also subclasses of <a class="reference internal" href="functions#int" title="int"><code>int</code></a>.</p> </dd>
</dl> <dl class="class"> <dt id="enum.Flag">
<code>class enum.Flag</code> </dt> <dd>
<p>Base class for creating enumerated constants that can be combined using the bitwise operations without losing their <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a> membership.</p> </dd>
</dl> <dl class="function"> <dt>
<code>enum.unique()</code> </dt> <dd>
<p>Enum class decorator that ensures only one name is bound to any one value.</p> </dd>
</dl> <dl class="class"> <dt id="enum.auto">
<code>class enum.auto</code> </dt> <dd>
<p>Instances are replaced with an appropriate value for Enum members. By default, the initial value starts at 1.</p> </dd>
</dl> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6: </span><code>Flag</code>, <code>IntFlag</code>, <code>auto</code></p> </div>   <h2 id="creating-an-enum">Creating an Enum</h2> <p>Enumerations are created using the <a class="reference internal" href="https://docs.python.org/3.9/reference/compound_stmts.html#class"><code>class</code></a> syntax, which makes them easy to read and write. An alternative creation method is described in <a class="reference internal" href="#functional-api">Functional API</a>. To define an enumeration, subclass <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> as follows:</p> <pre data-language="python">&gt;&gt;&gt; from enum import Enum
&gt;&gt;&gt; class Color(Enum):
...     RED = 1
...     GREEN = 2
...     BLUE = 3
...
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Enum member values</p> <p>Member values can be anything: <a class="reference internal" href="functions#int" title="int"><code>int</code></a>, <a class="reference internal" href="stdtypes#str" title="str"><code>str</code></a>, etc.. If the exact value is unimportant you may use <a class="reference internal" href="#enum.auto" title="enum.auto"><code>auto</code></a> instances and an appropriate value will be chosen for you. Care must be taken if you mix <a class="reference internal" href="#enum.auto" title="enum.auto"><code>auto</code></a> with other values.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Nomenclature</p> <ul class="simple"> <li>The class <code>Color</code> is an <em>enumeration</em> (or <em>enum</em>)</li> <li>The attributes <code>Color.RED</code>, <code>Color.GREEN</code>, etc., are <em>enumeration members</em> (or <em>enum members</em>) and are functionally constants.</li> <li>The enum members have <em>names</em> and <em>values</em> (the name of <code>Color.RED</code> is <code>RED</code>, the value of <code>Color.BLUE</code> is <code>3</code>, etc.)</li> </ul> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Even though we use the <a class="reference internal" href="https://docs.python.org/3.9/reference/compound_stmts.html#class"><code>class</code></a> syntax to create Enums, Enums are not normal Python classes. See <a class="reference internal" href="#how-are-enums-different">How are Enums different?</a> for more details.</p> </div> <p>Enumeration members have human readable string representations:</p> <pre data-language="python">&gt;&gt;&gt; print(Color.RED)
Color.RED
</pre> <p>…while their <code>repr</code> has more information:</p> <pre data-language="python">&gt;&gt;&gt; print(repr(Color.RED))
&lt;Color.RED: 1&gt;
</pre> <p>The <em>type</em> of an enumeration member is the enumeration it belongs to:</p> <pre data-language="python">&gt;&gt;&gt; type(Color.RED)
&lt;enum 'Color'&gt;
&gt;&gt;&gt; isinstance(Color.GREEN, Color)
True
&gt;&gt;&gt;
</pre> <p>Enum members also have a property that contains just their item name:</p> <pre data-language="python">&gt;&gt;&gt; print(Color.RED.name)
RED
</pre> <p>Enumerations support iteration, in definition order:</p> <pre data-language="python">&gt;&gt;&gt; class Shake(Enum):
...     VANILLA = 7
...     CHOCOLATE = 4
...     COOKIES = 9
...     MINT = 3
...
&gt;&gt;&gt; for shake in Shake:
...     print(shake)
...
Shake.VANILLA
Shake.CHOCOLATE
Shake.COOKIES
Shake.MINT
</pre> <p>Enumeration members are hashable, so they can be used in dictionaries and sets:</p> <pre data-language="python">&gt;&gt;&gt; apples = {}
&gt;&gt;&gt; apples[Color.RED] = 'red delicious'
&gt;&gt;&gt; apples[Color.GREEN] = 'granny smith'
&gt;&gt;&gt; apples == {Color.RED: 'red delicious', Color.GREEN: 'granny smith'}
True
</pre>   <h2 id="programmatic-access-to-enumeration-members-and-their-attributes">Programmatic access to enumeration members and their attributes</h2> <p>Sometimes it’s useful to access members in enumerations programmatically (i.e. situations where <code>Color.RED</code> won’t do because the exact color is not known at program-writing time). <code>Enum</code> allows such access:</p> <pre data-language="python">&gt;&gt;&gt; Color(1)
&lt;Color.RED: 1&gt;
&gt;&gt;&gt; Color(3)
&lt;Color.BLUE: 3&gt;
</pre> <p>If you want to access enum members by <em>name</em>, use item access:</p> <pre data-language="python">&gt;&gt;&gt; Color['RED']
&lt;Color.RED: 1&gt;
&gt;&gt;&gt; Color['GREEN']
&lt;Color.GREEN: 2&gt;
</pre> <p>If you have an enum member and need its <code>name</code> or <code>value</code>:</p> <pre data-language="python">&gt;&gt;&gt; member = Color.RED
&gt;&gt;&gt; member.name
'RED'
&gt;&gt;&gt; member.value
1
</pre>   <h2 id="duplicating-enum-members-and-values">Duplicating enum members and values</h2> <p>Having two enum members with the same name is invalid:</p> <pre data-language="python">&gt;&gt;&gt; class Shape(Enum):
...     SQUARE = 2
...     SQUARE = 3
...
Traceback (most recent call last):
...
TypeError: Attempted to reuse key: 'SQUARE'
</pre> <p>However, two enum members are allowed to have the same value. Given two members A and B with the same value (and A defined first), B is an alias to A. By-value lookup of the value of A and B will return A. By-name lookup of B will also return A:</p> <pre data-language="python">&gt;&gt;&gt; class Shape(Enum):
...     SQUARE = 2
...     DIAMOND = 1
...     CIRCLE = 3
...     ALIAS_FOR_SQUARE = 2
...
&gt;&gt;&gt; Shape.SQUARE
&lt;Shape.SQUARE: 2&gt;
&gt;&gt;&gt; Shape.ALIAS_FOR_SQUARE
&lt;Shape.SQUARE: 2&gt;
&gt;&gt;&gt; Shape(2)
&lt;Shape.SQUARE: 2&gt;
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Attempting to create a member with the same name as an already defined attribute (another member, a method, etc.) or attempting to create an attribute with the same name as a member is not allowed.</p> </div>   <h2 id="ensuring-unique-enumeration-values">Ensuring unique enumeration values</h2> <p>By default, enumerations allow multiple names as aliases for the same value. When this behavior isn’t desired, the following decorator can be used to ensure each value is used only once in the enumeration:</p> <dl class="function"> <dt id="enum.unique">
<code>@enum.unique</code> </dt> 
</dl> <p>A <a class="reference internal" href="https://docs.python.org/3.9/reference/compound_stmts.html#class"><code>class</code></a> decorator specifically for enumerations. It searches an enumeration’s <code>__members__</code> gathering any aliases it finds; if any are found <a class="reference internal" href="exceptions#ValueError" title="ValueError"><code>ValueError</code></a> is raised with the details:</p> <pre data-language="python">&gt;&gt;&gt; from enum import Enum, unique
&gt;&gt;&gt; @unique
... class Mistake(Enum):
...     ONE = 1
...     TWO = 2
...     THREE = 3
...     FOUR = 3
...
Traceback (most recent call last):
...
ValueError: duplicate values found in &lt;enum 'Mistake'&gt;: FOUR -&gt; THREE
</pre>   <h2 id="using-automatic-values">Using automatic values</h2> <p>If the exact value is unimportant you can use <a class="reference internal" href="#enum.auto" title="enum.auto"><code>auto</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; from enum import Enum, auto
&gt;&gt;&gt; class Color(Enum):
...     RED = auto()
...     BLUE = auto()
...     GREEN = auto()
...
&gt;&gt;&gt; list(Color)
[&lt;Color.RED: 1&gt;, &lt;Color.BLUE: 2&gt;, &lt;Color.GREEN: 3&gt;]
</pre> <p>The values are chosen by <code>_generate_next_value_()</code>, which can be overridden:</p> <pre data-language="python">&gt;&gt;&gt; class AutoName(Enum):
...     def _generate_next_value_(name, start, count, last_values):
...         return name
...
&gt;&gt;&gt; class Ordinal(AutoName):
...     NORTH = auto()
...     SOUTH = auto()
...     EAST = auto()
...     WEST = auto()
...
&gt;&gt;&gt; list(Ordinal)
[&lt;Ordinal.NORTH: 'NORTH'&gt;, &lt;Ordinal.SOUTH: 'SOUTH'&gt;, &lt;Ordinal.EAST: 'EAST'&gt;, &lt;Ordinal.WEST: 'WEST'&gt;]
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The goal of the default <code>_generate_next_value_()</code> method is to provide the next <a class="reference internal" href="functions#int" title="int"><code>int</code></a> in sequence with the last <a class="reference internal" href="functions#int" title="int"><code>int</code></a> provided, but the way it does this is an implementation detail and may change.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <code>_generate_next_value_()</code> method must be defined before any members.</p> </div>   <h2 id="iteration">Iteration</h2> <p>Iterating over the members of an enum does not provide the aliases:</p> <pre data-language="python">&gt;&gt;&gt; list(Shape)
[&lt;Shape.SQUARE: 2&gt;, &lt;Shape.DIAMOND: 1&gt;, &lt;Shape.CIRCLE: 3&gt;]
</pre> <p>The special attribute <code>__members__</code> is a read-only ordered mapping of names to members. It includes all names defined in the enumeration, including the aliases:</p> <pre data-language="python">&gt;&gt;&gt; for name, member in Shape.__members__.items():
...     name, member
...
('SQUARE', &lt;Shape.SQUARE: 2&gt;)
('DIAMOND', &lt;Shape.DIAMOND: 1&gt;)
('CIRCLE', &lt;Shape.CIRCLE: 3&gt;)
('ALIAS_FOR_SQUARE', &lt;Shape.SQUARE: 2&gt;)
</pre> <p>The <code>__members__</code> attribute can be used for detailed programmatic access to the enumeration members. For example, finding all the aliases:</p> <pre data-language="python">&gt;&gt;&gt; [name for name, member in Shape.__members__.items() if member.name != name]
['ALIAS_FOR_SQUARE']
</pre>   <h2 id="comparisons">Comparisons</h2> <p>Enumeration members are compared by identity:</p> <pre data-language="python">&gt;&gt;&gt; Color.RED is Color.RED
True
&gt;&gt;&gt; Color.RED is Color.BLUE
False
&gt;&gt;&gt; Color.RED is not Color.BLUE
True
</pre> <p>Ordered comparisons between enumeration values are <em>not</em> supported. Enum members are not integers (but see <a class="reference internal" href="#intenum">IntEnum</a> below):</p> <pre data-language="python">&gt;&gt;&gt; Color.RED &lt; Color.BLUE
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: '&lt;' not supported between instances of 'Color' and 'Color'
</pre> <p>Equality comparisons are defined though:</p> <pre data-language="python">&gt;&gt;&gt; Color.BLUE == Color.RED
False
&gt;&gt;&gt; Color.BLUE != Color.RED
True
&gt;&gt;&gt; Color.BLUE == Color.BLUE
True
</pre> <p>Comparisons against non-enumeration values will always compare not equal (again, <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> was explicitly designed to behave differently, see below):</p> <pre data-language="python">&gt;&gt;&gt; Color.BLUE == 2
False
</pre>   <h2 id="allowed-members-and-attributes-of-enumerations">Allowed members and attributes of enumerations</h2> <p>The examples above use integers for enumeration values. Using integers is short and handy (and provided by default by the <a class="reference internal" href="#functional-api">Functional API</a>), but not strictly enforced. In the vast majority of use-cases, one doesn’t care what the actual value of an enumeration is. But if the value <em>is</em> important, enumerations can have arbitrary values.</p> <p>Enumerations are Python classes, and can have methods and special methods as usual. If we have this enumeration:</p> <pre data-language="python">&gt;&gt;&gt; class Mood(Enum):
...     FUNKY = 1
...     HAPPY = 3
...
...     def describe(self):
...         # self is the member here
...         return self.name, self.value
...
...     def __str__(self):
...         return 'my custom str! {0}'.format(self.value)
...
...     @classmethod
...     def favorite_mood(cls):
...         # cls here is the enumeration
...         return cls.HAPPY
...
</pre> <p>Then:</p> <pre data-language="python">&gt;&gt;&gt; Mood.favorite_mood()
&lt;Mood.HAPPY: 3&gt;
&gt;&gt;&gt; Mood.HAPPY.describe()
('HAPPY', 3)
&gt;&gt;&gt; str(Mood.FUNKY)
'my custom str! 1'
</pre> <p>The rules for what is allowed are as follows: names that start and end with a single underscore are reserved by enum and cannot be used; all other attributes defined within an enumeration will become members of this enumeration, with the exception of special methods (<a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__str__" title="object.__str__"><code>__str__()</code></a>, <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__add__" title="object.__add__"><code>__add__()</code></a>, etc.), descriptors (methods are also descriptors), and variable names listed in <code>_ignore_</code>.</p> <p>Note: if your enumeration defines <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a> and/or <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> then any value(s) given to the enum member will be passed into those methods. See <a class="reference internal" href="#planet">Planet</a> for an example.</p>   <h2 id="restricted-enum-subclassing">Restricted Enum subclassing</h2> <p>A new <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class must have one base Enum class, up to one concrete data type, and as many <a class="reference internal" href="functions#object" title="object"><code>object</code></a>-based mixin classes as needed. The order of these base classes is:</p> <pre data-language="python">class EnumName([mix-in, ...,] [data-type,] base-enum):
    pass
</pre> <p>Also, subclassing an enumeration is allowed only if the enumeration does not define any members. So this is forbidden:</p> <pre data-language="python">&gt;&gt;&gt; class MoreColor(Color):
...     PINK = 17
...
Traceback (most recent call last):
...
TypeError: Cannot extend enumerations
</pre> <p>But this is allowed:</p> <pre data-language="python">&gt;&gt;&gt; class Foo(Enum):
...     def some_behavior(self):
...         pass
...
&gt;&gt;&gt; class Bar(Foo):
...     HAPPY = 1
...     SAD = 2
...
</pre> <p>Allowing subclassing of enums that define members would lead to a violation of some important invariants of types and instances. On the other hand, it makes sense to allow sharing some common behavior between a group of enumerations. (See <a class="reference internal" href="#orderedenum">OrderedEnum</a> for an example.)</p>   <h2 id="pickling">Pickling</h2> <p>Enumerations can be pickled and unpickled:</p> <pre data-language="python">&gt;&gt;&gt; from test.test_enum import Fruit
&gt;&gt;&gt; from pickle import dumps, loads
&gt;&gt;&gt; Fruit.TOMATO is loads(dumps(Fruit.TOMATO))
True
</pre> <p>The usual restrictions for pickling apply: picklable enums must be defined in the top level of a module, since unpickling requires them to be importable from that module.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>With pickle protocol version 4 it is possible to easily pickle enums nested in other classes.</p> </div> <p>It is possible to modify how Enum members are pickled/unpickled by defining <a class="reference internal" href="pickle#object.__reduce_ex__" title="object.__reduce_ex__"><code>__reduce_ex__()</code></a> in the enumeration class.</p>   <h2 id="functional-api">Functional API</h2> <p>The <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class is callable, providing the following functional API:</p> <pre data-language="python">&gt;&gt;&gt; Animal = Enum('Animal', 'ANT BEE CAT DOG')
&gt;&gt;&gt; Animal
&lt;enum 'Animal'&gt;
&gt;&gt;&gt; Animal.ANT
&lt;Animal.ANT: 1&gt;
&gt;&gt;&gt; Animal.ANT.value
1
&gt;&gt;&gt; list(Animal)
[&lt;Animal.ANT: 1&gt;, &lt;Animal.BEE: 2&gt;, &lt;Animal.CAT: 3&gt;, &lt;Animal.DOG: 4&gt;]
</pre> <p>The semantics of this API resemble <a class="reference internal" href="collections#collections.namedtuple" title="collections.namedtuple"><code>namedtuple</code></a>. The first argument of the call to <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> is the name of the enumeration.</p> <p>The second argument is the <em>source</em> of enumeration member names. It can be a whitespace-separated string of names, a sequence of names, a sequence of 2-tuples with key/value pairs, or a mapping (e.g. dictionary) of names to values. The last two options enable assigning arbitrary values to enumerations; the others auto-assign increasing integers starting with 1 (use the <code>start</code> parameter to specify a different starting value). A new class derived from <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> is returned. In other words, the above assignment to <code>Animal</code> is equivalent to:</p> <pre data-language="python">&gt;&gt;&gt; class Animal(Enum):
...     ANT = 1
...     BEE = 2
...     CAT = 3
...     DOG = 4
...
</pre> <p>The reason for defaulting to <code>1</code> as the starting number and not <code>0</code> is that <code>0</code> is <code>False</code> in a boolean sense, but enum members all evaluate to <code>True</code>.</p> <p>Pickling enums created with the functional API can be tricky as frame stack implementation details are used to try and figure out which module the enumeration is being created in (e.g. it will fail if you use a utility function in separate module, and also may not work on IronPython or Jython). The solution is to specify the module name explicitly as follows:</p> <pre data-language="python">&gt;&gt;&gt; Animal = Enum('Animal', 'ANT BEE CAT DOG', module=__name__)
</pre> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>If <code>module</code> is not supplied, and Enum cannot determine what it is, the new Enum members will not be unpicklable; to keep errors closer to the source, pickling will be disabled.</p> </div> <p>The new pickle protocol 4 also, in some circumstances, relies on <a class="reference internal" href="stdtypes#definition.__qualname__" title="definition.__qualname__"><code>__qualname__</code></a> being set to the location where pickle will be able to find the class. For example, if the class was made available in class SomeData in the global scope:</p> <pre data-language="python">&gt;&gt;&gt; Animal = Enum('Animal', 'ANT BEE CAT DOG', qualname='SomeData.Animal')
</pre> <p>The complete signature is:</p> <pre data-language="python">Enum(value='NewEnumName', names=&lt;...&gt;, *, module='...', qualname='...', type=&lt;mixed-in class&gt;, start=1)
</pre> <dl class="field-list"> <dt class="field-odd">value</dt> <dd class="field-odd">
<p>What the new Enum class will record as its name.</p> </dd> <dt class="field-even">names</dt> <dd class="field-even">
<p>The Enum members. This can be a whitespace or comma separated string (values will start at 1 unless otherwise specified):</p> <pre data-language="python">'RED GREEN BLUE' | 'RED,GREEN,BLUE' | 'RED, GREEN, BLUE'
</pre> <p>or an iterator of names:</p> <pre data-language="python">['RED', 'GREEN', 'BLUE']
</pre> <p>or an iterator of (name, value) pairs:</p> <pre data-language="python">[('CYAN', 4), ('MAGENTA', 5), ('YELLOW', 6)]
</pre> <p>or a mapping:</p> <pre data-language="python">{'CHARTREUSE': 7, 'SEA_GREEN': 11, 'ROSEMARY': 42}
</pre> </dd> <dt class="field-odd">module</dt> <dd class="field-odd">
<p>name of module where new Enum class can be found.</p> </dd> <dt class="field-even">qualname</dt> <dd class="field-even">
<p>where in module new Enum class can be found.</p> </dd> <dt class="field-odd">type</dt> <dd class="field-odd">
<p>type to mix in to new Enum class.</p> </dd> <dt class="field-even">start</dt> <dd class="field-even">
<p>number to start counting at if only names are passed in.</p> </dd> </dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>The <em>start</em> parameter was added.</p> </div>   <h2 id="derived-enumerations">Derived Enumerations</h2>  <h3 id="intenum">IntEnum</h3> <p>The first variation of <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> that is provided is also a subclass of <a class="reference internal" href="functions#int" title="int"><code>int</code></a>. Members of an <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> can be compared to integers; by extension, integer enumerations of different types can also be compared to each other:</p> <pre data-language="python">&gt;&gt;&gt; from enum import IntEnum
&gt;&gt;&gt; class Shape(IntEnum):
...     CIRCLE = 1
...     SQUARE = 2
...
&gt;&gt;&gt; class Request(IntEnum):
...     POST = 1
...     GET = 2
...
&gt;&gt;&gt; Shape == 1
False
&gt;&gt;&gt; Shape.CIRCLE == 1
True
&gt;&gt;&gt; Shape.CIRCLE == Request.POST
True
</pre> <p>However, they still can’t be compared to standard <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> enumerations:</p> <pre data-language="python">&gt;&gt;&gt; class Shape(IntEnum):
...     CIRCLE = 1
...     SQUARE = 2
...
&gt;&gt;&gt; class Color(Enum):
...     RED = 1
...     GREEN = 2
...
&gt;&gt;&gt; Shape.CIRCLE == Color.RED
False
</pre> <p><a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> values behave like integers in other ways you’d expect:</p> <pre data-language="python">&gt;&gt;&gt; int(Shape.CIRCLE)
1
&gt;&gt;&gt; ['a', 'b', 'c'][Shape.CIRCLE]
'b'
&gt;&gt;&gt; [i for i in range(Shape.SQUARE)]
[0, 1]
</pre>   <h3 id="intflag">IntFlag</h3> <p>The next variation of <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> provided, <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a>, is also based on <a class="reference internal" href="functions#int" title="int"><code>int</code></a>. The difference being <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> members can be combined using the bitwise operators (&amp;, |, ^, ~) and the result is still an <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> member. However, as the name implies, <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> members also subclass <a class="reference internal" href="functions#int" title="int"><code>int</code></a> and can be used wherever an <a class="reference internal" href="functions#int" title="int"><code>int</code></a> is used. Any operation on an <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> member besides the bit-wise operations will lose the <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> membership.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> <p>Sample <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> class:</p> <pre data-language="python">&gt;&gt;&gt; from enum import IntFlag
&gt;&gt;&gt; class Perm(IntFlag):
...     R = 4
...     W = 2
...     X = 1
...
&gt;&gt;&gt; Perm.R | Perm.W
&lt;Perm.R|W: 6&gt;
&gt;&gt;&gt; Perm.R + Perm.W
6
&gt;&gt;&gt; RW = Perm.R | Perm.W
&gt;&gt;&gt; Perm.R in RW
True
</pre> <p>It is also possible to name the combinations:</p> <pre data-language="python">&gt;&gt;&gt; class Perm(IntFlag):
...     R = 4
...     W = 2
...     X = 1
...     RWX = 7
&gt;&gt;&gt; Perm.RWX
&lt;Perm.RWX: 7&gt;
&gt;&gt;&gt; ~Perm.RWX
&lt;Perm.-8: -8&gt;
</pre> <p>Another important difference between <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> and <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> is that if no flags are set (the value is 0), its boolean evaluation is <a class="reference internal" href="constants#False" title="False"><code>False</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; Perm.R &amp; Perm.X
&lt;Perm.0: 0&gt;
&gt;&gt;&gt; bool(Perm.R &amp; Perm.X)
False
</pre> <p>Because <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> members are also subclasses of <a class="reference internal" href="functions#int" title="int"><code>int</code></a> they can be combined with them:</p> <pre data-language="python">&gt;&gt;&gt; Perm.X | 8
&lt;Perm.8|X: 9&gt;
</pre>   <h3 id="flag">Flag</h3> <p>The last variation is <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a>. Like <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a>, <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a> members can be combined using the bitwise operators (&amp;, |, ^, ~). Unlike <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a>, they cannot be combined with, nor compared against, any other <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a> enumeration, nor <a class="reference internal" href="functions#int" title="int"><code>int</code></a>. While it is possible to specify the values directly it is recommended to use <a class="reference internal" href="#enum.auto" title="enum.auto"><code>auto</code></a> as the value and let <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a> select an appropriate value.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> <p>Like <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a>, if a combination of <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a> members results in no flags being set, the boolean evaluation is <a class="reference internal" href="constants#False" title="False"><code>False</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; from enum import Flag, auto
&gt;&gt;&gt; class Color(Flag):
...     RED = auto()
...     BLUE = auto()
...     GREEN = auto()
...
&gt;&gt;&gt; Color.RED &amp; Color.GREEN
&lt;Color.0: 0&gt;
&gt;&gt;&gt; bool(Color.RED &amp; Color.GREEN)
False
</pre> <p>Individual flags should have values that are powers of two (1, 2, 4, 8, …), while combinations of flags won’t:</p> <pre data-language="python">&gt;&gt;&gt; class Color(Flag):
...     RED = auto()
...     BLUE = auto()
...     GREEN = auto()
...     WHITE = RED | BLUE | GREEN
...
&gt;&gt;&gt; Color.WHITE
&lt;Color.WHITE: 7&gt;
</pre> <p>Giving a name to the “no flags set” condition does not change its boolean value:</p> <pre data-language="python">&gt;&gt;&gt; class Color(Flag):
...     BLACK = 0
...     RED = auto()
...     BLUE = auto()
...     GREEN = auto()
...
&gt;&gt;&gt; Color.BLACK
&lt;Color.BLACK: 0&gt;
&gt;&gt;&gt; bool(Color.BLACK)
False
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For the majority of new code, <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> and <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a> are strongly recommended, since <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> and <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> break some semantic promises of an enumeration (by being comparable to integers, and thus by transitivity to other unrelated enumerations). <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> and <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> should be used only in cases where <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> and <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a> will not do; for example, when integer constants are replaced with enumerations, or for interoperability with other systems.</p> </div>   <h3 id="others">Others</h3> <p>While <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> is part of the <a class="reference internal" href="#module-enum" title="enum: Implementation of an enumeration class."><code>enum</code></a> module, it would be very simple to implement independently:</p> <pre data-language="python">class IntEnum(int, Enum):
    pass
</pre> <p>This demonstrates how similar derived enumerations can be defined; for example a <code>StrEnum</code> that mixes in <a class="reference internal" href="stdtypes#str" title="str"><code>str</code></a> instead of <a class="reference internal" href="functions#int" title="int"><code>int</code></a>.</p> <p>Some rules:</p> <ol class="arabic simple"> <li>When subclassing <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a>, mix-in types must appear before <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> itself in the sequence of bases, as in the <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> example above.</li> <li>While <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> can have members of any type, once you mix in an additional type, all the members must have values of that type, e.g. <a class="reference internal" href="functions#int" title="int"><code>int</code></a> above. This restriction does not apply to mix-ins which only add methods and don’t specify another type.</li> <li>When another data type is mixed in, the <code>value</code> attribute is <em>not the same</em> as the enum member itself, although it is equivalent and will compare equal.</li> <li>%-style formatting: <code>%s</code> and <code>%r</code> call the <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class’s <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__str__" title="object.__str__"><code>__str__()</code></a> and <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__repr__" title="object.__repr__"><code>__repr__()</code></a> respectively; other codes (such as <code>%i</code> or <code>%h</code> for IntEnum) treat the enum member as its mixed-in type.</li> <li>
<a class="reference internal" href="https://docs.python.org/3.9/reference/lexical_analysis.html#f-strings"><span class="std std-ref">Formatted string literals</span></a>, <a class="reference internal" href="stdtypes#str.format" title="str.format"><code>str.format()</code></a>, and <a class="reference internal" href="functions#format" title="format"><code>format()</code></a> will use the mixed-in type’s <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__format__" title="object.__format__"><code>__format__()</code></a> unless <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__str__" title="object.__str__"><code>__str__()</code></a> or <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__format__" title="object.__format__"><code>__format__()</code></a> is overridden in the subclass, in which case the overridden methods or <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> methods will be used. Use the !s and !r format codes to force usage of the <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class’s <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__str__" title="object.__str__"><code>__str__()</code></a> and <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__repr__" title="object.__repr__"><code>__repr__()</code></a> methods.</li> </ol>    <h2 id="when-to-use-new-vs-init">When to use __new__() vs. __init__()</h2> <p><a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a> must be used whenever you want to customize the actual value of the <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> member. Any other modifications may go in either <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a> or <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a>, with <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> being preferred.</p> <p>For example, if you want to pass several items to the constructor, but only want one of them to be the value:</p> <pre data-language="python">&gt;&gt;&gt; class Coordinate(bytes, Enum):
...     """
...     Coordinate with binary codes that can be indexed by the int code.
...     """
...     def __new__(cls, value, label, unit):
...         obj = bytes.__new__(cls, [value])
...         obj._value_ = value
...         obj.label = label
...         obj.unit = unit
...         return obj
...     PX = (0, 'P.X', 'km')
...     PY = (1, 'P.Y', 'km')
...     VX = (2, 'V.X', 'km/s')
...     VY = (3, 'V.Y', 'km/s')
...

&gt;&gt;&gt; print(Coordinate['PY'])
Coordinate.PY

&gt;&gt;&gt; print(Coordinate(3))
Coordinate.VY
</pre>   <h2 id="interesting-examples">Interesting examples</h2> <p>While <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a>, <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a>, <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a>, and <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a> are expected to cover the majority of use-cases, they cannot cover them all. Here are recipes for some different types of enumerations that can be used directly, or as examples for creating one’s own.</p>  <h3 id="omitting-values">Omitting values</h3> <p>In many use-cases one doesn’t care what the actual value of an enumeration is. There are several ways to define this type of simple enumeration:</p> <ul class="simple"> <li>use instances of <a class="reference internal" href="#enum.auto" title="enum.auto"><code>auto</code></a> for the value</li> <li>use instances of <a class="reference internal" href="functions#object" title="object"><code>object</code></a> as the value</li> <li>use a descriptive string as the value</li> <li>use a tuple as the value and a custom <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a> to replace the tuple with an <a class="reference internal" href="functions#int" title="int"><code>int</code></a> value</li> </ul> <p>Using any of these methods signifies to the user that these values are not important, and also enables one to add, remove, or reorder members without having to renumber the remaining members.</p> <p>Whichever method you choose, you should provide a <a class="reference internal" href="functions#repr" title="repr"><code>repr()</code></a> that also hides the (unimportant) value:</p> <pre data-language="python">&gt;&gt;&gt; class NoValue(Enum):
...     def __repr__(self):
...         return '&lt;%s.%s&gt;' % (self.__class__.__name__, self.name)
...
</pre>  <h4 id="using-auto">Using <a class="reference internal" href="#enum.auto" title="enum.auto"><code>auto</code></a>
</h4> <p>Using <a class="reference internal" href="#enum.auto" title="enum.auto"><code>auto</code></a> would look like:</p> <pre data-language="python">&gt;&gt;&gt; class Color(NoValue):
...     RED = auto()
...     BLUE = auto()
...     GREEN = auto()
...
&gt;&gt;&gt; Color.GREEN
&lt;Color.GREEN&gt;
</pre>   <h4 id="using-object">Using <a class="reference internal" href="functions#object" title="object"><code>object</code></a>
</h4> <p>Using <a class="reference internal" href="functions#object" title="object"><code>object</code></a> would look like:</p> <pre data-language="python">&gt;&gt;&gt; class Color(NoValue):
...     RED = object()
...     GREEN = object()
...     BLUE = object()
...
&gt;&gt;&gt; Color.GREEN
&lt;Color.GREEN&gt;
</pre>   <h4 id="using-a-descriptive-string">Using a descriptive string</h4> <p>Using a string as the value would look like:</p> <pre data-language="python">&gt;&gt;&gt; class Color(NoValue):
...     RED = 'stop'
...     GREEN = 'go'
...     BLUE = 'too fast!'
...
&gt;&gt;&gt; Color.GREEN
&lt;Color.GREEN&gt;
&gt;&gt;&gt; Color.GREEN.value
'go'
</pre>   <h4 id="using-a-custom-new">Using a custom <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a>
</h4> <p>Using an auto-numbering <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a> would look like:</p> <pre data-language="python">&gt;&gt;&gt; class AutoNumber(NoValue):
...     def __new__(cls):
...         value = len(cls.__members__) + 1
...         obj = object.__new__(cls)
...         obj._value_ = value
...         return obj
...
&gt;&gt;&gt; class Color(AutoNumber):
...     RED = ()
...     GREEN = ()
...     BLUE = ()
...
&gt;&gt;&gt; Color.GREEN
&lt;Color.GREEN&gt;
&gt;&gt;&gt; Color.GREEN.value
2
</pre> <p>To make a more general purpose <code>AutoNumber</code>, add <code>*args</code> to the signature:</p> <pre data-language="python">&gt;&gt;&gt; class AutoNumber(NoValue):
...     def __new__(cls, *args):      # this is the only change from above
...         value = len(cls.__members__) + 1
...         obj = object.__new__(cls)
...         obj._value_ = value
...         return obj
...
</pre> <p>Then when you inherit from <code>AutoNumber</code> you can write your own <code>__init__</code> to handle any extra arguments:</p> <pre data-language="python">&gt;&gt;&gt; class Swatch(AutoNumber):
...     def __init__(self, pantone='unknown'):
...         self.pantone = pantone
...     AUBURN = '3497'
...     SEA_GREEN = '1246'
...     BLEACHED_CORAL = () # New color, no Pantone code yet!
...
&gt;&gt;&gt; Swatch.SEA_GREEN
&lt;Swatch.SEA_GREEN: 2&gt;
&gt;&gt;&gt; Swatch.SEA_GREEN.pantone
'1246'
&gt;&gt;&gt; Swatch.BLEACHED_CORAL.pantone
'unknown'
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a> method, if defined, is used during creation of the Enum members; it is then replaced by Enum’s <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a> which is used after class creation for lookup of existing members.</p> </div>    <h3 id="orderedenum">OrderedEnum</h3> <p>An ordered enumeration that is not based on <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> and so maintains the normal <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> invariants (such as not being comparable to other enumerations):</p> <pre data-language="python">&gt;&gt;&gt; class OrderedEnum(Enum):
...     def __ge__(self, other):
...         if self.__class__ is other.__class__:
...             return self.value &gt;= other.value
...         return NotImplemented
...     def __gt__(self, other):
...         if self.__class__ is other.__class__:
...             return self.value &gt; other.value
...         return NotImplemented
...     def __le__(self, other):
...         if self.__class__ is other.__class__:
...             return self.value &lt;= other.value
...         return NotImplemented
...     def __lt__(self, other):
...         if self.__class__ is other.__class__:
...             return self.value &lt; other.value
...         return NotImplemented
...
&gt;&gt;&gt; class Grade(OrderedEnum):
...     A = 5
...     B = 4
...     C = 3
...     D = 2
...     F = 1
...
&gt;&gt;&gt; Grade.C &lt; Grade.A
True
</pre>   <h3 id="duplicatefreeenum">DuplicateFreeEnum</h3> <p>Raises an error if a duplicate member name is found instead of creating an alias:</p> <pre data-language="python">&gt;&gt;&gt; class DuplicateFreeEnum(Enum):
...     def __init__(self, *args):
...         cls = self.__class__
...         if any(self.value == e.value for e in cls):
...             a = self.name
...             e = cls(self.value).name
...             raise ValueError(
...                 "aliases not allowed in DuplicateFreeEnum:  %r --&gt; %r"
...                 % (a, e))
...
&gt;&gt;&gt; class Color(DuplicateFreeEnum):
...     RED = 1
...     GREEN = 2
...     BLUE = 3
...     GRENE = 2
...
Traceback (most recent call last):
...
ValueError: aliases not allowed in DuplicateFreeEnum:  'GRENE' --&gt; 'GREEN'
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This is a useful example for subclassing Enum to add or change other behaviors as well as disallowing aliases. If the only desired change is disallowing aliases, the <a class="reference internal" href="#enum.unique" title="enum.unique"><code>unique()</code></a> decorator can be used instead.</p> </div>   <h3 id="planet">Planet</h3> <p>If <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a> or <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> is defined the value of the enum member will be passed to those methods:</p> <pre data-language="python">&gt;&gt;&gt; class Planet(Enum):
...     MERCURY = (3.303e+23, 2.4397e6)
...     VENUS   = (4.869e+24, 6.0518e6)
...     EARTH   = (5.976e+24, 6.37814e6)
...     MARS    = (6.421e+23, 3.3972e6)
...     JUPITER = (1.9e+27,   7.1492e7)
...     SATURN  = (5.688e+26, 6.0268e7)
...     URANUS  = (8.686e+25, 2.5559e7)
...     NEPTUNE = (1.024e+26, 2.4746e7)
...     def __init__(self, mass, radius):
...         self.mass = mass       # in kilograms
...         self.radius = radius   # in meters
...     @property
...     def surface_gravity(self):
...         # universal gravitational constant  (m3 kg-1 s-2)
...         G = 6.67300E-11
...         return G * self.mass / (self.radius * self.radius)
...
&gt;&gt;&gt; Planet.EARTH.value
(5.976e+24, 6378140.0)
&gt;&gt;&gt; Planet.EARTH.surface_gravity
9.802652743337129
</pre>   <h3 id="timeperiod">TimePeriod</h3> <p>An example to show the <code>_ignore_</code> attribute in use:</p> <pre data-language="python">&gt;&gt;&gt; from datetime import timedelta
&gt;&gt;&gt; class Period(timedelta, Enum):
...     "different lengths of time"
...     _ignore_ = 'Period i'
...     Period = vars()
...     for i in range(367):
...         Period['day_%d' % i] = i
...
&gt;&gt;&gt; list(Period)[:2]
[&lt;Period.day_0: datetime.timedelta(0)&gt;, &lt;Period.day_1: datetime.timedelta(days=1)&gt;]
&gt;&gt;&gt; list(Period)[-2:]
[&lt;Period.day_365: datetime.timedelta(days=365)&gt;, &lt;Period.day_366: datetime.timedelta(days=366)&gt;]
</pre>    <h2 id="how-are-enums-different">How are Enums different?</h2> <p>Enums have a custom metaclass that affects many aspects of both derived Enum classes and their instances (members).</p>  <h3 id="enum-classes">Enum Classes</h3> <p>The <code>EnumMeta</code> metaclass is responsible for providing the <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__contains__" title="object.__contains__"><code>__contains__()</code></a>, <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__dir__" title="object.__dir__"><code>__dir__()</code></a>, <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__iter__" title="object.__iter__"><code>__iter__()</code></a> and other methods that allow one to do things with an <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class that fail on a typical class, such as <code>list(Color)</code> or <code>some_enum_var in Color</code>. <code>EnumMeta</code> is responsible for ensuring that various other methods on the final <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class are correct (such as <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a>, <a class="reference internal" href="pickle#object.__getnewargs__" title="object.__getnewargs__"><code>__getnewargs__()</code></a>, <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__str__" title="object.__str__"><code>__str__()</code></a> and <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__repr__" title="object.__repr__"><code>__repr__()</code></a>).</p>   <h3 id="enum-members-aka-instances">Enum Members (aka instances)</h3> <p>The most interesting thing about Enum members is that they are singletons. <code>EnumMeta</code> creates them all while it is creating the <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class itself, and then puts a custom <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a> in place to ensure that no new ones are ever instantiated by returning only the existing member instances.</p>   <h3 id="finer-points">Finer Points</h3>  <h4 id="supported-dunder-names">Supported <code>__dunder__</code> names</h4> <p><code>__members__</code> is a read-only ordered mapping of <code>member_name</code>:<code>member</code> items. It is only available on the class.</p> <p><a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__new__" title="object.__new__"><code>__new__()</code></a>, if specified, must create and return the enum members; it is also a very good idea to set the member’s <code>_value_</code> appropriately. Once all the members are created it is no longer used.</p>   <h4 id="supported-sunder-names">Supported <code>_sunder_</code> names</h4> <ul class="simple"> <li>
<code>_name_</code> – name of the member</li> <li>
<code>_value_</code> – value of the member; can be set / modified in <code>__new__</code>
</li> <li>
<code>_missing_</code> – a lookup function used when a value is not found; may be overridden</li> <li>
<code>_ignore_</code> – a list of names, either as a <a class="reference internal" href="stdtypes#list" title="list"><code>list</code></a> or a <a class="reference internal" href="stdtypes#str" title="str"><code>str</code></a>, that will not be transformed into members, and will be removed from the final class</li> <li>
<code>_order_</code> – used in Python 2/3 code to ensure member order is consistent (class attribute, removed during class creation)</li> <li>
<code>_generate_next_value_</code> – used by the <a class="reference internal" href="#functional-api">Functional API</a> and by <a class="reference internal" href="#enum.auto" title="enum.auto"><code>auto</code></a> to get an appropriate value for an enum member; may be overridden</li> </ul> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6: </span><code>_missing_</code>, <code>_order_</code>, <code>_generate_next_value_</code></p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.7: </span><code>_ignore_</code></p> </div> <p>To help keep Python 2 / Python 3 code in sync an <code>_order_</code> attribute can be provided. It will be checked against the actual order of the enumeration and raise an error if the two do not match:</p> <pre data-language="python">&gt;&gt;&gt; class Color(Enum):
...     _order_ = 'RED GREEN BLUE'
...     RED = 1
...     BLUE = 3
...     GREEN = 2
...
Traceback (most recent call last):
...
TypeError: member order does not match _order_
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In Python 2 code the <code>_order_</code> attribute is necessary as definition order is lost before it can be recorded.</p> </div>   <h4 id="private-names">_Private__names</h4> <p>Private names will be normal attributes in Python 3.10 instead of either an error or a member (depending on if the name ends with an underscore). Using these names in 3.9 will issue a <a class="reference internal" href="exceptions#DeprecationWarning" title="DeprecationWarning"><code>DeprecationWarning</code></a>.</p>   <h4 id="enum-member-type">
<code>Enum</code> member type</h4> <p><a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> members are instances of their <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class, and are normally accessed as <code>EnumClass.member</code>. Under certain circumstances they can also be accessed as <code>EnumClass.member.member</code>, but you should never do this as that lookup may fail or, worse, return something besides the <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> member you are looking for (this is another good reason to use all-uppercase names for members):</p> <pre data-language="python">&gt;&gt;&gt; class FieldTypes(Enum):
...     name = 0
...     value = 1
...     size = 2
...
&gt;&gt;&gt; FieldTypes.value.size
&lt;FieldTypes.size: 2&gt;
&gt;&gt;&gt; FieldTypes.size.value
2
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5.</span></p> </div>   <h4 id="boolean-value-of-enum-classes-and-members">Boolean value of <code>Enum</code> classes and members</h4> <p><a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> members that are mixed with non-<a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> types (such as <a class="reference internal" href="functions#int" title="int"><code>int</code></a>, <a class="reference internal" href="stdtypes#str" title="str"><code>str</code></a>, etc.) are evaluated according to the mixed-in type’s rules; otherwise, all members evaluate as <a class="reference internal" href="constants#True" title="True"><code>True</code></a>. To make your own Enum’s boolean evaluation depend on the member’s value add the following to your class:</p> <pre data-language="python">def __bool__(self):
    return bool(self.value)
</pre> <p><a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> classes always evaluate as <a class="reference internal" href="constants#True" title="True"><code>True</code></a>.</p>   <h4 id="enum-classes-with-methods">
<code>Enum</code> classes with methods</h4> <p>If you give your <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> subclass extra methods, like the <a class="reference internal" href="#planet">Planet</a> class above, those methods will show up in a <a class="reference internal" href="functions#dir" title="dir"><code>dir()</code></a> of the member, but not of the class:</p> <pre data-language="python">&gt;&gt;&gt; dir(Planet)
['EARTH', 'JUPITER', 'MARS', 'MERCURY', 'NEPTUNE', 'SATURN', 'URANUS', 'VENUS', '__class__', '__doc__', '__members__', '__module__']
&gt;&gt;&gt; dir(Planet.EARTH)
['__class__', '__doc__', '__module__', 'name', 'surface_gravity', 'value']
</pre>   <h4 id="combining-members-of-flag">Combining members of <code>Flag</code>
</h4> <p>If a combination of Flag members is not named, the <a class="reference internal" href="functions#repr" title="repr"><code>repr()</code></a> will include all named flags and all named combinations of flags that are in the value:</p> <pre data-language="python">&gt;&gt;&gt; class Color(Flag):
...     RED = auto()
...     GREEN = auto()
...     BLUE = auto()
...     MAGENTA = RED | BLUE
...     YELLOW = RED | GREEN
...     CYAN = GREEN | BLUE
...
&gt;&gt;&gt; Color(3)  # named combination
&lt;Color.YELLOW: 3&gt;
&gt;&gt;&gt; Color(7)      # not named combination
&lt;Color.CYAN|MAGENTA|BLUE|YELLOW|GREEN|RED: 7&gt;
</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2021 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.9/library/enum.html" class="_attribution-link">https://docs.python.org/3.9/library/enum.html</a>
  </p>
</div>
