<h1 id="pkgutil-package-extension-utility">pkgutil — Package extension utility</h1> <p id="module-pkgutil"><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/pkgutil.py">Lib/pkgutil.py</a></p>  <p>This module provides utilities for the import system, in particular package support.</p> <dl class="class"> <dt id="pkgutil.ModuleInfo">
<code>class pkgutil.ModuleInfo(module_finder, name, ispkg)</code> </dt> <dd>
<p>A namedtuple that holds a brief summary of a module’s info.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="pkgutil.extend_path">
<code>pkgutil.extend_path(path, name)</code> </dt> <dd>
<p>Extend the search path for the modules which comprise a package. Intended use is to place the following code in a package’s <code>__init__.py</code>:</p> <pre data-language="python">from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)
</pre> <p>This will add to the package’s <code>__path__</code> all subdirectories of directories on <code>sys.path</code> named after the package. This is useful if one wants to distribute different parts of a single logical package as multiple directories.</p> <p>It also looks for <code>*.pkg</code> files beginning where <code>*</code> matches the <em>name</em> argument. This feature is similar to <code>*.pth</code> files (see the <a class="reference internal" href="site#module-site" title="site: Module responsible for site-specific configuration."><code>site</code></a> module for more information), except that it doesn’t special-case lines starting with <code>import</code>. A <code>*.pkg</code> file is trusted at face value: apart from checking for duplicates, all entries found in a <code>*.pkg</code> file are added to the path, regardless of whether they exist on the filesystem. (This is a feature.)</p> <p>If the input path is not a list (as is the case for frozen packages) it is returned unchanged. The input path is not modified; an extended copy is returned. Items are only appended to the copy at the end.</p> <p>It is assumed that <a class="reference internal" href="sys#sys.path" title="sys.path"><code>sys.path</code></a> is a sequence. Items of <a class="reference internal" href="sys#sys.path" title="sys.path"><code>sys.path</code></a> that are not strings referring to existing directories are ignored. Unicode items on <a class="reference internal" href="sys#sys.path" title="sys.path"><code>sys.path</code></a> that cause errors when used as filenames may cause this function to raise an exception (in line with <a class="reference internal" href="os.path#os.path.isdir" title="os.path.isdir"><code>os.path.isdir()</code></a> behavior).</p> </dd>
</dl> <dl class="class"> <dt id="pkgutil.ImpImporter">
<code>class pkgutil.ImpImporter(dirname=None)</code> </dt> <dd>
<p><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302" id="index-0"><strong>PEP 302</strong></a> Finder that wraps Python’s “classic” import algorithm.</p> <p>If <em>dirname</em> is a string, a <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302" id="index-1"><strong>PEP 302</strong></a> finder is created that searches that directory. If <em>dirname</em> is <code>None</code>, a <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302" id="index-2"><strong>PEP 302</strong></a> finder is created that searches the current <a class="reference internal" href="sys#sys.path" title="sys.path"><code>sys.path</code></a>, plus any modules that are frozen or built-in.</p> <p>Note that <a class="reference internal" href="#pkgutil.ImpImporter" title="pkgutil.ImpImporter"><code>ImpImporter</code></a> does not currently support being used by placement on <a class="reference internal" href="sys#sys.meta_path" title="sys.meta_path"><code>sys.meta_path</code></a>.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.3: </span>This emulation is no longer needed, as the standard import mechanism is now fully <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302" id="index-3"><strong>PEP 302</strong></a> compliant and available in <a class="reference internal" href="importlib#module-importlib" title="importlib: The implementation of the import machinery."><code>importlib</code></a>.</p> </div> </dd>
</dl> <dl class="class"> <dt id="pkgutil.ImpLoader">
<code>class pkgutil.ImpLoader(fullname, file, filename, etc)</code> </dt> <dd>
<p><a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-loader"><span class="xref std std-term">Loader</span></a> that wraps Python’s “classic” import algorithm.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.3: </span>This emulation is no longer needed, as the standard import mechanism is now fully <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302" id="index-4"><strong>PEP 302</strong></a> compliant and available in <a class="reference internal" href="importlib#module-importlib" title="importlib: The implementation of the import machinery."><code>importlib</code></a>.</p> </div> </dd>
</dl> <dl class="function"> <dt id="pkgutil.find_loader">
<code>pkgutil.find_loader(fullname)</code> </dt> <dd>
<p>Retrieve a module <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-loader"><span class="xref std std-term">loader</span></a> for the given <em>fullname</em>.</p> <p>This is a backwards compatibility wrapper around <a class="reference internal" href="importlib#importlib.util.find_spec" title="importlib.util.find_spec"><code>importlib.util.find_spec()</code></a> that converts most failures to <a class="reference internal" href="exceptions#ImportError" title="ImportError"><code>ImportError</code></a> and only returns the loader rather than the full <code>ModuleSpec</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Updated to be based directly on <a class="reference internal" href="importlib#module-importlib" title="importlib: The implementation of the import machinery."><code>importlib</code></a> rather than relying on the package internal <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302" id="index-5"><strong>PEP 302</strong></a> import emulation.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Updated to be based on <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0451" id="index-6"><strong>PEP 451</strong></a></p> </div> </dd>
</dl> <dl class="function"> <dt id="pkgutil.get_importer">
<code>pkgutil.get_importer(path_item)</code> </dt> <dd>
<p>Retrieve a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-finder"><span class="xref std std-term">finder</span></a> for the given <em>path_item</em>.</p> <p>The returned finder is cached in <a class="reference internal" href="sys#sys.path_importer_cache" title="sys.path_importer_cache"><code>sys.path_importer_cache</code></a> if it was newly created by a path hook.</p> <p>The cache (or part of it) can be cleared manually if a rescan of <a class="reference internal" href="sys#sys.path_hooks" title="sys.path_hooks"><code>sys.path_hooks</code></a> is necessary.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Updated to be based directly on <a class="reference internal" href="importlib#module-importlib" title="importlib: The implementation of the import machinery."><code>importlib</code></a> rather than relying on the package internal <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302" id="index-7"><strong>PEP 302</strong></a> import emulation.</p> </div> </dd>
</dl> <dl class="function"> <dt id="pkgutil.get_loader">
<code>pkgutil.get_loader(module_or_name)</code> </dt> <dd>
<p>Get a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-loader"><span class="xref std std-term">loader</span></a> object for <em>module_or_name</em>.</p> <p>If the module or package is accessible via the normal import mechanism, a wrapper around the relevant part of that machinery is returned. Returns <code>None</code> if the module cannot be found or imported. If the named module is not already imported, its containing package (if any) is imported, in order to establish the package <code>__path__</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Updated to be based directly on <a class="reference internal" href="importlib#module-importlib" title="importlib: The implementation of the import machinery."><code>importlib</code></a> rather than relying on the package internal <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302" id="index-8"><strong>PEP 302</strong></a> import emulation.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>Updated to be based on <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0451" id="index-9"><strong>PEP 451</strong></a></p> </div> </dd>
</dl> <dl class="function"> <dt id="pkgutil.iter_importers">
<code>pkgutil.iter_importers(fullname='')</code> </dt> <dd>
<p>Yield <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-finder"><span class="xref std std-term">finder</span></a> objects for the given module name.</p> <p>If fullname contains a ‘.’, the finders will be for the package containing fullname, otherwise they will be all registered top level finders (i.e. those on both sys.meta_path and sys.path_hooks).</p> <p>If the named module is in a package, that package is imported as a side effect of invoking this function.</p> <p>If no module name is specified, all top level finders are produced.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Updated to be based directly on <a class="reference internal" href="importlib#module-importlib" title="importlib: The implementation of the import machinery."><code>importlib</code></a> rather than relying on the package internal <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302" id="index-10"><strong>PEP 302</strong></a> import emulation.</p> </div> </dd>
</dl> <dl class="function"> <dt id="pkgutil.iter_modules">
<code>pkgutil.iter_modules(path=None, prefix='')</code> </dt> <dd>
<p>Yields <a class="reference internal" href="#pkgutil.ModuleInfo" title="pkgutil.ModuleInfo"><code>ModuleInfo</code></a> for all submodules on <em>path</em>, or, if <em>path</em> is <code>None</code>, all top-level modules on <code>sys.path</code>.</p> <p><em>path</em> should be either <code>None</code> or a list of paths to look for modules in.</p> <p><em>prefix</em> is a string to output on the front of every module name on output.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Only works for a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-finder"><span class="xref std std-term">finder</span></a> which defines an <code>iter_modules()</code> method. This interface is non-standard, so the module also provides implementations for <a class="reference internal" href="importlib#importlib.machinery.FileFinder" title="importlib.machinery.FileFinder"><code>importlib.machinery.FileFinder</code></a> and <a class="reference internal" href="zipimport#zipimport.zipimporter" title="zipimport.zipimporter"><code>zipimport.zipimporter</code></a>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Updated to be based directly on <a class="reference internal" href="importlib#module-importlib" title="importlib: The implementation of the import machinery."><code>importlib</code></a> rather than relying on the package internal <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302" id="index-11"><strong>PEP 302</strong></a> import emulation.</p> </div> </dd>
</dl> <dl class="function"> <dt id="pkgutil.walk_packages">
<code>pkgutil.walk_packages(path=None, prefix='', onerror=None)</code> </dt> <dd>
<p>Yields <a class="reference internal" href="#pkgutil.ModuleInfo" title="pkgutil.ModuleInfo"><code>ModuleInfo</code></a> for all modules recursively on <em>path</em>, or, if <em>path</em> is <code>None</code>, all accessible modules.</p> <p><em>path</em> should be either <code>None</code> or a list of paths to look for modules in.</p> <p><em>prefix</em> is a string to output on the front of every module name on output.</p> <p>Note that this function must import all <em>packages</em> (<em>not</em> all modules!) on the given <em>path</em>, in order to access the <code>__path__</code> attribute to find submodules.</p> <p><em>onerror</em> is a function which gets called with one argument (the name of the package which was being imported) if any exception occurs while trying to import a package. If no <em>onerror</em> function is supplied, <a class="reference internal" href="exceptions#ImportError" title="ImportError"><code>ImportError</code></a>s are caught and ignored, while all other exceptions are propagated, terminating the search.</p> <p>Examples:</p> <pre data-language="python"># list all modules python can access
walk_packages()

# list all submodules of ctypes
walk_packages(ctypes.__path__, ctypes.__name__ + '.')
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Only works for a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-finder"><span class="xref std std-term">finder</span></a> which defines an <code>iter_modules()</code> method. This interface is non-standard, so the module also provides implementations for <a class="reference internal" href="importlib#importlib.machinery.FileFinder" title="importlib.machinery.FileFinder"><code>importlib.machinery.FileFinder</code></a> and <a class="reference internal" href="zipimport#zipimport.zipimporter" title="zipimport.zipimporter"><code>zipimport.zipimporter</code></a>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Updated to be based directly on <a class="reference internal" href="importlib#module-importlib" title="importlib: The implementation of the import machinery."><code>importlib</code></a> rather than relying on the package internal <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0302" id="index-12"><strong>PEP 302</strong></a> import emulation.</p> </div> </dd>
</dl> <dl class="function"> <dt id="pkgutil.get_data">
<code>pkgutil.get_data(package, resource)</code> </dt> <dd>
<p>Get a resource from a package.</p> <p>This is a wrapper for the <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-loader"><span class="xref std std-term">loader</span></a> <a class="reference internal" href="importlib#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code>get_data</code></a> API. The <em>package</em> argument should be the name of a package, in standard module format (<code>foo.bar</code>). The <em>resource</em> argument should be in the form of a relative filename, using <code>/</code> as the path separator. The parent directory name <code>..</code> is not allowed, and nor is a rooted name (starting with a <code>/</code>).</p> <p>The function returns a binary string that is the contents of the specified resource.</p> <p>For packages located in the filesystem, which have already been imported, this is the rough equivalent of:</p> <pre data-language="python">d = os.path.dirname(sys.modules[package].__file__)
data = open(os.path.join(d, resource), 'rb').read()
</pre> <p>If the package cannot be located or loaded, or it uses a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-loader"><span class="xref std std-term">loader</span></a> which does not support <a class="reference internal" href="importlib#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code>get_data</code></a>, then <code>None</code> is returned. In particular, the <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-loader"><span class="xref std std-term">loader</span></a> for <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-namespace-package"><span class="xref std std-term">namespace packages</span></a> does not support <a class="reference internal" href="importlib#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code>get_data</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="pkgutil.resolve_name">
<code>pkgutil.resolve_name(name)</code> </dt> <dd>
<p>Resolve a name to an object.</p> <p>This functionality is used in numerous places in the standard library (see <a class="reference external" href="https://bugs.python.org/issue12915">bpo-12915</a>) - and equivalent functionality is also in widely used third-party packages such as setuptools, Django and Pyramid.</p> <p>It is expected that <em>name</em> will be a string in one of the following formats, where W is shorthand for a valid Python identifier and dot stands for a literal period in these pseudo-regexes:</p> <ul class="simple"> <li><code>W(.W)*</code></li> <li><code>W(.W)*:(W(.W)*)?</code></li> </ul> <p>The first form is intended for backward compatibility only. It assumes that some part of the dotted name is a package, and the rest is an object somewhere within that package, possibly nested inside other objects. Because the place where the package stops and the object hierarchy starts can’t be inferred by inspection, repeated attempts to import must be done with this form.</p> <p>In the second form, the caller makes the division point clear through the provision of a single colon: the dotted name to the left of the colon is a package to be imported, and the dotted name to the right is the object hierarchy within that package. Only one import is needed in this form. If it ends with the colon, then a module object is returned.</p> <p>The function will return an object (which might be a module), or raise one of the following exceptions:</p> <p><a class="reference internal" href="exceptions#ValueError" title="ValueError"><code>ValueError</code></a> – if <em>name</em> isn’t in a recognised format.</p> <p><a class="reference internal" href="exceptions#ImportError" title="ImportError"><code>ImportError</code></a> – if an import failed when it shouldn’t have.</p> <p><a class="reference internal" href="exceptions#AttributeError" title="AttributeError"><code>AttributeError</code></a> – If a failure occurred when traversing the object hierarchy within the imported package to get to the desired object.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.9.</span></p> </div> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2021 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.9/library/pkgutil.html" class="_attribution-link">https://docs.python.org/3.9/library/pkgutil.html</a>
  </p>
</div>
