<h1 id="configparser-configuration-file-parser">configparser — Configuration file parser</h1> <p id="module-configparser"><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/configparser.py">Lib/configparser.py</a></p>  <p>This module provides the <a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code>ConfigParser</code></a> class which implements a basic configuration language which provides a structure similar to what’s found in Microsoft Windows INI files. You can use this to write Python programs which can be customized by end users easily.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This library does <em>not</em> interpret or write the value-type prefixes used in the Windows Registry extended version of INI syntax.</p> </div> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>Module</code> <a class="reference internal" href="shlex#module-shlex" title="shlex: Simple lexical analysis for Unix shell-like languages."><code>shlex</code></a>
</dt>
<dd>
<p>Support for creating Unix shell-like mini-languages which can be used as an alternate format for application configuration files.</p> </dd> <dt>
<code>Module</code> <a class="reference internal" href="json#module-json" title="json: Encode and decode the JSON format."><code>json</code></a>
</dt>
<dd>
<p>The json module implements a subset of JavaScript syntax which can also be used for this purpose.</p> </dd> </dl> </div>  <h2 id="quick-start">Quick Start</h2> <p>Let’s take a very basic configuration file that looks like this:</p> <pre data-language="ini">[DEFAULT]
ServerAliveInterval = 45
Compression = yes
CompressionLevel = 9
ForwardX11 = yes

[bitbucket.org]
User = hg

[topsecret.server.com]
Port = 50022
ForwardX11 = no
</pre> <p>The structure of INI files is described <a class="reference external" href="#supported-ini-file-structure">in the following section</a>. Essentially, the file consists of sections, each of which contains keys with values. <a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code>configparser</code></a> classes can read and write such files. Let’s start by creating the above configuration file programmatically.</p> <pre data-language="pycon3">&gt;&gt;&gt; import configparser
&gt;&gt;&gt; config = configparser.ConfigParser()
&gt;&gt;&gt; config['DEFAULT'] = {'ServerAliveInterval': '45',
...                      'Compression': 'yes',
...                      'CompressionLevel': '9'}
&gt;&gt;&gt; config['bitbucket.org'] = {}
&gt;&gt;&gt; config['bitbucket.org']['User'] = 'hg'
&gt;&gt;&gt; config['topsecret.server.com'] = {}
&gt;&gt;&gt; topsecret = config['topsecret.server.com']
&gt;&gt;&gt; topsecret['Port'] = '50022'     # mutates the parser
&gt;&gt;&gt; topsecret['ForwardX11'] = 'no'  # same here
&gt;&gt;&gt; config['DEFAULT']['ForwardX11'] = 'yes'
&gt;&gt;&gt; with open('example.ini', 'w') as configfile:
...   config.write(configfile)
...
</pre> <p>As you can see, we can treat a config parser much like a dictionary. There are differences, <a class="reference external" href="#mapping-protocol-access">outlined later</a>, but the behavior is very close to what you would expect from a dictionary.</p> <p>Now that we have created and saved a configuration file, let’s read it back and explore the data it holds.</p> <pre data-language="pycon3">&gt;&gt;&gt; config = configparser.ConfigParser()
&gt;&gt;&gt; config.sections()
[]
&gt;&gt;&gt; config.read('example.ini')
['example.ini']
&gt;&gt;&gt; config.sections()
['bitbucket.org', 'topsecret.server.com']
&gt;&gt;&gt; 'bitbucket.org' in config
True
&gt;&gt;&gt; 'bytebong.com' in config
False
&gt;&gt;&gt; config['bitbucket.org']['User']
'hg'
&gt;&gt;&gt; config['DEFAULT']['Compression']
'yes'
&gt;&gt;&gt; topsecret = config['topsecret.server.com']
&gt;&gt;&gt; topsecret['ForwardX11']
'no'
&gt;&gt;&gt; topsecret['Port']
'50022'
&gt;&gt;&gt; for key in config['bitbucket.org']:  
...     print(key)
user
compressionlevel
serveraliveinterval
compression
forwardx11
&gt;&gt;&gt; config['bitbucket.org']['ForwardX11']
'yes'
</pre> <p>As we can see above, the API is pretty straightforward. The only bit of magic involves the <code>DEFAULT</code> section which provides default values for all other sections <a class="footnote-reference brackets" href="#id14" id="id1">1</a>. Note also that keys in sections are case-insensitive and stored in lowercase <a class="footnote-reference brackets" href="#id14" id="id2">1</a>.</p>   <h2 id="supported-datatypes">Supported Datatypes</h2> <p>Config parsers do not guess datatypes of values in configuration files, always storing them internally as strings. This means that if you need other datatypes, you should convert on your own:</p> <pre data-language="pycon3">&gt;&gt;&gt; int(topsecret['Port'])
50022
&gt;&gt;&gt; float(topsecret['CompressionLevel'])
9.0
</pre> <p>Since this task is so common, config parsers provide a range of handy getter methods to handle integers, floats and booleans. The last one is the most interesting because simply passing the value to <code>bool()</code> would do no good since <code>bool('False')</code> is still <code>True</code>. This is why config parsers also provide <a class="reference internal" href="#configparser.ConfigParser.getboolean" title="configparser.ConfigParser.getboolean"><code>getboolean()</code></a>. This method is case-insensitive and recognizes Boolean values from <code>'yes'</code>/<code>'no'</code>, <code>'on'</code>/<code>'off'</code>, <code>'true'</code>/<code>'false'</code> and <code>'1'</code>/<code>'0'</code> <a class="footnote-reference brackets" href="#id14" id="id3">1</a>. For example:</p> <pre data-language="pycon3">&gt;&gt;&gt; topsecret.getboolean('ForwardX11')
False
&gt;&gt;&gt; config['bitbucket.org'].getboolean('ForwardX11')
True
&gt;&gt;&gt; config.getboolean('bitbucket.org', 'Compression')
True
</pre> <p>Apart from <a class="reference internal" href="#configparser.ConfigParser.getboolean" title="configparser.ConfigParser.getboolean"><code>getboolean()</code></a>, config parsers also provide equivalent <a class="reference internal" href="#configparser.ConfigParser.getint" title="configparser.ConfigParser.getint"><code>getint()</code></a> and <a class="reference internal" href="#configparser.ConfigParser.getfloat" title="configparser.ConfigParser.getfloat"><code>getfloat()</code></a> methods. You can register your own converters and customize the provided ones. <a class="footnote-reference brackets" href="#id14" id="id4">1</a></p>   <h2 id="fallback-values">Fallback Values</h2> <p>As with a dictionary, you can use a section’s <code>get()</code> method to provide fallback values:</p> <pre data-language="pycon3">&gt;&gt;&gt; topsecret.get('Port')
'50022'
&gt;&gt;&gt; topsecret.get('CompressionLevel')
'9'
&gt;&gt;&gt; topsecret.get('Cipher')
&gt;&gt;&gt; topsecret.get('Cipher', '3des-cbc')
'3des-cbc'
</pre> <p>Please note that default values have precedence over fallback values. For instance, in our example the <code>'CompressionLevel'</code> key was specified only in the <code>'DEFAULT'</code> section. If we try to get it from the section <code>'topsecret.server.com'</code>, we will always get the default, even if we specify a fallback:</p> <pre data-language="pycon3">&gt;&gt;&gt; topsecret.get('CompressionLevel', '3')
'9'
</pre> <p>One more thing to be aware of is that the parser-level <code>get()</code> method provides a custom, more complex interface, maintained for backwards compatibility. When using this method, a fallback value can be provided via the <code>fallback</code> keyword-only argument:</p> <pre data-language="pycon3">&gt;&gt;&gt; config.get('bitbucket.org', 'monster',
...            fallback='No such things as monsters')
'No such things as monsters'
</pre> <p>The same <code>fallback</code> argument can be used with the <a class="reference internal" href="#configparser.ConfigParser.getint" title="configparser.ConfigParser.getint"><code>getint()</code></a>, <a class="reference internal" href="#configparser.ConfigParser.getfloat" title="configparser.ConfigParser.getfloat"><code>getfloat()</code></a> and <a class="reference internal" href="#configparser.ConfigParser.getboolean" title="configparser.ConfigParser.getboolean"><code>getboolean()</code></a> methods, for example:</p> <pre data-language="pycon3">&gt;&gt;&gt; 'BatchMode' in topsecret
False
&gt;&gt;&gt; topsecret.getboolean('BatchMode', fallback=True)
True
&gt;&gt;&gt; config['DEFAULT']['BatchMode'] = 'no'
&gt;&gt;&gt; topsecret.getboolean('BatchMode', fallback=True)
False
</pre>   <h2 id="supported-ini-file-structure">Supported INI File Structure</h2> <p>A configuration file consists of sections, each led by a <code>[section]</code> header, followed by key/value entries separated by a specific string (<code>=</code> or <code>:</code> by default <a class="footnote-reference brackets" href="#id14" id="id5">1</a>). By default, section names are case sensitive but keys are not <a class="footnote-reference brackets" href="#id14" id="id6">1</a>. Leading and trailing whitespace is removed from keys and values. Values can be omitted, in which case the key/value delimiter may also be left out. Values can also span multiple lines, as long as they are indented deeper than the first line of the value. Depending on the parser’s mode, blank lines may be treated as parts of multiline values or ignored.</p> <p>Configuration files may include comments, prefixed by specific characters (<code>#</code> and <code>;</code> by default <a class="footnote-reference brackets" href="#id14" id="id7">1</a>). Comments may appear on their own on an otherwise empty line, possibly indented. <a class="footnote-reference brackets" href="#id14" id="id8">1</a></p> <p>For example:</p> <pre data-language="ini">[Simple Values]
key=value
spaces in keys=allowed
spaces in values=allowed as well
spaces around the delimiter = obviously
you can also use : to delimit keys from values

[All Values Are Strings]
values like this: 1000000
or this: 3.14159265359
are they treated as numbers? : no
integers, floats and booleans are held as: strings
can use the API to get converted values directly: true

[Multiline Values]
chorus: I'm a lumberjack, and I'm okay
    I sleep all night and I work all day

[No Values]
key_without_value
empty string value here =

[You can use comments]
# like this
; or this

# By default only in an empty line.
# Inline comments can be harmful because they prevent users
# from using the delimiting characters as parts of values.
# That being said, this can be customized.

    [Sections Can Be Indented]
        can_values_be_as_well = True
        does_that_mean_anything_special = False
        purpose = formatting for readability
        multiline_values = are
            handled just fine as
            long as they are indented
            deeper than the first line
            of a value
        # Did I mention we can indent comments, too?
</pre>   <h2 id="interpolation-of-values">Interpolation of values</h2> <p>On top of the core functionality, <a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code>ConfigParser</code></a> supports interpolation. This means values can be preprocessed before returning them from <code>get()</code> calls.</p> <dl class="class"> <dt id="configparser.BasicInterpolation">
<code>class configparser.BasicInterpolation</code> </dt> <dd>
<p>The default implementation used by <a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code>ConfigParser</code></a>. It enables values to contain format strings which refer to other values in the same section, or values in the special default section <a class="footnote-reference brackets" href="#id14" id="id9">1</a>. Additional default values can be provided on initialization.</p> <p>For example:</p> <pre data-language="ini">[Paths]
home_dir: /Users
my_dir: %(home_dir)s/lumberjack
my_pictures: %(my_dir)s/Pictures

[Escape]
gain: 80%%  # use a %% to escape the % sign (% is the only character that needs to be escaped)
</pre> <p>In the example above, <a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code>ConfigParser</code></a> with <em>interpolation</em> set to <code>BasicInterpolation()</code> would resolve <code>%(home_dir)s</code> to the value of <code>home_dir</code> (<code>/Users</code> in this case). <code>%(my_dir)s</code> in effect would resolve to <code>/Users/lumberjack</code>. All interpolations are done on demand so keys used in the chain of references do not have to be specified in any specific order in the configuration file.</p> <p>With <code>interpolation</code> set to <code>None</code>, the parser would simply return <code>%(my_dir)s/Pictures</code> as the value of <code>my_pictures</code> and <code>%(home_dir)s/lumberjack</code> as the value of <code>my_dir</code>.</p> </dd>
</dl> <dl class="class"> <dt id="configparser.ExtendedInterpolation">
<code>class configparser.ExtendedInterpolation</code> </dt> <dd>
<p>An alternative handler for interpolation which implements a more advanced syntax, used for instance in <code>zc.buildout</code>. Extended interpolation is using <code>${section:option}</code> to denote a value from a foreign section. Interpolation can span multiple levels. For convenience, if the <code>section:</code> part is omitted, interpolation defaults to the current section (and possibly the default values from the special section).</p> <p>For example, the configuration specified above with basic interpolation, would look like this with extended interpolation:</p> <pre data-language="ini">[Paths]
home_dir: /Users
my_dir: ${home_dir}/lumberjack
my_pictures: ${my_dir}/Pictures

[Escape]
cost: $$80  # use a $$ to escape the $ sign ($ is the only character that needs to be escaped)
</pre> <p>Values from other sections can be fetched as well:</p> <pre data-language="ini">[Common]
home_dir: /Users
library_dir: /Library
system_dir: /System
macports_dir: /opt/local

[Frameworks]
Python: 3.2
path: ${Common:system_dir}/Library/Frameworks/

[Arthur]
nickname: Two Sheds
last_name: Jackson
my_dir: ${Common:home_dir}/twosheds
my_pictures: ${my_dir}/Pictures
python_dir: ${Frameworks:path}/Python/Versions/${Frameworks:Python}
</pre> </dd>
</dl>   <h2 id="mapping-protocol-access">Mapping Protocol Access</h2> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> <p>Mapping protocol access is a generic name for functionality that enables using custom objects as if they were dictionaries. In case of <a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code>configparser</code></a>, the mapping interface implementation is using the <code>parser['section']['option']</code> notation.</p> <p><code>parser['section']</code> in particular returns a proxy for the section’s data in the parser. This means that the values are not copied but they are taken from the original parser on demand. What’s even more important is that when values are changed on a section proxy, they are actually mutated in the original parser.</p> <p><a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code>configparser</code></a> objects behave as close to actual dictionaries as possible. The mapping interface is complete and adheres to the <a class="reference internal" href="collections.abc#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code>MutableMapping</code></a> ABC. However, there are a few differences that should be taken into account:</p> <ul> <li>
<p>By default, all keys in sections are accessible in a case-insensitive manner <a class="footnote-reference brackets" href="#id14" id="id10">1</a>. E.g. <code>for option in parser["section"]</code> yields only <code>optionxform</code>’ed option key names. This means lowercased keys by default. At the same time, for a section that holds the key <code>'a'</code>, both expressions return <code>True</code>:</p> <pre data-language="python">"a" in parser["section"]
"A" in parser["section"]
</pre> </li> <li>All sections include <code>DEFAULTSECT</code> values as well which means that <code>.clear()</code> on a section may not leave the section visibly empty. This is because default values cannot be deleted from the section (because technically they are not there). If they are overridden in the section, deleting causes the default value to be visible again. Trying to delete a default value causes a <a class="reference internal" href="exceptions#KeyError" title="KeyError"><code>KeyError</code></a>.</li> <li>
<p><code>DEFAULTSECT</code> cannot be removed from the parser:</p> <ul class="simple"> <li>trying to delete it raises <a class="reference internal" href="exceptions#ValueError" title="ValueError"><code>ValueError</code></a>,</li> <li>
<code>parser.clear()</code> leaves it intact,</li> <li>
<code>parser.popitem()</code> never returns it.</li> </ul> </li> <li>
<code>parser.get(section, option, **kwargs)</code> - the second argument is <strong>not</strong> a fallback value. Note however that the section-level <code>get()</code> methods are compatible both with the mapping protocol and the classic configparser API.</li> <li>
<code>parser.items()</code> is compatible with the mapping protocol (returns a list of <em>section_name</em>, <em>section_proxy</em> pairs including the DEFAULTSECT). However, this method can also be invoked with arguments: <code>parser.items(section, raw,
vars)</code>. The latter call returns a list of <em>option</em>, <em>value</em> pairs for a specified <code>section</code>, with all interpolations expanded (unless <code>raw=True</code> is provided).</li> </ul> <p>The mapping protocol is implemented on top of the existing legacy API so that subclasses overriding the original interface still should have mappings working as expected.</p>   <h2 id="customizing-parser-behaviour">Customizing Parser Behaviour</h2> <p>There are nearly as many INI format variants as there are applications using it. <a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code>configparser</code></a> goes a long way to provide support for the largest sensible set of INI styles available. The default functionality is mainly dictated by historical background and it’s very likely that you will want to customize some of the features.</p> <p>The most common way to change the way a specific config parser works is to use the <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> options:</p> <ul> <li>
<p><em>defaults</em>, default value: <code>None</code></p> <p>This option accepts a dictionary of key-value pairs which will be initially put in the <code>DEFAULT</code> section. This makes for an elegant way to support concise configuration files that don’t specify values which are the same as the documented default.</p> <p>Hint: if you want to specify default values for a specific section, use <code>read_dict()</code> before you read the actual file.</p> </li> <li>
<p><em>dict_type</em>, default value: <a class="reference internal" href="stdtypes#dict" title="dict"><code>dict</code></a></p> <p>This option has a major impact on how the mapping protocol will behave and how the written configuration files look. With the standard dictionary, every section is stored in the order they were added to the parser. Same goes for options within sections.</p> <p>An alternative dictionary type can be used for example to sort sections and options on write-back.</p> <p>Please note: there are ways to add a set of key-value pairs in a single operation. When you use a regular dictionary in those operations, the order of the keys will be ordered. For example:</p> <pre data-language="pycon3">&gt;&gt;&gt; parser = configparser.ConfigParser()
&gt;&gt;&gt; parser.read_dict({'section1': {'key1': 'value1',
...                                'key2': 'value2',
...                                'key3': 'value3'},
...                   'section2': {'keyA': 'valueA',
...                                'keyB': 'valueB',
...                                'keyC': 'valueC'},
...                   'section3': {'foo': 'x',
...                                'bar': 'y',
...                                'baz': 'z'}
... })
&gt;&gt;&gt; parser.sections()
['section1', 'section2', 'section3']
&gt;&gt;&gt; [option for option in parser['section3']]
['foo', 'bar', 'baz']
</pre> </li> <li>
<p><em>allow_no_value</em>, default value: <code>False</code></p> <p>Some configuration files are known to include settings without values, but which otherwise conform to the syntax supported by <a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code>configparser</code></a>. The <em>allow_no_value</em> parameter to the constructor can be used to indicate that such values should be accepted:</p> <pre data-language="pycon3">&gt;&gt;&gt; import configparser

&gt;&gt;&gt; sample_config = """
... [mysqld]
...   user = mysql
...   pid-file = /var/run/mysqld/mysqld.pid
...   skip-external-locking
...   old_passwords = 1
...   skip-bdb
...   # we don't need ACID today
...   skip-innodb
... """
&gt;&gt;&gt; config = configparser.ConfigParser(allow_no_value=True)
&gt;&gt;&gt; config.read_string(sample_config)

&gt;&gt;&gt; # Settings with values are treated as before:
&gt;&gt;&gt; config["mysqld"]["user"]
'mysql'

&gt;&gt;&gt; # Settings without values provide None:
&gt;&gt;&gt; config["mysqld"]["skip-bdb"]

&gt;&gt;&gt; # Settings which aren't specified still raise an error:
&gt;&gt;&gt; config["mysqld"]["does-not-exist"]
Traceback (most recent call last):
  ...
KeyError: 'does-not-exist'
</pre> </li> <li>
<p><em>delimiters</em>, default value: <code>('=', ':')</code></p> <p>Delimiters are substrings that delimit keys from values within a section. The first occurrence of a delimiting substring on a line is considered a delimiter. This means values (but not keys) can contain the delimiters.</p> <p>See also the <em>space_around_delimiters</em> argument to <a class="reference internal" href="#configparser.ConfigParser.write" title="configparser.ConfigParser.write"><code>ConfigParser.write()</code></a>.</p> </li> <li>
<em>comment_prefixes</em>, default value: <code>('#', ';')</code>
</li> <li>
<p><em>inline_comment_prefixes</em>, default value: <code>None</code></p> <p>Comment prefixes are strings that indicate the start of a valid comment within a config file. <em>comment_prefixes</em> are used only on otherwise empty lines (optionally indented) whereas <em>inline_comment_prefixes</em> can be used after every valid value (e.g. section names, options and empty lines as well). By default inline comments are disabled and <code>'#'</code> and <code>';'</code> are used as prefixes for whole line comments.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>In previous versions of <a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code>configparser</code></a> behaviour matched <code>comment_prefixes=('#',';')</code> and <code>inline_comment_prefixes=(';',)</code>.</p> </div> <p>Please note that config parsers don’t support escaping of comment prefixes so using <em>inline_comment_prefixes</em> may prevent users from specifying option values with characters used as comment prefixes. When in doubt, avoid setting <em>inline_comment_prefixes</em>. In any circumstances, the only way of storing comment prefix characters at the beginning of a line in multiline values is to interpolate the prefix, for example:</p> <pre data-language="python">&gt;&gt;&gt; from configparser import ConfigParser, ExtendedInterpolation
&gt;&gt;&gt; parser = ConfigParser(interpolation=ExtendedInterpolation())
&gt;&gt;&gt; # the default BasicInterpolation could be used as well
&gt;&gt;&gt; parser.read_string("""
... [DEFAULT]
... hash = #
...
... [hashes]
... shebang =
...   ${hash}!/usr/bin/env python
...   ${hash} -*- coding: utf-8 -*-
...
... extensions =
...   enabled_extension
...   another_extension
...   #disabled_by_comment
...   yet_another_extension
...
... interpolation not necessary = if # is not at line start
... even in multiline values = line #1
...   line #2
...   line #3
... """)
&gt;&gt;&gt; print(parser['hashes']['shebang'])

#!/usr/bin/env python
# -*- coding: utf-8 -*-
&gt;&gt;&gt; print(parser['hashes']['extensions'])

enabled_extension
another_extension
yet_another_extension
&gt;&gt;&gt; print(parser['hashes']['interpolation not necessary'])
if # is not at line start
&gt;&gt;&gt; print(parser['hashes']['even in multiline values'])
line #1
line #2
line #3
</pre> </li> <li>
<p><em>strict</em>, default value: <code>True</code></p> <p>When set to <code>True</code>, the parser will not allow for any section or option duplicates while reading from a single source (using <code>read_file()</code>, <code>read_string()</code> or <code>read_dict()</code>). It is recommended to use strict parsers in new applications.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>In previous versions of <a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code>configparser</code></a> behaviour matched <code>strict=False</code>.</p> </div> </li> <li>
<p><em>empty_lines_in_values</em>, default value: <code>True</code></p> <p>In config parsers, values can span multiple lines as long as they are indented more than the key that holds them. By default parsers also let empty lines to be parts of values. At the same time, keys can be arbitrarily indented themselves to improve readability. In consequence, when configuration files get big and complex, it is easy for the user to lose track of the file structure. Take for instance:</p> <pre data-language="ini">[Section]
key = multiline
  value with a gotcha

 this = is still a part of the multiline value of 'key'
</pre> <p>This can be especially problematic for the user to see if she’s using a proportional font to edit the file. That is why when your application does not need values with empty lines, you should consider disallowing them. This will make empty lines split keys every time. In the example above, it would produce two keys, <code>key</code> and <code>this</code>.</p> </li> <li>
<p><em>default_section</em>, default value: <code>configparser.DEFAULTSECT</code> (that is: <code>"DEFAULT"</code>)</p> <p>The convention of allowing a special section of default values for other sections or interpolation purposes is a powerful concept of this library, letting users create complex declarative configurations. This section is normally called <code>"DEFAULT"</code> but this can be customized to point to any other valid section name. Some typical values include: <code>"general"</code> or <code>"common"</code>. The name provided is used for recognizing default sections when reading from any source and is used when writing configuration back to a file. Its current value can be retrieved using the <code>parser_instance.default_section</code> attribute and may be modified at runtime (i.e. to convert files from one format to another).</p> </li> <li>
<p><em>interpolation</em>, default value: <code>configparser.BasicInterpolation</code></p> <p>Interpolation behaviour may be customized by providing a custom handler through the <em>interpolation</em> argument. <code>None</code> can be used to turn off interpolation completely, <code>ExtendedInterpolation()</code> provides a more advanced variant inspired by <code>zc.buildout</code>. More on the subject in the <a class="reference external" href="#interpolation-of-values">dedicated documentation section</a>. <a class="reference internal" href="#configparser.RawConfigParser" title="configparser.RawConfigParser"><code>RawConfigParser</code></a> has a default value of <code>None</code>.</p> </li> <li>
<p><em>converters</em>, default value: not set</p> <p>Config parsers provide option value getters that perform type conversion. By default <a class="reference internal" href="#configparser.ConfigParser.getint" title="configparser.ConfigParser.getint"><code>getint()</code></a>, <a class="reference internal" href="#configparser.ConfigParser.getfloat" title="configparser.ConfigParser.getfloat"><code>getfloat()</code></a>, and <a class="reference internal" href="#configparser.ConfigParser.getboolean" title="configparser.ConfigParser.getboolean"><code>getboolean()</code></a> are implemented. Should other getters be desirable, users may define them in a subclass or pass a dictionary where each key is a name of the converter and each value is a callable implementing said conversion. For instance, passing <code>{'decimal': decimal.Decimal}</code> would add <code>getdecimal()</code> on both the parser object and all section proxies. In other words, it will be possible to write both <code>parser_instance.getdecimal('section', 'key', fallback=0)</code> and <code>parser_instance['section'].getdecimal('key', 0)</code>.</p> <p>If the converter needs to access the state of the parser, it can be implemented as a method on a config parser subclass. If the name of this method starts with <code>get</code>, it will be available on all section proxies, in the dict-compatible form (see the <code>getdecimal()</code> example above).</p> </li> </ul> <p>More advanced customization may be achieved by overriding default values of these parser attributes. The defaults are defined on the classes, so they may be overridden by subclasses or by attribute assignment.</p> <dl class="attribute"> <dt id="configparser.ConfigParser.BOOLEAN_STATES">
<code>ConfigParser.BOOLEAN_STATES</code> </dt> <dd>
<p>By default when using <a class="reference internal" href="#configparser.ConfigParser.getboolean" title="configparser.ConfigParser.getboolean"><code>getboolean()</code></a>, config parsers consider the following values <code>True</code>: <code>'1'</code>, <code>'yes'</code>, <code>'true'</code>, <code>'on'</code> and the following values <code>False</code>: <code>'0'</code>, <code>'no'</code>, <code>'false'</code>, <code>'off'</code>. You can override this by specifying a custom dictionary of strings and their Boolean outcomes. For example:</p> <pre data-language="pycon3">&gt;&gt;&gt; custom = configparser.ConfigParser()
&gt;&gt;&gt; custom['section1'] = {'funky': 'nope'}
&gt;&gt;&gt; custom['section1'].getboolean('funky')
Traceback (most recent call last):
...
ValueError: Not a boolean: nope
&gt;&gt;&gt; custom.BOOLEAN_STATES = {'sure': True, 'nope': False}
&gt;&gt;&gt; custom['section1'].getboolean('funky')
False
</pre> <p>Other typical Boolean pairs include <code>accept</code>/<code>reject</code> or <code>enabled</code>/<code>disabled</code>.</p> </dd>
</dl> <dl class="method"> <dt>
<code>ConfigParser.optionxform(option)</code> </dt> <dd>
<p>This method transforms option names on every read, get, or set operation. The default converts the name to lowercase. This also means that when a configuration file gets written, all keys will be lowercase. Override this method if that’s unsuitable. For example:</p> <pre data-language="pycon3">&gt;&gt;&gt; config = """
... [Section1]
... Key = Value
...
... [Section2]
... AnotherKey = Value
... """
&gt;&gt;&gt; typical = configparser.ConfigParser()
&gt;&gt;&gt; typical.read_string(config)
&gt;&gt;&gt; list(typical['Section1'].keys())
['key']
&gt;&gt;&gt; list(typical['Section2'].keys())
['anotherkey']
&gt;&gt;&gt; custom = configparser.RawConfigParser()
&gt;&gt;&gt; custom.optionxform = lambda option: option
&gt;&gt;&gt; custom.read_string(config)
&gt;&gt;&gt; list(custom['Section1'].keys())
['Key']
&gt;&gt;&gt; list(custom['Section2'].keys())
['AnotherKey']
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The optionxform function transforms option names to a canonical form. This should be an idempotent function: if the name is already in canonical form, it should be returned unchanged.</p> </div> </dd>
</dl> <dl class="attribute"> <dt id="configparser.ConfigParser.SECTCRE">
<code>ConfigParser.SECTCRE</code> </dt> <dd>
<p>A compiled regular expression used to parse section headers. The default matches <code>[section]</code> to the name <code>"section"</code>. Whitespace is considered part of the section name, thus <code>[  larch  ]</code> will be read as a section of name <code>"  larch  "</code>. Override this attribute if that’s unsuitable. For example:</p> <pre data-language="pycon3">&gt;&gt;&gt; import re
&gt;&gt;&gt; config = """
... [Section 1]
... option = value
...
... [  Section 2  ]
... another = val
... """
&gt;&gt;&gt; typical = configparser.ConfigParser()
&gt;&gt;&gt; typical.read_string(config)
&gt;&gt;&gt; typical.sections()
['Section 1', '  Section 2  ']
&gt;&gt;&gt; custom = configparser.ConfigParser()
&gt;&gt;&gt; custom.SECTCRE = re.compile(r"\[ *(?P&lt;header&gt;[^]]+?) *\]")
&gt;&gt;&gt; custom.read_string(config)
&gt;&gt;&gt; custom.sections()
['Section 1', 'Section 2']
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>While ConfigParser objects also use an <code>OPTCRE</code> attribute for recognizing option lines, it’s not recommended to override it because that would interfere with constructor options <em>allow_no_value</em> and <em>delimiters</em>.</p> </div> </dd>
</dl>   <h2 id="legacy-api-examples">Legacy API Examples</h2> <p>Mainly because of backwards compatibility concerns, <a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code>configparser</code></a> provides also a legacy API with explicit <code>get</code>/<code>set</code> methods. While there are valid use cases for the methods outlined below, mapping protocol access is preferred for new projects. The legacy API is at times more advanced, low-level and downright counterintuitive.</p> <p>An example of writing to a configuration file:</p> <pre data-language="python">import configparser

config = configparser.RawConfigParser()

# Please note that using RawConfigParser's set functions, you can assign
# non-string values to keys internally, but will receive an error when
# attempting to write to a file or when you get it in non-raw mode. Setting
# values using the mapping protocol or ConfigParser's set() does not allow
# such assignments to take place.
config.add_section('Section1')
config.set('Section1', 'an_int', '15')
config.set('Section1', 'a_bool', 'true')
config.set('Section1', 'a_float', '3.1415')
config.set('Section1', 'baz', 'fun')
config.set('Section1', 'bar', 'Python')
config.set('Section1', 'foo', '%(bar)s is %(baz)s!')

# Writing our configuration file to 'example.cfg'
with open('example.cfg', 'w') as configfile:
    config.write(configfile)
</pre> <p>An example of reading the configuration file again:</p> <pre data-language="python">import configparser

config = configparser.RawConfigParser()
config.read('example.cfg')

# getfloat() raises an exception if the value is not a float
# getint() and getboolean() also do this for their respective types
a_float = config.getfloat('Section1', 'a_float')
an_int = config.getint('Section1', 'an_int')
print(a_float + an_int)

# Notice that the next output does not interpolate '%(bar)s' or '%(baz)s'.
# This is because we are using a RawConfigParser().
if config.getboolean('Section1', 'a_bool'):
    print(config.get('Section1', 'foo'))
</pre> <p>To get interpolation, use <a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code>ConfigParser</code></a>:</p> <pre data-language="python">import configparser

cfg = configparser.ConfigParser()
cfg.read('example.cfg')

# Set the optional *raw* argument of get() to True if you wish to disable
# interpolation in a single get operation.
print(cfg.get('Section1', 'foo', raw=False))  # -&gt; "Python is fun!"
print(cfg.get('Section1', 'foo', raw=True))   # -&gt; "%(bar)s is %(baz)s!"

# The optional *vars* argument is a dict with members that will take
# precedence in interpolation.
print(cfg.get('Section1', 'foo', vars={'bar': 'Documentation',
                                       'baz': 'evil'}))

# The optional *fallback* argument can be used to provide a fallback value
print(cfg.get('Section1', 'foo'))
      # -&gt; "Python is fun!"

print(cfg.get('Section1', 'foo', fallback='Monty is not.'))
      # -&gt; "Python is fun!"

print(cfg.get('Section1', 'monster', fallback='No such things as monsters.'))
      # -&gt; "No such things as monsters."

# A bare print(cfg.get('Section1', 'monster')) would raise NoOptionError
# but we can also use:

print(cfg.get('Section1', 'monster', fallback=None))
      # -&gt; None
</pre> <p>Default values are available in both types of ConfigParsers. They are used in interpolation if an option used is not defined elsewhere.</p> <pre data-language="python">import configparser

# New instance with 'bar' and 'baz' defaulting to 'Life' and 'hard' each
config = configparser.ConfigParser({'bar': 'Life', 'baz': 'hard'})
config.read('example.cfg')

print(config.get('Section1', 'foo'))     # -&gt; "Python is fun!"
config.remove_option('Section1', 'bar')
config.remove_option('Section1', 'baz')
print(config.get('Section1', 'foo'))     # -&gt; "Life is hard!"
</pre>   <h2 id="id11">ConfigParser Objects</h2> <dl class="class" id="configparser-objects"> <dt id="configparser.ConfigParser">
<code>class configparser.ConfigParser(defaults=None, dict_type=dict, allow_no_value=False, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section=configparser.DEFAULTSECT, interpolation=BasicInterpolation(), converters={})</code> </dt> <dd>
<p>The main configuration parser. When <em>defaults</em> is given, it is initialized into the dictionary of intrinsic defaults. When <em>dict_type</em> is given, it will be used to create the dictionary objects for the list of sections, for the options within a section, and for the default values.</p> <p>When <em>delimiters</em> is given, it is used as the set of substrings that divide keys from values. When <em>comment_prefixes</em> is given, it will be used as the set of substrings that prefix comments in otherwise empty lines. Comments can be indented. When <em>inline_comment_prefixes</em> is given, it will be used as the set of substrings that prefix comments in non-empty lines.</p> <p>When <em>strict</em> is <code>True</code> (the default), the parser won’t allow for any section or option duplicates while reading from a single source (file, string or dictionary), raising <a class="reference internal" href="#configparser.DuplicateSectionError" title="configparser.DuplicateSectionError"><code>DuplicateSectionError</code></a> or <a class="reference internal" href="#configparser.DuplicateOptionError" title="configparser.DuplicateOptionError"><code>DuplicateOptionError</code></a>. When <em>empty_lines_in_values</em> is <code>False</code> (default: <code>True</code>), each empty line marks the end of an option. Otherwise, internal empty lines of a multiline option are kept as part of the value. When <em>allow_no_value</em> is <code>True</code> (default: <code>False</code>), options without values are accepted; the value held for these is <code>None</code> and they are serialized without the trailing delimiter.</p> <p>When <em>default_section</em> is given, it specifies the name for the special section holding default values for other sections and interpolation purposes (normally named <code>"DEFAULT"</code>). This value can be retrieved and changed on runtime using the <code>default_section</code> instance attribute.</p> <p>Interpolation behaviour may be customized by providing a custom handler through the <em>interpolation</em> argument. <code>None</code> can be used to turn off interpolation completely, <code>ExtendedInterpolation()</code> provides a more advanced variant inspired by <code>zc.buildout</code>. More on the subject in the <a class="reference external" href="#interpolation-of-values">dedicated documentation section</a>.</p> <p>All option names used in interpolation will be passed through the <a class="reference internal" href="#configparser.ConfigParser.optionxform" title="configparser.ConfigParser.optionxform"><code>optionxform()</code></a> method just like any other option name reference. For example, using the default implementation of <a class="reference internal" href="#configparser.ConfigParser.optionxform" title="configparser.ConfigParser.optionxform"><code>optionxform()</code></a> (which converts option names to lower case), the values <code>foo %(bar)s</code> and <code>foo
%(BAR)s</code> are equivalent.</p> <p>When <em>converters</em> is given, it should be a dictionary where each key represents the name of a type converter and each value is a callable implementing the conversion from string to the desired datatype. Every converter gets its own corresponding <code>get*()</code> method on the parser object and section proxies.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.1: </span>The default <em>dict_type</em> is <a class="reference internal" href="collections#collections.OrderedDict" title="collections.OrderedDict"><code>collections.OrderedDict</code></a>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span><em>allow_no_value</em>, <em>delimiters</em>, <em>comment_prefixes</em>, <em>strict</em>, <em>empty_lines_in_values</em>, <em>default_section</em> and <em>interpolation</em> were added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>The <em>converters</em> argument was added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.7: </span>The <em>defaults</em> argument is read with <a class="reference internal" href="#configparser.ConfigParser.read_dict" title="configparser.ConfigParser.read_dict"><code>read_dict()</code></a>, providing consistent behavior across the parser: non-string keys and values are implicitly converted to strings.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>The default <em>dict_type</em> is <a class="reference internal" href="stdtypes#dict" title="dict"><code>dict</code></a>, since it now preserves insertion order.</p> </div> <dl class="method"> <dt id="configparser.ConfigParser.defaults">
<code>defaults()</code> </dt> <dd>
<p>Return a dictionary containing the instance-wide defaults.</p> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.sections">
<code>sections()</code> </dt> <dd>
<p>Return a list of the sections available; the <em>default section</em> is not included in the list.</p> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.add_section">
<code>add_section(section)</code> </dt> <dd>
<p>Add a section named <em>section</em> to the instance. If a section by the given name already exists, <a class="reference internal" href="#configparser.DuplicateSectionError" title="configparser.DuplicateSectionError"><code>DuplicateSectionError</code></a> is raised. If the <em>default section</em> name is passed, <a class="reference internal" href="exceptions#ValueError" title="ValueError"><code>ValueError</code></a> is raised. The name of the section must be a string; if not, <a class="reference internal" href="exceptions#TypeError" title="TypeError"><code>TypeError</code></a> is raised.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>Non-string section names raise <a class="reference internal" href="exceptions#TypeError" title="TypeError"><code>TypeError</code></a>.</p> </div> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.has_section">
<code>has_section(section)</code> </dt> <dd>
<p>Indicates whether the named <em>section</em> is present in the configuration. The <em>default section</em> is not acknowledged.</p> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.options">
<code>options(section)</code> </dt> <dd>
<p>Return a list of options available in the specified <em>section</em>.</p> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.has_option">
<code>has_option(section, option)</code> </dt> <dd>
<p>If the given <em>section</em> exists, and contains the given <em>option</em>, return <a class="reference internal" href="constants#True" title="True"><code>True</code></a>; otherwise return <a class="reference internal" href="constants#False" title="False"><code>False</code></a>. If the specified <em>section</em> is <a class="reference internal" href="constants#None" title="None"><code>None</code></a> or an empty string, DEFAULT is assumed.</p> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.read">
<code>read(filenames, encoding=None)</code> </dt> <dd>
<p>Attempt to read and parse an iterable of filenames, returning a list of filenames which were successfully parsed.</p> <p>If <em>filenames</em> is a string, a <a class="reference internal" href="stdtypes#bytes" title="bytes"><code>bytes</code></a> object or a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>, it is treated as a single filename. If a file named in <em>filenames</em> cannot be opened, that file will be ignored. This is designed so that you can specify an iterable of potential configuration file locations (for example, the current directory, the user’s home directory, and some system-wide directory), and all existing configuration files in the iterable will be read.</p> <p>If none of the named files exist, the <a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code>ConfigParser</code></a> instance will contain an empty dataset. An application which requires initial values to be loaded from a file should load the required file or files using <a class="reference internal" href="#configparser.ConfigParser.read_file" title="configparser.ConfigParser.read_file"><code>read_file()</code></a> before calling <a class="reference internal" href="#configparser.ConfigParser.read" title="configparser.ConfigParser.read"><code>read()</code></a> for any optional files:</p> <pre data-language="python">import configparser, os

config = configparser.ConfigParser()
config.read_file(open('defaults.cfg'))
config.read(['site.cfg', os.path.expanduser('~/.myapp.cfg')],
            encoding='cp1250')
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2: </span>The <em>encoding</em> parameter. Previously, all files were read using the default encoding for <a class="reference internal" href="functions#open" title="open"><code>open()</code></a>.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.1: </span>The <em>filenames</em> parameter accepts a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.7: </span>The <em>filenames</em> parameter accepts a <a class="reference internal" href="stdtypes#bytes" title="bytes"><code>bytes</code></a> object.</p> </div> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.read_file">
<code>read_file(f, source=None)</code> </dt> <dd>
<p>Read and parse configuration data from <em>f</em> which must be an iterable yielding Unicode strings (for example files opened in text mode).</p> <p>Optional argument <em>source</em> specifies the name of the file being read. If not given and <em>f</em> has a <code>name</code> attribute, that is used for <em>source</em>; the default is <code>'&lt;???&gt;'</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2: </span>Replaces <a class="reference internal" href="#configparser.ConfigParser.readfp" title="configparser.ConfigParser.readfp"><code>readfp()</code></a>.</p> </div> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.read_string">
<code>read_string(string, source='&lt;string&gt;')</code> </dt> <dd>
<p>Parse configuration data from a string.</p> <p>Optional argument <em>source</em> specifies a context-specific name of the string passed. If not given, <code>'&lt;string&gt;'</code> is used. This should commonly be a filesystem path or a URL.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.read_dict">
<code>read_dict(dictionary, source='&lt;dict&gt;')</code> </dt> <dd>
<p>Load configuration from any object that provides a dict-like <code>items()</code> method. Keys are section names, values are dictionaries with keys and values that should be present in the section. If the used dictionary type preserves order, sections and their keys will be added in order. Values are automatically converted to strings.</p> <p>Optional argument <em>source</em> specifies a context-specific name of the dictionary passed. If not given, <code>&lt;dict&gt;</code> is used.</p> <p>This method can be used to copy state between parsers.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.get">
<code>get(section, option, *, raw=False, vars=None[, fallback])</code> </dt> <dd>
<p>Get an <em>option</em> value for the named <em>section</em>. If <em>vars</em> is provided, it must be a dictionary. The <em>option</em> is looked up in <em>vars</em> (if provided), <em>section</em>, and in <em>DEFAULTSECT</em> in that order. If the key is not found and <em>fallback</em> is provided, it is used as a fallback value. <code>None</code> can be provided as a <em>fallback</em> value.</p> <p>All the <code>'%'</code> interpolations are expanded in the return values, unless the <em>raw</em> argument is true. Values for interpolation keys are looked up in the same manner as the option.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>Arguments <em>raw</em>, <em>vars</em> and <em>fallback</em> are keyword only to protect users from trying to use the third argument as the <em>fallback</em> fallback (especially when using the mapping protocol).</p> </div> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.getint">
<code>getint(section, option, *, raw=False, vars=None[, fallback])</code> </dt> <dd>
<p>A convenience method which coerces the <em>option</em> in the specified <em>section</em> to an integer. See <a class="reference internal" href="#configparser.ConfigParser.get" title="configparser.ConfigParser.get"><code>get()</code></a> for explanation of <em>raw</em>, <em>vars</em> and <em>fallback</em>.</p> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.getfloat">
<code>getfloat(section, option, *, raw=False, vars=None[, fallback])</code> </dt> <dd>
<p>A convenience method which coerces the <em>option</em> in the specified <em>section</em> to a floating point number. See <a class="reference internal" href="#configparser.ConfigParser.get" title="configparser.ConfigParser.get"><code>get()</code></a> for explanation of <em>raw</em>, <em>vars</em> and <em>fallback</em>.</p> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.getboolean">
<code>getboolean(section, option, *, raw=False, vars=None[, fallback])</code> </dt> <dd>
<p>A convenience method which coerces the <em>option</em> in the specified <em>section</em> to a Boolean value. Note that the accepted values for the option are <code>'1'</code>, <code>'yes'</code>, <code>'true'</code>, and <code>'on'</code>, which cause this method to return <code>True</code>, and <code>'0'</code>, <code>'no'</code>, <code>'false'</code>, and <code>'off'</code>, which cause it to return <code>False</code>. These string values are checked in a case-insensitive manner. Any other value will cause it to raise <a class="reference internal" href="exceptions#ValueError" title="ValueError"><code>ValueError</code></a>. See <a class="reference internal" href="#configparser.ConfigParser.get" title="configparser.ConfigParser.get"><code>get()</code></a> for explanation of <em>raw</em>, <em>vars</em> and <em>fallback</em>.</p> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.items">
<code>items(raw=False, vars=None)</code> </dt> <dt>
<code>items(section, raw=False, vars=None)</code> </dt> <dd>
<p>When <em>section</em> is not given, return a list of <em>section_name</em>, <em>section_proxy</em> pairs, including DEFAULTSECT.</p> <p>Otherwise, return a list of <em>name</em>, <em>value</em> pairs for the options in the given <em>section</em>. Optional arguments have the same meaning as for the <a class="reference internal" href="#configparser.ConfigParser.get" title="configparser.ConfigParser.get"><code>get()</code></a> method.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Items present in <em>vars</em> no longer appear in the result. The previous behaviour mixed actual parser options with variables provided for interpolation.</p> </div> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.set">
<code>set(section, option, value)</code> </dt> <dd>
<p>If the given section exists, set the given option to the specified value; otherwise raise <a class="reference internal" href="#configparser.NoSectionError" title="configparser.NoSectionError"><code>NoSectionError</code></a>. <em>option</em> and <em>value</em> must be strings; if not, <a class="reference internal" href="exceptions#TypeError" title="TypeError"><code>TypeError</code></a> is raised.</p> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.write">
<code>write(fileobject, space_around_delimiters=True)</code> </dt> <dd>
<p>Write a representation of the configuration to the specified <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>, which must be opened in text mode (accepting strings). This representation can be parsed by a future <a class="reference internal" href="#configparser.ConfigParser.read" title="configparser.ConfigParser.read"><code>read()</code></a> call. If <em>space_around_delimiters</em> is true, delimiters between keys and values are surrounded by spaces.</p> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.remove_option">
<code>remove_option(section, option)</code> </dt> <dd>
<p>Remove the specified <em>option</em> from the specified <em>section</em>. If the section does not exist, raise <a class="reference internal" href="#configparser.NoSectionError" title="configparser.NoSectionError"><code>NoSectionError</code></a>. If the option existed to be removed, return <a class="reference internal" href="constants#True" title="True"><code>True</code></a>; otherwise return <a class="reference internal" href="constants#False" title="False"><code>False</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.remove_section">
<code>remove_section(section)</code> </dt> <dd>
<p>Remove the specified <em>section</em> from the configuration. If the section in fact existed, return <code>True</code>. Otherwise return <code>False</code>.</p> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.optionxform">
<code>optionxform(option)</code> </dt> <dd>
<p>Transforms the option name <em>option</em> as found in an input file or as passed in by client code to the form that should be used in the internal structures. The default implementation returns a lower-case version of <em>option</em>; subclasses may override this or client code can set an attribute of this name on instances to affect this behavior.</p> <p>You don’t need to subclass the parser to use this method, you can also set it on an instance, to a function that takes a string argument and returns a string. Setting it to <code>str</code>, for example, would make option names case sensitive:</p> <pre data-language="python">cfgparser = ConfigParser()
cfgparser.optionxform = str
</pre> <p>Note that when reading configuration files, whitespace around the option names is stripped before <a class="reference internal" href="#configparser.ConfigParser.optionxform" title="configparser.ConfigParser.optionxform"><code>optionxform()</code></a> is called.</p> </dd>
</dl> <dl class="method"> <dt id="configparser.ConfigParser.readfp">
<code>readfp(fp, filename=None)</code> </dt> <dd>
<div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 3.2: </span>Use <a class="reference internal" href="#configparser.ConfigParser.read_file" title="configparser.ConfigParser.read_file"><code>read_file()</code></a> instead.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span><a class="reference internal" href="#configparser.ConfigParser.readfp" title="configparser.ConfigParser.readfp"><code>readfp()</code></a> now iterates on <em>fp</em> instead of calling <code>fp.readline()</code>.</p> </div> <p>For existing code calling <a class="reference internal" href="#configparser.ConfigParser.readfp" title="configparser.ConfigParser.readfp"><code>readfp()</code></a> with arguments which don’t support iteration, the following generator may be used as a wrapper around the file-like object:</p> <pre data-language="python">def readline_generator(fp):
    line = fp.readline()
    while line:
        yield line
        line = fp.readline()
</pre> <p>Instead of <code>parser.readfp(fp)</code> use <code>parser.read_file(readline_generator(fp))</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="data"> <dt id="configparser.MAX_INTERPOLATION_DEPTH">
<code>configparser.MAX_INTERPOLATION_DEPTH</code> </dt> <dd>
<p>The maximum depth for recursive interpolation for <code>get()</code> when the <em>raw</em> parameter is false. This is relevant only when the default <em>interpolation</em> is used.</p> </dd>
</dl>   <h2 id="id13">RawConfigParser Objects</h2> <dl class="class" id="rawconfigparser-objects"> <dt id="configparser.RawConfigParser">
<code>class configparser.RawConfigParser(defaults=None, dict_type=dict, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section=configparser.DEFAULTSECT[, interpolation])</code> </dt> <dd>
<p>Legacy variant of the <a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code>ConfigParser</code></a>. It has interpolation disabled by default and allows for non-string section names, option names, and values via its unsafe <code>add_section</code> and <code>set</code> methods, as well as the legacy <code>defaults=</code> keyword argument handling.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>The default <em>dict_type</em> is <a class="reference internal" href="stdtypes#dict" title="dict"><code>dict</code></a>, since it now preserves insertion order.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Consider using <a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code>ConfigParser</code></a> instead which checks types of the values to be stored internally. If you don’t want interpolation, you can use <code>ConfigParser(interpolation=None)</code>.</p> </div> <dl class="method"> <dt id="configparser.RawConfigParser.add_section">
<code>add_section(section)</code> </dt> <dd>
<p>Add a section named <em>section</em> to the instance. If a section by the given name already exists, <a class="reference internal" href="#configparser.DuplicateSectionError" title="configparser.DuplicateSectionError"><code>DuplicateSectionError</code></a> is raised. If the <em>default section</em> name is passed, <a class="reference internal" href="exceptions#ValueError" title="ValueError"><code>ValueError</code></a> is raised.</p> <p>Type of <em>section</em> is not checked which lets users create non-string named sections. This behaviour is unsupported and may cause internal errors.</p> </dd>
</dl> <dl class="method"> <dt id="configparser.RawConfigParser.set">
<code>set(section, option, value)</code> </dt> <dd>
<p>If the given section exists, set the given option to the specified value; otherwise raise <a class="reference internal" href="#configparser.NoSectionError" title="configparser.NoSectionError"><code>NoSectionError</code></a>. While it is possible to use <a class="reference internal" href="#configparser.RawConfigParser" title="configparser.RawConfigParser"><code>RawConfigParser</code></a> (or <a class="reference internal" href="#configparser.ConfigParser" title="configparser.ConfigParser"><code>ConfigParser</code></a> with <em>raw</em> parameters set to true) for <em>internal</em> storage of non-string values, full functionality (including interpolation and output to files) can only be achieved using string values.</p> <p>This method lets users assign non-string values to keys internally. This behaviour is unsupported and will cause errors when attempting to write to a file or get it in non-raw mode. <strong>Use the mapping protocol API</strong> which does not allow such assignments to take place.</p> </dd>
</dl> </dd>
</dl>   <h2 id="exceptions">Exceptions</h2> <dl class="exception"> <dt id="configparser.Error">
<code>exception configparser.Error</code> </dt> <dd>
<p>Base class for all other <a class="reference internal" href="#module-configparser" title="configparser: Configuration file parser."><code>configparser</code></a> exceptions.</p> </dd>
</dl> <dl class="exception"> <dt id="configparser.NoSectionError">
<code>exception configparser.NoSectionError</code> </dt> <dd>
<p>Exception raised when a specified section is not found.</p> </dd>
</dl> <dl class="exception"> <dt id="configparser.DuplicateSectionError">
<code>exception configparser.DuplicateSectionError</code> </dt> <dd>
<p>Exception raised if <code>add_section()</code> is called with the name of a section that is already present or in strict parsers when a section if found more than once in a single input file, string or dictionary.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2: </span>Optional <code>source</code> and <code>lineno</code> attributes and arguments to <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> were added.</p> </div> </dd>
</dl> <dl class="exception"> <dt id="configparser.DuplicateOptionError">
<code>exception configparser.DuplicateOptionError</code> </dt> <dd>
<p>Exception raised by strict parsers if a single option appears twice during reading from a single file, string or dictionary. This catches misspellings and case sensitivity-related errors, e.g. a dictionary may have two keys representing the same case-insensitive configuration key.</p> </dd>
</dl> <dl class="exception"> <dt id="configparser.NoOptionError">
<code>exception configparser.NoOptionError</code> </dt> <dd>
<p>Exception raised when a specified option is not found in the specified section.</p> </dd>
</dl> <dl class="exception"> <dt id="configparser.InterpolationError">
<code>exception configparser.InterpolationError</code> </dt> <dd>
<p>Base class for exceptions raised when problems occur performing string interpolation.</p> </dd>
</dl> <dl class="exception"> <dt id="configparser.InterpolationDepthError">
<code>exception configparser.InterpolationDepthError</code> </dt> <dd>
<p>Exception raised when string interpolation cannot be completed because the number of iterations exceeds <a class="reference internal" href="#configparser.MAX_INTERPOLATION_DEPTH" title="configparser.MAX_INTERPOLATION_DEPTH"><code>MAX_INTERPOLATION_DEPTH</code></a>. Subclass of <a class="reference internal" href="#configparser.InterpolationError" title="configparser.InterpolationError"><code>InterpolationError</code></a>.</p> </dd>
</dl> <dl class="exception"> <dt id="configparser.InterpolationMissingOptionError">
<code>exception configparser.InterpolationMissingOptionError</code> </dt> <dd>
<p>Exception raised when an option referenced from a value does not exist. Subclass of <a class="reference internal" href="#configparser.InterpolationError" title="configparser.InterpolationError"><code>InterpolationError</code></a>.</p> </dd>
</dl> <dl class="exception"> <dt id="configparser.InterpolationSyntaxError">
<code>exception configparser.InterpolationSyntaxError</code> </dt> <dd>
<p>Exception raised when the source text into which substitutions are made does not conform to the required syntax. Subclass of <a class="reference internal" href="#configparser.InterpolationError" title="configparser.InterpolationError"><code>InterpolationError</code></a>.</p> </dd>
</dl> <dl class="exception"> <dt id="configparser.MissingSectionHeaderError">
<code>exception configparser.MissingSectionHeaderError</code> </dt> <dd>
<p>Exception raised when attempting to parse a file which has no section headers.</p> </dd>
</dl> <dl class="exception"> <dt id="configparser.ParsingError">
<code>exception configparser.ParsingError</code> </dt> <dd>
<p>Exception raised when errors occur attempting to parse a file.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>The <code>filename</code> attribute and <a class="reference internal" href="https://docs.python.org/3.9/reference/datamodel.html#object.__init__" title="object.__init__"><code>__init__()</code></a> argument were renamed to <code>source</code> for consistency.</p> </div> </dd>
</dl> <h4 class="rubric">Footnotes</h4> <dl class="footnote brackets"> <dt class="label" id="id14">
<code>1(1,2,3,4,5,6,7,8,9,10)</code> </dt> <dd>
<p>Config parsers allow for heavy customization. If you are interested in changing the behaviour outlined by the footnote reference, consult the <a class="reference internal" href="#customizing-parser-behaviour">Customizing Parser Behaviour</a> section.</p> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2021 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.9/library/configparser.html" class="_attribution-link">https://docs.python.org/3.9/library/configparser.html</a>
  </p>
</div>
