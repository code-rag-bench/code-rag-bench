<h1 id="zipapp-manage-executable-python-zip-archives">zipapp — Manage executable Python zip archives</h1> <div class="versionadded" id="module-zipapp"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/zipapp.py">Lib/zipapp.py</a></p>  <p>This module provides tools to manage the creation of zip files containing Python code, which can be <a class="reference internal" href="https://docs.python.org/3.9/using/cmdline.html#using-on-interface-options"><span class="std std-ref">executed directly by the Python interpreter</span></a>. The module provides both a <a class="reference internal" href="#zipapp-command-line-interface"><span class="std std-ref">Command-Line Interface</span></a> and a <a class="reference internal" href="#zipapp-python-api"><span class="std std-ref">Python API</span></a>.</p>  <h2 id="basic-example">Basic Example</h2> <p>The following example shows how the <a class="reference internal" href="#zipapp-command-line-interface"><span class="std std-ref">Command-Line Interface</span></a> can be used to create an executable archive from a directory containing Python code. When run, the archive will execute the <code>main</code> function from the module <code>myapp</code> in the archive.</p> <pre data-language="shell">$ python -m zipapp myapp -m "myapp:main"
$ python myapp.pyz
&lt;output from myapp&gt;
</pre>   <h2 id="zipapp-command-line-interface">Command-Line Interface</h2> <p id="command-line-interface">When called as a program from the command line, the following form is used:</p> <pre data-language="shell">$ python -m zipapp source [options]
</pre> <p>If <em>source</em> is a directory, this will create an archive from the contents of <em>source</em>. If <em>source</em> is a file, it should be an archive, and it will be copied to the target archive (or the contents of its shebang line will be displayed if the –info option is specified).</p> <p>The following options are understood:</p> <dl class="cmdoption"> <dt id="cmdoption-zipapp-o">
<code>-o &lt;output&gt;, --output=&lt;output&gt;</code> </dt> <dd>
<p>Write the output to a file named <em>output</em>. If this option is not specified, the output filename will be the same as the input <em>source</em>, with the extension <code>.pyz</code> added. If an explicit filename is given, it is used as is (so a <code>.pyz</code> extension should be included if required).</p> <p>An output filename must be specified if the <em>source</em> is an archive (and in that case, <em>output</em> must not be the same as <em>source</em>).</p> </dd>
</dl> <dl class="cmdoption"> <dt id="cmdoption-zipapp-p">
<code>-p &lt;interpreter&gt;, --python=&lt;interpreter&gt;</code> </dt> <dd>
<p>Add a <code>#!</code> line to the archive specifying <em>interpreter</em> as the command to run. Also, on POSIX, make the archive executable. The default is to write no <code>#!</code> line, and not make the file executable.</p> </dd>
</dl> <dl class="cmdoption"> <dt id="cmdoption-zipapp-m">
<code>-m &lt;mainfn&gt;, --main=&lt;mainfn&gt;</code> </dt> <dd>
<p>Write a <code>__main__.py</code> file to the archive that executes <em>mainfn</em>. The <em>mainfn</em> argument should have the form “pkg.mod:fn”, where “pkg.mod” is a package/module in the archive, and “fn” is a callable in the given module. The <code>__main__.py</code> file will execute that callable.</p> <p><a class="reference internal" href="#cmdoption-zipapp-m"><code>--main</code></a> cannot be specified when copying an archive.</p> </dd>
</dl> <dl class="cmdoption"> <dt id="cmdoption-zipapp-c">
<code>-c, --compress</code> </dt> <dd>
<p>Compress files with the deflate method, reducing the size of the output file. By default, files are stored uncompressed in the archive.</p> <p><a class="reference internal" href="#cmdoption-zipapp-c"><code>--compress</code></a> has no effect when copying an archive.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.7.</span></p> </div> </dd>
</dl> <dl class="cmdoption"> <dt id="cmdoption-zipapp-info">
<code>--info</code> </dt> <dd>
<p>Display the interpreter embedded in the archive, for diagnostic purposes. In this case, any other options are ignored and SOURCE must be an archive, not a directory.</p> </dd>
</dl> <dl class="cmdoption"> <dt id="cmdoption-zipapp-h">
<code>-h, --help</code> </dt> <dd>
<p>Print a short usage message and exit.</p> </dd>
</dl>   <h2 id="zipapp-python-api">Python API</h2> <p id="python-api">The module defines two convenience functions:</p> <dl class="function"> <dt id="zipapp.create_archive">
<code>zipapp.create_archive(source, target=None, interpreter=None, main=None, filter=None, compressed=False)</code> </dt> <dd>
<p>Create an application archive from <em>source</em>. The source can be any of the following:</p> <ul class="simple"> <li>The name of a directory, or a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a> referring to a directory, in which case a new application archive will be created from the content of that directory.</li> <li>The name of an existing application archive file, or a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a> referring to such a file, in which case the file is copied to the target (modifying it to reflect the value given for the <em>interpreter</em> argument). The file name should include the <code>.pyz</code> extension, if required.</li> <li>A file object open for reading in bytes mode. The content of the file should be an application archive, and the file object is assumed to be positioned at the start of the archive.</li> </ul> <p>The <em>target</em> argument determines where the resulting archive will be written:</p> <ul class="simple"> <li>If it is the name of a file, or a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>, the archive will be written to that file.</li> <li>If it is an open file object, the archive will be written to that file object, which must be open for writing in bytes mode.</li> <li>If the target is omitted (or <code>None</code>), the source must be a directory and the target will be a file with the same name as the source, with a <code>.pyz</code> extension added.</li> </ul> <p>The <em>interpreter</em> argument specifies the name of the Python interpreter with which the archive will be executed. It is written as a “shebang” line at the start of the archive. On POSIX, this will be interpreted by the OS, and on Windows it will be handled by the Python launcher. Omitting the <em>interpreter</em> results in no shebang line being written. If an interpreter is specified, and the target is a filename, the executable bit of the target file will be set.</p> <p>The <em>main</em> argument specifies the name of a callable which will be used as the main program for the archive. It can only be specified if the source is a directory, and the source does not already contain a <code>__main__.py</code> file. The <em>main</em> argument should take the form “pkg.module:callable” and the archive will be run by importing “pkg.module” and executing the given callable with no arguments. It is an error to omit <em>main</em> if the source is a directory and does not contain a <code>__main__.py</code> file, as otherwise the resulting archive would not be executable.</p> <p>The optional <em>filter</em> argument specifies a callback function that is passed a Path object representing the path to the file being added (relative to the source directory). It should return <code>True</code> if the file is to be added.</p> <p>The optional <em>compressed</em> argument determines whether files are compressed. If set to <code>True</code>, files in the archive are compressed with the deflate method; otherwise, files are stored uncompressed. This argument has no effect when copying an existing archive.</p> <p>If a file object is specified for <em>source</em> or <em>target</em>, it is the caller’s responsibility to close it after calling create_archive.</p> <p>When copying an existing archive, file objects supplied only need <code>read</code> and <code>readline</code>, or <code>write</code> methods. When creating an archive from a directory, if the target is a file object it will be passed to the <code>zipfile.ZipFile</code> class, and must supply the methods needed by that class.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.7: </span>Added the <em>filter</em> and <em>compressed</em> arguments.</p> </div> </dd>
</dl> <dl class="function"> <dt id="zipapp.get_interpreter">
<code>zipapp.get_interpreter(archive)</code> </dt> <dd>
<p>Return the interpreter specified in the <code>#!</code> line at the start of the archive. If there is no <code>#!</code> line, return <a class="reference internal" href="constants#None" title="None"><code>None</code></a>. The <em>archive</em> argument can be a filename or a file-like object open for reading in bytes mode. It is assumed to be at the start of the archive.</p> </dd>
</dl>   <h2 id="zipapp-examples">Examples</h2> <p id="examples">Pack up a directory into an archive, and run it.</p> <pre data-language="shell">$ python -m zipapp myapp
$ python myapp.pyz
&lt;output from myapp&gt;
</pre> <p>The same can be done using the <a class="reference internal" href="#zipapp.create_archive" title="zipapp.create_archive"><code>create_archive()</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; import zipapp
&gt;&gt;&gt; zipapp.create_archive('myapp', 'myapp.pyz')
</pre> <p>To make the application directly executable on POSIX, specify an interpreter to use.</p> <pre data-language="shell">$ python -m zipapp myapp -p "/usr/bin/env python"
$ ./myapp.pyz
&lt;output from myapp&gt;
</pre> <p>To replace the shebang line on an existing archive, create a modified archive using the <a class="reference internal" href="#zipapp.create_archive" title="zipapp.create_archive"><code>create_archive()</code></a> function:</p> <pre data-language="python">&gt;&gt;&gt; import zipapp
&gt;&gt;&gt; zipapp.create_archive('old_archive.pyz', 'new_archive.pyz', '/usr/bin/python3')
</pre> <p>To update the file in place, do the replacement in memory using a <code>BytesIO</code> object, and then overwrite the source afterwards. Note that there is a risk when overwriting a file in place that an error will result in the loss of the original file. This code does not protect against such errors, but production code should do so. Also, this method will only work if the archive fits in memory:</p> <pre data-language="python">&gt;&gt;&gt; import zipapp
&gt;&gt;&gt; import io
&gt;&gt;&gt; temp = io.BytesIO()
&gt;&gt;&gt; zipapp.create_archive('myapp.pyz', temp, '/usr/bin/python2')
&gt;&gt;&gt; with open('myapp.pyz', 'wb') as f:
&gt;&gt;&gt;     f.write(temp.getvalue())
</pre>   <h2 id="zipapp-specifying-the-interpreter">Specifying the Interpreter</h2> <p id="specifying-the-interpreter">Note that if you specify an interpreter and then distribute your application archive, you need to ensure that the interpreter used is portable. The Python launcher for Windows supports most common forms of POSIX <code>#!</code> line, but there are other issues to consider:</p> <ul class="simple"> <li>If you use “/usr/bin/env python” (or other forms of the “python” command, such as “/usr/bin/python”), you need to consider that your users may have either Python 2 or Python 3 as their default, and write your code to work under both versions.</li> <li>If you use an explicit version, for example “/usr/bin/env python3” your application will not work for users who do not have that version. (This may be what you want if you have not made your code Python 2 compatible).</li> <li>There is no way to say “python X.Y or later”, so be careful of using an exact version like “/usr/bin/env python3.4” as you will need to change your shebang line for users of Python 3.5, for example.</li> </ul> <p>Typically, you should use an “/usr/bin/env python2” or “/usr/bin/env python3”, depending on whether your code is written for Python 2 or 3.</p>   <h2 id="creating-standalone-applications-with-zipapp">Creating Standalone Applications with zipapp</h2> <p>Using the <a class="reference internal" href="#module-zipapp" title="zipapp: Manage executable Python zip archives"><code>zipapp</code></a> module, it is possible to create self-contained Python programs, which can be distributed to end users who only need to have a suitable version of Python installed on their system. The key to doing this is to bundle all of the application’s dependencies into the archive, along with the application code.</p> <p>The steps to create a standalone archive are as follows:</p> <ol class="arabic"> <li>Create your application in a directory as normal, so you have a <code>myapp</code> directory containing a <code>__main__.py</code> file, and any supporting application code.</li> <li>
<p>Install all of your application’s dependencies into the <code>myapp</code> directory, using pip:</p> <pre data-language="shell">$ python -m pip install -r requirements.txt --target myapp
</pre> <p>(this assumes you have your project requirements in a <code>requirements.txt</code> file - if not, you can just list the dependencies manually on the pip command line).</p> </li> <li>Optionally, delete the <code>.dist-info</code> directories created by pip in the <code>myapp</code> directory. These hold metadata for pip to manage the packages, and as you won’t be making any further use of pip they aren’t required - although it won’t do any harm if you leave them.</li> <li>
<p>Package the application using:</p> <pre data-language="shell">$ python -m zipapp -p "interpreter" myapp
</pre> </li> </ol> <p>This will produce a standalone executable, which can be run on any machine with the appropriate interpreter available. See <a class="reference internal" href="#zipapp-specifying-the-interpreter"><span class="std std-ref">Specifying the Interpreter</span></a> for details. It can be shipped to users as a single file.</p> <p>On Unix, the <code>myapp.pyz</code> file is executable as it stands. You can rename the file to remove the <code>.pyz</code> extension if you prefer a “plain” command name. On Windows, the <code>myapp.pyz[w]</code> file is executable by virtue of the fact that the Python interpreter registers the <code>.pyz</code> and <code>.pyzw</code> file extensions when installed.</p>  <h3 id="making-a-windows-executable">Making a Windows executable</h3> <p>On Windows, registration of the <code>.pyz</code> extension is optional, and furthermore, there are certain places that don’t recognise registered extensions “transparently” (the simplest example is that <code>subprocess.run(['myapp'])</code> won’t find your application - you need to explicitly specify the extension).</p> <p>On Windows, therefore, it is often preferable to create an executable from the zipapp. This is relatively easy, although it does require a C compiler. The basic approach relies on the fact that zipfiles can have arbitrary data prepended, and Windows exe files can have arbitrary data appended. So by creating a suitable launcher and tacking the <code>.pyz</code> file onto the end of it, you end up with a single-file executable that runs your application.</p> <p>A suitable launcher can be as simple as the following:</p> <pre data-language="python">#define Py_LIMITED_API 1
#include "Python.h"

#define WIN32_LEAN_AND_MEAN
#include &lt;windows.h&gt;

#ifdef WINDOWS
int WINAPI wWinMain(
    HINSTANCE hInstance,      /* handle to current instance */
    HINSTANCE hPrevInstance,  /* handle to previous instance */
    LPWSTR lpCmdLine,         /* pointer to command line */
    int nCmdShow              /* show state of window */
)
#else
int wmain()
#endif
{
    wchar_t **myargv = _alloca((__argc + 1) * sizeof(wchar_t*));
    myargv[0] = __wargv[0];
    memcpy(myargv + 1, __wargv, __argc * sizeof(wchar_t *));
    return Py_Main(__argc+1, myargv);
}
</pre> <p>If you define the <code>WINDOWS</code> preprocessor symbol, this will generate a GUI executable, and without it, a console executable.</p> <p>To compile the executable, you can either just use the standard MSVC command line tools, or you can take advantage of the fact that distutils knows how to compile Python source:</p> <pre data-language="python">&gt;&gt;&gt; from distutils.ccompiler import new_compiler
&gt;&gt;&gt; import distutils.sysconfig
&gt;&gt;&gt; import sys
&gt;&gt;&gt; import os
&gt;&gt;&gt; from pathlib import Path

&gt;&gt;&gt; def compile(src):
&gt;&gt;&gt;     src = Path(src)
&gt;&gt;&gt;     cc = new_compiler()
&gt;&gt;&gt;     exe = src.stem
&gt;&gt;&gt;     cc.add_include_dir(distutils.sysconfig.get_python_inc())
&gt;&gt;&gt;     cc.add_library_dir(os.path.join(sys.base_exec_prefix, 'libs'))
&gt;&gt;&gt;     # First the CLI executable
&gt;&gt;&gt;     objs = cc.compile([str(src)])
&gt;&gt;&gt;     cc.link_executable(objs, exe)
&gt;&gt;&gt;     # Now the GUI executable
&gt;&gt;&gt;     cc.define_macro('WINDOWS')
&gt;&gt;&gt;     objs = cc.compile([str(src)])
&gt;&gt;&gt;     cc.link_executable(objs, exe + 'w')

&gt;&gt;&gt; if __name__ == "__main__":
&gt;&gt;&gt;     compile("zastub.c")
</pre> <p>The resulting launcher uses the “Limited ABI”, so it will run unchanged with any version of Python 3.x. All it needs is for Python (<code>python3.dll</code>) to be on the user’s <code>PATH</code>.</p> <p>For a fully standalone distribution, you can distribute the launcher with your application appended, bundled with the Python “embedded” distribution. This will run on any PC with the appropriate architecture (32 bit or 64 bit).</p>   <h3 id="caveats">Caveats</h3> <p>There are some limitations to the process of bundling your application into a single file. In most, if not all, cases they can be addressed without needing major changes to your application.</p> <ol class="arabic simple"> <li>If your application depends on a package that includes a C extension, that package cannot be run from a zip file (this is an OS limitation, as executable code must be present in the filesystem for the OS loader to load it). In this case, you can exclude that dependency from the zipfile, and either require your users to have it installed, or ship it alongside your zipfile and add code to your <code>__main__.py</code> to include the directory containing the unzipped module in <code>sys.path</code>. In this case, you will need to make sure to ship appropriate binaries for your target architecture(s) (and potentially pick the correct version to add to <code>sys.path</code> at runtime, based on the user’s machine).</li> <li>If you are shipping a Windows executable as described above, you either need to ensure that your users have <code>python3.dll</code> on their PATH (which is not the default behaviour of the installer) or you should bundle your application with the embedded distribution.</li> <li>The suggested launcher above uses the Python embedding API. This means that in your application, <code>sys.executable</code> will be your application, and <em>not</em> a conventional Python interpreter. Your code and its dependencies need to be prepared for this possibility. For example, if your application uses the <a class="reference internal" href="multiprocessing#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code>multiprocessing</code></a> module, it will need to call <a class="reference internal" href="multiprocessing#multiprocessing.set_executable" title="multiprocessing.set_executable"><code>multiprocessing.set_executable()</code></a> to let the module know where to find the standard Python interpreter.</li> </ol>    <h2 id="the-python-zip-application-archive-format">The Python Zip Application Archive Format</h2> <p>Python has been able to execute zip files which contain a <code>__main__.py</code> file since version 2.6. In order to be executed by Python, an application archive simply has to be a standard zip file containing a <code>__main__.py</code> file which will be run as the entry point for the application. As usual for any Python script, the parent of the script (in this case the zip file) will be placed on <a class="reference internal" href="sys#sys.path" title="sys.path"><code>sys.path</code></a> and thus further modules can be imported from the zip file.</p> <p>The zip file format allows arbitrary data to be prepended to a zip file. The zip application format uses this ability to prepend a standard POSIX “shebang” line to the file (<code>#!/path/to/interpreter</code>).</p> <p>Formally, the Python zip application format is therefore:</p> <ol class="arabic simple"> <li>An optional shebang line, containing the characters <code>b'#!'</code> followed by an interpreter name, and then a newline (<code>b'\n'</code>) character. The interpreter name can be anything acceptable to the OS “shebang” processing, or the Python launcher on Windows. The interpreter should be encoded in UTF-8 on Windows, and in <a class="reference internal" href="sys#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code>sys.getfilesystemencoding()</code></a> on POSIX.</li> <li>Standard zipfile data, as generated by the <a class="reference internal" href="zipfile#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code>zipfile</code></a> module. The zipfile content <em>must</em> include a file called <code>__main__.py</code> (which must be in the “root” of the zipfile - i.e., it cannot be in a subdirectory). The zipfile data can be compressed or uncompressed.</li> </ol> <p>If an application archive has a shebang line, it may have the executable bit set on POSIX systems, to allow it to be executed directly.</p> <p>There is no requirement that the tools in this module are used to create application archives - the module is a convenience, but archives in the above format created by any means are acceptable to Python.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2021 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.9/library/zipapp.html" class="_attribution-link">https://docs.python.org/3.9/library/zipapp.html</a>
  </p>
</div>
