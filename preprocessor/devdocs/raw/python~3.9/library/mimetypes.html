<h1 id="mimetypes-map-filenames-to-mime-types">mimetypes — Map filenames to MIME types</h1> <p id="module-mimetypes"><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/mimetypes.py">Lib/mimetypes.py</a></p>  <p>The <a class="reference internal" href="#module-mimetypes" title="mimetypes: Mapping of filename extensions to MIME types."><code>mimetypes</code></a> module converts between a filename or URL and the MIME type associated with the filename extension. Conversions are provided from filename to MIME type and from MIME type to filename extension; encodings are not supported for the latter conversion.</p> <p>The module provides one class and a number of convenience functions. The functions are the normal interface to this module, but some applications may be interested in the class as well.</p> <p>The functions described below provide the primary interface for this module. If the module has not been initialized, they will call <a class="reference internal" href="#mimetypes.init" title="mimetypes.init"><code>init()</code></a> if they rely on the information <a class="reference internal" href="#mimetypes.init" title="mimetypes.init"><code>init()</code></a> sets up.</p> <dl class="function"> <dt id="mimetypes.guess_type">
<code>mimetypes.guess_type(url, strict=True)</code> </dt> <dd>
<p id="index-1">Guess the type of a file based on its filename, path or URL, given by <em>url</em>. URL can be a string or a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> <p>The return value is a tuple <code>(type, encoding)</code> where <em>type</em> is <code>None</code> if the type can’t be guessed (missing or unknown suffix) or a string of the form <code>'type/subtype'</code>, usable for a MIME <em class="mailheader">content-type</em> header.</p> <p><em>encoding</em> is <code>None</code> for no encoding or the name of the program used to encode (e.g. <strong class="program">compress</strong> or <strong class="program">gzip</strong>). The encoding is suitable for use as a <em class="mailheader">Content-Encoding</em> header, <strong>not</strong> as a <em class="mailheader">Content-Transfer-Encoding</em> header. The mappings are table driven. Encoding suffixes are case sensitive; type suffixes are first tried case sensitively, then case insensitively.</p> <p>The optional <em>strict</em> argument is a flag specifying whether the list of known MIME types is limited to only the official types <a class="reference external" href="https://www.iana.org/assignments/media-types/media-types.xhtml">registered with IANA</a>. When <em>strict</em> is <code>True</code> (the default), only the IANA types are supported; when <em>strict</em> is <code>False</code>, some additional non-standard but commonly used MIME types are also recognized.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.8: </span>Added support for url being a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p> </div> </dd>
</dl> <dl class="function"> <dt id="mimetypes.guess_all_extensions">
<code>mimetypes.guess_all_extensions(type, strict=True)</code> </dt> <dd>
<p>Guess the extensions for a file based on its MIME type, given by <em>type</em>. The return value is a list of strings giving all possible filename extensions, including the leading dot (<code>'.'</code>). The extensions are not guaranteed to have been associated with any particular data stream, but would be mapped to the MIME type <em>type</em> by <a class="reference internal" href="#mimetypes.guess_type" title="mimetypes.guess_type"><code>guess_type()</code></a>.</p> <p>The optional <em>strict</em> argument has the same meaning as with the <a class="reference internal" href="#mimetypes.guess_type" title="mimetypes.guess_type"><code>guess_type()</code></a> function.</p> </dd>
</dl> <dl class="function"> <dt id="mimetypes.guess_extension">
<code>mimetypes.guess_extension(type, strict=True)</code> </dt> <dd>
<p>Guess the extension for a file based on its MIME type, given by <em>type</em>. The return value is a string giving a filename extension, including the leading dot (<code>'.'</code>). The extension is not guaranteed to have been associated with any particular data stream, but would be mapped to the MIME type <em>type</em> by <a class="reference internal" href="#mimetypes.guess_type" title="mimetypes.guess_type"><code>guess_type()</code></a>. If no extension can be guessed for <em>type</em>, <code>None</code> is returned.</p> <p>The optional <em>strict</em> argument has the same meaning as with the <a class="reference internal" href="#mimetypes.guess_type" title="mimetypes.guess_type"><code>guess_type()</code></a> function.</p> </dd>
</dl> <p>Some additional functions and data items are available for controlling the behavior of the module.</p> <dl class="function"> <dt id="mimetypes.init">
<code>mimetypes.init(files=None)</code> </dt> <dd>
<p>Initialize the internal data structures. If given, <em>files</em> must be a sequence of file names which should be used to augment the default type map. If omitted, the file names to use are taken from <a class="reference internal" href="#mimetypes.knownfiles" title="mimetypes.knownfiles"><code>knownfiles</code></a>; on Windows, the current registry settings are loaded. Each file named in <em>files</em> or <a class="reference internal" href="#mimetypes.knownfiles" title="mimetypes.knownfiles"><code>knownfiles</code></a> takes precedence over those named before it. Calling <a class="reference internal" href="#mimetypes.init" title="mimetypes.init"><code>init()</code></a> repeatedly is allowed.</p> <p>Specifying an empty list for <em>files</em> will prevent the system defaults from being applied: only the well-known values will be present from a built-in list.</p> <p>If <em>files</em> is <code>None</code> the internal data structure is completely rebuilt to its initial default value. This is a stable operation and will produce the same results when called multiple times.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.2: </span>Previously, Windows registry settings were ignored.</p> </div> </dd>
</dl> <dl class="function"> <dt id="mimetypes.read_mime_types">
<code>mimetypes.read_mime_types(filename)</code> </dt> <dd>
<p>Load the type map given in the file <em>filename</em>, if it exists. The type map is returned as a dictionary mapping filename extensions, including the leading dot (<code>'.'</code>), to strings of the form <code>'type/subtype'</code>. If the file <em>filename</em> does not exist or cannot be read, <code>None</code> is returned.</p> </dd>
</dl> <dl class="function"> <dt id="mimetypes.add_type">
<code>mimetypes.add_type(type, ext, strict=True)</code> </dt> <dd>
<p>Add a mapping from the MIME type <em>type</em> to the extension <em>ext</em>. When the extension is already known, the new type will replace the old one. When the type is already known the extension will be added to the list of known extensions.</p> <p>When <em>strict</em> is <code>True</code> (the default), the mapping will be added to the official MIME types, otherwise to the non-standard ones.</p> </dd>
</dl> <dl class="data"> <dt id="mimetypes.inited">
<code>mimetypes.inited</code> </dt> <dd>
<p>Flag indicating whether or not the global data structures have been initialized. This is set to <code>True</code> by <a class="reference internal" href="#mimetypes.init" title="mimetypes.init"><code>init()</code></a>.</p> </dd>
</dl> <dl class="data"> <dt id="mimetypes.knownfiles">
<code>mimetypes.knownfiles</code> </dt> <dd>
<p id="index-2">List of type map file names commonly installed. These files are typically named <code>mime.types</code> and are installed in different locations by different packages.</p> </dd>
</dl> <dl class="data"> <dt id="mimetypes.suffix_map">
<code>mimetypes.suffix_map</code> </dt> <dd>
<p>Dictionary mapping suffixes to suffixes. This is used to allow recognition of encoded files for which the encoding and the type are indicated by the same extension. For example, the <code>.tgz</code> extension is mapped to <code>.tar.gz</code> to allow the encoding and type to be recognized separately.</p> </dd>
</dl> <dl class="data"> <dt id="mimetypes.encodings_map">
<code>mimetypes.encodings_map</code> </dt> <dd>
<p>Dictionary mapping filename extensions to encoding types.</p> </dd>
</dl> <dl class="data"> <dt id="mimetypes.types_map">
<code>mimetypes.types_map</code> </dt> <dd>
<p>Dictionary mapping filename extensions to MIME types.</p> </dd>
</dl> <dl class="data"> <dt id="mimetypes.common_types">
<code>mimetypes.common_types</code> </dt> <dd>
<p>Dictionary mapping filename extensions to non-standard, but commonly found MIME types.</p> </dd>
</dl> <p>An example usage of the module:</p> <pre data-language="python">&gt;&gt;&gt; import mimetypes
&gt;&gt;&gt; mimetypes.init()
&gt;&gt;&gt; mimetypes.knownfiles
['/etc/mime.types', '/etc/httpd/mime.types', ... ]
&gt;&gt;&gt; mimetypes.suffix_map['.tgz']
'.tar.gz'
&gt;&gt;&gt; mimetypes.encodings_map['.gz']
'gzip'
&gt;&gt;&gt; mimetypes.types_map['.tgz']
'application/x-tar-gz'
</pre>  <h2 id="id1">MimeTypes Objects</h2> <p id="mimetypes-objects">The <a class="reference internal" href="#mimetypes.MimeTypes" title="mimetypes.MimeTypes"><code>MimeTypes</code></a> class may be useful for applications which may want more than one MIME-type database; it provides an interface similar to the one of the <a class="reference internal" href="#module-mimetypes" title="mimetypes: Mapping of filename extensions to MIME types."><code>mimetypes</code></a> module.</p> <dl class="class"> <dt id="mimetypes.MimeTypes">
<code>class mimetypes.MimeTypes(filenames=(), strict=True)</code> </dt> <dd>
<p>This class represents a MIME-types database. By default, it provides access to the same database as the rest of this module. The initial database is a copy of that provided by the module, and may be extended by loading additional <code>mime.types</code>-style files into the database using the <a class="reference internal" href="#mimetypes.MimeTypes.read" title="mimetypes.MimeTypes.read"><code>read()</code></a> or <a class="reference internal" href="#mimetypes.MimeTypes.readfp" title="mimetypes.MimeTypes.readfp"><code>readfp()</code></a> methods. The mapping dictionaries may also be cleared before loading additional data if the default data is not desired.</p> <p>The optional <em>filenames</em> parameter can be used to cause additional files to be loaded “on top” of the default database.</p> <dl class="attribute"> <dt id="mimetypes.MimeTypes.suffix_map">
<code>suffix_map</code> </dt> <dd>
<p>Dictionary mapping suffixes to suffixes. This is used to allow recognition of encoded files for which the encoding and the type are indicated by the same extension. For example, the <code>.tgz</code> extension is mapped to <code>.tar.gz</code> to allow the encoding and type to be recognized separately. This is initially a copy of the global <a class="reference internal" href="#mimetypes.suffix_map" title="mimetypes.suffix_map"><code>suffix_map</code></a> defined in the module.</p> </dd>
</dl> <dl class="attribute"> <dt id="mimetypes.MimeTypes.encodings_map">
<code>encodings_map</code> </dt> <dd>
<p>Dictionary mapping filename extensions to encoding types. This is initially a copy of the global <a class="reference internal" href="#mimetypes.encodings_map" title="mimetypes.encodings_map"><code>encodings_map</code></a> defined in the module.</p> </dd>
</dl> <dl class="attribute"> <dt id="mimetypes.MimeTypes.types_map">
<code>types_map</code> </dt> <dd>
<p>Tuple containing two dictionaries, mapping filename extensions to MIME types: the first dictionary is for the non-standards types and the second one is for the standard types. They are initialized by <a class="reference internal" href="#mimetypes.common_types" title="mimetypes.common_types"><code>common_types</code></a> and <a class="reference internal" href="#mimetypes.types_map" title="mimetypes.types_map"><code>types_map</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="mimetypes.MimeTypes.types_map_inv">
<code>types_map_inv</code> </dt> <dd>
<p>Tuple containing two dictionaries, mapping MIME types to a list of filename extensions: the first dictionary is for the non-standards types and the second one is for the standard types. They are initialized by <a class="reference internal" href="#mimetypes.common_types" title="mimetypes.common_types"><code>common_types</code></a> and <a class="reference internal" href="#mimetypes.types_map" title="mimetypes.types_map"><code>types_map</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="mimetypes.MimeTypes.guess_extension">
<code>guess_extension(type, strict=True)</code> </dt> <dd>
<p>Similar to the <a class="reference internal" href="#mimetypes.guess_extension" title="mimetypes.guess_extension"><code>guess_extension()</code></a> function, using the tables stored as part of the object.</p> </dd>
</dl> <dl class="method"> <dt id="mimetypes.MimeTypes.guess_type">
<code>guess_type(url, strict=True)</code> </dt> <dd>
<p>Similar to the <a class="reference internal" href="#mimetypes.guess_type" title="mimetypes.guess_type"><code>guess_type()</code></a> function, using the tables stored as part of the object.</p> </dd>
</dl> <dl class="method"> <dt id="mimetypes.MimeTypes.guess_all_extensions">
<code>guess_all_extensions(type, strict=True)</code> </dt> <dd>
<p>Similar to the <a class="reference internal" href="#mimetypes.guess_all_extensions" title="mimetypes.guess_all_extensions"><code>guess_all_extensions()</code></a> function, using the tables stored as part of the object.</p> </dd>
</dl> <dl class="method"> <dt id="mimetypes.MimeTypes.read">
<code>read(filename, strict=True)</code> </dt> <dd>
<p>Load MIME information from a file named <em>filename</em>. This uses <a class="reference internal" href="#mimetypes.MimeTypes.readfp" title="mimetypes.MimeTypes.readfp"><code>readfp()</code></a> to parse the file.</p> <p>If <em>strict</em> is <code>True</code>, information will be added to list of standard types, else to the list of non-standard types.</p> </dd>
</dl> <dl class="method"> <dt id="mimetypes.MimeTypes.readfp">
<code>readfp(fp, strict=True)</code> </dt> <dd>
<p>Load MIME type information from an open file <em>fp</em>. The file must have the format of the standard <code>mime.types</code> files.</p> <p>If <em>strict</em> is <code>True</code>, information will be added to the list of standard types, else to the list of non-standard types.</p> </dd>
</dl> <dl class="method"> <dt id="mimetypes.MimeTypes.read_windows_registry">
<code>read_windows_registry(strict=True)</code> </dt> <dd>
<p>Load MIME type information from the Windows registry.</p> <p class="availability"><a class="reference internal" href="https://docs.python.org/3.9/library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p> <p>If <em>strict</em> is <code>True</code>, information will be added to the list of standard types, else to the list of non-standard types.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> </dd>
</dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2021 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.9/library/mimetypes.html" class="_attribution-link">https://docs.python.org/3.9/library/mimetypes.html</a>
  </p>
</div>
