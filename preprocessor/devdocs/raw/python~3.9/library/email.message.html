<h1 id="email-message-representing-an-email-message">email.message: Representing an email message</h1> <p id="module-email.message"><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/email/message.py">Lib/email/message.py</a></p>  <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6: </span><a class="footnote-reference brackets" href="#id2" id="id1">1</a></p> </div> <p>The central class in the <a class="reference internal" href="email#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code>email</code></a> package is the <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a> class, imported from the <a class="reference internal" href="#module-email.message" title="email.message: The base class representing email messages."><code>email.message</code></a> module. It is the base class for the <a class="reference internal" href="email#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code>email</code></a> object model. <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a> provides the core functionality for setting and querying header fields, for accessing message bodies, and for creating or modifying structured messages.</p> <p>An email message consists of <em>headers</em> and a <em>payload</em> (which is also referred to as the <em>content</em>). Headers are <a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html" id="index-0"><strong>RFC 5322</strong></a> or <a class="rfc reference external" href="https://tools.ietf.org/html/rfc6532.html" id="index-1"><strong>RFC 6532</strong></a> style field names and values, where the field name and value are separated by a colon. The colon is not part of either the field name or the field value. The payload may be a simple text message, or a binary object, or a structured sequence of sub-messages each with their own set of headers and their own payload. The latter type of payload is indicated by the message having a MIME type such as <em class="mimetype">multipart/*</em> or <em class="mimetype">message/rfc822</em>.</p> <p>The conceptual model provided by an <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a> object is that of an ordered dictionary of headers coupled with a <em>payload</em> that represents the <a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html" id="index-2"><strong>RFC 5322</strong></a> body of the message, which might be a list of sub-<code>EmailMessage</code> objects. In addition to the normal dictionary methods for accessing the header names and values, there are methods for accessing specialized information from the headers (for example the MIME content type), for operating on the payload, for generating a serialized version of the message, and for recursively walking over the object tree.</p> <p>The <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a> dictionary-like interface is indexed by the header names, which must be ASCII values. The values of the dictionary are strings with some extra methods. Headers are stored and returned in case-preserving form, but field names are matched case-insensitively. Unlike a real dict, there is an ordering to the keys, and there can be duplicate keys. Additional methods are provided for working with headers that have duplicate keys.</p> <p>The <em>payload</em> is either a string or bytes object, in the case of simple message objects, or a list of <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a> objects, for MIME container documents such as <em class="mimetype">multipart/*</em> and <em class="mimetype">message/rfc822</em> message objects.</p> <dl class="class"> <dt id="email.message.EmailMessage">
<code>class email.message.EmailMessage(policy=default)</code> </dt> <dd>
<p>If <em>policy</em> is specified use the rules it specifies to update and serialize the representation of the message. If <em>policy</em> is not set, use the <a class="reference internal" href="email.policy#email.policy.default" title="email.policy.default"><code>default</code></a> policy, which follows the rules of the email RFCs except for line endings (instead of the RFC mandated <code>\r\n</code>, it uses the Python standard <code>\n</code> line endings). For more information see the <a class="reference internal" href="email.policy#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code>policy</code></a> documentation.</p> <dl class="method"> <dt id="email.message.EmailMessage.as_string">
<code>as_string(unixfrom=False, maxheaderlen=None, policy=None)</code> </dt> <dd>
<p>Return the entire message flattened as a string. When optional <em>unixfrom</em> is true, the envelope header is included in the returned string. <em>unixfrom</em> defaults to <code>False</code>. For backward compatibility with the base <a class="reference internal" href="email.compat32-message#email.message.Message" title="email.message.Message"><code>Message</code></a> class <em>maxheaderlen</em> is accepted, but defaults to <code>None</code>, which means that by default the line length is controlled by the <code>max_line_length</code> of the policy. The <em>policy</em> argument may be used to override the default policy obtained from the message instance. This can be used to control some of the formatting produced by the method, since the specified <em>policy</em> will be passed to the <a class="reference internal" href="email.generator#email.generator.Generator" title="email.generator.Generator"><code>Generator</code></a>.</p> <p>Flattening the message may trigger changes to the <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a> if defaults need to be filled in to complete the transformation to a string (for example, MIME boundaries may be generated or modified).</p> <p>Note that this method is provided as a convenience and may not be the most useful way to serialize messages in your application, especially if you are dealing with multiple messages. See <a class="reference internal" href="email.generator#email.generator.Generator" title="email.generator.Generator"><code>email.generator.Generator</code></a> for a more flexible API for serializing messages. Note also that this method is restricted to producing messages serialized as “7 bit clean” when <a class="reference internal" href="email.policy#email.policy.EmailPolicy.utf8" title="email.policy.EmailPolicy.utf8"><code>utf8</code></a> is <code>False</code>, which is the default.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>the default behavior when <em>maxheaderlen</em> is not specified was changed from defaulting to 0 to defaulting to the value of <em>max_line_length</em> from the policy.</p> </div> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.__str__">
<code>__str__()</code> </dt> <dd>
<p>Equivalent to <code>as_string(policy=self.policy.clone(utf8=True))</code>. Allows <code>str(msg)</code> to produce a string containing the serialized message in a readable format.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span>the method was changed to use <code>utf8=True</code>, thus producing an <a class="rfc reference external" href="https://tools.ietf.org/html/rfc6531.html" id="index-3"><strong>RFC 6531</strong></a>-like message representation, instead of being a direct alias for <a class="reference internal" href="#email.message.EmailMessage.as_string" title="email.message.EmailMessage.as_string"><code>as_string()</code></a>.</p> </div> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.as_bytes">
<code>as_bytes(unixfrom=False, policy=None)</code> </dt> <dd>
<p>Return the entire message flattened as a bytes object. When optional <em>unixfrom</em> is true, the envelope header is included in the returned string. <em>unixfrom</em> defaults to <code>False</code>. The <em>policy</em> argument may be used to override the default policy obtained from the message instance. This can be used to control some of the formatting produced by the method, since the specified <em>policy</em> will be passed to the <a class="reference internal" href="email.generator#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code>BytesGenerator</code></a>.</p> <p>Flattening the message may trigger changes to the <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a> if defaults need to be filled in to complete the transformation to a string (for example, MIME boundaries may be generated or modified).</p> <p>Note that this method is provided as a convenience and may not be the most useful way to serialize messages in your application, especially if you are dealing with multiple messages. See <a class="reference internal" href="email.generator#email.generator.BytesGenerator" title="email.generator.BytesGenerator"><code>email.generator.BytesGenerator</code></a> for a more flexible API for serializing messages.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.__bytes__">
<code>__bytes__()</code> </dt> <dd>
<p>Equivalent to <a class="reference internal" href="#email.message.EmailMessage.as_bytes" title="email.message.EmailMessage.as_bytes"><code>as_bytes()</code></a>. Allows <code>bytes(msg)</code> to produce a bytes object containing the serialized message.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.is_multipart">
<code>is_multipart()</code> </dt> <dd>
<p>Return <code>True</code> if the message’s payload is a list of sub-<a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a> objects, otherwise return <code>False</code>. When <a class="reference internal" href="#email.message.EmailMessage.is_multipart" title="email.message.EmailMessage.is_multipart"><code>is_multipart()</code></a> returns <code>False</code>, the payload should be a string object (which might be a CTE encoded binary payload). Note that <a class="reference internal" href="#email.message.EmailMessage.is_multipart" title="email.message.EmailMessage.is_multipart"><code>is_multipart()</code></a> returning <code>True</code> does not necessarily mean that “msg.get_content_maintype() == ‘multipart’” will return the <code>True</code>. For example, <code>is_multipart</code> will return <code>True</code> when the <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a> is of type <code>message/rfc822</code>.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.set_unixfrom">
<code>set_unixfrom(unixfrom)</code> </dt> <dd>
<p>Set the message’s envelope header to <em>unixfrom</em>, which should be a string. (See <a class="reference internal" href="mailbox#mailbox.mboxMessage" title="mailbox.mboxMessage"><code>mboxMessage</code></a> for a brief description of this header.)</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.get_unixfrom">
<code>get_unixfrom()</code> </dt> <dd>
<p>Return the message’s envelope header. Defaults to <code>None</code> if the envelope header was never set.</p> </dd>
</dl> <p>The following methods implement the mapping-like interface for accessing the message’s headers. Note that there are some semantic differences between these methods and a normal mapping (i.e. dictionary) interface. For example, in a dictionary there are no duplicate keys, but here there may be duplicate message headers. Also, in dictionaries there is no guaranteed order to the keys returned by <a class="reference internal" href="#email.message.EmailMessage.keys" title="email.message.EmailMessage.keys"><code>keys()</code></a>, but in an <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a> object, headers are always returned in the order they appeared in the original message, or in which they were added to the message later. Any header deleted and then re-added is always appended to the end of the header list.</p> <p>These semantic differences are intentional and are biased toward convenience in the most common use cases.</p> <p>Note that in all cases, any envelope header present in the message is not included in the mapping interface.</p> <dl class="method"> <dt id="email.message.EmailMessage.__len__">
<code>__len__()</code> </dt> <dd>
<p>Return the total number of headers, including duplicates.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.__contains__">
<code>__contains__(name)</code> </dt> <dd>
<p>Return <code>True</code> if the message object has a field named <em>name</em>. Matching is done without regard to case and <em>name</em> does not include the trailing colon. Used for the <code>in</code> operator. For example:</p> <pre data-language="python">if 'message-id' in myMessage:
   print('Message-ID:', myMessage['message-id'])
</pre> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.__getitem__">
<code>__getitem__(name)</code> </dt> <dd>
<p>Return the value of the named header field. <em>name</em> does not include the colon field separator. If the header is missing, <code>None</code> is returned; a <a class="reference internal" href="exceptions#KeyError" title="KeyError"><code>KeyError</code></a> is never raised.</p> <p>Note that if the named field appears more than once in the message’s headers, exactly which of those field values will be returned is undefined. Use the <a class="reference internal" href="#email.message.EmailMessage.get_all" title="email.message.EmailMessage.get_all"><code>get_all()</code></a> method to get the values of all the extant headers named <em>name</em>.</p> <p>Using the standard (non-<code>compat32</code>) policies, the returned value is an instance of a subclass of <a class="reference internal" href="email.headerregistry#email.headerregistry.BaseHeader" title="email.headerregistry.BaseHeader"><code>email.headerregistry.BaseHeader</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.__setitem__">
<code>__setitem__(name, val)</code> </dt> <dd>
<p>Add a header to the message with field name <em>name</em> and value <em>val</em>. The field is appended to the end of the message’s existing headers.</p> <p>Note that this does <em>not</em> overwrite or delete any existing header with the same name. If you want to ensure that the new header is the only one present in the message with field name <em>name</em>, delete the field first, e.g.:</p> <pre data-language="python">del msg['subject']
msg['subject'] = 'Python roolz!'
</pre> <p>If the <code>policy</code> defines certain headers to be unique (as the standard policies do), this method may raise a <a class="reference internal" href="exceptions#ValueError" title="ValueError"><code>ValueError</code></a> when an attempt is made to assign a value to such a header when one already exists. This behavior is intentional for consistency’s sake, but do not depend on it as we may choose to make such assignments do an automatic deletion of the existing header in the future.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.__delitem__">
<code>__delitem__(name)</code> </dt> <dd>
<p>Delete all occurrences of the field with name <em>name</em> from the message’s headers. No exception is raised if the named field isn’t present in the headers.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.keys">
<code>keys()</code> </dt> <dd>
<p>Return a list of all the message’s header field names.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.values">
<code>values()</code> </dt> <dd>
<p>Return a list of all the message’s field values.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.items">
<code>items()</code> </dt> <dd>
<p>Return a list of 2-tuples containing all the message’s field headers and values.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.get">
<code>get(name, failobj=None)</code> </dt> <dd>
<p>Return the value of the named header field. This is identical to <a class="reference internal" href="#email.message.EmailMessage.__getitem__" title="email.message.EmailMessage.__getitem__"><code>__getitem__()</code></a> except that optional <em>failobj</em> is returned if the named header is missing (<em>failobj</em> defaults to <code>None</code>).</p> </dd>
</dl> <p>Here are some additional useful header related methods:</p> <dl class="method"> <dt id="email.message.EmailMessage.get_all">
<code>get_all(name, failobj=None)</code> </dt> <dd>
<p>Return a list of all the values for the field named <em>name</em>. If there are no such named headers in the message, <em>failobj</em> is returned (defaults to <code>None</code>).</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.add_header">
<code>add_header(_name, _value, **_params)</code> </dt> <dd>
<p>Extended header setting. This method is similar to <a class="reference internal" href="#email.message.EmailMessage.__setitem__" title="email.message.EmailMessage.__setitem__"><code>__setitem__()</code></a> except that additional header parameters can be provided as keyword arguments. <em>_name</em> is the header field to add and <em>_value</em> is the <em>primary</em> value for the header.</p> <p>For each item in the keyword argument dictionary <em>_params</em>, the key is taken as the parameter name, with underscores converted to dashes (since dashes are illegal in Python identifiers). Normally, the parameter will be added as <code>key="value"</code> unless the value is <code>None</code>, in which case only the key will be added.</p> <p>If the value contains non-ASCII characters, the charset and language may be explicitly controlled by specifying the value as a three tuple in the format <code>(CHARSET, LANGUAGE, VALUE)</code>, where <code>CHARSET</code> is a string naming the charset to be used to encode the value, <code>LANGUAGE</code> can usually be set to <code>None</code> or the empty string (see <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2231.html" id="index-4"><strong>RFC 2231</strong></a> for other possibilities), and <code>VALUE</code> is the string value containing non-ASCII code points. If a three tuple is not passed and the value contains non-ASCII characters, it is automatically encoded in <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2231.html" id="index-5"><strong>RFC 2231</strong></a> format using a <code>CHARSET</code> of <code>utf-8</code> and a <code>LANGUAGE</code> of <code>None</code>.</p> <p>Here is an example:</p> <pre data-language="python">msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')
</pre> <p>This will add a header that looks like</p> <pre data-language="python">Content-Disposition: attachment; filename="bud.gif"
</pre> <p>An example of the extended interface with non-ASCII characters:</p> <pre data-language="python">msg.add_header('Content-Disposition', 'attachment',
               filename=('iso-8859-1', '', 'Fußballer.ppt'))
</pre> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.replace_header">
<code>replace_header(_name, _value)</code> </dt> <dd>
<p>Replace a header. Replace the first header found in the message that matches <em>_name</em>, retaining header order and field name case of the original header. If no matching header is found, raise a <a class="reference internal" href="exceptions#KeyError" title="KeyError"><code>KeyError</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.get_content_type">
<code>get_content_type()</code> </dt> <dd>
<p>Return the message’s content type, coerced to lower case of the form <em class="mimetype">maintype/subtype</em>. If there is no <em class="mailheader">Content-Type</em> header in the message return the value returned by <a class="reference internal" href="#email.message.EmailMessage.get_default_type" title="email.message.EmailMessage.get_default_type"><code>get_default_type()</code></a>. If the <em class="mailheader">Content-Type</em> header is invalid, return <code>text/plain</code>.</p> <p>(According to <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2045.html" id="index-6"><strong>RFC 2045</strong></a>, messages always have a default type, <a class="reference internal" href="#email.message.EmailMessage.get_content_type" title="email.message.EmailMessage.get_content_type"><code>get_content_type()</code></a> will always return a value. <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2045.html" id="index-7"><strong>RFC 2045</strong></a> defines a message’s default type to be <em class="mimetype">text/plain</em> unless it appears inside a <em class="mimetype">multipart/digest</em> container, in which case it would be <em class="mimetype">message/rfc822</em>. If the <em class="mailheader">Content-Type</em> header has an invalid type specification, <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2045.html" id="index-8"><strong>RFC 2045</strong></a> mandates that the default type be <em class="mimetype">text/plain</em>.)</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.get_content_maintype">
<code>get_content_maintype()</code> </dt> <dd>
<p>Return the message’s main content type. This is the <em class="mimetype">maintype</em> part of the string returned by <a class="reference internal" href="#email.message.EmailMessage.get_content_type" title="email.message.EmailMessage.get_content_type"><code>get_content_type()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.get_content_subtype">
<code>get_content_subtype()</code> </dt> <dd>
<p>Return the message’s sub-content type. This is the <em class="mimetype">subtype</em> part of the string returned by <a class="reference internal" href="#email.message.EmailMessage.get_content_type" title="email.message.EmailMessage.get_content_type"><code>get_content_type()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.get_default_type">
<code>get_default_type()</code> </dt> <dd>
<p>Return the default content type. Most messages have a default content type of <em class="mimetype">text/plain</em>, except for messages that are subparts of <em class="mimetype">multipart/digest</em> containers. Such subparts have a default content type of <em class="mimetype">message/rfc822</em>.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.set_default_type">
<code>set_default_type(ctype)</code> </dt> <dd>
<p>Set the default content type. <em>ctype</em> should either be <em class="mimetype">text/plain</em> or <em class="mimetype">message/rfc822</em>, although this is not enforced. The default content type is not stored in the <em class="mailheader">Content-Type</em> header, so it only affects the return value of the <code>get_content_type</code> methods when no <em class="mailheader">Content-Type</em> header is present in the message.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.set_param">
<code>set_param(param, value, header='Content-Type', requote=True, charset=None, language='', replace=False)</code> </dt> <dd>
<p>Set a parameter in the <em class="mailheader">Content-Type</em> header. If the parameter already exists in the header, replace its value with <em>value</em>. When <em>header</em> is <code>Content-Type</code> (the default) and the header does not yet exist in the message, add it, set its value to <em class="mimetype">text/plain</em>, and append the new parameter value. Optional <em>header</em> specifies an alternative header to <em class="mailheader">Content-Type</em>.</p> <p>If the value contains non-ASCII characters, the charset and language may be explicitly specified using the optional <em>charset</em> and <em>language</em> parameters. Optional <em>language</em> specifies the <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2231.html" id="index-9"><strong>RFC 2231</strong></a> language, defaulting to the empty string. Both <em>charset</em> and <em>language</em> should be strings. The default is to use the <code>utf8</code> <em>charset</em> and <code>None</code> for the <em>language</em>.</p> <p>If <em>replace</em> is <code>False</code> (the default) the header is moved to the end of the list of headers. If <em>replace</em> is <code>True</code>, the header will be updated in place.</p> <p>Use of the <em>requote</em> parameter with <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a> objects is deprecated.</p> <p>Note that existing parameter values of headers may be accessed through the <code>params</code> attribute of the header value (for example, <code>msg['Content-Type'].params['charset']</code>).</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4: </span><code>replace</code> keyword was added.</p> </div> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.del_param">
<code>del_param(param, header='content-type', requote=True)</code> </dt> <dd>
<p>Remove the given parameter completely from the <em class="mailheader">Content-Type</em> header. The header will be re-written in place without the parameter or its value. Optional <em>header</em> specifies an alternative to <em class="mailheader">Content-Type</em>.</p> <p>Use of the <em>requote</em> parameter with <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a> objects is deprecated.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.get_filename">
<code>get_filename(failobj=None)</code> </dt> <dd>
<p>Return the value of the <code>filename</code> parameter of the <em class="mailheader">Content-Disposition</em> header of the message. If the header does not have a <code>filename</code> parameter, this method falls back to looking for the <code>name</code> parameter on the <em class="mailheader">Content-Type</em> header. If neither is found, or the header is missing, then <em>failobj</em> is returned. The returned string will always be unquoted as per <a class="reference internal" href="email.utils#email.utils.unquote" title="email.utils.unquote"><code>email.utils.unquote()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.get_boundary">
<code>get_boundary(failobj=None)</code> </dt> <dd>
<p>Return the value of the <code>boundary</code> parameter of the <em class="mailheader">Content-Type</em> header of the message, or <em>failobj</em> if either the header is missing, or has no <code>boundary</code> parameter. The returned string will always be unquoted as per <a class="reference internal" href="email.utils#email.utils.unquote" title="email.utils.unquote"><code>email.utils.unquote()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.set_boundary">
<code>set_boundary(boundary)</code> </dt> <dd>
<p>Set the <code>boundary</code> parameter of the <em class="mailheader">Content-Type</em> header to <em>boundary</em>. <a class="reference internal" href="#email.message.EmailMessage.set_boundary" title="email.message.EmailMessage.set_boundary"><code>set_boundary()</code></a> will always quote <em>boundary</em> if necessary. A <a class="reference internal" href="email.errors#email.errors.HeaderParseError" title="email.errors.HeaderParseError"><code>HeaderParseError</code></a> is raised if the message object has no <em class="mailheader">Content-Type</em> header.</p> <p>Note that using this method is subtly different from deleting the old <em class="mailheader">Content-Type</em> header and adding a new one with the new boundary via <a class="reference internal" href="#email.message.EmailMessage.add_header" title="email.message.EmailMessage.add_header"><code>add_header()</code></a>, because <a class="reference internal" href="#email.message.EmailMessage.set_boundary" title="email.message.EmailMessage.set_boundary"><code>set_boundary()</code></a> preserves the order of the <em class="mailheader">Content-Type</em> header in the list of headers.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.get_content_charset">
<code>get_content_charset(failobj=None)</code> </dt> <dd>
<p>Return the <code>charset</code> parameter of the <em class="mailheader">Content-Type</em> header, coerced to lower case. If there is no <em class="mailheader">Content-Type</em> header, or if that header has no <code>charset</code> parameter, <em>failobj</em> is returned.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.get_charsets">
<code>get_charsets(failobj=None)</code> </dt> <dd>
<p>Return a list containing the character set names in the message. If the message is a <em class="mimetype">multipart</em>, then the list will contain one element for each subpart in the payload, otherwise, it will be a list of length 1.</p> <p>Each item in the list will be a string which is the value of the <code>charset</code> parameter in the <em class="mailheader">Content-Type</em> header for the represented subpart. If the subpart has no <em class="mailheader">Content-Type</em> header, no <code>charset</code> parameter, or is not of the <em class="mimetype">text</em> main MIME type, then that item in the returned list will be <em>failobj</em>.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.is_attachment">
<code>is_attachment()</code> </dt> <dd>
<p>Return <code>True</code> if there is a <em class="mailheader">Content-Disposition</em> header and its (case insensitive) value is <code>attachment</code>, <code>False</code> otherwise.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4.2: </span>is_attachment is now a method instead of a property, for consistency with <a class="reference internal" href="email.compat32-message#email.message.Message.is_multipart" title="email.message.Message.is_multipart"><code>is_multipart()</code></a>.</p> </div> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.get_content_disposition">
<code>get_content_disposition()</code> </dt> <dd>
<p>Return the lowercased value (without parameters) of the message’s <em class="mailheader">Content-Disposition</em> header if it has one, or <code>None</code>. The possible values for this method are <em>inline</em>, <em>attachment</em> or <code>None</code> if the message follows <a class="rfc reference external" href="https://tools.ietf.org/html/rfc2183.html" id="index-10"><strong>RFC 2183</strong></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <p>The following methods relate to interrogating and manipulating the content (payload) of the message.</p> <dl class="method"> <dt id="email.message.EmailMessage.walk">
<code>walk()</code> </dt> <dd>
<p>The <a class="reference internal" href="#email.message.EmailMessage.walk" title="email.message.EmailMessage.walk"><code>walk()</code></a> method is an all-purpose generator which can be used to iterate over all the parts and subparts of a message object tree, in depth-first traversal order. You will typically use <a class="reference internal" href="#email.message.EmailMessage.walk" title="email.message.EmailMessage.walk"><code>walk()</code></a> as the iterator in a <code>for</code> loop; each iteration returns the next subpart.</p> <p>Here’s an example that prints the MIME type of every part of a multipart message structure:</p> <pre data-language="pycon3">&gt;&gt;&gt; for part in msg.walk():
...     print(part.get_content_type())
multipart/report
text/plain
message/delivery-status
text/plain
text/plain
message/rfc822
text/plain
</pre> <p><code>walk</code> iterates over the subparts of any part where <a class="reference internal" href="#email.message.EmailMessage.is_multipart" title="email.message.EmailMessage.is_multipart"><code>is_multipart()</code></a> returns <code>True</code>, even though <code>msg.get_content_maintype() == 'multipart'</code> may return <code>False</code>. We can see this in our example by making use of the <code>_structure</code> debug helper function:</p> <pre data-language="pycon3">&gt;&gt;&gt; from email.iterators import _structure
&gt;&gt;&gt; for part in msg.walk():
...     print(part.get_content_maintype() == 'multipart',
...           part.is_multipart())
True True
False False
False True
False False
False False
False True
False False
&gt;&gt;&gt; _structure(msg)
multipart/report
    text/plain
    message/delivery-status
        text/plain
        text/plain
    message/rfc822
        text/plain
</pre> <p>Here the <code>message</code> parts are not <code>multiparts</code>, but they do contain subparts. <code>is_multipart()</code> returns <code>True</code> and <code>walk</code> descends into the subparts.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.get_body">
<code>get_body(preferencelist=('related', 'html', 'plain'))</code> </dt> <dd>
<p>Return the MIME part that is the best candidate to be the “body” of the message.</p> <p><em>preferencelist</em> must be a sequence of strings from the set <code>related</code>, <code>html</code>, and <code>plain</code>, and indicates the order of preference for the content type of the part returned.</p> <p>Start looking for candidate matches with the object on which the <code>get_body</code> method is called.</p> <p>If <code>related</code> is not included in <em>preferencelist</em>, consider the root part (or subpart of the root part) of any related encountered as a candidate if the (sub-)part matches a preference.</p> <p>When encountering a <code>multipart/related</code>, check the <code>start</code> parameter and if a part with a matching <em class="mailheader">Content-ID</em> is found, consider only it when looking for candidate matches. Otherwise consider only the first (default root) part of the <code>multipart/related</code>.</p> <p>If a part has a <em class="mailheader">Content-Disposition</em> header, only consider the part a candidate match if the value of the header is <code>inline</code>.</p> <p>If none of the candidates matches any of the preferences in <em>preferencelist</em>, return <code>None</code>.</p> <p>Notes: (1) For most applications the only <em>preferencelist</em> combinations that really make sense are <code>('plain',)</code>, <code>('html', 'plain')</code>, and the default <code>('related', 'html', 'plain')</code>. (2) Because matching starts with the object on which <code>get_body</code> is called, calling <code>get_body</code> on a <code>multipart/related</code> will return the object itself unless <em>preferencelist</em> has a non-default value. (3) Messages (or message parts) that do not specify a <em class="mailheader">Content-Type</em> or whose <em class="mailheader">Content-Type</em> header is invalid will be treated as if they are of type <code>text/plain</code>, which may occasionally cause <code>get_body</code> to return unexpected results.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.iter_attachments">
<code>iter_attachments()</code> </dt> <dd>
<p>Return an iterator over all of the immediate sub-parts of the message that are not candidate “body” parts. That is, skip the first occurrence of each of <code>text/plain</code>, <code>text/html</code>, <code>multipart/related</code>, or <code>multipart/alternative</code> (unless they are explicitly marked as attachments via <em class="mailheader">Content-Disposition: attachment</em>), and return all remaining parts. When applied directly to a <code>multipart/related</code>, return an iterator over the all the related parts except the root part (ie: the part pointed to by the <code>start</code> parameter, or the first part if there is no <code>start</code> parameter or the <code>start</code> parameter doesn’t match the <em class="mailheader">Content-ID</em> of any of the parts). When applied directly to a <code>multipart/alternative</code> or a non-<code>multipart</code>, return an empty iterator.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.iter_parts">
<code>iter_parts()</code> </dt> <dd>
<p>Return an iterator over all of the immediate sub-parts of the message, which will be empty for a non-<code>multipart</code>. (See also <a class="reference internal" href="#email.message.EmailMessage.walk" title="email.message.EmailMessage.walk"><code>walk()</code></a>.)</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.get_content">
<code>get_content(*args, content_manager=None, **kw)</code> </dt> <dd>
<p>Call the <a class="reference internal" href="email.contentmanager#email.contentmanager.ContentManager.get_content" title="email.contentmanager.ContentManager.get_content"><code>get_content()</code></a> method of the <em>content_manager</em>, passing self as the message object, and passing along any other arguments or keywords as additional arguments. If <em>content_manager</em> is not specified, use the <code>content_manager</code> specified by the current <a class="reference internal" href="email.policy#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code>policy</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.set_content">
<code>set_content(*args, content_manager=None, **kw)</code> </dt> <dd>
<p>Call the <a class="reference internal" href="email.contentmanager#email.contentmanager.ContentManager.set_content" title="email.contentmanager.ContentManager.set_content"><code>set_content()</code></a> method of the <em>content_manager</em>, passing self as the message object, and passing along any other arguments or keywords as additional arguments. If <em>content_manager</em> is not specified, use the <code>content_manager</code> specified by the current <a class="reference internal" href="email.policy#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code>policy</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.make_related">
<code>make_related(boundary=None)</code> </dt> <dd>
<p>Convert a non-<code>multipart</code> message into a <code>multipart/related</code> message, moving any existing <em class="mailheader">Content-</em> headers and payload into a (new) first part of the <code>multipart</code>. If <em>boundary</em> is specified, use it as the boundary string in the multipart, otherwise leave the boundary to be automatically created when it is needed (for example, when the message is serialized).</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.make_alternative">
<code>make_alternative(boundary=None)</code> </dt> <dd>
<p>Convert a non-<code>multipart</code> or a <code>multipart/related</code> into a <code>multipart/alternative</code>, moving any existing <em class="mailheader">Content-</em> headers and payload into a (new) first part of the <code>multipart</code>. If <em>boundary</em> is specified, use it as the boundary string in the multipart, otherwise leave the boundary to be automatically created when it is needed (for example, when the message is serialized).</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.make_mixed">
<code>make_mixed(boundary=None)</code> </dt> <dd>
<p>Convert a non-<code>multipart</code>, a <code>multipart/related</code>, or a <code>multipart-alternative</code> into a <code>multipart/mixed</code>, moving any existing <em class="mailheader">Content-</em> headers and payload into a (new) first part of the <code>multipart</code>. If <em>boundary</em> is specified, use it as the boundary string in the multipart, otherwise leave the boundary to be automatically created when it is needed (for example, when the message is serialized).</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.add_related">
<code>add_related(*args, content_manager=None, **kw)</code> </dt> <dd>
<p>If the message is a <code>multipart/related</code>, create a new message object, pass all of the arguments to its <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code>set_content()</code></a> method, and <a class="reference internal" href="email.compat32-message#email.message.Message.attach" title="email.message.Message.attach"><code>attach()</code></a> it to the <code>multipart</code>. If the message is a non-<code>multipart</code>, call <a class="reference internal" href="#email.message.EmailMessage.make_related" title="email.message.EmailMessage.make_related"><code>make_related()</code></a> and then proceed as above. If the message is any other type of <code>multipart</code>, raise a <a class="reference internal" href="exceptions#TypeError" title="TypeError"><code>TypeError</code></a>. If <em>content_manager</em> is not specified, use the <code>content_manager</code> specified by the current <a class="reference internal" href="email.policy#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code>policy</code></a>. If the added part has no <em class="mailheader">Content-Disposition</em> header, add one with the value <code>inline</code>.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.add_alternative">
<code>add_alternative(*args, content_manager=None, **kw)</code> </dt> <dd>
<p>If the message is a <code>multipart/alternative</code>, create a new message object, pass all of the arguments to its <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code>set_content()</code></a> method, and <a class="reference internal" href="email.compat32-message#email.message.Message.attach" title="email.message.Message.attach"><code>attach()</code></a> it to the <code>multipart</code>. If the message is a non-<code>multipart</code> or <code>multipart/related</code>, call <a class="reference internal" href="#email.message.EmailMessage.make_alternative" title="email.message.EmailMessage.make_alternative"><code>make_alternative()</code></a> and then proceed as above. If the message is any other type of <code>multipart</code>, raise a <a class="reference internal" href="exceptions#TypeError" title="TypeError"><code>TypeError</code></a>. If <em>content_manager</em> is not specified, use the <code>content_manager</code> specified by the current <a class="reference internal" href="email.policy#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code>policy</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.add_attachment">
<code>add_attachment(*args, content_manager=None, **kw)</code> </dt> <dd>
<p>If the message is a <code>multipart/mixed</code>, create a new message object, pass all of the arguments to its <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code>set_content()</code></a> method, and <a class="reference internal" href="email.compat32-message#email.message.Message.attach" title="email.message.Message.attach"><code>attach()</code></a> it to the <code>multipart</code>. If the message is a non-<code>multipart</code>, <code>multipart/related</code>, or <code>multipart/alternative</code>, call <a class="reference internal" href="#email.message.EmailMessage.make_mixed" title="email.message.EmailMessage.make_mixed"><code>make_mixed()</code></a> and then proceed as above. If <em>content_manager</em> is not specified, use the <code>content_manager</code> specified by the current <a class="reference internal" href="email.policy#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code>policy</code></a>. If the added part has no <em class="mailheader">Content-Disposition</em> header, add one with the value <code>attachment</code>. This method can be used both for explicit attachments (<em class="mailheader">Content-Disposition: attachment</em>) and <code>inline</code> attachments (<em class="mailheader">Content-Disposition: inline</em>), by passing appropriate options to the <code>content_manager</code>.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.clear">
<code>clear()</code> </dt> <dd>
<p>Remove the payload and all of the headers.</p> </dd>
</dl> <dl class="method"> <dt id="email.message.EmailMessage.clear_content">
<code>clear_content()</code> </dt> <dd>
<p>Remove the payload and all of the <code>Content-</code> headers, leaving all other headers intact and in their original order.</p> </dd>
</dl> <p><a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a> objects have the following instance attributes:</p> <dl class="attribute"> <dt id="email.message.EmailMessage.preamble">
<code>preamble</code> </dt> <dd>
<p>The format of a MIME document allows for some text between the blank line following the headers, and the first multipart boundary string. Normally, this text is never visible in a MIME-aware mail reader because it falls outside the standard MIME armor. However, when viewing the raw text of the message, or when viewing the message in a non-MIME aware reader, this text can become visible.</p> <p>The <em>preamble</em> attribute contains this leading extra-armor text for MIME documents. When the <a class="reference internal" href="email.parser#email.parser.Parser" title="email.parser.Parser"><code>Parser</code></a> discovers some text after the headers but before the first boundary string, it assigns this text to the message’s <em>preamble</em> attribute. When the <a class="reference internal" href="email.generator#email.generator.Generator" title="email.generator.Generator"><code>Generator</code></a> is writing out the plain text representation of a MIME message, and it finds the message has a <em>preamble</em> attribute, it will write this text in the area between the headers and the first boundary. See <a class="reference internal" href="email.parser#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code>email.parser</code></a> and <a class="reference internal" href="email.generator#module-email.generator" title="email.generator: Generate flat text email messages from a message structure."><code>email.generator</code></a> for details.</p> <p>Note that if the message object has no preamble, the <em>preamble</em> attribute will be <code>None</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="email.message.EmailMessage.epilogue">
<code>epilogue</code> </dt> <dd>
<p>The <em>epilogue</em> attribute acts the same way as the <em>preamble</em> attribute, except that it contains text that appears between the last boundary and the end of the message. As with the <a class="reference internal" href="#email.message.EmailMessage.preamble" title="email.message.EmailMessage.preamble"><code>preamble</code></a>, if there is no epilog text this attribute will be <code>None</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="email.message.EmailMessage.defects">
<code>defects</code> </dt> <dd>
<p>The <em>defects</em> attribute contains a list of all the problems found when parsing this message. See <a class="reference internal" href="email.errors#module-email.errors" title="email.errors: The exception classes used by the email package."><code>email.errors</code></a> for a detailed description of the possible parsing defects.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="email.message.MIMEPart">
<code>class email.message.MIMEPart(policy=default)</code> </dt> <dd>
<p>This class represents a subpart of a MIME message. It is identical to <a class="reference internal" href="#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a>, except that no <em class="mailheader">MIME-Version</em> headers are added when <a class="reference internal" href="#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code>set_content()</code></a> is called, since sub-parts do not need their own <em class="mailheader">MIME-Version</em> headers.</p> </dd>
</dl> <h4 class="rubric">Footnotes</h4> <dl class="footnote brackets"> <dt class="label" id="id2">
<code>1</code> </dt> <dd>
<p>Originally added in 3.4 as a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-provisional-package"><span class="xref std std-term">provisional module</span></a>. Docs for legacy message class moved to <a class="reference internal" href="email.compat32-message#compat32-message"><span class="std std-ref">email.message.Message: Representing an email message using the compat32 API</span></a>.</p> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2021 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.9/library/email.message.html" class="_attribution-link">https://docs.python.org/3.9/library/email.message.html</a>
  </p>
</div>
