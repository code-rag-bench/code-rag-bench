<h1 id="email-parser-parsing-email-messages">email.parser: Parsing email messages</h1> <p id="module-email.parser"><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.9/Lib/email/parser.py">Lib/email/parser.py</a></p>  <p>Message object structures can be created in one of two ways: they can be created from whole cloth by creating an <a class="reference internal" href="email.message#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a> object, adding headers using the dictionary interface, and adding payload(s) using <a class="reference internal" href="email.message#email.message.EmailMessage.set_content" title="email.message.EmailMessage.set_content"><code>set_content()</code></a> and related methods, or they can be created by parsing a serialized representation of the email message.</p> <p>The <a class="reference internal" href="email#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code>email</code></a> package provides a standard parser that understands most email document structures, including MIME documents. You can pass the parser a bytes, string or file object, and the parser will return to you the root <a class="reference internal" href="email.message#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a> instance of the object structure. For simple, non-MIME messages the payload of this root object will likely be a string containing the text of the message. For MIME messages, the root object will return <code>True</code> from its <a class="reference internal" href="email.message#email.message.EmailMessage.is_multipart" title="email.message.EmailMessage.is_multipart"><code>is_multipart()</code></a> method, and the subparts can be accessed via the payload manipulation methods, such as <a class="reference internal" href="email.message#email.message.EmailMessage.get_body" title="email.message.EmailMessage.get_body"><code>get_body()</code></a>, <a class="reference internal" href="email.message#email.message.EmailMessage.iter_parts" title="email.message.EmailMessage.iter_parts"><code>iter_parts()</code></a>, and <a class="reference internal" href="email.message#email.message.EmailMessage.walk" title="email.message.EmailMessage.walk"><code>walk()</code></a>.</p> <p>There are actually two parser interfaces available for use, the <a class="reference internal" href="#email.parser.Parser" title="email.parser.Parser"><code>Parser</code></a> API and the incremental <a class="reference internal" href="#email.parser.FeedParser" title="email.parser.FeedParser"><code>FeedParser</code></a> API. The <a class="reference internal" href="#email.parser.Parser" title="email.parser.Parser"><code>Parser</code></a> API is most useful if you have the entire text of the message in memory, or if the entire message lives in a file on the file system. <a class="reference internal" href="#email.parser.FeedParser" title="email.parser.FeedParser"><code>FeedParser</code></a> is more appropriate when you are reading the message from a stream which might block waiting for more input (such as reading an email message from a socket). The <a class="reference internal" href="#email.parser.FeedParser" title="email.parser.FeedParser"><code>FeedParser</code></a> can consume and parse the message incrementally, and only returns the root object when you close the parser.</p> <p>Note that the parser can be extended in limited ways, and of course you can implement your own parser completely from scratch. All of the logic that connects the <a class="reference internal" href="email#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code>email</code></a> package’s bundled parser and the <a class="reference internal" href="email.message#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a> class is embodied in the <code>policy</code> class, so a custom parser can create message object trees any way it finds necessary by implementing custom versions of the appropriate <code>policy</code> methods.</p>  <h2 id="feedparser-api">FeedParser API</h2> <p>The <a class="reference internal" href="#email.parser.BytesFeedParser" title="email.parser.BytesFeedParser"><code>BytesFeedParser</code></a>, imported from the <code>email.feedparser</code> module, provides an API that is conducive to incremental parsing of email messages, such as would be necessary when reading the text of an email message from a source that can block (such as a socket). The <a class="reference internal" href="#email.parser.BytesFeedParser" title="email.parser.BytesFeedParser"><code>BytesFeedParser</code></a> can of course be used to parse an email message fully contained in a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>, string, or file, but the <a class="reference internal" href="#email.parser.BytesParser" title="email.parser.BytesParser"><code>BytesParser</code></a> API may be more convenient for such use cases. The semantics and results of the two parser APIs are identical.</p> <p>The <a class="reference internal" href="#email.parser.BytesFeedParser" title="email.parser.BytesFeedParser"><code>BytesFeedParser</code></a>’s API is simple; you create an instance, feed it a bunch of bytes until there’s no more to feed it, then close the parser to retrieve the root message object. The <a class="reference internal" href="#email.parser.BytesFeedParser" title="email.parser.BytesFeedParser"><code>BytesFeedParser</code></a> is extremely accurate when parsing standards-compliant messages, and it does a very good job of parsing non-compliant messages, providing information about how a message was deemed broken. It will populate a message object’s <a class="reference internal" href="email.message#email.message.EmailMessage.defects" title="email.message.EmailMessage.defects"><code>defects</code></a> attribute with a list of any problems it found in a message. See the <a class="reference internal" href="email.errors#module-email.errors" title="email.errors: The exception classes used by the email package."><code>email.errors</code></a> module for the list of defects that it can find.</p> <p>Here is the API for the <a class="reference internal" href="#email.parser.BytesFeedParser" title="email.parser.BytesFeedParser"><code>BytesFeedParser</code></a>:</p> <dl class="class"> <dt id="email.parser.BytesFeedParser">
<code>class email.parser.BytesFeedParser(_factory=None, *, policy=policy.compat32)</code> </dt> <dd>
<p>Create a <a class="reference internal" href="#email.parser.BytesFeedParser" title="email.parser.BytesFeedParser"><code>BytesFeedParser</code></a> instance. Optional <em>_factory</em> is a no-argument callable; if not specified use the <a class="reference internal" href="email.policy#email.policy.Policy.message_factory" title="email.policy.Policy.message_factory"><code>message_factory</code></a> from the <em>policy</em>. Call <em>_factory</em> whenever a new message object is needed.</p> <p>If <em>policy</em> is specified use the rules it specifies to update the representation of the message. If <em>policy</em> is not set, use the <a class="reference internal" href="email.policy#email.policy.Compat32" title="email.policy.Compat32"><code>compat32</code></a> policy, which maintains backward compatibility with the Python 3.2 version of the email package and provides <a class="reference internal" href="email.compat32-message#email.message.Message" title="email.message.Message"><code>Message</code></a> as the default factory. All other policies provide <a class="reference internal" href="email.message#email.message.EmailMessage" title="email.message.EmailMessage"><code>EmailMessage</code></a> as the default <em>_factory</em>. For more information on what else <em>policy</em> controls, see the <a class="reference internal" href="email.policy#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code>policy</code></a> documentation.</p> <p>Note: <strong>The policy keyword should always be specified</strong>; The default will change to <a class="reference internal" href="email.policy#email.policy.default" title="email.policy.default"><code>email.policy.default</code></a> in a future version of Python.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Added the <em>policy</em> keyword.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span><em>_factory</em> defaults to the policy <code>message_factory</code>.</p> </div> <dl class="method"> <dt id="email.parser.BytesFeedParser.feed">
<code>feed(data)</code> </dt> <dd>
<p>Feed the parser some more data. <em>data</em> should be a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> containing one or more lines. The lines can be partial and the parser will stitch such partial lines together properly. The lines can have any of the three common line endings: carriage return, newline, or carriage return and newline (they can even be mixed).</p> </dd>
</dl> <dl class="method"> <dt id="email.parser.BytesFeedParser.close">
<code>close()</code> </dt> <dd>
<p>Complete the parsing of all previously fed data and return the root message object. It is undefined what happens if <a class="reference internal" href="#email.parser.BytesFeedParser.feed" title="email.parser.BytesFeedParser.feed"><code>feed()</code></a> is called after this method has been called.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="email.parser.FeedParser">
<code>class email.parser.FeedParser(_factory=None, *, policy=policy.compat32)</code> </dt> <dd>
<p>Works like <a class="reference internal" href="#email.parser.BytesFeedParser" title="email.parser.BytesFeedParser"><code>BytesFeedParser</code></a> except that the input to the <a class="reference internal" href="#email.parser.BytesFeedParser.feed" title="email.parser.BytesFeedParser.feed"><code>feed()</code></a> method must be a string. This is of limited utility, since the only way for such a message to be valid is for it to contain only ASCII text or, if <code>utf8</code> is <code>True</code>, no binary attachments.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Added the <em>policy</em> keyword.</p> </div> </dd>
</dl>   <h2 id="parser-api">Parser API</h2> <p>The <a class="reference internal" href="#email.parser.BytesParser" title="email.parser.BytesParser"><code>BytesParser</code></a> class, imported from the <a class="reference internal" href="#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code>email.parser</code></a> module, provides an API that can be used to parse a message when the complete contents of the message are available in a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> or file. The <a class="reference internal" href="#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code>email.parser</code></a> module also provides <a class="reference internal" href="#email.parser.Parser" title="email.parser.Parser"><code>Parser</code></a> for parsing strings, and header-only parsers, <a class="reference internal" href="#email.parser.BytesHeaderParser" title="email.parser.BytesHeaderParser"><code>BytesHeaderParser</code></a> and <a class="reference internal" href="#email.parser.HeaderParser" title="email.parser.HeaderParser"><code>HeaderParser</code></a>, which can be used if you’re only interested in the headers of the message. <a class="reference internal" href="#email.parser.BytesHeaderParser" title="email.parser.BytesHeaderParser"><code>BytesHeaderParser</code></a> and <a class="reference internal" href="#email.parser.HeaderParser" title="email.parser.HeaderParser"><code>HeaderParser</code></a> can be much faster in these situations, since they do not attempt to parse the message body, instead setting the payload to the raw body.</p> <dl class="class"> <dt id="email.parser.BytesParser">
<code>class email.parser.BytesParser(_class=None, *, policy=policy.compat32)</code> </dt> <dd>
<p>Create a <a class="reference internal" href="#email.parser.BytesParser" title="email.parser.BytesParser"><code>BytesParser</code></a> instance. The <em>_class</em> and <em>policy</em> arguments have the same meaning and semantics as the <em>_factory</em> and <em>policy</em> arguments of <a class="reference internal" href="#email.parser.BytesFeedParser" title="email.parser.BytesFeedParser"><code>BytesFeedParser</code></a>.</p> <p>Note: <strong>The policy keyword should always be specified</strong>; The default will change to <a class="reference internal" href="email.policy#email.policy.default" title="email.policy.default"><code>email.policy.default</code></a> in a future version of Python.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Removed the <em>strict</em> argument that was deprecated in 2.4. Added the <em>policy</em> keyword.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span><em>_class</em> defaults to the policy <code>message_factory</code>.</p> </div> <dl class="method"> <dt id="email.parser.BytesParser.parse">
<code>parse(fp, headersonly=False)</code> </dt> <dd>
<p>Read all the data from the binary file-like object <em>fp</em>, parse the resulting bytes, and return the message object. <em>fp</em> must support both the <a class="reference internal" href="io#io.IOBase.readline" title="io.IOBase.readline"><code>readline()</code></a> and the <code>read()</code> methods.</p> <p>The bytes contained in <em>fp</em> must be formatted as a block of <a class="rfc reference external" href="https://tools.ietf.org/html/rfc5322.html" id="index-0"><strong>RFC 5322</strong></a> (or, if <code>utf8</code> is <code>True</code>, <a class="rfc reference external" href="https://tools.ietf.org/html/rfc6532.html" id="index-1"><strong>RFC 6532</strong></a>) style headers and header continuation lines, optionally preceded by an envelope header. The header block is terminated either by the end of the data or by a blank line. Following the header block is the body of the message (which may contain MIME-encoded subparts, including subparts with a <em class="mailheader">Content-Transfer-Encoding</em> of <code>8bit</code>).</p> <p>Optional <em>headersonly</em> is a flag specifying whether to stop parsing after reading the headers or not. The default is <code>False</code>, meaning it parses the entire contents of the file.</p> </dd>
</dl> <dl class="method"> <dt id="email.parser.BytesParser.parsebytes">
<code>parsebytes(bytes, headersonly=False)</code> </dt> <dd>
<p>Similar to the <a class="reference internal" href="#email.parser.BytesParser.parse" title="email.parser.BytesParser.parse"><code>parse()</code></a> method, except it takes a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> instead of a file-like object. Calling this method on a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> is equivalent to wrapping <em>bytes</em> in a <a class="reference internal" href="io#io.BytesIO" title="io.BytesIO"><code>BytesIO</code></a> instance first and calling <a class="reference internal" href="#email.parser.BytesParser.parse" title="email.parser.BytesParser.parse"><code>parse()</code></a>.</p> <p>Optional <em>headersonly</em> is as with the <a class="reference internal" href="#email.parser.BytesParser.parse" title="email.parser.BytesParser.parse"><code>parse()</code></a> method.</p> </dd>
</dl> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> </dd>
</dl> <dl class="class"> <dt id="email.parser.BytesHeaderParser">
<code>class email.parser.BytesHeaderParser(_class=None, *, policy=policy.compat32)</code> </dt> <dd>
<p>Exactly like <a class="reference internal" href="#email.parser.BytesParser" title="email.parser.BytesParser"><code>BytesParser</code></a>, except that <em>headersonly</em> defaults to <code>True</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="class"> <dt id="email.parser.Parser">
<code>class email.parser.Parser(_class=None, *, policy=policy.compat32)</code> </dt> <dd>
<p>This class is parallel to <a class="reference internal" href="#email.parser.BytesParser" title="email.parser.BytesParser"><code>BytesParser</code></a>, but handles string input.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Removed the <em>strict</em> argument. Added the <em>policy</em> keyword.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span><em>_class</em> defaults to the policy <code>message_factory</code>.</p> </div> <dl class="method"> <dt id="email.parser.Parser.parse">
<code>parse(fp, headersonly=False)</code> </dt> <dd>
<p>Read all the data from the text-mode file-like object <em>fp</em>, parse the resulting text, and return the root message object. <em>fp</em> must support both the <a class="reference internal" href="io#io.TextIOBase.readline" title="io.TextIOBase.readline"><code>readline()</code></a> and the <a class="reference internal" href="io#io.TextIOBase.read" title="io.TextIOBase.read"><code>read()</code></a> methods on file-like objects.</p> <p>Other than the text mode requirement, this method operates like <a class="reference internal" href="#email.parser.BytesParser.parse" title="email.parser.BytesParser.parse"><code>BytesParser.parse()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="email.parser.Parser.parsestr">
<code>parsestr(text, headersonly=False)</code> </dt> <dd>
<p>Similar to the <a class="reference internal" href="#email.parser.Parser.parse" title="email.parser.Parser.parse"><code>parse()</code></a> method, except it takes a string object instead of a file-like object. Calling this method on a string is equivalent to wrapping <em>text</em> in a <a class="reference internal" href="io#io.StringIO" title="io.StringIO"><code>StringIO</code></a> instance first and calling <a class="reference internal" href="#email.parser.Parser.parse" title="email.parser.Parser.parse"><code>parse()</code></a>.</p> <p>Optional <em>headersonly</em> is as with the <a class="reference internal" href="#email.parser.Parser.parse" title="email.parser.Parser.parse"><code>parse()</code></a> method.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="email.parser.HeaderParser">
<code>class email.parser.HeaderParser(_class=None, *, policy=policy.compat32)</code> </dt> <dd>
<p>Exactly like <a class="reference internal" href="#email.parser.Parser" title="email.parser.Parser"><code>Parser</code></a>, except that <em>headersonly</em> defaults to <code>True</code>.</p> </dd>
</dl> <p>Since creating a message object structure from a string or a file object is such a common task, four functions are provided as a convenience. They are available in the top-level <a class="reference internal" href="email#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code>email</code></a> package namespace.</p> <dl class="function"> <dt id="email.message_from_bytes">
<code>email.message_from_bytes(s, _class=None, *, policy=policy.compat32)</code> </dt> <dd>
<p>Return a message object structure from a <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>. This is equivalent to <code>BytesParser().parsebytes(s)</code>. Optional <em>_class</em> and <em>policy</em> are interpreted as with the <a class="reference internal" href="#email.parser.BytesParser" title="email.parser.BytesParser"><code>BytesParser</code></a> class constructor.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Removed the <em>strict</em> argument. Added the <em>policy</em> keyword.</p> </div> </dd>
</dl> <dl class="function"> <dt id="email.message_from_binary_file">
<code>email.message_from_binary_file(fp, _class=None, *, policy=policy.compat32)</code> </dt> <dd>
<p>Return a message object structure tree from an open binary <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>. This is equivalent to <code>BytesParser().parse(fp)</code>. <em>_class</em> and <em>policy</em> are interpreted as with the <a class="reference internal" href="#email.parser.BytesParser" title="email.parser.BytesParser"><code>BytesParser</code></a> class constructor.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.2.</span></p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Removed the <em>strict</em> argument. Added the <em>policy</em> keyword.</p> </div> </dd>
</dl> <dl class="function"> <dt id="email.message_from_string">
<code>email.message_from_string(s, _class=None, *, policy=policy.compat32)</code> </dt> <dd>
<p>Return a message object structure from a string. This is equivalent to <code>Parser().parsestr(s)</code>. <em>_class</em> and <em>policy</em> are interpreted as with the <a class="reference internal" href="#email.parser.Parser" title="email.parser.Parser"><code>Parser</code></a> class constructor.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Removed the <em>strict</em> argument. Added the <em>policy</em> keyword.</p> </div> </dd>
</dl> <dl class="function"> <dt id="email.message_from_file">
<code>email.message_from_file(fp, _class=None, *, policy=policy.compat32)</code> </dt> <dd>
<p>Return a message object structure tree from an open <a class="reference internal" href="https://docs.python.org/3.9/glossary.html#term-file-object"><span class="xref std std-term">file object</span></a>. This is equivalent to <code>Parser().parse(fp)</code>. <em>_class</em> and <em>policy</em> are interpreted as with the <a class="reference internal" href="#email.parser.Parser" title="email.parser.Parser"><code>Parser</code></a> class constructor.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.3: </span>Removed the <em>strict</em> argument. Added the <em>policy</em> keyword.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span><em>_class</em> defaults to the policy <code>message_factory</code>.</p> </div> </dd>
</dl> <p>Here’s an example of how you might use <a class="reference internal" href="#email.message_from_bytes" title="email.message_from_bytes"><code>message_from_bytes()</code></a> at an interactive Python prompt:</p> <pre data-language="python">&gt;&gt;&gt; import email
&gt;&gt;&gt; msg = email.message_from_bytes(myBytes)  
</pre>   <h2 id="additional-notes">Additional notes</h2> <p>Here are some notes on the parsing semantics:</p> <ul class="simple"> <li>Most non-<em class="mimetype">multipart</em> type messages are parsed as a single message object with a string payload. These objects will return <code>False</code> for <a class="reference internal" href="email.message#email.message.EmailMessage.is_multipart" title="email.message.EmailMessage.is_multipart"><code>is_multipart()</code></a>, and <a class="reference internal" href="email.message#email.message.EmailMessage.iter_parts" title="email.message.EmailMessage.iter_parts"><code>iter_parts()</code></a> will yield an empty list.</li> <li>All <em class="mimetype">multipart</em> type messages will be parsed as a container message object with a list of sub-message objects for their payload. The outer container message will return <code>True</code> for <a class="reference internal" href="email.message#email.message.EmailMessage.is_multipart" title="email.message.EmailMessage.is_multipart"><code>is_multipart()</code></a>, and <a class="reference internal" href="email.message#email.message.EmailMessage.iter_parts" title="email.message.EmailMessage.iter_parts"><code>iter_parts()</code></a> will yield a list of subparts.</li> <li>Most messages with a content type of <em class="mimetype">message/*</em> (such as <em class="mimetype">message/delivery-status</em> and <em class="mimetype">message/rfc822</em>) will also be parsed as container object containing a list payload of length 1. Their <a class="reference internal" href="email.message#email.message.EmailMessage.is_multipart" title="email.message.EmailMessage.is_multipart"><code>is_multipart()</code></a> method will return <code>True</code>. The single element yielded by <a class="reference internal" href="email.message#email.message.EmailMessage.iter_parts" title="email.message.EmailMessage.iter_parts"><code>iter_parts()</code></a> will be a sub-message object.</li> <li>Some non-standards-compliant messages may not be internally consistent about their <em class="mimetype">multipart</em>-edness. Such messages may have a <em class="mailheader">Content-Type</em> header of type <em class="mimetype">multipart</em>, but their <a class="reference internal" href="email.message#email.message.EmailMessage.is_multipart" title="email.message.EmailMessage.is_multipart"><code>is_multipart()</code></a> method may return <code>False</code>. If such messages were parsed with the <a class="reference internal" href="#email.parser.FeedParser" title="email.parser.FeedParser"><code>FeedParser</code></a>, they will have an instance of the <code>MultipartInvariantViolationDefect</code> class in their <em>defects</em> attribute list. See <a class="reference internal" href="email.errors#module-email.errors" title="email.errors: The exception classes used by the email package."><code>email.errors</code></a> for details.</li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2001&ndash;2021 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.9/library/email.parser.html" class="_attribution-link">https://docs.python.org/3.9/library/email.parser.html</a>
  </p>
</div>
