<h1 class="devsite-page-title">tf.raw_ops.StridedSlice</h1>       <p>Return a strided slice from <code translate="no" dir="ltr">input</code>.</p> <section class="expandable"> <h4 class="showalways" id="view-aliases" data-text="View aliases">View aliases</h4> <p> <b>Compat aliases for migration</b> </p>
<p>See <a href="https://www.tensorflow.org/guide/migrate">Migration guide</a> for more details.</p> <p><a href="https://www.tensorflow.org/api_docs/python/tf/raw_ops/StridedSlice"><code translate="no" dir="ltr">tf.compat.v1.raw_ops.StridedSlice</code></a></p> </section> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tf.raw_ops.StridedSlice(
    input, begin, end, strides, begin_mask=0, end_mask=0, ellipsis_mask=0,
    new_axis_mask=0, shrink_axis_mask=0, name=None
)
</pre>  <p>Note, most python users will want to use the Python <a href="../tensor#__getitem__"><code translate="no" dir="ltr">Tensor.<strong>getitem</strong></code></a> or <a href="../variable#__getitem__"><code translate="no" dir="ltr">Variable.<strong>getitem</strong></code></a> rather than this op directly.</p> <p>The goal of this op is to produce a new tensor with a subset of the elements from the <code translate="no" dir="ltr">n</code> dimensional <code translate="no" dir="ltr">input</code> tensor. The subset is chosen using a sequence of <code translate="no" dir="ltr">m</code> sparse range specifications encoded into the arguments of this function. Note, in some cases <code translate="no" dir="ltr">m</code> could be equal to <code translate="no" dir="ltr">n</code>, but this need not be the case. Each range specification entry can be one of the following:</p> <ul> <li><p>An ellipsis (...). Ellipses are used to imply zero or more dimensions of full-dimension selection and are produced using <code translate="no" dir="ltr">ellipsis_mask</code>. For example, <code translate="no" dir="ltr">foo[...]</code> is the identity slice.</p></li> <li><p>A new axis. This is used to insert a new shape=1 dimension and is produced using <code translate="no" dir="ltr">new_axis_mask</code>. For example, <code translate="no" dir="ltr">foo[:, ...]</code> where <code translate="no" dir="ltr">foo</code> is shape <code translate="no" dir="ltr">(3, 4)</code> produces a <code translate="no" dir="ltr">(1, 3, 4)</code> tensor.</p></li> <li><p>A range <code translate="no" dir="ltr">begin:end:stride</code>. This is used to specify how much to choose from a given dimension. <code translate="no" dir="ltr">stride</code> can be any integer but 0. <code translate="no" dir="ltr">begin</code> is an integer which represents the index of the first value to select while <code translate="no" dir="ltr">end</code> represents the index of the last value to select. The number of values selected in each dimension is <code translate="no" dir="ltr">end - begin</code> if <code translate="no" dir="ltr">stride &gt; 0</code> and <code translate="no" dir="ltr">begin - end</code> if <code translate="no" dir="ltr">stride &lt; 0</code>. <code translate="no" dir="ltr">begin</code> and <code translate="no" dir="ltr">end</code> can be negative where <code translate="no" dir="ltr">-1</code> is the last element, <code translate="no" dir="ltr">-2</code> is the second to last. <code translate="no" dir="ltr">begin_mask</code> controls whether to replace the explicitly given <code translate="no" dir="ltr">begin</code> with an implicit effective value of <code translate="no" dir="ltr">0</code> if <code translate="no" dir="ltr">stride &gt; 0</code> and <code translate="no" dir="ltr">-1</code> if <code translate="no" dir="ltr">stride &lt; 0</code>. <code translate="no" dir="ltr">end_mask</code> is analogous but produces the number required to create the largest open interval. For example, given a shape <code translate="no" dir="ltr">(3,)</code> tensor <code translate="no" dir="ltr">foo[:]</code>, the effective <code translate="no" dir="ltr">begin</code> and <code translate="no" dir="ltr">end</code> are <code translate="no" dir="ltr">0</code> and <code translate="no" dir="ltr">3</code>. Do not assume this is equivalent to <code translate="no" dir="ltr">foo[0:-1]</code> which has an effective <code translate="no" dir="ltr">begin</code> and <code translate="no" dir="ltr">end</code> of <code translate="no" dir="ltr">0</code> and <code translate="no" dir="ltr">2</code>. Another example is <code translate="no" dir="ltr">foo[-2::-1]</code> which reverses the first dimension of a tensor while dropping the last two (in the original order elements). For example <code translate="no" dir="ltr">foo = [1,2,3,4]; foo[-2::-1]</code> is <code translate="no" dir="ltr">[4,3]</code>.</p></li> <li><p>A single index. This is used to keep only elements that have a given index. For example (<code translate="no" dir="ltr">foo[2, :]</code> on a shape <code translate="no" dir="ltr">(5,6)</code> tensor produces a shape <code translate="no" dir="ltr">(6,)</code> tensor. This is encoded in <code translate="no" dir="ltr">begin</code> and <code translate="no" dir="ltr">end</code> and <code translate="no" dir="ltr">shrink_axis_mask</code>.</p></li> </ul> <p>Each conceptual range specification is encoded in the op's argument. This encoding is best understand by considering a non-trivial example. In particular, <code translate="no" dir="ltr">foo[1, 2:4, None, ..., :-3:-1, :]</code> will be encoded as</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">begin = [1, 2, x, x, 0, x] # x denotes don't care (usually 0)
end = [2, 4, x, x, -3, x]
strides = [1, 1, x, x, -1, 1]
begin_mask = 1&lt;&lt;4 | 1&lt;&lt;5 = 48
end_mask = 1&lt;&lt;5 = 32
ellipsis_mask = 1&lt;&lt;3 = 8
new_axis_mask = 1&lt;&lt;2 = 4
shrink_axis_mask = 1&lt;&lt;0 = 1
</pre> <p>In this case if <code translate="no" dir="ltr">foo.shape</code> is (5, 5, 5, 5, 5, 5) the final shape of the slice becomes (2, 1, 5, 5, 2, 5). Let us walk step by step through each argument specification.</p> <ol> <li><p>The first argument in the example slice is turned into <code translate="no" dir="ltr">begin = 1</code> and <code translate="no" dir="ltr">end = begin + 1 = 2</code>. To disambiguate from the original spec <code translate="no" dir="ltr">2:4</code> we also set the appropriate bit in <code translate="no" dir="ltr">shrink_axis_mask</code>.</p></li> <li><p><code translate="no" dir="ltr">2:4</code> is contributes 2, 4, 1 to begin, end, and stride. All masks have zero bits contributed.</p></li> <li><p>None is a synonym for <a href="../../tf#newaxis"><code translate="no" dir="ltr">tf.newaxis</code></a>. This means insert a dimension of size 1 dimension in the final shape. Dummy values are contributed to begin, end and stride, while the new_axis_mask bit is set.</p></li> <li><p><code translate="no" dir="ltr">...</code> grab the full ranges from as many dimensions as needed to fully specify a slice for every dimension of the input shape.</p></li> <li><p><code translate="no" dir="ltr">:-3:-1</code> shows the use of negative indices. A negative index <code translate="no" dir="ltr">i</code> associated with a dimension that has shape <code translate="no" dir="ltr">s</code> is converted to a positive index <code translate="no" dir="ltr">s + i</code>. So <code translate="no" dir="ltr">-1</code> becomes <code translate="no" dir="ltr">s-1</code> (i.e. the last element). This conversion is done internally so begin, end and strides receive x, -3, and -1. The appropriate begin_mask bit is set to indicate the start range is the full range (ignoring the x).</p></li> <li><p><code translate="no" dir="ltr">:</code> indicates that the entire contents of the corresponding dimension is selected. This is equivalent to <code translate="no" dir="ltr">::</code> or <code translate="no" dir="ltr">0::1</code>. begin, end, and strides receive 0, 0, and 1, respectively. The appropriate bits in <code translate="no" dir="ltr">begin_mask</code> and <code translate="no" dir="ltr">end_mask</code> are also set.</p></li> </ol> <p><em>Requirements</em>: <code translate="no" dir="ltr">0 != strides[i] for i in [0, m)</code> <code translate="no" dir="ltr">ellipsis_mask must be a power of two (only one ellipsis)</code></p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">input</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">begin</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must be one of the following types: <code translate="no" dir="ltr">int32</code>, <code translate="no" dir="ltr">int64</code>. <code translate="no" dir="ltr">begin[k]</code> specifies the offset into the <code translate="no" dir="ltr">k</code>th range specification. The exact dimension this corresponds to will be determined by context. Out-of-bounds values will be silently clamped. If the <code translate="no" dir="ltr">k</code>th bit of <code translate="no" dir="ltr">begin_mask</code> then <code translate="no" dir="ltr">begin[k]</code> is ignored and the full range of the appropriate dimension is used instead. Negative values causes indexing to start from the highest element e.g. If <code translate="no" dir="ltr">foo==[1,2,3]</code> then <code translate="no" dir="ltr">foo[-1]==3</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">end</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must have the same type as <code translate="no" dir="ltr">begin</code>. <code translate="no" dir="ltr">end[i]</code> is like <code translate="no" dir="ltr">begin</code> with the exception that <code translate="no" dir="ltr">end_mask</code> is used to determine full ranges. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">strides</code> </td> <td> A <code translate="no" dir="ltr">Tensor</code>. Must have the same type as <code translate="no" dir="ltr">begin</code>. <code translate="no" dir="ltr">strides[i]</code> specifies the increment in the <code translate="no" dir="ltr">i</code>th specification after extracting a given element. Negative indices will reverse the original order. Out or range values are clamped to <code translate="no" dir="ltr">[0,dim[i]) if slice[i]&gt;0</code> or <code translate="no" dir="ltr">[-1,dim[i]-1] if slice[i] &lt; 0</code> </td> </tr>
<tr> <td> <code translate="no" dir="ltr">begin_mask</code> </td> <td> An optional <code translate="no" dir="ltr">int</code>. Defaults to <code translate="no" dir="ltr">0</code>. a bitmask where a bit i being 1 means to ignore the begin value and instead use the largest interval possible. At runtime begin[i] will be replaced with <code translate="no" dir="ltr">[0, n-1)</code> if <code translate="no" dir="ltr">stride[i] &gt; 0</code> or <code translate="no" dir="ltr">[-1, n-1]</code> if <code translate="no" dir="ltr">stride[i] &lt; 0</code> </td> </tr>
<tr> <td> <code translate="no" dir="ltr">end_mask</code> </td> <td> An optional <code translate="no" dir="ltr">int</code>. Defaults to <code translate="no" dir="ltr">0</code>. analogous to <code translate="no" dir="ltr">begin_mask</code> </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ellipsis_mask</code> </td> <td> An optional <code translate="no" dir="ltr">int</code>. Defaults to <code translate="no" dir="ltr">0</code>. a bitmask where bit <code translate="no" dir="ltr">i</code> being 1 means the <code translate="no" dir="ltr">i</code>th position is actually an ellipsis. One bit at most can be 1. If <code translate="no" dir="ltr">ellipsis_mask == 0</code>, then an implicit ellipsis mask of <code translate="no" dir="ltr">1 &lt;&lt; (m+1)</code> is provided. This means that <code translate="no" dir="ltr">foo[3:5] == foo[3:5, ...]</code>. An ellipsis implicitly creates as many range specifications as necessary to fully specify the sliced range for every dimension. For example for a 4-dimensional tensor <code translate="no" dir="ltr">foo</code> the slice <code translate="no" dir="ltr">foo[2, ..., 5:8]</code> implies <code translate="no" dir="ltr">foo[2, :, :, 5:8]</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">new_axis_mask</code> </td> <td> An optional <code translate="no" dir="ltr">int</code>. Defaults to <code translate="no" dir="ltr">0</code>. a bitmask where bit <code translate="no" dir="ltr">i</code> being 1 means the <code translate="no" dir="ltr">i</code>th specification creates a new shape 1 dimension. For example <code translate="no" dir="ltr">foo[:4, tf.newaxis, :2]</code> would produce a shape <code translate="no" dir="ltr">(4, 1, 2)</code> tensor. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">shrink_axis_mask</code> </td> <td> An optional <code translate="no" dir="ltr">int</code>. Defaults to <code translate="no" dir="ltr">0</code>. a bitmask where bit <code translate="no" dir="ltr">i</code> implies that the <code translate="no" dir="ltr">i</code>th specification should shrink the dimensionality. begin and end must imply a slice of size 1 in the dimension. For example in python one might do <code translate="no" dir="ltr">foo[:, 3, :]</code> which would result in <code translate="no" dir="ltr">shrink_axis_mask</code> being 2. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> A name for the operation (optional). </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A <code translate="no" dir="ltr">Tensor</code>. Has the same type as <code translate="no" dir="ltr">input</code>. </td> </tr> 
</table>  <devsite-page-rating position="footer" selected-rating="0" hover-rating-star="0"> </devsite-page-rating><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2020 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r2.4/api_docs/python/tf/raw_ops/StridedSlice" class="_attribution-link">https://www.tensorflow.org/versions/r2.4/api_docs/python/tf/raw_ops/StridedSlice</a>
  </p>
</div>
