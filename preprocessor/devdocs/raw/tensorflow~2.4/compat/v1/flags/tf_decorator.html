<h1 class="devsite-page-title">Module: tf.compat.v1.flags.tf_decorator</h1>       <p>Base TFDecorator class and utility functions for working with decorators.</p> <section class="expandable"> <h4 class="showalways" id="view-aliases" data-text="View aliases">View aliases</h4> <p> <b>Compat aliases for migration</b> </p>
<p>See <a href="https://www.tensorflow.org/guide/migrate">Migration guide</a> for more details.</p> <p><a href="https://www.tensorflow.org/api_docs/python/tf/compat/v1/flags/tf_decorator"><code translate="no" dir="ltr">tf.compat.v1.app.flags.tf_decorator</code></a></p> </section> <p>There are two ways to create decorators that TensorFlow can introspect into. This is important for documentation generation purposes, so that function signatures aren't obscured by the (*args, **kwds) signature that decorators often provide.</p> <ol> <li>Call <code translate="no" dir="ltr">tf_decorator.make_decorator</code> on your wrapper function. If your decorator is stateless, or can capture all of the variables it needs to work with through lexical closure, this is the simplest option. Create your wrapper function as usual, but instead of returning it, return <code translate="no" dir="ltr">tf_decorator.make_decorator(target, your_wrapper)</code>. This will attach some decorator introspection metadata onto your wrapper and return it.</li> </ol> <h4 id="example" data-text="Example:">Example:</h4> <p>def print_hello_before_calling(target): def wrapper(*args, *<em>kwargs): print('hello') return target(</em>args, **kwargs) return tf_decorator.make_decorator(target, wrapper)</p> <ol> <li>Derive from TFDecorator. If your decorator needs to be stateful, you can implement it in terms of a TFDecorator. Store whatever state you need in your derived class, and implement the <code translate="no" dir="ltr">__call__</code> method to do your work before calling into your target. You can retrieve the target via <code translate="no" dir="ltr">super(MyDecoratorClass, self).decorated_target</code>, and call it with whatever parameters it needs.</li> </ol> <h4 id="example_2" data-text="Example:">Example:</h4> <p>class CallCounter(tf_decorator.TFDecorator): def <strong>init</strong>(self, target): super(CallCounter, self).<strong>init</strong>('count_calls', target) self.call_count = 0</p> <p>def <strong>call</strong>(self, *args, *<em>kwargs): self.call_count += 1 return super(CallCounter, self).decorated_target(</em>args, **kwargs)</p> <p>def count_calls(target): return CallCounter(target)</p> <h2 id="modules" data-text="Modules">Modules</h2> <p><a href="tf_decorator/tf_stack"><code translate="no" dir="ltr">tf_stack</code></a> module: Functions used to extract and analyze stacks. Faster than Python libs.</p> <h2 id="classes" data-text="Classes">Classes</h2> <p><a href="tf_decorator/tfdecorator"><code translate="no" dir="ltr">class TFDecorator</code></a>: Base class for all TensorFlow decorators.</p> <h2 id="functions" data-text="Functions">Functions</h2> <p><a href="tf_decorator/make_decorator"><code translate="no" dir="ltr">make_decorator(...)</code></a>: Make a decorator from a wrapper and a target.</p> <p><a href="tf_decorator/rewrap"><code translate="no" dir="ltr">rewrap(...)</code></a>: Injects a new target into a function built by make_decorator.</p> <p><a href="tf_decorator/unwrap"><code translate="no" dir="ltr">unwrap(...)</code></a>: Unwraps an object into a list of TFDecorators and a final target.</p>  <devsite-page-rating position="footer" selected-rating="0" hover-rating-star="0"> </devsite-page-rating><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2020 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r2.4/api_docs/python/tf/compat/v1/flags/tf_decorator" class="_attribution-link">https://www.tensorflow.org/versions/r2.4/api_docs/python/tf/compat/v1/flags/tf_decorator</a>
  </p>
</div>
