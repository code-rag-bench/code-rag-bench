<h1 class="devsite-page-title">tf.compat.v1.keras.layers.LSTMCell</h1>       <p>Cell class for the LSTM layer.</p> <p>Inherits From: <a href="../../../../keras/layers/layer"><code translate="no" dir="ltr">Layer</code></a>, <a href="../../../../module"><code translate="no" dir="ltr">Module</code></a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tf.compat.v1.keras.layers.LSTMCell(
    units, activation='tanh',
    recurrent_activation='hard_sigmoid', use_bias=True,
    kernel_initializer='glorot_uniform',
    recurrent_initializer='orthogonal',
    bias_initializer='zeros', unit_forget_bias=True,
    kernel_regularizer=None, recurrent_regularizer=None, bias_regularizer=None,
    kernel_constraint=None, recurrent_constraint=None, bias_constraint=None,
    dropout=0.0, recurrent_dropout=0.0, **kwargs
)
</pre>   
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Arguments</th></tr> 
<tr> <td> <code translate="no" dir="ltr">units</code> </td> <td> Positive integer, dimensionality of the output space. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">activation</code> </td> <td> Activation function to use. Default: hyperbolic tangent (<code translate="no" dir="ltr">tanh</code>). If you pass <code translate="no" dir="ltr">None</code>, no activation is applied (ie. "linear" activation: <code translate="no" dir="ltr">a(x) = x</code>). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">recurrent_activation</code> </td> <td> Activation function to use for the recurrent step. Default: hard sigmoid (<code translate="no" dir="ltr">hard_sigmoid</code>). If you pass <code translate="no" dir="ltr">None</code>, no activation is applied (ie. "linear" activation: <code translate="no" dir="ltr">a(x) = x</code>). </td> </tr>
<tr> <td> <code translate="no" dir="ltr">use_bias</code> </td> <td> Boolean, whether the layer uses a bias vector. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">kernel_initializer</code> </td> <td> Initializer for the <code translate="no" dir="ltr">kernel</code> weights matrix, used for the linear transformation of the inputs. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">recurrent_initializer</code> </td> <td> Initializer for the <code translate="no" dir="ltr">recurrent_kernel</code> weights matrix, used for the linear transformation of the recurrent state. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">bias_initializer</code> </td> <td> Initializer for the bias vector. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">unit_forget_bias</code> </td> <td> Boolean. If True, add 1 to the bias of the forget gate at initialization. Setting it to true will also force <code translate="no" dir="ltr">bias_initializer="zeros"</code>. This is recommended in <a href="http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf">Jozefowicz et al., 2015</a> </td> </tr>
<tr> <td> <code translate="no" dir="ltr">kernel_regularizer</code> </td> <td> Regularizer function applied to the <code translate="no" dir="ltr">kernel</code> weights matrix. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">recurrent_regularizer</code> </td> <td> Regularizer function applied to the <code translate="no" dir="ltr">recurrent_kernel</code> weights matrix. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">bias_regularizer</code> </td> <td> Regularizer function applied to the bias vector. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">kernel_constraint</code> </td> <td> Constraint function applied to the <code translate="no" dir="ltr">kernel</code> weights matrix. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">recurrent_constraint</code> </td> <td> Constraint function applied to the <code translate="no" dir="ltr">recurrent_kernel</code> weights matrix. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">bias_constraint</code> </td> <td> Constraint function applied to the bias vector. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">dropout</code> </td> <td> Float between 0 and 1. Fraction of the units to drop for the linear transformation of the inputs. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">recurrent_dropout</code> </td> <td> Float between 0 and 1. Fraction of the units to drop for the linear transformation of the recurrent state. </td> </tr> </table> <h4 id="call_arguments" data-text="Call arguments:">Call arguments:</h4> <ul> <li>
<b><code translate="no" dir="ltr">inputs</code></b>: A 2D tensor.</li> <li>
<b><code translate="no" dir="ltr">states</code></b>: List of state tensors corresponding to the previous timestep.</li> <li>
<b><code translate="no" dir="ltr">training</code></b>: Python boolean indicating whether the layer should behave in training mode or in inference mode. Only relevant when <code translate="no" dir="ltr">dropout</code> or <code translate="no" dir="ltr">recurrent_dropout</code> is used.</li> </ul> <h2 id="methods" data-text="Methods">Methods</h2> <h3 id="get_dropout_mask_for_cell" data-text="get_dropout_mask_for_cell"><code translate="no" dir="ltr">get_dropout_mask_for_cell</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.4.0/tensorflow/python/keras/layers/recurrent.py#L1163-L1182">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
get_dropout_mask_for_cell(
    inputs, training, count=1
)
</pre> <p>Get the dropout mask for RNN cell's input.</p> <p>It will create mask based on context if there isn't any existing cached mask. If a new mask is generated, it will update the cache in the cell.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">inputs</code> </td> <td> The input tensor whose shape will be used to generate dropout mask. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">training</code> </td> <td> Boolean tensor, whether its in training mode, dropout will be ignored in non-training mode. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">count</code> </td> <td> Int, how many dropout mask will be generated. It is useful for cell that has internal weights fused together. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> List of mask tensor, generated or cached mask based on context. </td> </tr> 
</table> <h3 id="get_initial_state" data-text="get_initial_state"><code translate="no" dir="ltr">get_initial_state</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.4.0/tensorflow/python/keras/layers/recurrent.py#L2505-L2507">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
get_initial_state(
    inputs=None, batch_size=None, dtype=None
)
</pre> <h3 id="get_recurrent_dropout_mask_for_cell" data-text="get_recurrent_dropout_mask_for_cell"><code translate="no" dir="ltr">get_recurrent_dropout_mask_for_cell</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.4.0/tensorflow/python/keras/layers/recurrent.py#L1184-L1203">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
get_recurrent_dropout_mask_for_cell(
    inputs, training, count=1
)
</pre> <p>Get the recurrent dropout mask for RNN cell.</p> <p>It will create mask based on context if there isn't any existing cached mask. If a new mask is generated, it will update the cache in the cell.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">inputs</code> </td> <td> The input tensor whose shape will be used to generate dropout mask. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">training</code> </td> <td> Boolean tensor, whether its in training mode, dropout will be ignored in non-training mode. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">count</code> </td> <td> Int, how many dropout mask will be generated. It is useful for cell that has internal weights fused together. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> List of mask tensor, generated or cached mask based on context. </td> </tr> 
</table> <h3 id="reset_dropout_mask" data-text="reset_dropout_mask"><code translate="no" dir="ltr">reset_dropout_mask</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.4.0/tensorflow/python/keras/layers/recurrent.py#L1127-L1136">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
reset_dropout_mask()
</pre> <p>Reset the cached dropout masks if any.</p> <p>This is important for the RNN layer to invoke this in it <code translate="no" dir="ltr">call()</code> method so that the cached mask is cleared before calling the <code translate="no" dir="ltr">cell.call()</code>. The mask should be cached across the timestep within the same batch, but shouldn't be cached between batches. Otherwise it will introduce unreasonable bias against certain index of data within the batch.</p> <h3 id="reset_recurrent_dropout_mask" data-text="reset_recurrent_dropout_mask"><code translate="no" dir="ltr">reset_recurrent_dropout_mask</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/v2.4.0/tensorflow/python/keras/layers/recurrent.py#L1138-L1147">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
reset_recurrent_dropout_mask()
</pre> <p>Reset the cached recurrent dropout masks if any.</p> <p>This is important for the RNN layer to invoke this in it call() method so that the cached mask is cleared before calling the cell.call(). The mask should be cached across the timestep within the same batch, but shouldn't be cached between batches. Otherwise it will introduce unreasonable bias against certain index of data within the batch.</p>  <devsite-page-rating position="footer" selected-rating="0" hover-rating-star="0"> </devsite-page-rating><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2020 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r2.4/api_docs/python/tf/compat/v1/keras/layers/LSTMCell" class="_attribution-link">https://www.tensorflow.org/versions/r2.4/api_docs/python/tf/compat/v1/keras/layers/LSTMCell</a>
  </p>
</div>
