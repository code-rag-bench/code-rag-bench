<h1 class="devsite-page-title">tf.compat.v1.estimator.tpu.TPUEstimator</h1>       <p>Estimator with TPU support.</p> <p>Inherits From: <a href="../estimator"><code translate="no" dir="ltr">Estimator</code></a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
tf.compat.v1.estimator.tpu.TPUEstimator(
    model_fn=None, model_dir=None, config=None, params=None, use_tpu=True,
    train_batch_size=None, eval_batch_size=None, predict_batch_size=None,
    batch_axis=None, eval_on_tpu=True, export_to_tpu=True, export_to_cpu=True,
    warm_start_from=None, embedding_config_spec=None,
    export_saved_model_api_version=ExportSavedModelApiVersion.V1
)
</pre>  <p>TPUEstimator also supports training on CPU and GPU. You don't need to define a separate <a href="../../../../estimator/estimator"><code translate="no" dir="ltr">tf.estimator.Estimator</code></a>.</p> <p>TPUEstimator handles many of the details of running on TPU devices, such as replicating inputs and models for each core, and returning to host periodically to run hooks.</p> <p>TPUEstimator transforms a global batch size in params to a per-shard batch size when calling the <code translate="no" dir="ltr">input_fn</code> and <code translate="no" dir="ltr">model_fn</code>. Users should specify global batch size in constructor, and then get the batch size for each shard in <code translate="no" dir="ltr">input_fn</code> and <code translate="no" dir="ltr">model_fn</code> by <code translate="no" dir="ltr">params['batch_size']</code>.</p> <ul> <li><p>For training, <code translate="no" dir="ltr">model_fn</code> gets per-core batch size; <code translate="no" dir="ltr">input_fn</code> may get per-core or per-host batch size depending on <code translate="no" dir="ltr">per_host_input_for_training</code> in <code translate="no" dir="ltr">TPUConfig</code> (See docstring for TPUConfig for details).</p></li> <li><p>For evaluation and prediction, <code translate="no" dir="ltr">model_fn</code> gets per-core batch size and <code translate="no" dir="ltr">input_fn</code> get per-host batch size.</p></li> </ul> <h1 id="evaluation" class="page-title" data-text="Evaluation">Evaluation</h1> <p><code translate="no" dir="ltr">model_fn</code> should return <code translate="no" dir="ltr">TPUEstimatorSpec</code>, which expects the <code translate="no" dir="ltr">eval_metrics</code> for TPU evaluation. If eval_on_tpu is False, the evaluation will execute on CPU or GPU; in this case the following discussion on TPU evaluation does not apply.</p> <p><code translate="no" dir="ltr">TPUEstimatorSpec.eval_metrics</code> is a tuple of <code translate="no" dir="ltr">metric_fn</code> and <code translate="no" dir="ltr">tensors</code>, where <code translate="no" dir="ltr">tensors</code> could be a list of any nested structure of <code translate="no" dir="ltr">Tensor</code>s (See <code translate="no" dir="ltr">TPUEstimatorSpec</code> for details). <code translate="no" dir="ltr">metric_fn</code> takes the <code translate="no" dir="ltr">tensors</code> and returns a dict from metric string name to the result of calling a metric function, namely a <code translate="no" dir="ltr">(metric_tensor, update_op)</code> tuple.</p> <p>One can set <code translate="no" dir="ltr">use_tpu</code> to <code translate="no" dir="ltr">False</code> for testing. All training, evaluation, and predict will be executed on CPU. <code translate="no" dir="ltr">input_fn</code> and <code translate="no" dir="ltr">model_fn</code> will receive <code translate="no" dir="ltr">train_batch_size</code> or <code translate="no" dir="ltr">eval_batch_size</code> unmodified as <code translate="no" dir="ltr">params['batch_size']</code>.</p> <h4 id="current_limitations" data-text="Current limitations:">Current limitations:</h4>  <ol> <li><p>TPU evaluation only works on a single host (one TPU worker) except BROADCAST mode.</p></li> <li><p><code translate="no" dir="ltr">input_fn</code> for evaluation should <strong>NOT</strong> raise an end-of-input exception (<code translate="no" dir="ltr">OutOfRangeError</code> or <code translate="no" dir="ltr">StopIteration</code>). And all evaluation steps and all batches should have the same size.</p></li> </ol> <h2 id="example_mnist" data-text="Example (MNIST):">Example (MNIST):</h2> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp"># The metric Fn which runs on CPU.
def metric_fn(labels, logits):
  predictions = tf.argmax(logits, 1)
  return {
    'accuracy': tf.compat.v1.metrics.precision(
        labels=labels, predictions=predictions),
  }

# Your model Fn which runs on TPU (eval_metrics is list in this example)
def model_fn(features, labels, mode, config, params):
  ...
  logits = ...

  if mode = tf.estimator.ModeKeys.EVAL:
    return tpu_estimator.TPUEstimatorSpec(
        mode=mode,
        loss=loss,
        eval_metrics=(metric_fn, [labels, logits]))

# or specify the eval_metrics tensors as dict.
def model_fn(features, labels, mode, config, params):
  ...
  final_layer_output = ...

  if mode = tf.estimator.ModeKeys.EVAL:
    return tpu_estimator.TPUEstimatorSpec(
        mode=mode,
        loss=loss,
        eval_metrics=(metric_fn, {
            'labels': labels,
            'logits': final_layer_output,
        }))
</pre> <h1 id="prediction" class="page-title" data-text="Prediction">Prediction</h1> <p>Prediction on TPU is an experimental feature to support large batch inference. It is not designed for latency-critical system. In addition, due to some usability issues, for prediction with small dataset, CPU <code translate="no" dir="ltr">.predict</code>, i.e., creating a new <code translate="no" dir="ltr">TPUEstimator</code> instance with <code translate="no" dir="ltr">use_tpu=False</code>, might be more convenient.</p> <blockquote class="note">
<strong>Note:</strong><span> In contrast to TPU training/evaluation, the <code translate="no" dir="ltr">input_fn</code> for prediction <em>should</em> raise an end-of-input exception (<code translate="no" dir="ltr">OutOfRangeError</code> or <code translate="no" dir="ltr">StopIteration</code>), which serves as the stopping signal to <code translate="no" dir="ltr">TPUEstimator</code>. To be precise, the ops created by <code translate="no" dir="ltr">input_fn</code> produce one batch of the data. The <code translate="no" dir="ltr">predict()</code> API processes one batch at a time. When reaching the end of the data source, an end-of-input exception should be raised by one of these operations. The user usually does not need to do this manually. As long as the dataset is not repeated forever, the <a href="../../../../data"><code translate="no" dir="ltr">tf.data</code></a> API will raise an end-of-input exception automatically after the last batch has been produced.</span>
</blockquote>
<blockquote class="note">
<strong>Note:</strong><span> Estimator.predict returns a Python generator. Please consume all the data from the generator so that TPUEstimator can shutdown the TPU system properly for user.</span>
</blockquote> <h4 id="current_limitations_2" data-text="Current limitations:">Current limitations:</h4>  <ol> <li><p>TPU prediction only works on a single host (one TPU worker).</p></li> <li><p><code translate="no" dir="ltr">input_fn</code> must return a <code translate="no" dir="ltr">Dataset</code> instance rather than <code translate="no" dir="ltr">features</code>. In fact, .train() and .evaluate() also support Dataset as return value.</p></li> </ol> <h2 id="example_mnist_2" data-text="Example (MNIST):">Example (MNIST):</h2> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">height = 32
width = 32
total_examples = 100

def predict_input_fn(params):
  batch_size = params['batch_size']

  images = tf.random.uniform(
      [total_examples, height, width, 3], minval=-1, maxval=1)

  dataset = tf.data.Dataset.from_tensor_slices(images)
  dataset = dataset.map(lambda images: {'image': images})

  dataset = dataset.batch(batch_size)
  return dataset

def model_fn(features, labels, params, mode):
   # Generate predictions, called 'output', from features['image']

  if mode == tf.estimator.ModeKeys.PREDICT:
    return tf.contrib.tpu.TPUEstimatorSpec(
        mode=mode,
        predictions={
            'predictions': output,
            'is_padding': features['is_padding']
        })

tpu_est = TPUEstimator(
    model_fn=model_fn,
    ...,
    predict_batch_size=16)

# Fully consume the generator so that TPUEstimator can shutdown the TPU
# system.
for item in tpu_est.predict(input_fn=input_fn):
  # Filter out item if the `is_padding` is 1.
  # Process the 'predictions'
</pre> <h1 id="exporting" class="page-title" data-text="Exporting">Exporting</h1> <p><code translate="no" dir="ltr">export_saved_model</code> exports 2 metagraphs, one with <a href="https://www.tensorflow.org/api_docs/python/tf/saved_model#SERVING"><code translate="no" dir="ltr">saved_model.SERVING</code></a>, and another with <a href="https://www.tensorflow.org/api_docs/python/tf/saved_model#SERVING"><code translate="no" dir="ltr">saved_model.SERVING</code></a> and <a href="https://www.tensorflow.org/api_docs/python/tf/saved_model#TPU"><code translate="no" dir="ltr">saved_model.TPU</code></a> tags. At serving time, these tags are used to select the appropriate metagraph to load.</p> <p>Before running the graph on TPU, the TPU system needs to be initialized. If TensorFlow Serving model-server is used, this is done automatically. If not, please use <code translate="no" dir="ltr">session.run(tpu.initialize_system())</code>.</p> <p>There are two versions of the API: 1 or 2.</p> <p>In V1, the exported CPU graph is <code translate="no" dir="ltr">model_fn</code> as it is. The exported TPU graph wraps <code translate="no" dir="ltr">tpu.rewrite()</code> and <code translate="no" dir="ltr">TPUPartitionedCallOp</code> around <code translate="no" dir="ltr">model_fn</code> so <code translate="no" dir="ltr">model_fn</code> is on TPU by default. To place ops on CPU, <code translate="no" dir="ltr">tpu.outside_compilation(host_call, logits)</code> can be used.</p> <h4 id="example" data-text="Example:">Example:</h4>  <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">def model_fn(features, labels, mode, config, params):
  ...
  logits = ...
  export_outputs = {
    'logits': export_output_lib.PredictOutput(
      {'logits': logits})
  }

  def host_call(logits):
    class_ids = math_ops.argmax(logits)
    classes = string_ops.as_string(class_ids)
    export_outputs['classes'] =
      export_output_lib.ClassificationOutput(classes=classes)

  tpu.outside_compilation(host_call, logits)

  ...
</pre> <p>In V2, <code translate="no" dir="ltr">export_saved_model()</code> sets up <code translate="no" dir="ltr">params['use_tpu']</code> flag to let the user know if the code is exporting to TPU (or not). When <code translate="no" dir="ltr">params['use_tpu']</code> is <code translate="no" dir="ltr">True</code>, users need to call <code translate="no" dir="ltr">tpu.rewrite()</code>, <code translate="no" dir="ltr">TPUPartitionedCallOp</code> and/or <code translate="no" dir="ltr">batch_function()</code>. Alternatively use <code translate="no" dir="ltr">inference_on_tpu()</code> which is a convenience wrapper of the three.</p> <pre class="prettyprint" translate="no" dir="ltr" data-language="cpp">def model_fn(features, labels, mode, config, params):
  ...
  # This could be some pre-processing on CPU like calls to input layer with
  # embedding columns.
  x2 = features['x'] * 2

  def computation(input_tensor):
    return layers.dense(
        input_tensor, 1, kernel_initializer=init_ops.zeros_initializer())

  inputs = [x2]
  if params['use_tpu']:
    predictions = array_ops.identity(
        tpu_estimator.inference_on_tpu(computation, inputs,
        num_batch_threads=1, max_batch_size=2, batch_timeout_micros=100),
        name='predictions')
  else:
    predictions = array_ops.identity(
        computation(*inputs), name='predictions')
  key = signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY
  export_outputs = {
      key: export_lib.PredictOutput({'prediction': predictions})
  }
  ...
</pre> <p>TIP: V2 is recommended as it is more flexible (eg: batching, etc).</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">model_fn</code> </td> <td> Model function as required by <code translate="no" dir="ltr">Estimator</code> which returns EstimatorSpec or TPUEstimatorSpec. <code translate="no" dir="ltr">training_hooks</code>, 'evaluation_hooks', and <code translate="no" dir="ltr">prediction_hooks</code> must not capure any TPU Tensor inside the model_fn. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">model_dir</code> </td> <td> Directory to save model parameters, graph and etc. This can also be used to load checkpoints from the directory into a estimator to continue training a previously saved model. If <code translate="no" dir="ltr">None</code>, the model_dir in <code translate="no" dir="ltr">config</code> will be used if set. If both are set, they must be same. If both are <code translate="no" dir="ltr">None</code>, a temporary directory will be used. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">config</code> </td> <td> An <code translate="no" dir="ltr">tpu_config.RunConfig</code> configuration object. Cannot be <code translate="no" dir="ltr">None</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">params</code> </td> <td> An optional <code translate="no" dir="ltr">dict</code> of hyper parameters that will be passed into <code translate="no" dir="ltr">input_fn</code> and <code translate="no" dir="ltr">model_fn</code>. Keys are names of parameters, values are basic python types. There are reserved keys for <code translate="no" dir="ltr">TPUEstimator</code>, including 'batch_size'. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">use_tpu</code> </td> <td> A bool indicating whether TPU support is enabled. Currently, - TPU training and evaluation respect this bit, but eval_on_tpu can override execution of eval. See below. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">train_batch_size</code> </td> <td> An int representing the global training batch size. TPUEstimator transforms this global batch size to a per-shard batch size, as params['batch_size'], when calling <code translate="no" dir="ltr">input_fn</code> and <code translate="no" dir="ltr">model_fn</code>. Cannot be <code translate="no" dir="ltr">None</code> if <code translate="no" dir="ltr">use_tpu</code> is <code translate="no" dir="ltr">True</code>. Must be divisible by total number of replicas. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">eval_batch_size</code> </td> <td> An int representing evaluation batch size. Must be divisible by total number of replicas. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">predict_batch_size</code> </td> <td> An int representing the prediction batch size. Must be divisible by total number of replicas. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">batch_axis</code> </td> <td> A python tuple of int values describing how each tensor produced by the Estimator <code translate="no" dir="ltr">input_fn</code> should be split across the TPU compute shards. For example, if your input_fn produced (images, labels) where the images tensor is in <code translate="no" dir="ltr">HWCN</code> format, your shard dimensions would be [3, 0], where 3 corresponds to the <code translate="no" dir="ltr">N</code> dimension of your images Tensor, and 0 corresponds to the dimension along which to split the labels to match up with the corresponding images. If None is supplied, and per_host_input_for_training is True, batches will be sharded based on the major dimension. If tpu_config.per_host_input_for_training is False or <code translate="no" dir="ltr">PER_HOST_V2</code>, batch_axis is ignored. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">eval_on_tpu</code> </td> <td> If False, evaluation runs on CPU or GPU. In this case, the model_fn must return <code translate="no" dir="ltr">EstimatorSpec</code> when called with <code translate="no" dir="ltr">mode</code> as <code translate="no" dir="ltr">EVAL</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">export_to_tpu</code> </td> <td> If True, <code translate="no" dir="ltr">export_saved_model()</code> exports a metagraph for serving on TPU. Note that unsupported export modes such as EVAL will be ignored. For those modes, only a CPU model will be exported. Currently, export_to_tpu only supports PREDICT. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">export_to_cpu</code> </td> <td> If True, <code translate="no" dir="ltr">export_saved_model()</code> exports a metagraph for serving on CPU. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">warm_start_from</code> </td> <td> Optional string filepath to a checkpoint or SavedModel to warm-start from, or a <a href="../../../../estimator/warmstartsettings"><code translate="no" dir="ltr">tf.estimator.WarmStartSettings</code></a> object to fully configure warm-starting. If the string filepath is provided instead of a <code translate="no" dir="ltr">WarmStartSettings</code>, then all variables are warm-started, and it is assumed that vocabularies and Tensor names are unchanged. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">embedding_config_spec</code> </td> <td> Optional EmbeddingConfigSpec instance to support using TPU embedding. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">export_saved_model_api_version</code> </td> <td> an integer: 1 or 2. 1 corresponds to V1, 2 corresponds to V2. (Defaults to V1). With V1, <code translate="no" dir="ltr">export_saved_model()</code> adds rewrite() and TPUPartitionedCallOp() for user; while in v2, user is expected to add rewrite(), TPUPartitionedCallOp() etc in their model_fn. A helper function <code translate="no" dir="ltr">inference_on_tpu</code> is provided for V2. brn_tpu_estimator.py includes examples for both versions i.e. TPUEstimatorExportTest and TPUEstimatorExportV2Test. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> <code translate="no" dir="ltr">params</code> has reserved keys already. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Attributes</th></tr> 
<tr> <td> <code translate="no" dir="ltr">config</code> </td> <td> 
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">model_dir</code> </td> <td> 
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">model_fn</code> </td> <td> Returns the <code translate="no" dir="ltr">model_fn</code> which is bound to <code translate="no" dir="ltr">self.params</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">params</code> </td> <td> 
</td> </tr> </table> <h2 id="methods" data-text="Methods">Methods</h2> <h3 id="eval_dir" data-text="eval_dir"><code translate="no" dir="ltr">eval_dir</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/estimator/tree/master/tensorflow_estimator/python/estimator/estimator.py#L378-L390">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
eval_dir(
    name=None
)
</pre> <p>Shows the directory name where evaluation metrics are dumped.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> Name of the evaluation if user needs to run multiple evaluations on different data sets, such as on training data vs test data. Metrics for different evaluations are saved in separate folders, and appear separately in tensorboard. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A string which is the path of directory contains evaluation metrics. </td> </tr> 
</table> <h3 id="evaluate" data-text="evaluate"><code translate="no" dir="ltr">evaluate</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/estimator/tree/master/tensorflow_estimator/python/estimator/tpu/tpu_estimator.py#L3132-L3151">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
evaluate(
    input_fn, steps=None, hooks=None, checkpoint_path=None, name=None
)
</pre> <p>Evaluates the model given evaluation data <code translate="no" dir="ltr">input_fn</code>.</p> <p>For each step, calls <code translate="no" dir="ltr">input_fn</code>, which returns one batch of data. Evaluates until:</p> <ul> <li>
<code translate="no" dir="ltr">steps</code> batches are processed, or</li> <li>
<code translate="no" dir="ltr">input_fn</code> raises an end-of-input exception (<a href="../../../../errors/outofrangeerror"><code translate="no" dir="ltr">tf.errors.OutOfRangeError</code></a> or <code translate="no" dir="ltr">StopIteration</code>).</li> </ul>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">input_fn</code> </td> <td> A function that constructs the input data for evaluation. See <a href="https://tensorflow.org/guide/premade_estimators#create_input_functions">Premade Estimators</a> for more information. The function should construct and return one of the following: <ul> <li>A <a href="../../../../data/dataset"><code translate="no" dir="ltr">tf.data.Dataset</code></a> object: Outputs of <code translate="no" dir="ltr">Dataset</code> object must be a tuple <code translate="no" dir="ltr">(features, labels)</code> with same constraints as below.</li> <li>A tuple <code translate="no" dir="ltr">(features, labels)</code>: Where <code translate="no" dir="ltr">features</code> is a <a href="../../../../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a> or a dictionary of string feature name to <code translate="no" dir="ltr">Tensor</code> and <code translate="no" dir="ltr">labels</code> is a <code translate="no" dir="ltr">Tensor</code> or a dictionary of string label name to <code translate="no" dir="ltr">Tensor</code>. Both <code translate="no" dir="ltr">features</code> and <code translate="no" dir="ltr">labels</code> are consumed by <code translate="no" dir="ltr">model_fn</code>. They should satisfy the expectation of <code translate="no" dir="ltr">model_fn</code> from inputs. </li>
</ul>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">steps</code> </td> <td> Number of steps for which to evaluate model. If <code translate="no" dir="ltr">None</code>, evaluates until <code translate="no" dir="ltr">input_fn</code> raises an end-of-input exception. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">hooks</code> </td> <td> List of <code translate="no" dir="ltr">tf.train.SessionRunHook</code> subclass instances. Used for callbacks inside the evaluation call. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">checkpoint_path</code> </td> <td> Path of a specific checkpoint to evaluate. If <code translate="no" dir="ltr">None</code>, the latest checkpoint in <code translate="no" dir="ltr">model_dir</code> is used. If there are no checkpoints in <code translate="no" dir="ltr">model_dir</code>, evaluation is run with newly initialized <code translate="no" dir="ltr">Variables</code> instead of ones restored from checkpoint. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> Name of the evaluation if user needs to run multiple evaluations on different data sets, such as on training data vs test data. Metrics for different evaluations are saved in separate folders, and appear separately in tensorboard. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> A dict containing the evaluation metrics specified in <code translate="no" dir="ltr">model_fn</code> keyed by name, as well as an entry <code translate="no" dir="ltr">global_step</code> which contains the value of the global step for which this evaluation was performed. For canned estimators, the dict contains the <code translate="no" dir="ltr">loss</code> (mean loss per mini-batch) and the <code translate="no" dir="ltr">average_loss</code> (mean loss per sample). Canned classifiers also return the <code translate="no" dir="ltr">accuracy</code>. Canned regressors also return the <code translate="no" dir="ltr">label/mean</code> and the <code translate="no" dir="ltr">prediction/mean</code>. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If <code translate="no" dir="ltr">steps &lt;= 0</code>. </td> </tr> </table> <h3 id="experimental_export_all_saved_models" data-text="experimental_export_all_saved_models"><code translate="no" dir="ltr">experimental_export_all_saved_models</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/estimator/tree/master/tensorflow_estimator/python/estimator/estimator.py#L727-L799">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
experimental_export_all_saved_models(
    export_dir_base, input_receiver_fn_map, assets_extra=None, as_text=False,
    checkpoint_path=None
)
</pre> <p>Exports a <code translate="no" dir="ltr">SavedModel</code> with <code translate="no" dir="ltr">tf.MetaGraphDefs</code> for each requested mode.</p> <p>For each mode passed in via the <code translate="no" dir="ltr">input_receiver_fn_map</code>, this method builds a new graph by calling the <code translate="no" dir="ltr">input_receiver_fn</code> to obtain feature and label <code translate="no" dir="ltr">Tensor</code>s. Next, this method calls the <code translate="no" dir="ltr">Estimator</code>'s <code translate="no" dir="ltr">model_fn</code> in the passed mode to generate the model graph based on those features and labels, and restores the given checkpoint (or, lacking that, the most recent checkpoint) into the graph. Only one of the modes is used for saving variables to the <code translate="no" dir="ltr">SavedModel</code> (order of preference: <a href="../../../../estimator/modekeys#TRAIN"><code translate="no" dir="ltr">tf.estimator.ModeKeys.TRAIN</code></a>, <a href="../../../../estimator/modekeys#EVAL"><code translate="no" dir="ltr">tf.estimator.ModeKeys.EVAL</code></a>, then <a href="../../../../estimator/modekeys#PREDICT"><code translate="no" dir="ltr">tf.estimator.ModeKeys.PREDICT</code></a>), such that up to three <code translate="no" dir="ltr">tf.MetaGraphDefs</code> are saved with a single set of variables in a single <code translate="no" dir="ltr">SavedModel</code> directory.</p> <p>For the variables and <code translate="no" dir="ltr">tf.MetaGraphDefs</code>, a timestamped export directory below <code translate="no" dir="ltr">export_dir_base</code>, and writes a <code translate="no" dir="ltr">SavedModel</code> into it containing the <code translate="no" dir="ltr">tf.MetaGraphDef</code> for the given mode and its associated signatures.</p> <p>For prediction, the exported <code translate="no" dir="ltr">MetaGraphDef</code> will provide one <code translate="no" dir="ltr">SignatureDef</code> for each element of the <code translate="no" dir="ltr">export_outputs</code> dict returned from the <code translate="no" dir="ltr">model_fn</code>, named using the same keys. One of these keys is always <code translate="no" dir="ltr">tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY</code>, indicating which signature will be served when a serving request does not specify one. For each signature, the outputs are provided by the corresponding <a href="../../../../estimator/export/exportoutput"><code translate="no" dir="ltr">tf.estimator.export.ExportOutput</code></a>s, and the inputs are always the input receivers provided by the <code translate="no" dir="ltr">serving_input_receiver_fn</code>.</p> <p>For training and evaluation, the <code translate="no" dir="ltr">train_op</code> is stored in an extra collection, and loss, metrics, and predictions are included in a <code translate="no" dir="ltr">SignatureDef</code> for the mode in question.</p> <p>Extra assets may be written into the <code translate="no" dir="ltr">SavedModel</code> via the <code translate="no" dir="ltr">assets_extra</code> argument. This should be a dict, where each key gives a destination path (including the filename) relative to the assets.extra directory. The corresponding value gives the full path of the source file to be copied. For example, the simple case of copying a single file without renaming it is specified as <code translate="no" dir="ltr">{'my_asset_file.txt': '/path/to/my_asset_file.txt'}</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">export_dir_base</code> </td> <td> A string containing a directory in which to create timestamped subdirectories containing exported <code translate="no" dir="ltr">SavedModel</code>s. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">input_receiver_fn_map</code> </td> <td> dict of <a href="../../../../estimator/modekeys"><code translate="no" dir="ltr">tf.estimator.ModeKeys</code></a> to <code translate="no" dir="ltr">input_receiver_fn</code> mappings, where the <code translate="no" dir="ltr">input_receiver_fn</code> is a function that takes no arguments and returns the appropriate subclass of <code translate="no" dir="ltr">InputReceiver</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">assets_extra</code> </td> <td> A dict specifying how to populate the assets.extra directory within the exported <code translate="no" dir="ltr">SavedModel</code>, or <code translate="no" dir="ltr">None</code> if no extra assets are needed. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">as_text</code> </td> <td> whether to write the <code translate="no" dir="ltr">SavedModel</code> proto in text format. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">checkpoint_path</code> </td> <td> The checkpoint path to export. If <code translate="no" dir="ltr">None</code> (the default), the most recent checkpoint found within the model directory is chosen. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> The path to the exported directory as a bytes object. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> if any <code translate="no" dir="ltr">input_receiver_fn</code> is <code translate="no" dir="ltr">None</code>, no <code translate="no" dir="ltr">export_outputs</code> are provided, or no checkpoint can be found. </td> </tr> </table> <h3 id="export_saved_model" data-text="export_saved_model"><code translate="no" dir="ltr">export_saved_model</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/estimator/tree/master/tensorflow_estimator/python/estimator/estimator.py#L648-L725">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
export_saved_model(
    export_dir_base, serving_input_receiver_fn, assets_extra=None, as_text=False,
    checkpoint_path=None, experimental_mode=ModeKeys.PREDICT
)
</pre> <p>Exports inference graph as a <code translate="no" dir="ltr">SavedModel</code> into the given dir.</p> <p>For a detailed guide, see <a href="https://tensorflow.org/guide/saved_model#savedmodels_from_estimators">SavedModel from Estimators</a>.</p> <p>This method builds a new graph by first calling the <code translate="no" dir="ltr">serving_input_receiver_fn</code> to obtain feature <code translate="no" dir="ltr">Tensor</code>s, and then calling this <code translate="no" dir="ltr">Estimator</code>'s <code translate="no" dir="ltr">model_fn</code> to generate the model graph based on those features. It restores the given checkpoint (or, lacking that, the most recent checkpoint) into this graph in a fresh session. Finally it creates a timestamped export directory below the given <code translate="no" dir="ltr">export_dir_base</code>, and writes a <code translate="no" dir="ltr">SavedModel</code> into it containing a single <code translate="no" dir="ltr">tf.MetaGraphDef</code> saved from this session.</p> <p>The exported <code translate="no" dir="ltr">MetaGraphDef</code> will provide one <code translate="no" dir="ltr">SignatureDef</code> for each element of the <code translate="no" dir="ltr">export_outputs</code> dict returned from the <code translate="no" dir="ltr">model_fn</code>, named using the same keys. One of these keys is always <code translate="no" dir="ltr">tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY</code>, indicating which signature will be served when a serving request does not specify one. For each signature, the outputs are provided by the corresponding <a href="../../../../estimator/export/exportoutput"><code translate="no" dir="ltr">tf.estimator.export.ExportOutput</code></a>s, and the inputs are always the input receivers provided by the <code translate="no" dir="ltr">serving_input_receiver_fn</code>.</p> <p>Extra assets may be written into the <code translate="no" dir="ltr">SavedModel</code> via the <code translate="no" dir="ltr">assets_extra</code> argument. This should be a dict, where each key gives a destination path (including the filename) relative to the assets.extra directory. The corresponding value gives the full path of the source file to be copied. For example, the simple case of copying a single file without renaming it is specified as <code translate="no" dir="ltr">{'my_asset_file.txt': '/path/to/my_asset_file.txt'}</code>.</p> <p>The experimental_mode parameter can be used to export a single train/eval/predict graph as a <code translate="no" dir="ltr">SavedModel</code>. See <code translate="no" dir="ltr">experimental_export_all_saved_models</code> for full docs.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">export_dir_base</code> </td> <td> A string containing a directory in which to create timestamped subdirectories containing exported <code translate="no" dir="ltr">SavedModel</code>s. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">serving_input_receiver_fn</code> </td> <td> A function that takes no argument and returns a <a href="../../../../estimator/export/servinginputreceiver"><code translate="no" dir="ltr">tf.estimator.export.ServingInputReceiver</code></a> or <a href="../../../../estimator/export/tensorservinginputreceiver"><code translate="no" dir="ltr">tf.estimator.export.TensorServingInputReceiver</code></a>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">assets_extra</code> </td> <td> A dict specifying how to populate the assets.extra directory within the exported <code translate="no" dir="ltr">SavedModel</code>, or <code translate="no" dir="ltr">None</code> if no extra assets are needed. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">as_text</code> </td> <td> whether to write the <code translate="no" dir="ltr">SavedModel</code> proto in text format. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">checkpoint_path</code> </td> <td> The checkpoint path to export. If <code translate="no" dir="ltr">None</code> (the default), the most recent checkpoint found within the model directory is chosen. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">experimental_mode</code> </td> <td> <a href="../../../../estimator/modekeys"><code translate="no" dir="ltr">tf.estimator.ModeKeys</code></a> value indicating with mode will be exported. Note that this feature is experimental. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> The path to the exported directory as a bytes object. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> if no <code translate="no" dir="ltr">serving_input_receiver_fn</code> is provided, no <code translate="no" dir="ltr">export_outputs</code> are provided, or no checkpoint can be found. </td> </tr> </table> <h3 id="export_savedmodel" data-text="export_savedmodel"><code translate="no" dir="ltr">export_savedmodel</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/estimator/tree/master/tensorflow_estimator/python/estimator/estimator.py#L1670-L1744">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
export_savedmodel(
    export_dir_base, serving_input_receiver_fn, assets_extra=None, as_text=False,
    checkpoint_path=None, strip_default_attrs=False
)
</pre> <p>Exports inference graph as a <code translate="no" dir="ltr">SavedModel</code> into the given dir. (deprecated)</p> <aside class="warning"><strong>Warning:</strong><span> THIS FUNCTION IS DEPRECATED. It will be removed in a future version. Instructions for updating: This function has been renamed, use <code translate="no" dir="ltr">export_saved_model</code> instead.</span></aside> <p>For a detailed guide, see <a href="https://tensorflow.org/guide/saved_model#savedmodels_from_estimators">SavedModel from Estimators</a>.</p> <p>This method builds a new graph by first calling the <code translate="no" dir="ltr">serving_input_receiver_fn</code> to obtain feature <code translate="no" dir="ltr">Tensor</code>s, and then calling this <code translate="no" dir="ltr">Estimator</code>'s <code translate="no" dir="ltr">model_fn</code> to generate the model graph based on those features. It restores the given checkpoint (or, lacking that, the most recent checkpoint) into this graph in a fresh session. Finally it creates a timestamped export directory below the given <code translate="no" dir="ltr">export_dir_base</code>, and writes a <code translate="no" dir="ltr">SavedModel</code> into it containing a single <code translate="no" dir="ltr">tf.MetaGraphDef</code> saved from this session.</p> <p>The exported <code translate="no" dir="ltr">MetaGraphDef</code> will provide one <code translate="no" dir="ltr">SignatureDef</code> for each element of the <code translate="no" dir="ltr">export_outputs</code> dict returned from the <code translate="no" dir="ltr">model_fn</code>, named using the same keys. One of these keys is always <code translate="no" dir="ltr">tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY</code>, indicating which signature will be served when a serving request does not specify one. For each signature, the outputs are provided by the corresponding <a href="../../../../estimator/export/exportoutput"><code translate="no" dir="ltr">tf.estimator.export.ExportOutput</code></a>s, and the inputs are always the input receivers provided by the <code translate="no" dir="ltr">serving_input_receiver_fn</code>.</p> <p>Extra assets may be written into the <code translate="no" dir="ltr">SavedModel</code> via the <code translate="no" dir="ltr">assets_extra</code> argument. This should be a dict, where each key gives a destination path (including the filename) relative to the assets.extra directory. The corresponding value gives the full path of the source file to be copied. For example, the simple case of copying a single file without renaming it is specified as <code translate="no" dir="ltr">{'my_asset_file.txt': '/path/to/my_asset_file.txt'}</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">export_dir_base</code> </td> <td> A string containing a directory in which to create timestamped subdirectories containing exported <code translate="no" dir="ltr">SavedModel</code>s. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">serving_input_receiver_fn</code> </td> <td> A function that takes no argument and returns a <a href="../../../../estimator/export/servinginputreceiver"><code translate="no" dir="ltr">tf.estimator.export.ServingInputReceiver</code></a> or <a href="../../../../estimator/export/tensorservinginputreceiver"><code translate="no" dir="ltr">tf.estimator.export.TensorServingInputReceiver</code></a>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">assets_extra</code> </td> <td> A dict specifying how to populate the assets.extra directory within the exported <code translate="no" dir="ltr">SavedModel</code>, or <code translate="no" dir="ltr">None</code> if no extra assets are needed. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">as_text</code> </td> <td> whether to write the <code translate="no" dir="ltr">SavedModel</code> proto in text format. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">checkpoint_path</code> </td> <td> The checkpoint path to export. If <code translate="no" dir="ltr">None</code> (the default), the most recent checkpoint found within the model directory is chosen. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">strip_default_attrs</code> </td> <td> Boolean. If <code translate="no" dir="ltr">True</code>, default-valued attributes will be removed from the <code translate="no" dir="ltr">NodeDef</code>s. For a detailed guide, see <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/saved_model/README.md#stripping-default-valued-attributes">Stripping Default-Valued Attributes</a>. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> The path to the exported directory as a bytes object. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> if no <code translate="no" dir="ltr">serving_input_receiver_fn</code> is provided, no <code translate="no" dir="ltr">export_outputs</code> are provided, or no checkpoint can be found. </td> </tr> </table> <h3 id="get_variable_names" data-text="get_variable_names"><code translate="no" dir="ltr">get_variable_names</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/estimator/tree/master/tensorflow_estimator/python/estimator/estimator.py#L250-L261">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
get_variable_names()
</pre> <p>Returns list of all variable names in this model.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> List of names. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If the <code translate="no" dir="ltr">Estimator</code> has not produced a checkpoint yet. </td> </tr> </table> <h3 id="get_variable_value" data-text="get_variable_value"><code translate="no" dir="ltr">get_variable_value</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/estimator/tree/master/tensorflow_estimator/python/estimator/estimator.py#L234-L248">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
get_variable_value(
    name
)
</pre> <p>Returns value of the variable given by name.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">name</code> </td> <td> string or a list of string, name of the tensor. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> Numpy array - value of the tensor. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If the <code translate="no" dir="ltr">Estimator</code> has not produced a checkpoint yet. </td> </tr> </table> <h3 id="latest_checkpoint" data-text="latest_checkpoint"><code translate="no" dir="ltr">latest_checkpoint</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/estimator/tree/master/tensorflow_estimator/python/estimator/estimator.py#L263-L271">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
latest_checkpoint()
</pre> <p>Finds the filename of the latest saved checkpoint file in <code translate="no" dir="ltr">model_dir</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> The full path to the latest checkpoint or <code translate="no" dir="ltr">None</code> if no checkpoint was found. </td> </tr> 
</table> <h3 id="predict" data-text="predict"><code translate="no" dir="ltr">predict</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/estimator/tree/master/tensorflow_estimator/python/estimator/tpu/tpu_estimator.py#L3153-L3176">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
predict(
    input_fn, predict_keys=None, hooks=None, checkpoint_path=None,
    yield_single_examples=True
)
</pre> <p>Yields predictions for given features.</p> <p>Please note that interleaving two predict outputs does not work. See: <a href="https://github.com/tensorflow/tensorflow/issues/20506#issuecomment-422208517">issue/20506</a></p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">input_fn</code> </td> <td> A function that constructs the features. Prediction continues until <code translate="no" dir="ltr">input_fn</code> raises an end-of-input exception (<a href="../../../../errors/outofrangeerror"><code translate="no" dir="ltr">tf.errors.OutOfRangeError</code></a> or <code translate="no" dir="ltr">StopIteration</code>). See <a href="https://tensorflow.org/guide/premade_estimators#create_input_functions">Premade Estimators</a> for more information. The function should construct and return one of the following: <ul> <li>
<a href="../../../../data/dataset"><code translate="no" dir="ltr">tf.data.Dataset</code></a> object -- Outputs of <code translate="no" dir="ltr">Dataset</code> object must have same constraints as below.</li> <li>features -- A <a href="../../../../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a> or a dictionary of string feature name to <code translate="no" dir="ltr">Tensor</code>. features are consumed by <code translate="no" dir="ltr">model_fn</code>. They should satisfy the expectation of <code translate="no" dir="ltr">model_fn</code> from inputs.</li> <li>A tuple, in which case the first item is extracted as features. </li>
</ul>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">predict_keys</code> </td> <td> list of <code translate="no" dir="ltr">str</code>, name of the keys to predict. It is used if the <a href="../../../../estimator/estimatorspec#predictions"><code translate="no" dir="ltr">tf.estimator.EstimatorSpec.predictions</code></a> is a <code translate="no" dir="ltr">dict</code>. If <code translate="no" dir="ltr">predict_keys</code> is used then rest of the predictions will be filtered from the dictionary. If <code translate="no" dir="ltr">None</code>, returns all. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">hooks</code> </td> <td> List of <code translate="no" dir="ltr">tf.train.SessionRunHook</code> subclass instances. Used for callbacks inside the prediction call. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">checkpoint_path</code> </td> <td> Path of a specific checkpoint to predict. If <code translate="no" dir="ltr">None</code>, the latest checkpoint in <code translate="no" dir="ltr">model_dir</code> is used. If there are no checkpoints in <code translate="no" dir="ltr">model_dir</code>, prediction is run with newly initialized <code translate="no" dir="ltr">Variables</code> instead of ones restored from checkpoint. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">yield_single_examples</code> </td> <td> If <code translate="no" dir="ltr">False</code>, yields the whole batch as returned by the <code translate="no" dir="ltr">model_fn</code> instead of decomposing the batch into individual elements. This is useful if <code translate="no" dir="ltr">model_fn</code> returns some tensors whose first dimension is not equal to the batch size. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Yields</th></tr> <tr class="alt"> <td colspan="2"> Evaluated values of <code translate="no" dir="ltr">predictions</code> tensors. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If batch length of predictions is not the same and <code translate="no" dir="ltr">yield_single_examples</code> is <code translate="no" dir="ltr">True</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If there is a conflict between <code translate="no" dir="ltr">predict_keys</code> and <code translate="no" dir="ltr">predictions</code>. For example if <code translate="no" dir="ltr">predict_keys</code> is not <code translate="no" dir="ltr">None</code> but <a href="../../../../estimator/estimatorspec#predictions"><code translate="no" dir="ltr">tf.estimator.EstimatorSpec.predictions</code></a> is not a <code translate="no" dir="ltr">dict</code>. </td> </tr> </table> <h3 id="train" data-text="train"><code translate="no" dir="ltr">train</code></h3> <p><a target="_blank" href="https://github.com/tensorflow/estimator/tree/master/tensorflow_estimator/python/estimator/tpu/tpu_estimator.py#L3111-L3130">View source</a></p> <pre class="devsite-click-to-copy prettyprint lang-py tfo-signature-link" translate="no" dir="ltr" data-language="cpp">
train(
    input_fn, hooks=None, steps=None, max_steps=None, saving_listeners=None
)
</pre> <p>Trains a model given training data <code translate="no" dir="ltr">input_fn</code>.</p>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Args</th></tr> 
<tr> <td> <code translate="no" dir="ltr">input_fn</code> </td> <td> A function that provides input data for training as minibatches. See <a href="https://tensorflow.org/guide/premade_estimators#create_input_functions">Premade Estimators</a> for more information. The function should construct and return one of the following: <ul> <li>A <a href="../../../../data/dataset"><code translate="no" dir="ltr">tf.data.Dataset</code></a> object: Outputs of <code translate="no" dir="ltr">Dataset</code> object must be a tuple <code translate="no" dir="ltr">(features, labels)</code> with same constraints as below.</li> <li>A tuple <code translate="no" dir="ltr">(features, labels)</code>: Where <code translate="no" dir="ltr">features</code> is a <a href="../../../../tensor"><code translate="no" dir="ltr">tf.Tensor</code></a> or a dictionary of string feature name to <code translate="no" dir="ltr">Tensor</code> and <code translate="no" dir="ltr">labels</code> is a <code translate="no" dir="ltr">Tensor</code> or a dictionary of string label name to <code translate="no" dir="ltr">Tensor</code>. Both <code translate="no" dir="ltr">features</code> and <code translate="no" dir="ltr">labels</code> are consumed by <code translate="no" dir="ltr">model_fn</code>. They should satisfy the expectation of <code translate="no" dir="ltr">model_fn</code> from inputs. </li>
</ul>
</td> </tr>
<tr> <td> <code translate="no" dir="ltr">hooks</code> </td> <td> List of <code translate="no" dir="ltr">tf.train.SessionRunHook</code> subclass instances. Used for callbacks inside the training loop. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">steps</code> </td> <td> Number of steps for which to train the model. If <code translate="no" dir="ltr">None</code>, train forever or train until <code translate="no" dir="ltr">input_fn</code> generates the <code translate="no" dir="ltr">tf.errors.OutOfRange</code> error or <code translate="no" dir="ltr">StopIteration</code> exception. <code translate="no" dir="ltr">steps</code> works incrementally. If you call two times <code translate="no" dir="ltr">train(steps=10)</code> then training occurs in total 20 steps. If <code translate="no" dir="ltr">OutOfRange</code> or <code translate="no" dir="ltr">StopIteration</code> occurs in the middle, training stops before 20 steps. If you don't want to have incremental behavior please set <code translate="no" dir="ltr">max_steps</code> instead. If set, <code translate="no" dir="ltr">max_steps</code> must be <code translate="no" dir="ltr">None</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">max_steps</code> </td> <td> Number of total steps for which to train model. If <code translate="no" dir="ltr">None</code>, train forever or train until <code translate="no" dir="ltr">input_fn</code> generates the <code translate="no" dir="ltr">tf.errors.OutOfRange</code> error or <code translate="no" dir="ltr">StopIteration</code> exception. If set, <code translate="no" dir="ltr">steps</code> must be <code translate="no" dir="ltr">None</code>. If <code translate="no" dir="ltr">OutOfRange</code> or <code translate="no" dir="ltr">StopIteration</code> occurs in the middle, training stops before <code translate="no" dir="ltr">max_steps</code> steps. Two calls to <code translate="no" dir="ltr">train(steps=100)</code> means 200 training iterations. On the other hand, two calls to <code translate="no" dir="ltr">train(max_steps=100)</code> means that the second call will not do any iteration since first call did all 100 steps. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">saving_listeners</code> </td> <td> list of <code translate="no" dir="ltr">CheckpointSaverListener</code> objects. Used for callbacks that run immediately before or after checkpoint savings. </td> </tr> </table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Returns</th></tr> <tr class="alt"> <td colspan="2"> <code translate="no" dir="ltr">self</code>, for chaining. </td> </tr> 
</table>  
<table class="responsive fixed orange"> <colgroup>
<col width="214px">
<col>
</colgroup> <tr><th colspan="2">Raises</th></tr> 
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If both <code translate="no" dir="ltr">steps</code> and <code translate="no" dir="ltr">max_steps</code> are not <code translate="no" dir="ltr">None</code>. </td> </tr>
<tr> <td> <code translate="no" dir="ltr">ValueError</code> </td> <td> If either <code translate="no" dir="ltr">steps</code> or <code translate="no" dir="ltr">max_steps &lt;= 0</code>. </td> </tr> </table>  <devsite-page-rating position="footer" selected-rating="0" hover-rating-star="0"> </devsite-page-rating><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2020 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 3.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/versions/r2.4/api_docs/python/tf/compat/v1/estimator/tpu/TPUEstimator" class="_attribution-link">https://www.tensorflow.org/versions/r2.4/api_docs/python/tf/compat/v1/estimator/tpu/TPUEstimator</a>
  </p>
</div>
