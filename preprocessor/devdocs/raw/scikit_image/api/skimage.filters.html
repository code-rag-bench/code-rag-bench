<h1 id="module-filters">Module: filters</h1> <table class="longtable docutils align-default" id="module-skimage.filters">   <tr>
<td><p><a class="reference internal" href="#skimage.filters.apply_hysteresis_threshold" title="skimage.filters.apply_hysteresis_threshold"><code>skimage.filters.apply_hysteresis_threshold</code></a>(…)</p></td> <td><p>Apply hysteresis thresholding to <code>image</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.correlate_sparse" title="skimage.filters.correlate_sparse"><code>skimage.filters.correlate_sparse</code></a>(image, kernel)</p></td> <td><p>Compute valid cross-correlation of <code>padded_array</code> and <code>kernel</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.difference_of_gaussians" title="skimage.filters.difference_of_gaussians"><code>skimage.filters.difference_of_gaussians</code></a>(…)</p></td> <td><p>Find features between <code>low_sigma</code> and <code>high_sigma</code> in size.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.farid" title="skimage.filters.farid"><code>skimage.filters.farid</code></a>(image, *[, mask])</p></td> <td><p>Find the edge magnitude using the Farid transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.farid_h" title="skimage.filters.farid_h"><code>skimage.filters.farid_h</code></a>(image, *[, mask])</p></td> <td><p>Find the horizontal edges of an image using the Farid transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.farid_v" title="skimage.filters.farid_v"><code>skimage.filters.farid_v</code></a>(image, *[, mask])</p></td> <td><p>Find the vertical edges of an image using the Farid transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.frangi" title="skimage.filters.frangi"><code>skimage.filters.frangi</code></a>(image[, sigmas, …])</p></td> <td><p>Filter an image with the Frangi vesselness filter.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.gabor" title="skimage.filters.gabor"><code>skimage.filters.gabor</code></a>(image, frequency[, …])</p></td> <td><p>Return real and imaginary responses to Gabor filter.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.gabor_kernel" title="skimage.filters.gabor_kernel"><code>skimage.filters.gabor_kernel</code></a>(frequency[, …])</p></td> <td><p>Return complex 2D Gabor filter kernel.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.gaussian" title="skimage.filters.gaussian"><code>skimage.filters.gaussian</code></a>(image[, sigma, …])</p></td> <td><p>Multi-dimensional Gaussian filter.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.hessian" title="skimage.filters.hessian"><code>skimage.filters.hessian</code></a>(image[, sigmas, …])</p></td> <td><p>Filter an image with the Hybrid Hessian filter.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.inverse" title="skimage.filters.inverse"><code>skimage.filters.inverse</code></a>(data[, …])</p></td> <td><p>Apply the filter in reverse to the given data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.laplace" title="skimage.filters.laplace"><code>skimage.filters.laplace</code></a>(image[, ksize, mask])</p></td> <td><p>Find the edges of an image using the Laplace operator.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.median" title="skimage.filters.median"><code>skimage.filters.median</code></a>(image[, selem, out, …])</p></td> <td><p>Return local median of an image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.meijering" title="skimage.filters.meijering"><code>skimage.filters.meijering</code></a>(image[, sigmas, …])</p></td> <td><p>Filter an image with the Meijering neuriteness filter.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.prewitt" title="skimage.filters.prewitt"><code>skimage.filters.prewitt</code></a>(image[, mask, axis, …])</p></td> <td><p>Find the edge magnitude using the Prewitt transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.prewitt_h" title="skimage.filters.prewitt_h"><code>skimage.filters.prewitt_h</code></a>(image[, mask])</p></td> <td><p>Find the horizontal edges of an image using the Prewitt transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.prewitt_v" title="skimage.filters.prewitt_v"><code>skimage.filters.prewitt_v</code></a>(image[, mask])</p></td> <td><p>Find the vertical edges of an image using the Prewitt transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.rank_order" title="skimage.filters.rank_order"><code>skimage.filters.rank_order</code></a>(image)</p></td> <td><p>Return an image of the same shape where each pixel is the index of the pixel value in the ascending order of the unique values of <code>image</code>, aka the rank-order value.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.roberts" title="skimage.filters.roberts"><code>skimage.filters.roberts</code></a>(image[, mask])</p></td> <td><p>Find the edge magnitude using Roberts’ cross operator.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.roberts_neg_diag" title="skimage.filters.roberts_neg_diag"><code>skimage.filters.roberts_neg_diag</code></a>(image[, mask])</p></td> <td><p>Find the cross edges of an image using the Roberts’ Cross operator.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.roberts_pos_diag" title="skimage.filters.roberts_pos_diag"><code>skimage.filters.roberts_pos_diag</code></a>(image[, mask])</p></td> <td><p>Find the cross edges of an image using Roberts’ cross operator.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.sato" title="skimage.filters.sato"><code>skimage.filters.sato</code></a>(image[, sigmas, …])</p></td> <td><p>Filter an image with the Sato tubeness filter.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.scharr" title="skimage.filters.scharr"><code>skimage.filters.scharr</code></a>(image[, mask, axis, …])</p></td> <td><p>Find the edge magnitude using the Scharr transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.scharr_h" title="skimage.filters.scharr_h"><code>skimage.filters.scharr_h</code></a>(image[, mask])</p></td> <td><p>Find the horizontal edges of an image using the Scharr transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.scharr_v" title="skimage.filters.scharr_v"><code>skimage.filters.scharr_v</code></a>(image[, mask])</p></td> <td><p>Find the vertical edges of an image using the Scharr transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.sobel" title="skimage.filters.sobel"><code>skimage.filters.sobel</code></a>(image[, mask, axis, …])</p></td> <td><p>Find edges in an image using the Sobel filter.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.sobel_h" title="skimage.filters.sobel_h"><code>skimage.filters.sobel_h</code></a>(image[, mask])</p></td> <td><p>Find the horizontal edges of an image using the Sobel transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.sobel_v" title="skimage.filters.sobel_v"><code>skimage.filters.sobel_v</code></a>(image[, mask])</p></td> <td><p>Find the vertical edges of an image using the Sobel transform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.threshold_isodata" title="skimage.filters.threshold_isodata"><code>skimage.filters.threshold_isodata</code></a>([image, …])</p></td> <td><p>Return threshold value(s) based on ISODATA method.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.threshold_li" title="skimage.filters.threshold_li"><code>skimage.filters.threshold_li</code></a>(image, *[, …])</p></td> <td><p>Compute threshold value by Li’s iterative Minimum Cross Entropy method.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.threshold_local" title="skimage.filters.threshold_local"><code>skimage.filters.threshold_local</code></a>(image, …)</p></td> <td><p>Compute a threshold mask image based on local pixel neighborhood.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.threshold_mean" title="skimage.filters.threshold_mean"><code>skimage.filters.threshold_mean</code></a>(image)</p></td> <td><p>Return threshold value based on the mean of grayscale values.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.threshold_minimum" title="skimage.filters.threshold_minimum"><code>skimage.filters.threshold_minimum</code></a>([image, …])</p></td> <td><p>Return threshold value based on minimum method.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.threshold_multiotsu" title="skimage.filters.threshold_multiotsu"><code>skimage.filters.threshold_multiotsu</code></a>(image[, …])</p></td> <td><p>Generate <code>classes</code>-1 threshold values to divide gray levels in <code>image</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.threshold_niblack" title="skimage.filters.threshold_niblack"><code>skimage.filters.threshold_niblack</code></a>(image[, …])</p></td> <td><p>Applies Niblack local threshold to an array.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.threshold_otsu" title="skimage.filters.threshold_otsu"><code>skimage.filters.threshold_otsu</code></a>([image, …])</p></td> <td><p>Return threshold value based on Otsu’s method.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.threshold_sauvola" title="skimage.filters.threshold_sauvola"><code>skimage.filters.threshold_sauvola</code></a>(image[, …])</p></td> <td><p>Applies Sauvola local threshold to an array.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.threshold_triangle" title="skimage.filters.threshold_triangle"><code>skimage.filters.threshold_triangle</code></a>(image[, …])</p></td> <td><p>Return threshold value based on the triangle algorithm.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.threshold_yen" title="skimage.filters.threshold_yen"><code>skimage.filters.threshold_yen</code></a>([image, …])</p></td> <td><p>Return threshold value based on Yen’s method.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.try_all_threshold" title="skimage.filters.try_all_threshold"><code>skimage.filters.try_all_threshold</code></a>(image[, …])</p></td> <td><p>Returns a figure comparing the outputs of different thresholding methods.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.unsharp_mask" title="skimage.filters.unsharp_mask"><code>skimage.filters.unsharp_mask</code></a>(image[, …])</p></td> <td><p>Unsharp masking filter.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.wiener" title="skimage.filters.wiener"><code>skimage.filters.wiener</code></a>(data[, …])</p></td> <td><p>Minimum Mean Square Error (Wiener) inverse filter.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.window" title="skimage.filters.window"><code>skimage.filters.window</code></a>(window_type, shape[, …])</p></td> <td><p>Return an n-dimensional window of a given size and dimensionality.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.filters.LPIFilter2D" title="skimage.filters.LPIFilter2D"><code>skimage.filters.LPIFilter2D</code></a>(…)</p></td> <td><p>Linear Position-Invariant Filter (2-dimensional)</p></td> </tr> <tr>
<td><p><a class="reference internal" href="skimage.filters.rank#module-skimage.filters.rank" title="skimage.filters.rank"><code>skimage.filters.rank</code></a></p></td> <td></td> </tr>  </table>  <h2 id="apply-hysteresis-threshold">apply_hysteresis_threshold</h2> <dl class="function"> <dt id="skimage.filters.apply_hysteresis_threshold">
<code>skimage.filters.apply_hysteresis_threshold(image, low, high)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/thresholding.py#L1090-L1134"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply hysteresis thresholding to <code>image</code>.</p> <p>This algorithm finds regions where <code>image</code> is greater than <code>high</code> OR <code>image</code> is greater than <code>low</code> <em>and</em> that region is connected to a region greater than <code>high</code>.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>imagearray, shape (M,[ N, …, P])</code> </dt>
<dd>
<p>Grayscale input image.</p> </dd> <dt>
<code>lowfloat, or array of same shape as image</code> </dt>
<dd>
<p>Lower threshold.</p> </dd> <dt>
<code>highfloat, or array of same shape as image</code> </dt>
<dd>
<p>Higher threshold.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>thresholdedarray of bool, same shape as image</code> </dt>
<dd>
<p>Array in which <code>True</code> indicates the locations where <code>image</code> was above the hysteresis threshold.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rfd96194f9a6b-1">
<code>1</code> </dt> <dd>
<p>J. Canny. A computational approach to edge detection. IEEE Transactions on Pattern Analysis and Machine Intelligence. 1986; vol. 8, pp.679-698. <a class="reference external" href="https://doi.org/10.1109/TPAMI.1986.4767851">DOI:10.1109/TPAMI.1986.4767851</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; image = np.array([1, 2, 3, 2, 1, 2, 1, 3, 2])
&gt;&gt;&gt; apply_hysteresis_threshold(image, 1.5, 2.5).astype(int)
array([0, 1, 1, 1, 0, 0, 0, 1, 1])
</pre> </dd>
</dl>   <h2 id="correlate-sparse">correlate_sparse</h2> <dl class="function"> <dt id="skimage.filters.correlate_sparse">
<code>skimage.filters.correlate_sparse(image, kernel, mode='reflect')</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/_sparse.py#L35-L97"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute valid cross-correlation of <code>padded_array</code> and <code>kernel</code>.</p> <p>This function is <em>fast</em> when <code>kernel</code> is large with many zeros.</p> <p>See <code>scipy.ndimage.correlate</code> for a description of cross-correlation.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray, dtype float, shape (M, N,[ …,] P)</code> </dt>
<dd>
<p>The input array. If mode is ‘valid’, this array should already be padded, as a margin of the same shape as kernel will be stripped off.</p> </dd> <dt>
<code>kernelndarray, dtype float shape (Q, R,[ …,] S)</code> </dt>
<dd>
<p>The kernel to be correlated. Must have the same number of dimensions as <code>padded_array</code>. For high performance, it should be sparse (few nonzero entries).</p> </dd> <dt>
<code>modestring, optional</code> </dt>
<dd>
<p>See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.correlate.html#scipy.ndimage.correlate" title="(in SciPy v1.5.4)"><code>scipy.ndimage.correlate</code></a> for valid modes. Additionally, mode ‘valid’ is accepted, in which case no padding is applied and the result is the result for the smaller image for which the kernel is entirely inside the original data.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>resultarray of float, shape (M, N,[ …,] P)</code> </dt>
<dd>
<p>The result of cross-correlating <code>image</code> with <code>kernel</code>. If mode ‘valid’ is used, the resulting shape is (M-Q+1, N-R+1,[ …,] P-S+1).</p> </dd> </dl> </dd> </dl> </dd>
</dl>   <h2 id="difference-of-gaussians">difference_of_gaussians</h2> <dl class="function"> <dt id="skimage.filters.difference_of_gaussians">
<code>skimage.filters.difference_of_gaussians(image, low_sigma, high_sigma=None, *, mode='nearest', cval=0, multichannel=False, truncate=4.0)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/_gaussian.py#L160-L290"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find features between <code>low_sigma</code> and <code>high_sigma</code> in size.</p> <p>This function uses the Difference of Gaussians method for applying band-pass filters to multi-dimensional arrays. The input array is blurred with two Gaussian kernels of differing sigmas to produce two intermediate, filtered images. The more-blurred image is then subtracted from the less-blurred image. The final output image will therefore have had high-frequency components attenuated by the smaller-sigma Gaussian, and low frequency components will have been removed due to their presence in the more-blurred intermediate.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Input array to filter.</p> </dd> <dt>
<code>low_sigmascalar or sequence of scalars</code> </dt>
<dd>
<p>Standard deviation(s) for the Gaussian kernel with the smaller sigmas across all axes. The standard deviations are given for each axis as a sequence, or as a single number, in which case the single number is used as the standard deviation value for all axes.</p> </dd> <dt>
<code>high_sigmascalar or sequence of scalars, optional (default is None)</code> </dt>
<dd>
<p>Standard deviation(s) for the Gaussian kernel with the larger sigmas across all axes. The standard deviations are given for each axis as a sequence, or as a single number, in which case the single number is used as the standard deviation value for all axes. If None is given (default), sigmas for all axes are calculated as 1.6 * low_sigma.</p> </dd> <dt>
<code>mode{‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional</code> </dt>
<dd>
<p>The <code>mode</code> parameter determines how the array borders are handled, where <code>cval</code> is the value when mode is equal to ‘constant’. Default is ‘nearest’.</p> </dd> <dt>
<code>cvalscalar, optional</code> </dt>
<dd>
<p>Value to fill past edges of input if <code>mode</code> is ‘constant’. Default is 0.0</p> </dd> <dt>
<code>multichannelbool, optional (default: False)</code> </dt>
<dd>
<p>Whether the last axis of the image is to be interpreted as multiple channels. If True, each channel is filtered separately (channels are not mixed together).</p> </dd> <dt>
<code>truncatefloat, optional (default is 4.0)</code> </dt>
<dd>
<p>Truncate the filter at this many standard deviations.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>filtered_imagendarray</code> </dt>
<dd>
<p>the filtered array.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>skimage.feature.blog_dog</code> </dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>This function will subtract an array filtered with a Gaussian kernel with sigmas given by <code>high_sigma</code> from an array filtered with a Gaussian kernel with sigmas provided by <code>low_sigma</code>. The values for <code>high_sigma</code> must always be greater than or equal to the corresponding values in <code>low_sigma</code>, or a <code>ValueError</code> will be raised.</p> <p>When <code>high_sigma</code> is none, the values for <code>high_sigma</code> will be calculated as 1.6x the corresponding values in <code>low_sigma</code>. This ratio was originally proposed by Marr and Hildreth (1980) <a class="reference internal" href="#r96d4c0941595-1" id="id2">[1]</a> and is commonly used when approximating the inverted Laplacian of Gaussian, which is used in edge and blob detection.</p> <p>Input image is converted according to the conventions of <code>img_as_float</code>.</p> <p>Except for sigma values, all parameters are used for both filters.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r96d4c0941595-1">
<code>1</code> </dt> <dd>
<p>Marr, D. and Hildreth, E. Theory of Edge Detection. Proc. R. Soc. Lond. Series B 207, 187-217 (1980). <a class="reference external" href="https://doi.org/10.1098/rspb.1980.0020">https://doi.org/10.1098/rspb.1980.0020</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <p>Apply a simple Difference of Gaussians filter to a color image:</p> <pre data-language="python">&gt;&gt;&gt; from skimage.data import astronaut
&gt;&gt;&gt; from skimage.filters import difference_of_gaussians
&gt;&gt;&gt; filtered_image = difference_of_gaussians(astronaut(), 2, 10,
...                                          multichannel=True)
</pre> <p>Apply a Laplacian of Gaussian filter as approximated by the Difference of Gaussians filter:</p> <pre data-language="python">&gt;&gt;&gt; filtered_image = difference_of_gaussians(astronaut(), 2,
...                                          multichannel=True)
</pre> <p>Apply a Difference of Gaussians filter to a grayscale image using different sigma values for each axis:</p> <pre data-language="python">&gt;&gt;&gt; from skimage.data import camera
&gt;&gt;&gt; filtered_image = difference_of_gaussians(camera(), (2,5), (3,20))
</pre> </dd>
</dl>   <h2 id="farid">farid</h2> <dl class="function"> <dt id="skimage.filters.farid">
<code>skimage.filters.farid(image, *, mask=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/edges.py#L690-L737"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the edge magnitude using the Farid transform.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image2-D array</code> </dt>
<dd>
<p>Image to process.</p> </dd> <dt>
<code>mask2-D array, optional</code> </dt>
<dd>
<p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>output2-D array</code> </dt>
<dd>
<p>The Farid edge map.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>sobel, prewitt, canny</code> </dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>Take the square root of the sum of the squares of the horizontal and vertical derivatives to get a magnitude that is somewhat insensitive to direction. Similar to the Scharr operator, this operator is designed with a rotation invariance constraint.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r17be61216823-1">
<code>1</code> </dt> <dd>
<p>Farid, H. and Simoncelli, E. P., “Differentiation of discrete multidimensional signals”, IEEE Transactions on Image Processing 13(4): 496-508, 2004. <a class="reference external" href="https://doi.org/10.1109/TIP.2004.823819">DOI:10.1109/TIP.2004.823819</a></p> </dd> <dt class="label" id="r17be61216823-2">
<code>2</code> </dt> <dd>
<p>Wikipedia, “Farid and Simoncelli Derivatives.” Available at: &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/Image_derivatives#Farid_and_Simoncelli_Derivatives">https://en.wikipedia.org/wiki/Image_derivatives#Farid_and_Simoncelli_Derivatives</a>&gt;</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; camera = data.camera()
&gt;&gt;&gt; from skimage import filters
&gt;&gt;&gt; edges = filters.farid(camera)
</pre> </dd>
</dl>   <h2 id="farid-h">farid_h</h2> <dl class="function"> <dt id="skimage.filters.farid_h">
<code>skimage.filters.farid_h(image, *, mask=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/edges.py#L740-L773"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the horizontal edges of an image using the Farid transform.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image2-D array</code> </dt>
<dd>
<p>Image to process.</p> </dd> <dt>
<code>mask2-D array, optional</code> </dt>
<dd>
<p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>output2-D array</code> </dt>
<dd>
<p>The Farid edge map.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The kernel was constructed using the 5-tap weights from [1].</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rcc13081f5169-1">
<code>1</code> </dt> <dd>
<p>Farid, H. and Simoncelli, E. P., “Differentiation of discrete multidimensional signals”, IEEE Transactions on Image Processing 13(4): 496-508, 2004. <a class="reference external" href="https://doi.org/10.1109/TIP.2004.823819">DOI:10.1109/TIP.2004.823819</a></p> </dd> <dt class="label" id="rcc13081f5169-2">
<code>2</code> </dt> <dd>
<p>Farid, H. and Simoncelli, E. P. “Optimally rotation-equivariant directional derivative kernels”, In: 7th International Conference on Computer Analysis of Images and Patterns, Kiel, Germany. Sep, 1997.</p> </dd> </dl> </dd>
</dl>   <h2 id="farid-v">farid_v</h2> <dl class="function"> <dt id="skimage.filters.farid_v">
<code>skimage.filters.farid_v(image, *, mask=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/edges.py#L776-L806"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the vertical edges of an image using the Farid transform.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image2-D array</code> </dt>
<dd>
<p>Image to process.</p> </dd> <dt>
<code>mask2-D array, optional</code> </dt>
<dd>
<p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>output2-D array</code> </dt>
<dd>
<p>The Farid edge map.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The kernel was constructed using the 5-tap weights from [1].</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rb924cb19b62d-1">
<code>1</code> </dt> <dd>
<p>Farid, H. and Simoncelli, E. P., “Differentiation of discrete multidimensional signals”, IEEE Transactions on Image Processing 13(4): 496-508, 2004. <a class="reference external" href="https://doi.org/10.1109/TIP.2004.823819">DOI:10.1109/TIP.2004.823819</a></p> </dd> </dl> </dd>
</dl>   <h2 id="frangi">frangi</h2> <dl class="function"> <dt id="skimage.filters.frangi">
<code>skimage.filters.frangi(image, sigmas=range(1, 10, 2), scale_range=None, scale_step=None, alpha=0.5, beta=0.5, gamma=15, black_ridges=True, mode='reflect', cval=0)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/ridges.py#L357-L490"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Filter an image with the Frangi vesselness filter.</p> <p>This filter can be used to detect continuous ridges, e.g. vessels, wrinkles, rivers. It can be used to calculate the fraction of the whole image containing such objects.</p> <p>Defined only for 2-D and 3-D images. Calculates the eigenvectors of the Hessian to compute the similarity of an image region to vessels, according to the method described in <a class="reference internal" href="#r9152c279884a-1" id="id9">[1]</a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(N, M[, P]) ndarray</code> </dt>
<dd>
<p>Array with input image data.</p> </dd> <dt>
<code>sigmasiterable of floats, optional</code> </dt>
<dd>
<p>Sigmas used as scales of filter, i.e., np.arange(scale_range[0], scale_range[1], scale_step)</p> </dd> <dt>
<code>scale_range2-tuple of floats, optional</code> </dt>
<dd>
<p>The range of sigmas used.</p> </dd> <dt>
<code>scale_stepfloat, optional</code> </dt>
<dd>
<p>Step size between sigmas.</p> </dd> <dt>
<code>alphafloat, optional</code> </dt>
<dd>
<p>Frangi correction constant that adjusts the filter’s sensitivity to deviation from a plate-like structure.</p> </dd> <dt>
<code>betafloat, optional</code> </dt>
<dd>
<p>Frangi correction constant that adjusts the filter’s sensitivity to deviation from a blob-like structure.</p> </dd> <dt>
<code>gammafloat, optional</code> </dt>
<dd>
<p>Frangi correction constant that adjusts the filter’s sensitivity to areas of high variance/texture/structure.</p> </dd> <dt>
<code>black_ridgesboolean, optional</code> </dt>
<dd>
<p>When True (the default), the filter detects black ridges; when False, it detects white ridges.</p> </dd> <dt>
<code>mode{‘constant’, ‘reflect’, ‘wrap’, ‘nearest’, ‘mirror’}, optional</code> </dt>
<dd>
<p>How to handle values outside the image borders.</p> </dd> <dt>
<code>cvalfloat, optional</code> </dt>
<dd>
<p>Used in conjunction with mode ‘constant’, the value outside the image boundaries.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>out(N, M[, P]) ndarray</code> </dt>
<dd>
<p>Filtered image (maximum of pixels across all scales).</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.filters.meijering" title="skimage.filters.meijering"><code>meijering</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.filters.sato" title="skimage.filters.sato"><code>sato</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.filters.hessian" title="skimage.filters.hessian"><code>hessian</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>Written by Marc Schrijver, November 2001 Re-Written by D. J. Kroon, University of Twente, May 2009, <a class="reference internal" href="#r9152c279884a-2" id="id10">[2]</a> Adoption of 3D version from D. G. Ellis, Januar 20017, <a class="reference internal" href="#r9152c279884a-3" id="id11">[3]</a></p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r9152c279884a-1">
<code>1</code> </dt> <dd>
<p>Frangi, A. F., Niessen, W. J., Vincken, K. L., &amp; Viergever, M. A. (1998,). Multiscale vessel enhancement filtering. In International Conference on Medical Image Computing and Computer-Assisted Intervention (pp. 130-137). Springer Berlin Heidelberg. <a class="reference external" href="https://doi.org/10.1007/BFb0056195">DOI:10.1007/BFb0056195</a></p> </dd> <dt class="label" id="r9152c279884a-2">
<code>2</code> </dt> <dd>
<p>Kroon, D. J.: Hessian based Frangi vesselness filter.</p> </dd> <dt class="label" id="r9152c279884a-3">
<code>3</code> </dt> <dd>
<p>Ellis, D. G.: <a class="reference external" href="https://github.com/ellisdg/frangi3d/tree/master/frangi">https://github.com/ellisdg/frangi3d/tree/master/frangi</a></p> </dd> </dl> </dd>
</dl>   <h2 id="gabor">gabor</h2> <dl class="function"> <dt id="skimage.filters.gabor">
<code>skimage.filters.gabor(image, frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0, mode='reflect', cval=0)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/_gabor.py#L98-L177"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return real and imaginary responses to Gabor filter.</p> <p>The real and imaginary parts of the Gabor filter kernel are applied to the image and the response is returned as a pair of arrays.</p> <p>Gabor filter is a linear filter with a Gaussian kernel which is modulated by a sinusoidal plane wave. Frequency and orientation representations of the Gabor filter are similar to those of the human visual system. Gabor filter banks are commonly used in computer vision and image processing. They are especially suitable for edge detection and texture classification.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image2-D array</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>frequencyfloat</code> </dt>
<dd>
<p>Spatial frequency of the harmonic function. Specified in pixels.</p> </dd> <dt>
<code>thetafloat, optional</code> </dt>
<dd>
<p>Orientation in radians. If 0, the harmonic is in the x-direction.</p> </dd> <dt>
<code>bandwidthfloat, optional</code> </dt>
<dd>
<p>The bandwidth captured by the filter. For fixed bandwidth, <code>sigma_x</code> and <code>sigma_y</code> will decrease with increasing frequency. This value is ignored if <code>sigma_x</code> and <code>sigma_y</code> are set by the user.</p> </dd> <dt>
<code>sigma_x, sigma_yfloat, optional</code> </dt>
<dd>
<p>Standard deviation in x- and y-directions. These directions apply to the kernel <em>before</em> rotation. If <code>theta = pi/2</code>, then the kernel is rotated 90 degrees so that <code>sigma_x</code> controls the <em>vertical</em> direction.</p> </dd> <dt>
<code>n_stdsscalar, optional</code> </dt>
<dd>
<p>The linear size of the kernel is n_stds (3 by default) standard deviations.</p> </dd> <dt>
<code>offsetfloat, optional</code> </dt>
<dd>
<p>Phase offset of harmonic function in radians.</p> </dd> <dt>
<code>mode{‘constant’, ‘nearest’, ‘reflect’, ‘mirror’, ‘wrap’}, optional</code> </dt>
<dd>
<p>Mode used to convolve image with a kernel, passed to <code>ndi.convolve</code></p> </dd> <dt>
<code>cvalscalar, optional</code> </dt>
<dd>
<p>Value to fill past edges of input if <code>mode</code> of convolution is ‘constant’. The parameter is passed to <code>ndi.convolve</code>.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>real, imagarrays</code> </dt>
<dd>
<p>Filtered images using the real and imaginary parts of the Gabor filter kernel. Images are of the same dimensions as the input one.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rc394129659a3-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Gabor_filter">https://en.wikipedia.org/wiki/Gabor_filter</a></p> </dd> <dt class="label" id="rc394129659a3-2">
<code>2</code> </dt> <dd>
<p><a class="reference external" href="https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf">https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.filters import gabor
&gt;&gt;&gt; from skimage import data, io
&gt;&gt;&gt; from matplotlib import pyplot as plt  
</pre> <pre data-language="python">&gt;&gt;&gt; image = data.coins()
&gt;&gt;&gt; # detecting edges in a coin image
&gt;&gt;&gt; filt_real, filt_imag = gabor(image, frequency=0.6)
&gt;&gt;&gt; plt.figure()            
&gt;&gt;&gt; io.imshow(filt_real)    
&gt;&gt;&gt; io.show()               
</pre> <pre data-language="python">&gt;&gt;&gt; # less sensitivity to finer details with the lower frequency kernel
&gt;&gt;&gt; filt_real, filt_imag = gabor(image, frequency=0.1)
&gt;&gt;&gt; plt.figure()            
&gt;&gt;&gt; io.imshow(filt_real)    
&gt;&gt;&gt; io.show()               
</pre> </dd>
</dl>   <h2 id="gabor-kernel">gabor_kernel</h2> <dl class="function"> <dt id="skimage.filters.gabor_kernel">
<code>skimage.filters.gabor_kernel(frequency, theta=0, bandwidth=1, sigma_x=None, sigma_y=None, n_stds=3, offset=0)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/_gabor.py#L16-L95"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return complex 2D Gabor filter kernel.</p> <p>Gabor kernel is a Gaussian kernel modulated by a complex harmonic function. Harmonic function consists of an imaginary sine function and a real cosine function. Spatial frequency is inversely proportional to the wavelength of the harmonic and to the standard deviation of a Gaussian kernel. The bandwidth is also inversely proportional to the standard deviation.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>frequencyfloat</code> </dt>
<dd>
<p>Spatial frequency of the harmonic function. Specified in pixels.</p> </dd> <dt>
<code>thetafloat, optional</code> </dt>
<dd>
<p>Orientation in radians. If 0, the harmonic is in the x-direction.</p> </dd> <dt>
<code>bandwidthfloat, optional</code> </dt>
<dd>
<p>The bandwidth captured by the filter. For fixed bandwidth, <code>sigma_x</code> and <code>sigma_y</code> will decrease with increasing frequency. This value is ignored if <code>sigma_x</code> and <code>sigma_y</code> are set by the user.</p> </dd> <dt>
<code>sigma_x, sigma_yfloat, optional</code> </dt>
<dd>
<p>Standard deviation in x- and y-directions. These directions apply to the kernel <em>before</em> rotation. If <code>theta = pi/2</code>, then the kernel is rotated 90 degrees so that <code>sigma_x</code> controls the <em>vertical</em> direction.</p> </dd> <dt>
<code>n_stdsscalar, optional</code> </dt>
<dd>
<p>The linear size of the kernel is n_stds (3 by default) standard deviations</p> </dd> <dt>
<code>offsetfloat, optional</code> </dt>
<dd>
<p>Phase offset of harmonic function in radians.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>gcomplex array</code> </dt>
<dd>
<p>Complex filter kernel.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r5ad457f519cf-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Gabor_filter">https://en.wikipedia.org/wiki/Gabor_filter</a></p> </dd> <dt class="label" id="r5ad457f519cf-2">
<code>2</code> </dt> <dd>
<p><a class="reference external" href="https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf">https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.filters import gabor_kernel
&gt;&gt;&gt; from skimage import io
&gt;&gt;&gt; from matplotlib import pyplot as plt  
</pre> <pre data-language="python">&gt;&gt;&gt; gk = gabor_kernel(frequency=0.2)
&gt;&gt;&gt; plt.figure()        
&gt;&gt;&gt; io.imshow(gk.real)  
&gt;&gt;&gt; io.show()           
</pre> <pre data-language="python">&gt;&gt;&gt; # more ripples (equivalent to increasing the size of the
&gt;&gt;&gt; # Gaussian spread)
&gt;&gt;&gt; gk = gabor_kernel(frequency=0.2, bandwidth=0.1)
&gt;&gt;&gt; plt.figure()        
&gt;&gt;&gt; io.imshow(gk.real)  
&gt;&gt;&gt; io.show()           
</pre> </dd>
</dl>   <h2 id="gaussian">gaussian</h2> <dl class="function"> <dt id="skimage.filters.gaussian">
<code>skimage.filters.gaussian(image, sigma=1, output=None, mode='nearest', cval=0, multichannel=None, preserve_range=False, truncate=4.0)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/_gaussian.py#L12-L126"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Multi-dimensional Gaussian filter.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagearray-like</code> </dt>
<dd>
<p>Input image (grayscale or color) to filter.</p> </dd> <dt>
<code>sigmascalar or sequence of scalars, optional</code> </dt>
<dd>
<p>Standard deviation for Gaussian kernel. The standard deviations of the Gaussian filter are given for each axis as a sequence, or as a single number, in which case it is equal for all axes.</p> </dd> <dt>
<code>outputarray, optional</code> </dt>
<dd>
<p>The <code>output</code> parameter passes an array in which to store the filter output.</p> </dd> <dt>
<code>mode{‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional</code> </dt>
<dd>
<p>The <code>mode</code> parameter determines how the array borders are handled, where <code>cval</code> is the value when mode is equal to ‘constant’. Default is ‘nearest’.</p> </dd> <dt>
<code>cvalscalar, optional</code> </dt>
<dd>
<p>Value to fill past edges of input if <code>mode</code> is ‘constant’. Default is 0.0</p> </dd> <dt>
<code>multichannelbool, optional (default: None)</code> </dt>
<dd>
<p>Whether the last axis of the image is to be interpreted as multiple channels. If True, each channel is filtered separately (channels are not mixed together). Only 3 channels are supported. If <code>None</code>, the function will attempt to guess this, and raise a warning if ambiguous, when the array has shape (M, N, 3).</p> </dd> <dt>
<code>preserve_rangebool, optional</code> </dt>
<dd>
<p>Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>. Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p> </dd> <dt>
<code>truncatefloat, optional</code> </dt>
<dd>
<p>Truncate the filter at this many standard deviations.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>filtered_imagendarray</code> </dt>
<dd>
<p>the filtered array</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This function is a wrapper around <code>scipy.ndi.gaussian_filter()</code>.</p> <p>Integer arrays are converted to float.</p> <p>The <code>output</code> should be floating point data type since gaussian converts to float provided <code>image</code>. If <code>output</code> is not provided, another array will be allocated and returned as the result.</p> <p>The multi-dimensional filter is implemented as a sequence of one-dimensional convolution filters. The intermediate arrays are stored in the same data type as the output. Therefore, for output types with a limited precision, the results may be imprecise because intermediate results may be stored with insufficient precision.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; a = np.zeros((3, 3))
&gt;&gt;&gt; a[1, 1] = 1
&gt;&gt;&gt; a
array([[0., 0., 0.],
       [0., 1., 0.],
       [0., 0., 0.]])
&gt;&gt;&gt; gaussian(a, sigma=0.4)  # mild smoothing
array([[0.00163116, 0.03712502, 0.00163116],
       [0.03712502, 0.84496158, 0.03712502],
       [0.00163116, 0.03712502, 0.00163116]])
&gt;&gt;&gt; gaussian(a, sigma=1)  # more smoothing
array([[0.05855018, 0.09653293, 0.05855018],
       [0.09653293, 0.15915589, 0.09653293],
       [0.05855018, 0.09653293, 0.05855018]])
&gt;&gt;&gt; # Several modes are possible for handling boundaries
&gt;&gt;&gt; gaussian(a, sigma=1, mode='reflect')
array([[0.08767308, 0.12075024, 0.08767308],
       [0.12075024, 0.16630671, 0.12075024],
       [0.08767308, 0.12075024, 0.08767308]])
&gt;&gt;&gt; # For RGB images, each is filtered separately
&gt;&gt;&gt; from skimage.data import astronaut
&gt;&gt;&gt; image = astronaut()
&gt;&gt;&gt; filtered_img = gaussian(image, sigma=1, multichannel=True)
</pre> </dd>
</dl>   <h2 id="hessian">hessian</h2> <dl class="function"> <dt id="skimage.filters.hessian">
<code>skimage.filters.hessian(image, sigmas=range(1, 10, 2), scale_range=None, scale_step=None, alpha=0.5, beta=0.5, gamma=15, black_ridges=True, mode=None, cval=0)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/ridges.py#L493-L571"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Filter an image with the Hybrid Hessian filter.</p> <p>This filter can be used to detect continuous edges, e.g. vessels, wrinkles, rivers. It can be used to calculate the fraction of the whole image containing such objects.</p> <p>Defined only for 2-D and 3-D images. Almost equal to Frangi filter, but uses alternative method of smoothing. Refer to <a class="reference internal" href="#r29057abd4159-1" id="id19">[1]</a> to find the differences between Frangi and Hessian filters.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(N, M[, P]) ndarray</code> </dt>
<dd>
<p>Array with input image data.</p> </dd> <dt>
<code>sigmasiterable of floats, optional</code> </dt>
<dd>
<p>Sigmas used as scales of filter, i.e., np.arange(scale_range[0], scale_range[1], scale_step)</p> </dd> <dt>
<code>scale_range2-tuple of floats, optional</code> </dt>
<dd>
<p>The range of sigmas used.</p> </dd> <dt>
<code>scale_stepfloat, optional</code> </dt>
<dd>
<p>Step size between sigmas.</p> </dd> <dt>
<code>betafloat, optional</code> </dt>
<dd>
<p>Frangi correction constant that adjusts the filter’s sensitivity to deviation from a blob-like structure.</p> </dd> <dt>
<code>gammafloat, optional</code> </dt>
<dd>
<p>Frangi correction constant that adjusts the filter’s sensitivity to areas of high variance/texture/structure.</p> </dd> <dt>
<code>black_ridgesboolean, optional</code> </dt>
<dd>
<p>When True (the default), the filter detects black ridges; when False, it detects white ridges.</p> </dd> <dt>
<code>mode{‘constant’, ‘reflect’, ‘wrap’, ‘nearest’, ‘mirror’}, optional</code> </dt>
<dd>
<p>How to handle values outside the image borders.</p> </dd> <dt>
<code>cvalfloat, optional</code> </dt>
<dd>
<p>Used in conjunction with mode ‘constant’, the value outside the image boundaries.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>out(N, M[, P]) ndarray</code> </dt>
<dd>
<p>Filtered image (maximum of pixels across all scales).</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.filters.meijering" title="skimage.filters.meijering"><code>meijering</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.filters.sato" title="skimage.filters.sato"><code>sato</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.filters.frangi" title="skimage.filters.frangi"><code>frangi</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>Written by Marc Schrijver (November 2001) Re-Written by D. J. Kroon University of Twente (May 2009) <a class="reference internal" href="#r29057abd4159-2" id="id20">[2]</a></p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r29057abd4159-1">
<code>1</code> </dt> <dd>
<p>Ng, C. C., Yap, M. H., Costen, N., &amp; Li, B. (2014,). Automatic wrinkle detection using hybrid Hessian filter. In Asian Conference on Computer Vision (pp. 609-622). Springer International Publishing. <a class="reference external" href="https://doi.org/10.1007/978-3-319-16811-1_40">DOI:10.1007/978-3-319-16811-1_40</a></p> </dd> <dt class="label" id="r29057abd4159-2">
<code>2</code> </dt> <dd>
<p>Kroon, D. J.: Hessian based Frangi vesselness filter.</p> </dd> </dl> </dd>
</dl>   <h2 id="inverse">inverse</h2> <dl class="function"> <dt id="skimage.filters.inverse">
<code>skimage.filters.inverse(data, impulse_response=None, filter_params={}, max_gain=2, predefined_filter=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/lpi_filter.py#L167-L204"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Apply the filter in reverse to the given data.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>data(M,N) ndarray</code> </dt>
<dd>
<p>Input data.</p> </dd> <dt>
<code>impulse_responsecallable f(r, c, **filter_params)</code> </dt>
<dd>
<p>Impulse response of the filter. See LPIFilter2D.__init__.</p> </dd> <dt>
<code>filter_paramsdict</code> </dt>
<dd>
<p>Additional keyword parameters to the impulse_response function.</p> </dd> <dt>
<code>max_gainfloat</code> </dt>
<dd>
<p>Limit the filter gain. Often, the filter contains zeros, which would cause the inverse filter to have infinite gain. High gain causes amplification of artefacts, so a conservative limit is recommended.</p> </dd> </dl> </dd> <dt class="field-even">Other Parameters</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>predefined_filterLPIFilter2D</code> </dt>
<dd>
<p>If you need to apply the same filter multiple times over different images, construct the LPIFilter2D and specify it here.</p> </dd> </dl> </dd> </dl> </dd>
</dl>   <h2 id="laplace">laplace</h2> <dl class="function"> <dt id="skimage.filters.laplace">
<code>skimage.filters.laplace(image, ksize=3, mask=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/edges.py#L656-L687"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the edges of an image using the Laplace operator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Image to process.</p> </dd> <dt>
<code>ksizeint, optional</code> </dt>
<dd>
<p>Define the size of the discrete Laplacian operator such that it will have a size of (ksize,) * image.ndim.</p> </dd> <dt>
<code>maskndarray, optional</code> </dt>
<dd>
<p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>outputndarray</code> </dt>
<dd>
<p>The Laplace edge map.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The Laplacian operator is generated using the function skimage.restoration.uft.laplacian().</p> </dd>
</dl>   <h2 id="median">median</h2> <dl class="function"> <dt id="skimage.filters.median">
<code>skimage.filters.median(image, selem=None, out=None, mode='nearest', cval=0.0, behavior='ndimage')</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/_median.py#L10-L78"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return local median of an image.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>imagearray-like</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>If <code>behavior=='rank'</code>, <code>selem</code> is a 2-D array of 1’s and 0’s. If <code>behavior=='ndimage'</code>, <code>selem</code> is a N-D array of 1’s and 0’s with the same number of dimension than <code>image</code>. If None, <code>selem</code> will be a N-D array with 3 elements for each dimension (e.g., vector, square, cube, etc.)</p> </dd> <dt>
<code>outndarray, (same dtype as image), optional</code> </dt>
<dd>
<p>If None, a new array is allocated.</p> </dd> <dt>
<code>mode{‘reflect’, ‘constant’, ‘nearest’, ‘mirror’,’‘wrap’}, optional</code> </dt>
<dd>
<p>The mode parameter determines how the array borders are handled, where <code>cval</code> is the value when mode is equal to ‘constant’. Default is ‘nearest’.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.15: </span><code>mode</code> is used when <code>behavior='ndimage'</code>.</p> </div> </dd> <dt>
<code>cvalscalar, optional</code> </dt>
<dd>
<p>Value to fill past edges of input if mode is ‘constant’. Default is 0.0</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.15: </span><code>cval</code> was added in 0.15 is used when <code>behavior='ndimage'</code>.</p> </div> </dd> <dt>
<code>behavior{‘ndimage’, ‘rank’}, optional</code> </dt>
<dd>
<p>Either to use the old behavior (i.e., &lt; 0.15) or the new behavior. The old behavior will call the <a class="reference internal" href="skimage.filters.rank#skimage.filters.rank.median" title="skimage.filters.rank.median"><code>skimage.filters.rank.median()</code></a>. The new behavior will call the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.median_filter.html#scipy.ndimage.median_filter" title="(in SciPy v1.5.4)"><code>scipy.ndimage.median_filter()</code></a>. Default is ‘ndimage’.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.15: </span><code>behavior</code> is introduced in 0.15</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.16: </span>Default <code>behavior</code> has been changed from ‘rank’ to ‘ndimage’</p> </div> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>out2-D array (same dtype as input image)</code> </dt>
<dd>
<p>Output image.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="skimage.filters.rank#skimage.filters.rank.median" title="skimage.filters.rank.median"><code>skimage.filters.rank.median</code></a>
</dt>
<dd>
<p>Rank-based implementation of the median filtering offering more flexibility with additional parameters but dedicated for unsigned integer images.</p> </dd> </dl> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; from skimage.morphology import disk
&gt;&gt;&gt; from skimage.filters import median
&gt;&gt;&gt; img = data.camera()
&gt;&gt;&gt; med = median(img, disk(5))
</pre> </dd>
</dl>   <h2 id="meijering">meijering</h2> <dl class="function"> <dt id="skimage.filters.meijering">
<code>skimage.filters.meijering(image, sigmas=range(1, 10, 2), alpha=None, black_ridges=True, mode='reflect', cval=0)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/ridges.py#L167-L265"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Filter an image with the Meijering neuriteness filter.</p> <p>This filter can be used to detect continuous ridges, e.g. neurites, wrinkles, rivers. It can be used to calculate the fraction of the whole image containing such objects.</p> <p>Calculates the eigenvectors of the Hessian to compute the similarity of an image region to neurites, according to the method described in <a class="reference internal" href="#rbd62388c4e81-1" id="id23">[1]</a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(N, M[, …, P]) ndarray</code> </dt>
<dd>
<p>Array with input image data.</p> </dd> <dt>
<code>sigmasiterable of floats, optional</code> </dt>
<dd>
<p>Sigmas used as scales of filter</p> </dd> <dt>
<code>alphafloat, optional</code> </dt>
<dd>
<p>Frangi correction constant that adjusts the filter’s sensitivity to deviation from a plate-like structure.</p> </dd> <dt>
<code>black_ridgesboolean, optional</code> </dt>
<dd>
<p>When True (the default), the filter detects black ridges; when False, it detects white ridges.</p> </dd> <dt>
<code>mode{‘constant’, ‘reflect’, ‘wrap’, ‘nearest’, ‘mirror’}, optional</code> </dt>
<dd>
<p>How to handle values outside the image borders.</p> </dd> <dt>
<code>cvalfloat, optional</code> </dt>
<dd>
<p>Used in conjunction with mode ‘constant’, the value outside the image boundaries.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>out(N, M[, …, P]) ndarray</code> </dt>
<dd>
<p>Filtered image (maximum of pixels across all scales).</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.filters.sato" title="skimage.filters.sato"><code>sato</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.filters.frangi" title="skimage.filters.frangi"><code>frangi</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.filters.hessian" title="skimage.filters.hessian"><code>hessian</code></a>
</dt>
 </dl> </div> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rbd62388c4e81-1">
<code>1</code> </dt> <dd>
<p>Meijering, E., Jacob, M., Sarria, J. C., Steiner, P., Hirling, H., Unser, M. (2004). Design and validation of a tool for neurite tracing and analysis in fluorescence microscopy images. Cytometry Part A, 58(2), 167-176. <a class="reference external" href="https://doi.org/10.1002/cyto.a.20022">DOI:10.1002/cyto.a.20022</a></p> </dd> </dl> </dd>
</dl>   <h2 id="prewitt">prewitt</h2> <dl class="function"> <dt id="skimage.filters.prewitt">
<code>skimage.filters.prewitt(image, mask=None, *, axis=None, mode='reflect', cval=0.0)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/edges.py#L434-L489"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the edge magnitude using the Prewitt transform.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>imagearray</code> </dt>
<dd>
<p>The input image.</p> </dd> <dt>
<code>maskarray of bool, optional</code> </dt>
<dd>
<p>Clip the output image to this mask. (Values where mask=0 will be set to 0.)</p> </dd> <dt>
<code>axisint or sequence of int, optional</code> </dt>
<dd>
<p>Compute the edge filter along this axis. If not provided, the edge magnitude is computed. This is defined as:</p> <pre data-language="python">prw_mag = np.sqrt(sum([prewitt(image, axis=i)**2
                       for i in range(image.ndim)]) / image.ndim)
</pre> <p>The magnitude is also computed if axis is a sequence.</p> </dd> <dt>
<code>modestr or sequence of str, optional</code> </dt>
<dd>
<p>The boundary mode for the convolution. See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.convolve.html#scipy.ndimage.convolve" title="(in SciPy v1.5.4)"><code>scipy.ndimage.convolve</code></a> for a description of the modes. This can be either a single boundary mode or one boundary mode per axis.</p> </dd> <dt>
<code>cvalfloat, optional</code> </dt>
<dd>
<p>When <code>mode</code> is <code>'constant'</code>, this is the constant used in values outside the boundary of the image data.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>outputarray of float</code> </dt>
<dd>
<p>The Prewitt edge map.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>sobel,</code> <a class="reference internal" href="#skimage.filters.scharr" title="skimage.filters.scharr"><code>scharr</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>The edge magnitude depends slightly on edge directions, since the approximation of the gradient operator by the Prewitt operator is not completely rotation invariant. For a better rotation invariance, the Scharr operator should be used. The Sobel operator has a better rotation invariance than the Prewitt operator, but a worse rotation invariance than the Scharr operator.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; from skimage import filters
&gt;&gt;&gt; camera = data.camera()
&gt;&gt;&gt; edges = filters.prewitt(camera)
</pre> </dd>
</dl>   <h2 id="prewitt-h">prewitt_h</h2> <dl class="function"> <dt id="skimage.filters.prewitt_h">
<code>skimage.filters.prewitt_h(image, mask=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/edges.py#L492-L519"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the horizontal edges of an image using the Prewitt transform.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image2-D array</code> </dt>
<dd>
<p>Image to process.</p> </dd> <dt>
<code>mask2-D array, optional</code> </dt>
<dd>
<p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>output2-D array</code> </dt>
<dd>
<p>The Prewitt edge map.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python"> 1/3   1/3   1/3
  0     0     0
-1/3  -1/3  -1/3
</pre> </dd>
</dl>   <h2 id="prewitt-v">prewitt_v</h2> <dl class="function"> <dt id="skimage.filters.prewitt_v">
<code>skimage.filters.prewitt_v(image, mask=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/edges.py#L522-L549"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the vertical edges of an image using the Prewitt transform.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image2-D array</code> </dt>
<dd>
<p>Image to process.</p> </dd> <dt>
<code>mask2-D array, optional</code> </dt>
<dd>
<p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>output2-D array</code> </dt>
<dd>
<p>The Prewitt edge map.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python">1/3   0  -1/3
1/3   0  -1/3
1/3   0  -1/3
</pre> </dd>
</dl>   <h2 id="rank-order">rank_order</h2> <dl class="function"> <dt id="skimage.filters.rank_order">
<code>skimage.filters.rank_order(image)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/_rank_order.py#L14-L59"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return an image of the same shape where each pixel is the index of the pixel value in the ascending order of the unique values of <code>image</code>, aka the rank-order value.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
 </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>labelsndarray of type np.uint32, of shape image.shape</code> </dt>
<dd>
<p>New array where each pixel has the rank-order value of the corresponding pixel in <code>image</code>. Pixel values are between 0 and n - 1, where n is the number of distinct unique values in <code>image</code>.</p> </dd> <dt>
<code>original_values1-D ndarray</code> </dt>
<dd>
<p>Unique original values of <code>image</code></p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; a = np.array([[1, 4, 5], [4, 4, 1], [5, 1, 1]])
&gt;&gt;&gt; a
array([[1, 4, 5],
       [4, 4, 1],
       [5, 1, 1]])
&gt;&gt;&gt; rank_order(a)
(array([[0, 1, 2],
       [1, 1, 0],
       [2, 0, 0]], dtype=uint32), array([1, 4, 5]))
&gt;&gt;&gt; b = np.array([-1., 2.5, 3.1, 2.5])
&gt;&gt;&gt; rank_order(b)
(array([0, 1, 2, 1], dtype=uint32), array([-1. ,  2.5,  3.1]))
</pre> </dd>
</dl>   <h2 id="roberts">roberts</h2> <dl class="function"> <dt id="skimage.filters.roberts">
<code>skimage.filters.roberts(image, mask=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/edges.py#L552-L585"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the edge magnitude using Roberts’ cross operator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image2-D array</code> </dt>
<dd>
<p>Image to process.</p> </dd> <dt>
<code>mask2-D array, optional</code> </dt>
<dd>
<p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>output2-D array</code> </dt>
<dd>
<p>The Roberts’ Cross edge map.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>sobel, scharr, prewitt, feature.canny</code> </dt>
 </dl> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; camera = data.camera()
&gt;&gt;&gt; from skimage import filters
&gt;&gt;&gt; edges = filters.roberts(camera)
</pre> </dd>
</dl>   <h2 id="roberts-neg-diag">roberts_neg_diag</h2> <dl class="function"> <dt id="skimage.filters.roberts_neg_diag">
<code>skimage.filters.roberts_neg_diag(image, mask=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/edges.py#L622-L653"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the cross edges of an image using the Roberts’ Cross operator.</p> <p>The kernel is applied to the input image to produce separate measurements of the gradient component one orientation.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image2-D array</code> </dt>
<dd>
<p>Image to process.</p> </dd> <dt>
<code>mask2-D array, optional</code> </dt>
<dd>
<p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>output2-D array</code> </dt>
<dd>
<p>The Robert’s edge map.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python"> 0   1
-1   0
</pre> </dd>
</dl>   <h2 id="roberts-pos-diag">roberts_pos_diag</h2> <dl class="function"> <dt id="skimage.filters.roberts_pos_diag">
<code>skimage.filters.roberts_pos_diag(image, mask=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/edges.py#L588-L619"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the cross edges of an image using Roberts’ cross operator.</p> <p>The kernel is applied to the input image to produce separate measurements of the gradient component one orientation.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image2-D array</code> </dt>
<dd>
<p>Image to process.</p> </dd> <dt>
<code>mask2-D array, optional</code> </dt>
<dd>
<p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>output2-D array</code> </dt>
<dd>
<p>The Robert’s edge map.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python">1   0
0  -1
</pre> </dd>
</dl>   <h2 id="sato">sato</h2> <dl class="function"> <dt id="skimage.filters.sato">
<code>skimage.filters.sato(image, sigmas=range(1, 10, 2), black_ridges=True, mode=None, cval=0)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/ridges.py#L268-L354"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Filter an image with the Sato tubeness filter.</p> <p>This filter can be used to detect continuous ridges, e.g. tubes, wrinkles, rivers. It can be used to calculate the fraction of the whole image containing such objects.</p> <p>Defined only for 2-D and 3-D images. Calculates the eigenvectors of the Hessian to compute the similarity of an image region to tubes, according to the method described in <a class="reference internal" href="#r7b0e4f38c6a4-1" id="id25">[1]</a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(N, M[, P]) ndarray</code> </dt>
<dd>
<p>Array with input image data.</p> </dd> <dt>
<code>sigmasiterable of floats, optional</code> </dt>
<dd>
<p>Sigmas used as scales of filter.</p> </dd> <dt>
<code>black_ridgesboolean, optional</code> </dt>
<dd>
<p>When True (the default), the filter detects black ridges; when False, it detects white ridges.</p> </dd> <dt>
<code>mode{‘constant’, ‘reflect’, ‘wrap’, ‘nearest’, ‘mirror’}, optional</code> </dt>
<dd>
<p>How to handle values outside the image borders.</p> </dd> <dt>
<code>cvalfloat, optional</code> </dt>
<dd>
<p>Used in conjunction with mode ‘constant’, the value outside the image boundaries.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>out(N, M[, P]) ndarray</code> </dt>
<dd>
<p>Filtered image (maximum of pixels across all scales).</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.filters.meijering" title="skimage.filters.meijering"><code>meijering</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.filters.frangi" title="skimage.filters.frangi"><code>frangi</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.filters.hessian" title="skimage.filters.hessian"><code>hessian</code></a>
</dt>
 </dl> </div> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r7b0e4f38c6a4-1">
<code>1</code> </dt> <dd>
<p>Sato, Y., Nakajima, S., Shiraga, N., Atsumi, H., Yoshida, S., Koller, T., …, Kikinis, R. (1998). Three-dimensional multi-scale line filter for segmentation and visualization of curvilinear structures in medical images. Medical image analysis, 2(2), 143-168. <a class="reference external" href="https://doi.org/10.1016/S1361-8415(98)80009-1">DOI:10.1016/S1361-8415(98)80009-1</a></p> </dd> </dl> </dd>
</dl>   <h2 id="scharr">scharr</h2> <dl class="function"> <dt id="skimage.filters.scharr">
<code>skimage.filters.scharr(image, mask=None, *, axis=None, mode='reflect', cval=0.0)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/edges.py#L304-L362"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the edge magnitude using the Scharr transform.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>imagearray</code> </dt>
<dd>
<p>The input image.</p> </dd> <dt>
<code>maskarray of bool, optional</code> </dt>
<dd>
<p>Clip the output image to this mask. (Values where mask=0 will be set to 0.)</p> </dd> <dt>
<code>axisint or sequence of int, optional</code> </dt>
<dd>
<p>Compute the edge filter along this axis. If not provided, the edge magnitude is computed. This is defined as:</p> <pre data-language="python">sch_mag = np.sqrt(sum([scharr(image, axis=i)**2
                       for i in range(image.ndim)]) / image.ndim)
</pre> <p>The magnitude is also computed if axis is a sequence.</p> </dd> <dt>
<code>modestr or sequence of str, optional</code> </dt>
<dd>
<p>The boundary mode for the convolution. See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.convolve.html#scipy.ndimage.convolve" title="(in SciPy v1.5.4)"><code>scipy.ndimage.convolve</code></a> for a description of the modes. This can be either a single boundary mode or one boundary mode per axis.</p> </dd> <dt>
<code>cvalfloat, optional</code> </dt>
<dd>
<p>When <code>mode</code> is <code>'constant'</code>, this is the constant used in values outside the boundary of the image data.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>outputarray of float</code> </dt>
<dd>
<p>The Scharr edge map.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>sobel, prewitt, canny</code> </dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>The Scharr operator has a better rotation invariance than other edge filters such as the Sobel or the Prewitt operators.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r6247f1470247-1">
<code>1</code> </dt> <dd>
<p>D. Kroon, 2009, Short Paper University Twente, Numerical Optimization of Kernel Based Image Derivatives.</p> </dd> <dt class="label" id="r6247f1470247-2">
<code>2</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Sobel_operator#Alternative_operators">https://en.wikipedia.org/wiki/Sobel_operator#Alternative_operators</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; from skimage import filters
&gt;&gt;&gt; camera = data.camera()
&gt;&gt;&gt; edges = filters.scharr(camera)
</pre> </dd>
</dl>   <h2 id="scharr-h">scharr_h</h2> <dl class="function"> <dt id="skimage.filters.scharr_h">
<code>skimage.filters.scharr_h(image, mask=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/edges.py#L365-L397"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the horizontal edges of an image using the Scharr transform.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image2-D array</code> </dt>
<dd>
<p>Image to process.</p> </dd> <dt>
<code>mask2-D array, optional</code> </dt>
<dd>
<p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>output2-D array</code> </dt>
<dd>
<p>The Scharr edge map.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python"> 3   10   3
 0    0   0
-3  -10  -3
</pre> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rd36c6da974bf-1">
<code>1</code> </dt> <dd>
<p>D. Kroon, 2009, Short Paper University Twente, Numerical Optimization of Kernel Based Image Derivatives.</p> </dd> </dl> </dd>
</dl>   <h2 id="scharr-v">scharr_v</h2> <dl class="function"> <dt id="skimage.filters.scharr_v">
<code>skimage.filters.scharr_v(image, mask=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/edges.py#L400-L431"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the vertical edges of an image using the Scharr transform.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image2-D array</code> </dt>
<dd>
<p>Image to process</p> </dd> <dt>
<code>mask2-D array, optional</code> </dt>
<dd>
<p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>output2-D array</code> </dt>
<dd>
<p>The Scharr edge map.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python"> 3   0   -3
10   0  -10
 3   0   -3
</pre> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rb707fee1145e-1">
<code>1</code> </dt> <dd>
<p>D. Kroon, 2009, Short Paper University Twente, Numerical Optimization of Kernel Based Image Derivatives.</p> </dd> </dl> </dd>
</dl>   <h2 id="sobel">sobel</h2> <dl class="function"> <dt id="skimage.filters.sobel">
<code>skimage.filters.sobel(image, mask=None, *, axis=None, mode='reflect', cval=0.0)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/edges.py#L188-L241"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find edges in an image using the Sobel filter.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>imagearray</code> </dt>
<dd>
<p>The input image.</p> </dd> <dt>
<code>maskarray of bool, optional</code> </dt>
<dd>
<p>Clip the output image to this mask. (Values where mask=0 will be set to 0.)</p> </dd> <dt>
<code>axisint or sequence of int, optional</code> </dt>
<dd>
<p>Compute the edge filter along this axis. If not provided, the edge magnitude is computed. This is defined as:</p> <pre data-language="python">sobel_mag = np.sqrt(sum([sobel(image, axis=i)**2
                         for i in range(image.ndim)]) / image.ndim)
</pre> <p>The magnitude is also computed if axis is a sequence.</p> </dd> <dt>
<code>modestr or sequence of str, optional</code> </dt>
<dd>
<p>The boundary mode for the convolution. See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.convolve.html#scipy.ndimage.convolve" title="(in SciPy v1.5.4)"><code>scipy.ndimage.convolve</code></a> for a description of the modes. This can be either a single boundary mode or one boundary mode per axis.</p> </dd> <dt>
<code>cvalfloat, optional</code> </dt>
<dd>
<p>When <code>mode</code> is <code>'constant'</code>, this is the constant used in values outside the boundary of the image data.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>outputarray of float</code> </dt>
<dd>
<p>The Sobel edge map.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>scharr, prewitt, canny</code> </dt>
 </dl> </div> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r1e927ecde2f1-1">
<code>1</code> </dt> <dd>
<p>D. Kroon, 2009, Short Paper University Twente, Numerical Optimization of Kernel Based Image Derivatives.</p> </dd> <dt class="label" id="r1e927ecde2f1-2">
<code>2</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Sobel_operator">https://en.wikipedia.org/wiki/Sobel_operator</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; from skimage import filters
&gt;&gt;&gt; camera = data.camera()
&gt;&gt;&gt; edges = filters.sobel(camera)
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-filters-sobel">Examples using <code>skimage.filters.sobel</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="Flood fill is an algorithm to identify and/or change adjacent values in an image based on their...">
<div class="figure align-default" id="id60"> <img alt="Flood Fill" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_floodfill.html#sphx-glr-auto-examples-segmentation-plot-floodfill-py"><span class="std std-ref">Flood Fill</span></a></span></p> </div> </div>   <h2 id="sobel-h">sobel_h</h2> <dl class="function"> <dt id="skimage.filters.sobel_h">
<code>skimage.filters.sobel_h(image, mask=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/edges.py#L244-L271"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the horizontal edges of an image using the Sobel transform.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image2-D array</code> </dt>
<dd>
<p>Image to process.</p> </dd> <dt>
<code>mask2-D array, optional</code> </dt>
<dd>
<p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>output2-D array</code> </dt>
<dd>
<p>The Sobel edge map.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python"> 1   2   1
 0   0   0
-1  -2  -1
</pre> </dd>
</dl>   <h2 id="sobel-v">sobel_v</h2> <dl class="function"> <dt id="skimage.filters.sobel_v">
<code>skimage.filters.sobel_v(image, mask=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/edges.py#L274-L301"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the vertical edges of an image using the Sobel transform.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image2-D array</code> </dt>
<dd>
<p>Image to process.</p> </dd> <dt>
<code>mask2-D array, optional</code> </dt>
<dd>
<p>An optional mask to limit the application to a certain area. Note that pixels surrounding masked regions are also masked to prevent masked regions from affecting the result.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>output2-D array</code> </dt>
<dd>
<p>The Sobel edge map.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>We use the following kernel:</p> <pre data-language="python">1   0  -1
2   0  -2
1   0  -1
</pre> </dd>
</dl>   <h2 id="threshold-isodata">threshold_isodata</h2> <dl class="function"> <dt id="skimage.filters.threshold_isodata">
<code>skimage.filters.threshold_isodata(image=None, nbins=256, return_all=False, *, hist=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/thresholding.py#L414-L528"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return threshold value(s) based on ISODATA method.</p> <p>Histogram-based threshold, known as Ridler-Calvard method or inter-means. Threshold values returned satisfy the following equality:</p> <pre data-language="python">threshold = (image[image &lt;= threshold].mean() +
             image[image &gt; threshold].mean()) / 2.0
</pre> <p>That is, returned thresholds are intensities that separate the image into two groups of pixels, where the threshold intensity is midway between the mean intensities of these groups.</p> <p>For integer images, the above equality holds to within one; for floating- point images, the equality holds to within the histogram bin-width.</p> <p>Either image or hist must be provided. In case hist is given, the actual histogram of the image is ignored.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(N, M) ndarray, optional</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>nbinsint, optional</code> </dt>
<dd>
<p>Number of bins used to calculate histogram. This value is ignored for integer arrays.</p> </dd> <dt>
<code>return_allbool, optional</code> </dt>
<dd>
<p>If False (default), return only the lowest threshold that satisfies the above equality. If True, return all valid thresholds.</p> </dd> <dt>
<code>histarray, or 2-tuple of arrays, optional</code> </dt>
<dd>
<p>Histogram to determine the threshold from and a corresponding array of bin center intensities. Alternatively, only the histogram can be passed.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>thresholdfloat or int or array</code> </dt>
<dd>
<p>Threshold value(s).</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="re728dd270820-1">
<code>1</code> </dt> <dd>
<p>Ridler, TW &amp; Calvard, S (1978), “Picture thresholding using an iterative selection method” IEEE Transactions on Systems, Man and Cybernetics 8: 630-632, <a class="reference external" href="https://doi.org/10.1109/TSMC.1978.4310039">DOI:10.1109/TSMC.1978.4310039</a></p> </dd> <dt class="label" id="re728dd270820-2">
<code>2</code> </dt> <dd>
<p>Sezgin M. and Sankur B. (2004) “Survey over Image Thresholding Techniques and Quantitative Performance Evaluation” Journal of Electronic Imaging, 13(1): 146-165, <a class="reference external" href="http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf">http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf</a> <a class="reference external" href="https://doi.org/10.1117/1.1631315">DOI:10.1117/1.1631315</a></p> </dd> <dt class="label" id="re728dd270820-3">
<code>3</code> </dt> <dd>
<p>ImageJ AutoThresholder code, <a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold">http://fiji.sc/wiki/index.php/Auto_Threshold</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import coins
&gt;&gt;&gt; image = coins()
&gt;&gt;&gt; thresh = threshold_isodata(image)
&gt;&gt;&gt; binary = image &gt; thresh
</pre> </dd>
</dl>   <h2 id="threshold-li">threshold_li</h2> <dl class="function"> <dt id="skimage.filters.threshold_li">
<code>skimage.filters.threshold_li(image, *, tolerance=None, initial_guess=None, iter_callback=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/thresholding.py#L586-L707"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute threshold value by Li’s iterative Minimum Cross Entropy method.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>tolerancefloat, optional</code> </dt>
<dd>
<p>Finish the computation when the change in the threshold in an iteration is less than this value. By default, this is half the smallest difference between intensity values in <code>image</code>.</p> </dd> <dt>
<code>initial_guessfloat or Callable[[array[float]], float], optional</code> </dt>
<dd>
<p>Li’s iterative method uses gradient descent to find the optimal threshold. If the image intensity histogram contains more than two modes (peaks), the gradient descent could get stuck in a local optimum. An initial guess for the iteration can help the algorithm find the globally-optimal threshold. A float value defines a specific start point, while a callable should take in an array of image intensities and return a float value. Example valid callables include <code>numpy.mean</code> (default), <code>lambda arr: numpy.quantile(arr, 0.95)</code>, or even <a class="reference internal" href="#skimage.filters.threshold_otsu" title="skimage.filters.threshold_otsu"><code>skimage.filters.threshold_otsu()</code></a>.</p> </dd> <dt>
<code>iter_callbackCallable[[float], Any], optional</code> </dt>
<dd>
<p>A function that will be called on the threshold at every iteration of the algorithm.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>thresholdfloat</code> </dt>
<dd>
<p>Upper threshold value. All pixels with an intensity higher than this value are assumed to be foreground.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rc1e664efa0df-1">
<code>1</code> </dt> <dd>
<p>Li C.H. and Lee C.K. (1993) “Minimum Cross Entropy Thresholding” Pattern Recognition, 26(4): 617-625 <a class="reference external" href="https://doi.org/10.1016/0031-3203(93)90115-D">DOI:10.1016/0031-3203(93)90115-D</a></p> </dd> <dt class="label" id="rc1e664efa0df-2">
<code>2</code> </dt> <dd>
<p>Li C.H. and Tam P.K.S. (1998) “An Iterative Algorithm for Minimum Cross Entropy Thresholding” Pattern Recognition Letters, 18(8): 771-776 <a class="reference external" href="https://doi.org/10.1016/S0167-8655(98)00057-9">DOI:10.1016/S0167-8655(98)00057-9</a></p> </dd> <dt class="label" id="rc1e664efa0df-3">
<code>3</code> </dt> <dd>
<p>Sezgin M. and Sankur B. (2004) “Survey over Image Thresholding Techniques and Quantitative Performance Evaluation” Journal of Electronic Imaging, 13(1): 146-165 <a class="reference external" href="https://doi.org/10.1117/1.1631315">DOI:10.1117/1.1631315</a></p> </dd> <dt class="label" id="rc1e664efa0df-4">
<code>4</code> </dt> <dd>
<p>ImageJ AutoThresholder code, <a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold">http://fiji.sc/wiki/index.php/Auto_Threshold</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import camera
&gt;&gt;&gt; image = camera()
&gt;&gt;&gt; thresh = threshold_li(image)
&gt;&gt;&gt; binary = image &gt; thresh
</pre> </dd>
</dl>   <h2 id="threshold-local">threshold_local</h2> <dl class="function"> <dt id="skimage.filters.threshold_local">
<code>skimage.filters.threshold_local(image, block_size, method='gaussian', offset=0, mode='reflect', param=None, cval=0)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/thresholding.py#L145-L236"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute a threshold mask image based on local pixel neighborhood.</p> <p>Also known as adaptive or dynamic thresholding. The threshold value is the weighted mean for the local neighborhood of a pixel subtracted by a constant. Alternatively the threshold can be determined dynamically by a given function, using the ‘generic’ method.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>image(N, M) ndarray</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>block_sizeint</code> </dt>
<dd>
<p>Odd size of pixel neighborhood which is used to calculate the threshold value (e.g. 3, 5, 7, …, 21, …).</p> </dd> <dt>
<code>method{‘generic’, ‘gaussian’, ‘mean’, ‘median’}, optional</code> </dt>
<dd>
<p>Method used to determine adaptive threshold for local neighbourhood in weighted mean image.</p> <ul class="simple"> <li>‘generic’: use custom function (see <code>param</code> parameter)</li> <li>‘gaussian’: apply gaussian filter (see <code>param</code> parameter for custom sigma value)</li> <li>‘mean’: apply arithmetic mean filter</li> <li>‘median’: apply median rank filter</li> </ul> <p>By default the ‘gaussian’ method is used.</p> </dd> <dt>
<code>offsetfloat, optional</code> </dt>
<dd>
<p>Constant subtracted from weighted mean of neighborhood to calculate the local threshold value. Default offset is 0.</p> </dd> <dt>
<code>mode{‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional</code> </dt>
<dd>
<p>The mode parameter determines how the array borders are handled, where cval is the value when mode is equal to ‘constant’. Default is ‘reflect’.</p> </dd> <dt>
<code>param{int, function}, optional</code> </dt>
<dd>
<p>Either specify sigma for ‘gaussian’ method or function object for ‘generic’ method. This functions takes the flat array of local neighbourhood as a single argument and returns the calculated threshold for the centre pixel.</p> </dd> <dt>
<code>cvalfloat, optional</code> </dt>
<dd>
<p>Value to fill past edges of input if mode is ‘constant’.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>threshold(N, M) ndarray</code> </dt>
<dd>
<p>Threshold image. All pixels in the input image higher than the corresponding pixel in the threshold image are considered foreground.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rf57739a75c82-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="https://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html?highlight=threshold#adaptivethreshold">https://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html?highlight=threshold#adaptivethreshold</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import camera
&gt;&gt;&gt; image = camera()[:50, :50]
&gt;&gt;&gt; binary_image1 = image &gt; threshold_local(image, 15, 'mean')
&gt;&gt;&gt; func = lambda arr: arr.mean()
&gt;&gt;&gt; binary_image2 = image &gt; threshold_local(image, 15, 'generic',
...                                         param=func)
</pre> </dd>
</dl>   <h2 id="threshold-mean">threshold_mean</h2> <dl class="function"> <dt id="skimage.filters.threshold_mean">
<code>skimage.filters.threshold_mean(image)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/thresholding.py#L802-L830"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return threshold value based on the mean of grayscale values.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(N, M[, …, P]) ndarray</code> </dt>
<dd>
<p>Grayscale input image.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>thresholdfloat</code> </dt>
<dd>
<p>Upper threshold value. All pixels with an intensity higher than this value are assumed to be foreground.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r6186ece30463-1">
<code>1</code> </dt> <dd>
<p>C. A. Glasbey, “An analysis of histogram-based thresholding algorithms,” CVGIP: Graphical Models and Image Processing, vol. 55, pp. 532-537, 1993. <a class="reference external" href="https://doi.org/10.1006/cgip.1993.1040">DOI:10.1006/cgip.1993.1040</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import camera
&gt;&gt;&gt; image = camera()
&gt;&gt;&gt; thresh = threshold_mean(image)
&gt;&gt;&gt; binary = image &gt; thresh
</pre> </dd>
</dl>   <h2 id="threshold-minimum">threshold_minimum</h2> <dl class="function"> <dt id="skimage.filters.threshold_minimum">
<code>skimage.filters.threshold_minimum(image=None, nbins=256, max_iter=10000, *, hist=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/thresholding.py#L710-L799"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return threshold value based on minimum method.</p> <p>The histogram of the input <code>image</code> is computed if not provided and smoothed until there are only two maxima. Then the minimum in between is the threshold value.</p> <p>Either image or hist must be provided. In case hist is given, the actual histogram of the image is ignored.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(M, N) ndarray, optional</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>nbinsint, optional</code> </dt>
<dd>
<p>Number of bins used to calculate histogram. This value is ignored for integer arrays.</p> </dd> <dt>
<code>max_iterint, optional</code> </dt>
<dd>
<p>Maximum number of iterations to smooth the histogram.</p> </dd> <dt>
<code>histarray, or 2-tuple of arrays, optional</code> </dt>
<dd>
<p>Histogram to determine the threshold from and a corresponding array of bin center intensities. Alternatively, only the histogram can be passed.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>thresholdfloat</code> </dt>
<dd>
<p>Upper threshold value. All pixels with an intensity higher than this value are assumed to be foreground.</p> </dd> </dl> </dd> <dt class="field-odd">Raises</dt> <dd class="field-odd">
<dl class="simple"> <dt>RuntimeError</dt>
<dd>
<p>If unable to find two local maxima in the histogram or if the smoothing takes more than 1e4 iterations.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rd44294765be8-1">
<code>1</code> </dt> <dd>
<p>C. A. Glasbey, “An analysis of histogram-based thresholding algorithms,” CVGIP: Graphical Models and Image Processing, vol. 55, pp. 532-537, 1993.</p> </dd> <dt class="label" id="rd44294765be8-2">
<code>2</code> </dt> <dd>
<p>Prewitt, JMS &amp; Mendelsohn, ML (1966), “The analysis of cell images”, Annals of the New York Academy of Sciences 128: 1035-1053 <a class="reference external" href="https://doi.org/10.1111/j.1749-6632.1965.tb11715.x">DOI:10.1111/j.1749-6632.1965.tb11715.x</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import camera
&gt;&gt;&gt; image = camera()
&gt;&gt;&gt; thresh = threshold_minimum(image)
&gt;&gt;&gt; binary = image &gt; thresh
</pre> </dd>
</dl>   <h2 id="threshold-multiotsu">threshold_multiotsu</h2> <dl class="function"> <dt id="skimage.filters.threshold_multiotsu">
<code>skimage.filters.threshold_multiotsu(image, classes=3, nbins=256)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/thresholding.py#L1137-L1228"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate <code>classes</code>-1 threshold values to divide gray levels in <code>image</code>.</p> <p>The threshold values are chosen to maximize the total sum of pairwise variances between the thresholded graylevel classes. See Notes and <a class="reference internal" href="#r9f5f8b3d5d49-1" id="id44">[1]</a> for more details.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(N, M) ndarray</code> </dt>
<dd>
<p>Grayscale input image.</p> </dd> <dt>
<code>classesint, optional</code> </dt>
<dd>
<p>Number of classes to be thresholded, i.e. the number of resulting regions.</p> </dd> <dt>
<code>nbinsint, optional</code> </dt>
<dd>
<p>Number of bins used to calculate the histogram. This value is ignored for integer arrays.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>thresharray</code> </dt>
<dd>
<p>Array containing the threshold values for the desired classes.</p> </dd> </dl> </dd> <dt class="field-odd">Raises</dt> <dd class="field-odd">
<dl class="simple"> <dt>ValueError</dt>
<dd>
<p>If <code>image</code> contains less grayscale value then the desired number of classes.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This implementation relies on a Cython function whose complexity is <span class="math notranslate nohighlight">\(O\left(\frac{Ch^{C-1}}{(C-1)!}\right)\)</span>, where <span class="math notranslate nohighlight">\(h\)</span> is the number of histogram bins and <span class="math notranslate nohighlight">\(C\)</span> is the number of classes desired.</p> <p>The input image must be grayscale.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r9f5f8b3d5d49-1">
<code>1</code> </dt> <dd>
<p>Liao, P-S., Chen, T-S. and Chung, P-C., “A fast algorithm for multilevel thresholding”, Journal of Information Science and Engineering 17 (5): 713-727, 2001. Available at: &lt;<a class="reference external" href="https://ftp.iis.sinica.edu.tw/JISE/2001/200109_01.pdf">https://ftp.iis.sinica.edu.tw/JISE/2001/200109_01.pdf</a>&gt; <a class="reference external" href="https://doi.org/10.6688/JISE.2001.17.5.1">DOI:10.6688/JISE.2001.17.5.1</a></p> </dd> <dt class="label" id="r9f5f8b3d5d49-2">
<code>2</code> </dt> <dd>
<p>Tosa, Y., “Multi-Otsu Threshold”, a java plugin for ImageJ. Available at: &lt;<a class="reference external" href="http://imagej.net/plugins/download/Multi_OtsuThreshold.java">http://imagej.net/plugins/download/Multi_OtsuThreshold.java</a>&gt;</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.color import label2rgb
&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; image = data.camera()
&gt;&gt;&gt; thresholds = threshold_multiotsu(image)
&gt;&gt;&gt; regions = np.digitize(image, bins=thresholds)
&gt;&gt;&gt; regions_colorized = label2rgb(regions)
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-filters-threshold-multiotsu">Examples using <code>skimage.filters.threshold_multiotsu</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="The multi-Otsu threshold [1]_ is a thresholding algorithm that is used to separate the pixels o...">
<div class="figure align-default" id="id61"> <img alt="Multi-Otsu Thresholding" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAADECAMAAABz285eAAADAFBMVEX///8XFxebm5vHx8d8/3nJycmcnJx/AAAAAH8fd7TFxcUTExMbGxv/dHTT09MVcbGysrIZGRmfn5+kpKQDAwPe3t6Wlpb+///MzMzNzc3V1dX7+/uVlZUAAHx//3bj4+N9AACF/3HPz8+Tk5Pq6uodHR2C/3ORkZGZmZmXl5f/8O8ODg4cdbPR0dGenp56AACgoKDW1tb/9fWLi4umpqZ8/3eOjo7G3OzRo6P9/f3u7u6g/VWpqamBgoKioqIYc7IrKyuU/mHDw8OI/22urq6O/mgfHx/Ozs6L/2qGh4djgpeY/l0JCQmKuNja2toAAYYlJSW9vb319fWQ/2Sn/E/AwMAiIiK1tbX2//Vtp87n5+eGBAFHR0fc3Nx8fHz0+fzg4OB3d3cuLpcnfLdycnHj7vbY2NgxgrpYWFgvLy/4+Pg1NTXy8vKs+kpPT0/X5/K090MBCI6IFBJOlMSXLi681+mH/4T27Oy6urp5/n9oaGj5+/0BC5nv9vp3rdI4ODg+Pj6vz+WS+WMed7Q6hbue01ab+1oQMZnq8/hhYGCRCQBq6YuR/3gEG5a3uLhjoMtbnMhtbGs/i7+88joVTZyf81e36EByMUAobaCz1EJBJ22U5mGn8VBSt5qoFgBcyJOexN/Y+6he25HE6jGnyuB81HiTvdpy7oSFhcPL4O7O4u8MTsW1gyXT5PGawdzB/7+sWxeF7nHP/rGcKwsNPKqBh3A9mJyC/3iJ+m0tUJdquYPI2C6VGQbc0xyde0OWM095VVvT4SR2mXcMHYqrnzghIIC9JgMPE4WCISGluEXBniyQYjdNaXxbn49cfYrIYBRGxac8orWAeF6Go2LK/rc+d5YaV7B0+4TPwSlSbIxc+p5pPl10XIUFJbnO7SY/ToQkacL5/fG3xV3x2Y4pN4aeqUUcm9rjZWbY3KYxs70okbDwLQEbG5I60b3J+C/Yr6/Qo6Pq+Ji9S12Oa3WeOVSFhcCbm8316+vH/7ik5Hqk4YK26shwf3MXeMgXm8c+/xdLspK9AAAbfUlEQVR42uzZa2xa5xnA8UMwNgNKIAiDcQgEQ4EhMAxKF3aw0BkDWUq5ScACHGJUm3KTI0fJhl1UW5GszER2miqaXUd1qyhp1cWpHNmLm8qKIjW+JF7kpVPTLlUUbWpWZdXUfps27cPew8XGNnbowNYUvX8sjPFF9i/PeThHQRAYDAaDwWAwGAwGg8FgMBgMBoPBYDAYDAaDwWAwGAwGg8FgMBgMBoPBYDAYDAaDwWAwGAy2Mx06BA02l0p70EDKZDWlPIg04TGZEs1STwq6ICkzGvbLyWGsXstS7DGS2+QsvVEJZRCTAg+z/Hu0TVZU39SiFcnDWjJqFUEYjzrhZbrJZPuI1xFRqD0sv1qkE8CJKS1Bew48TOQU0gz+joQn92GAV8H3SGnkcmHFBxQJZdNzpTm22VTc5iiC8AIe4neKqnmeDZ8HC32X/nGVXoXXG5WkBQIv2eMNaJor+CYvxuXim27Mb7h44fHqk/g30c1fGTVs/aP5nbRO3KTeZybrEGYby2DWebkBbsKTjroDFCYu5WvMHbsCI61HjGG+Bm3TogoO1m5s2xJGwDWpExKPToog5LIr9ccvlHnyhZ9sfo7H2vr3UZvNCi1Ta1CqUYkh6tFrMaXbi5q4+xXGxhasTbKP05jYFZjmer/C0IEajBzU7a6X6zlbwfDq3X5Wm59jtSKBtupgmreBkbAwFN2vsWq8VhFTY3Ar1C0GTbunI52W00bknBaNdU9gl46laCLV7PGbRSmPx8M1pbbcMXiblWVgGQCMlFOE6Tpaa5hEAkl58JTHFAC7JNCBBETcZpGIBzYO19RhIj4jNe3qa+2z59MhSumamQlH6aH04W9qDbPr8UzSCguUTVr6w7AizO9qAPPd9z+tou+/q3LlNFMwGghbn3dT7vwduK0rTakO5hBvKxjeidaqCv6zSpimwinG6skELR9GvGGb2+DFrw7mw6Nbw4gbqkh8/NdVwtgpFD64lZTnyQHllbCt85aH+ahSmJf/f2EkFD7BsplmLRp5a6GmsjCvPAcw6iZ7UzF+voISuRSIVloJjL0szPvPAQxTks9eeAfKCW2YIMo6n9UhwiTlJ6brOYApiBCp1YU7gGOX2NeGZxWIQqas39PlYd44uXMw4GmxeJdhciyFvKgf40tWj671rdGodxlG3DB9c3l6LijehUMJKEjUkg08ylh/stvMkthXN89Godzk7DaMODj6+PT5G/9Zzop3GkaXHxBm7paLkOp0WVw2BrtfriYOq5LFzN+woJngsqHZhIAbuMqk7TQMcMlQhUKq8/TQM2RqAcNcF0ETDdMtcUvcRaK7GtWrG3mTDyHDRFJGFpo2pNE04hnZaZjgaA+VSnUKqcKer7aXqR4myhQwN+RA2XRLMtmftLHZlj1rR5l9FWjNhomMRORYC63RbUVweRHmyA7BLM0Dl0xPBtwP39pWpgYwOpAgV54laveHVCS2L54ciLPZ9OQIc/3+WeMhfARIimJPB/wBd3Tt6vr1t16uCIbH+0EwwaVxZx4GvBOeXt7ZiXHoShLodI50N4OuUqnobFd/3Ociqc7ljq4NOAUfO19XbvlWCtPVVfG1EvhgabyHcKEKnU7ivfPxdiNTC5hotOjiwKM6NCkjqQ4DGDo77pLZ6Kru3N5ZXc0Ekk5UFGqqCuZY18muymCCweNL82C3gM1L3BEwwvnjZU5xageDR4vhOGYcCsV9Pgb9sG+AdJiejCV9roGIbv1mJqYnWpwhe7S6ibl0tRKY4PHR8a8/zU3L8JVhIbVn7DyVevoxOJkRi0tO9sTBiYkiTvUwXEchrrsz6bMxGC7wYqQaivTTQxF549BAPUaASJokJToBvCgkqQaGd/JqBTDi4PHx+dzBQ8CM/eMR9fzF3t6/Z25NZYNgkoLBNZiJYA0nhovjuAPccH3S5vP5ZAwXMTGx+r54uH0oFgvF9Bq3l+U3sHTF9axmSjuY+XMfdXmYQxVOzPuXng0DTl3mCypgr1DH7ryTuT57/8GProxdfntlYWpqcrIEpoaH0qEOLkGDi4w+n8vns8nYPpsvRkrKO7vDHGWnFo2Y9RRwnLUrHPmXLwIm0FFcOOVhul59r2YwDblTl4LLjcWe339w/cyF25+MLt+794elBnH29mfBHYMBifwWGWABb2ybjWE+F+8f6utsRFFMt9/fRPa6/aiksKIJmjxM7qhylIO5uveVCmHeOPYsmKVPqWuNjzt7rh+sOzD426nsrZsLEysrk19Oi4tbNw+T3zo1gCHmhYt309kyn81m8xEwoZFQf/dQn1nT2OgNhw1WFNUqUF1UJ8C5gIeAETApNIlOwCwPc6xCmI+OnN0GphX8veLguLMEZvHWFefMmRdfOnDwTyujnw8+uXCw7u0T4MuCeRACRpxdyBIruQbLl4uLUmlw3kKy2WQMGYPQSbcnk91DneZ2OS4falfu4yj74pgEzA+Xy2wSCEQdOmba73aDh3hVMGfPbnMogb0qblhaLHGhOkc/Gxaef/eLL858Mjf62uXeuhdn3x0enbg9FRSLg9MN4DVJ3Lrw7bfT0w2tVU+MY6TNGpB2q1QkEgnAsGVsmY0U8Ycs8RAYGiwg4sRC3d2xkIulYeGBQEcH7oiK8CiAUZj1I9VOzJuXtvzvkxNTT55Mz60bGCr165XHPVTnzNP7y3PTy2OPrjy4tzczensy2AoU5xomgtkggLk7+/Fkdq5KmIRBaZTvi4FrADqJBOaFxGCTZOyQwRxXMUKx/vY9ipYkyRW3MCydjVY84Ig6RPy0tsWqTrcZzWa90cr732FeP3Lkzfe2nJh/X+udvfDn9S7C03cGZ6jCmacz75w6depB5lFmRkj9/OCdbDYbzGanp54M3s4ufHnq2rULg3/9S7UwGg6rk04HA0MnsRkMQgfABPR0l81mGdDL5fIkXZXsJ1nCevMIy0u2Koz6sLkxnWb5R7xWrRUJYA7M5JZi3LVrpQphjr56dhuYf10YnLqYEa6DoS7OLRMvUovDFw/U9e51UhdnhJk/9p6ZXAGv24Mfz9bV/XxlYnoBbOW7VcOgWk5bP7gAAANDZ4NxodPB3FiUA654HFxGRtrbY5YB10DS1m2ODIUj5yLhsBnAoF4amcZXk7UKJKWUe5VeRdqKcBt/IMxr28Hcnbw7eYO6IedXuZ0j7Hn68OH9mUxmfl744OGZv/X+7BcHZ3vrXvrg8s25hlbwqjR991e/rHZi6tEI0ACHEkABewY8lPkscZclnoz3J0N9ff9lzfx/m7jPOB7fvFPCWUr8Zc6m2sdut9wXOTrd5NiodezEvVx0rl3Z3XmJ6NxMBrM4CYREEdMSvtYlBkSzEkqAEKJUWdOIMlVFIxCYhBBlm4oKAiqGRlsVVVV/qNr9BdO05zlnfAkxzLEfH5dz8hMvvd/v53k+F3NYE327W0dGstmR9Hgm3RXsSu3Jput++IPft8l+f9XaOqGtrrmuubNqcx2A2bS9JDDri2bMVx9f+3RwORj3jqWfZ7+9PuiuHvvuxODN7+9/cy+gm82+4btv7Lh/59ivf/rhtSm1XDCb+7PBVg+CsZosJg8FYDxUR09Pa2trT0+ifU8QwFDp3Ynd/RDBI+nMeNAb7AI6XZGmzpBsc7mef2Ft76tVa+tf7S2c4J3aWRKYt4oq5v6Rua+rn6gla7nHpq/E3YM3vv5r/DTUTfPBm/OjueHZ6TNTU1f/Npk8mXuzTDC/zBzYTcXQSFarFckYpmo1qiPm6JOzDgcVTKX6u5pG+tPpdIYXIhGBECVSZP0uiZWWh29JYA4PDW0vppjPPzleXbTcY3MI5sqF2n0njl04e/Pe/K35jxeH1cDE0YH8qJ6f0MsF01uX8XhioBIgA2w8YCcLrAWJ9o7WBOVw9GViMQ8VzHbZf/HzV5yiUxRZ1sWyfKH8vNe+vF2//2wwWx+A6R7q/k0xxXz16UdPAbPv5lj14I6Lt75XP/zzn8zDZpr2DZuhjBuUr1wrPUf0UB6HaUkyJo/JAqNMg6WDMiUoT8zh8Thi6fSBEd4eCoFzJJKEiyQelNi2HMy7zwSzbtf2R8DsLKaY3x1xFwdTHd/hjn95+9Z/Zrnz5xmfz7y8ygbT2w+h4qCsRshg+sKEZ7E0tONZlQn+4og5sqFsuklGIKQk22RZDsmSTbYVnuqWg3kZwbS89RQwQ92PgGk5VQzM3uqnFlA7caz7Fm1eucoG80KP1UI5YtiP0EPQnCy4FnSYYhSCiqFq+oNZkItsQAEY+GyzSRLcJaIImKHiYPZ3t7z+EEztumJW2uCufkbFN9y4MG+QYQwWlQXTSplAF8Ygg2NMuzHmwaYNxoLfxaiYI2b1p1whAAJ2gnsTuqpQdrvcWTqYjbXvLYHZ21jTWAYY9+C/N8xySKFw43xmrqAgH1cRMDEAg9mLMdOAY57F0tEB6oFIxoyJebxeIAIqISXQSeh/0jG0UzqYTY+DOVUamPhjYMYv0gxHc7SPxguo0HBxFQJjQjAOw0vgJgsqpj3Riq0bZAROijlaxaYmu90OREAjhk4MZxlZXLqVtrVgAiGYrRvfqGnZVgqY+OBjI9++zNTihK6EGZrTFYYJAyTGvKSZN8sHA10ZvWSAsRq66cAUTu2B0Q7TN+UlUC8CgekrYejaoCToT4Lgai4VTD2AOVQAs66lpubR/vVsMDsGsVMfH3Qbb1GO3LsyyinDd5dYmNFKHG188VXCSgaY2BIZnHxjQMSa8MqZVtBSImMnBNnOH8j6SVKAVk0Ssg0RCQIhSMQT2/Wu958B5r2HYBpLBWP4Z/r8zJF4dXzsnJkJjtLz356e4cwGDh+nMUuMlPLBJApgjMYEAUyhr2Lw5YBMysJ4akQMyemuSCYbcQEJFI3NRgiCMc0IUG31vb1Vxqe+AGY9pOnrtUP1xcBs7W5sGXp+9WCqjzOwL07fOXeQUWf+OTP9j5mD0I4UhmN8HIPdSWEq1JUKGYM0oIwnDxgqJcL/HLOEJIOJPaksC4MMQRbsROLf8AvMwU1VP2pua15jX9P8q6rnXlkC80Ft9/5iYN6trWncuH/VYNz75hXFZ9YYqINjX5z+5qDKcZyZYTgFbGRm4FEF1dCVAGMt4HhYVIOpxy+hPICBKGf6dqdG4Bsh2ARBFFyC6ILdgCCdThEzZnNbaA3/Y/7FtqrfepfAvFO7cVMxMO+UBcY9Bv0ZSKiaz6zPjn1x9r6GNDjGmGJoaE5mTjOipgJgLNSjVDBgTJY0RIhAQuaSki3iTaQidbA2krLIunBdEshQCK0kCry96sXmn9S91vZa3c8K2/X/AQZb0SrBxM9xvkUfrem6mVNmP//76e6rgEXTaB+D7RraU14xcqYCioGxxfMQC6QMLJVZ2J1BE5AnQCbi7Rvn22T0DvwTQSYiUiMAjCg+Eb7PArOrpRwwR6D1YNRySi7HXLz83Z27t6cUDmJX0SBhIIJhqikEcPntGnZGq+cBFpMJmlIKctYJAsEZThL9Xp4gXZ0saAZEJLAgGaAjuAAShm+JYA4VevTqwEDAaLSay+UDbw9EuRs3gqPRi1fhNxqtBUAvxpCnYeOuhGIsDbBN45RLUVbjtIrq40ErckgSAIQg8UKQlUJsmw0iBlJXZJ1OFvwkugQnEXpywEMw64uDwWm3pnbXasDE3R/NRfO5iZOBxYCS05nF8ZcWJpMnb49qUZVTAwqtQyT74IoqtKpUQDHtDTjWWRssFgTTYElEJBhRBBsZspO2UCgodfGkTPJ/QCPBWoCK4V0ABgAJbPNKYA614J64IphNG1cLJh4fvJhXVDWsR5N/1KMDA3OXp7smt0RnriUXVS0ZDdBmTTNzUVUFb1UifPH4xWI1DjcRkKUjIxgjConZC6N/RAxC2greZjvIRBQk0SmIPA+9ycmzrL+pfkUwtcXAvAzZuzow7vg5XdX1cDQJNXA08PaVyzMLowFmeGFSDTM6E9ZoHdYkTg+rsEBxFVgJ0EoW47zXhLcU6YT5n8QxF4YYgucjfp6QSdHfCZECkSMCD0IAN7nggS8VzK7Vg9k3zOS35JLJLeFcYEsgunjjk7muyX8l9ZlL4ZwykKQDCsfonKbgTKMxFQCDBzBwUR4Ye2MUtUdEsWCwspDBIZ7sAjDgId7ejA0JVML7BTzcBEfxfnvV6hVzqjQwY/NqODmgKkxYnchrgcnLd84sTObDgfzCZFTV8qoOox2IhVF0laGVSgx4oBdUjfFqibL0eEWnE3JWkGTBaQtFXEGWx8Neyd9JiAIBHoKIIZ08z/qh7CsoZufexuKKgaZUAzsBgvmgtPAdnFUZyBKGAR8x0YG5z64fBSRa7ujcpXCYmYiGA7BmqzDgwFBs5ipxgodgLEjGeNuWiOCQC9ogQ9h7/EGv14ttSPDLTbwoEiLrByQ873Q54edKVtrZXRTM9sONCOYwgtnfXWLGTOuBiYk8o0b/klOj+vXPZs8sjIbzis5cmQyr+YBGM4CFplVOB1NVInwNL+GbWSsEcXt7hgDBuFhYheDjJ8cFvxdMBb6JtPEi6oV1+SOFlwQsu5JioPMUA7Ot8Q0A07h3J4ApNKgS5pg74fBAWFPhE8gnFzNfnplaGFUgUrTZS3ldi9KMRtPD/23nbGPaOO8A7jqxNTvZTG3FhtgQkaO5O2GQ0YEjen6p8RkwXpuAzaxEhJeaBEZ7xBWyVGBbIICTiTVADBYpRilyErpWCQofoiSIpCT7UimppoZ2idqhVtm0fpgqtWunSdOk/R+f3wIkZYs/ZOz5haDTA1/yy/N/uzs/MBrA2GTPz8RIIIhBlakShdSv0b0FSlpMoWHIKe2ROhlCrIbYIZWcmFIToMYY88LAxrGsIyZglT1OTCz3ygZkR/8bMdeOu2w8G+EdqDSd/+Ba9az5TDASrM6z3brvsrvstny0aewwMWXkfkwsx8R4YVss17RbYHQsFjp+gmFa1WanEZVoI+Hk1CRjhFhiGJRfoFwxFk1JwaFDBbvrJB3CQ/24mEvrixlBKQZiqT8hxjrSq9momHHe485z8Xy1wxV0nP3sim24ZQhMVdttwzcm7FvtbBDGhXy3fWumpuuEl8rCbZWVlds7SbWakkI11pE0Q4+ZaafZiGII9gllIRknSZAghmGgjhuNFlH2qSxO5TV45aJdypSYA+uKaYqlGNgnl5Jiut775QbF5I53O1joYmx2R76j++7b19nZz4fsQd5vs7tufWiHmdpWDQMl9DDwrToD5fr557cLCbjypUL0olmnUoweNtK0Ero7QzstNZsJqVQNSYZ2cjA40bRUrYPcDCWKgXKdreI4E/yRiApMIGbkArplaU179Jom5pKwYWCfpMT8dgNiTqCbmbnjHuhvbXm2apaNXv74T1M8iGH9riCsDn884d7qOM5DaeL9rIfNf/qRYD+akISKXdnTV4jEUDpSLUXdDGUgde0UYTarxWodhJaUJEw6MVQmikC1mtCRpEnUXLLr4OuHtEe0QiiNHBC9Y4X0uq6YA4q4mNGEGP1GxOy7ciX26QHHnjz4RyOWhj4Yd9hnYSSYsIVZV+j43d95wpCSQ6wNSrfb7Q5mQsxzcTE/azW/Bvm3wQDbQ0rE7tPRY68pDU4zhJZFBa2N1MmhnynFBCRhHWFUk2sbvNOoidOfXk9MIpLSxFhHNxBK+6a70QP+v0YiwYkJD+9h/V+f/+yty/7Zz8+w/uhiKOLnL99YiThCIb4aRqmrbhjAf/PlU4sRXnSAyrS/1dwCDU2DSWVRGdQGSynFqPoaeszmVtJQXEpRtE6sZsSQctGNPPhLkzpibVXyBbr0Mn3aM+mUmKO+uBj94F+SobT3B8XkvnF2z+yJ3B/dXlhcWFhw+UMLIce9t69NXj//YCgUWlwK86yfv/Xnq/ZqyMSsLej25LtcGdgxSTE/bzE727e90KdUUgaVhaIMlJnrVBI9DQ09UnSHBpKLsqezkTTSakKIJWKdztfqQ4lEcW6tmPJ4TUJb5ttEKPn6m35QzFvDeXnTb+Tenvg6yC8tRYNR//CNa5Ho3ff/KIv42bDjuI13Xf/i9y5XyOP2TMBICd1eRsQIU8H2Y40tZvP+5/pog6q42KAqVTHHxtob0UtCauhs0HNIk8nZyah1qJMBMYyR1K0W09tlHYjVnQtrxRz2DSTE6L+tE8TIfP3CjtH0PkHMH8rKusdzb08t3F+ILi0uLp458cm/zk5PT9+b8vv5UCi8cH9x6tPrEGIRmy3igPrttmVox8TE9LW0tpjbC49RBppWGYqlVMtLDWMkSYlVllhXQxAwVzIWKaxAP8MwTijahlU5pncwXpDXEfOOPilm4LuDon5h/4y+JwwLex8vZhz62byz+25PrPjZ+9FQ1H/+F+9PTkUi/NKKxw/Z2BUMR/ir98KOYNgTtNuhy8vAjarKnxaij20hOltbWxtbtu0n0Q0ZHUFbmMYGM0XqGAKCSErEOl3oeS0ktHZGxglDlNH5ODH6wcBqMUfbkl5k+puXRP1CF6wXxDStElP+am6SyTKg+8S+y3x0ccHjDy+Gxz69t+QPudjoytIKxE8wyAfZoQ/d7j12t6uszM2GbJ6nfWuTMgpvR0HW8NbX11fIKVqyu+hIUXaOJFvezGWXoDMxcrKLiqpyJLt3V0myYUVSIZdI5Fskki1VOzXri5HpZb96VMzJA8kMA9wcvBh4RMzqHSP6+/fvxvn+3Bziwrv/nJl5+HB+fn5m/uGprx4uL8/PAN98M7/81czM8hx8n5+bm5+Zm/sH/MqyVvTskC4GzASa0sX0K2TpYhQj56xP2jHplIs0msR/gAZ9lcfPnUmuxpY1GtEzyiNiwMxIU0JMrybQpn9EjN4nRNaA/uLhdXfMk9FscO1ZFCPT60+/HAicPPjjw3u7unzpgQRiwIiQhmV7RwP/uZj/HepeXCMG2hWFXt82+F2bz2odkK0Wk7hss/ounhQ1BTanGC1XWieqbxY1tSmsAgr0pQAmbyoU1sSqsGy13pxMXKIfDo72d70s6uA2oZgOjnvxiLjU66xJ8tGd+MXfamrupJbvfBRfq6l58CBtmcrivJsxlIrk6PxrTX2qShakTgrRVqR+sSp1kF9z6tNOmlrR5iZ1+py2QxuXpC2HZeFaq9XUxS/RWrkmsSxKLm9OXi+tTyRj4yu1JuEo2Zw367ktwjmcu0y1pl2GImEXcabaU6aYyR2cMmuHYecmFnPozcTrD1q5ifMKn18qyMqq1VXIhRzdzJXKY7lEU2KoVZm8saMX67JyYPnUJhZTxyWOUtTWb5FnCYG101DhLTHFDBTQVd5XTLHU0kFnZ0kqvLEAkqt+Ass7RP8XaDKxjMFgMBgMBoPBYDAYDAaDwWAwGAwGg8FgMBgMBoPBYDAYDAaDwWAwGAwGg8FgMBgMBoPBrObfd5cs9tjDucIAAAAASUVORK5CYII="> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_multiotsu.html#sphx-glr-auto-examples-segmentation-plot-multiotsu-py"><span class="std std-ref">Multi-Otsu Thresholding</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="In this example, we analyze a microscopy image of human cells. We use data provided by Jason Mo...">
<div class="figure align-default" id="id62"> <img alt="Segment human cells (in mitosis)" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/applications/plot_human_mitosis.html#sphx-glr-auto-examples-applications-plot-human-mitosis-py"><span class="std std-ref">Segment human cells (in mitosis)</span></a></span></p> </div> </div>   <h2 id="threshold-niblack">threshold_niblack</h2> <dl class="function"> <dt id="skimage.filters.threshold_niblack">
<code>skimage.filters.threshold_niblack(image, window_size=15, k=0.2)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/thresholding.py#L967-L1027"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Applies Niblack local threshold to an array.</p> <p>A threshold T is calculated for every pixel in the image using the following formula:</p> <pre data-language="python">T = m(x,y) - k * s(x,y)
</pre> <p>where m(x,y) and s(x,y) are the mean and standard deviation of pixel (x,y) neighborhood defined by a rectangular window with size w times w centered around the pixel. k is a configurable parameter that weights the effect of standard deviation.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>window_sizeint, or iterable of int, optional</code> </dt>
<dd>
<p>Window size specified as a single odd integer (3, 5, 7, …), or an iterable of length <code>image.ndim</code> containing only odd integers (e.g. <code>(1, 5, 5)</code>).</p> </dd> <dt>
<code>kfloat, optional</code> </dt>
<dd>
<p>Value of parameter k in threshold formula.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>threshold(N, M) ndarray</code> </dt>
<dd>
<p>Threshold mask. All pixels with an intensity higher than this value are assumed to be foreground.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This algorithm is originally designed for text recognition.</p> <p>The Bradley threshold is a particular case of the Niblack one, being equivalent to</p> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; image = data.page()
&gt;&gt;&gt; q = 1
&gt;&gt;&gt; threshold_image = threshold_niblack(image, k=0) * q
</pre> <p>for some value <code>q</code>. By default, Bradley and Roth use <code>q=1</code>.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="re9c5e7c193ed-1">
<code>1</code> </dt> <dd>
<p>W. Niblack, An introduction to Digital Image Processing, Prentice-Hall, 1986.</p> </dd> <dt class="label" id="re9c5e7c193ed-2">
<code>2</code> </dt> <dd>
<p>D. Bradley and G. Roth, “Adaptive thresholding using Integral Image”, Journal of Graphics Tools 12(2), pp. 13-21, 2007. <a class="reference external" href="https://doi.org/10.1080/2151237X.2007.10129236">DOI:10.1080/2151237X.2007.10129236</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; image = data.page()
&gt;&gt;&gt; threshold_image = threshold_niblack(image, window_size=7, k=0.1)
</pre> </dd>
</dl>   <h2 id="threshold-otsu">threshold_otsu</h2> <dl class="function"> <dt id="skimage.filters.threshold_otsu">
<code>skimage.filters.threshold_otsu(image=None, nbins=256, *, hist=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/thresholding.py#L282-L350"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return threshold value based on Otsu’s method.</p> <p>Either image or hist must be provided. If hist is provided, the actual histogram of the image is ignored.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(N, M) ndarray, optional</code> </dt>
<dd>
<p>Grayscale input image.</p> </dd> <dt>
<code>nbinsint, optional</code> </dt>
<dd>
<p>Number of bins used to calculate histogram. This value is ignored for integer arrays.</p> </dd> <dt>
<code>histarray, or 2-tuple of arrays, optional</code> </dt>
<dd>
<p>Histogram from which to determine the threshold, and optionally a corresponding array of bin center intensities. An alternative use of this function is to pass it only hist.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>thresholdfloat</code> </dt>
<dd>
<p>Upper threshold value. All pixels with an intensity higher than this value are assumed to be foreground.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The input image must be grayscale.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r1bb8cdf6ebea-1">
<code>1</code> </dt> <dd>
<p>Wikipedia, <a class="reference external" href="https://en.wikipedia.org/wiki/Otsu's_Method">https://en.wikipedia.org/wiki/Otsu’s_Method</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import camera
&gt;&gt;&gt; image = camera()
&gt;&gt;&gt; thresh = threshold_otsu(image)
&gt;&gt;&gt; binary = image &lt;= thresh
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-filters-threshold-otsu">Examples using <code>skimage.filters.threshold_otsu</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima...">
<div class="figure align-default" id="id63"> <img alt="Measure region properties" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="Rank filters are non-linear filters using local gray-level ordering to compute the filtered val...">
<div class="figure align-default" id="id64"> <img alt="Rank filters" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/applications/plot_rank_filters.html#sphx-glr-auto-examples-applications-plot-rank-filters-py"><span class="std std-ref">Rank filters</span></a></span></p> </div> </div>   <h2 id="threshold-sauvola">threshold_sauvola</h2> <dl class="function"> <dt id="skimage.filters.threshold_sauvola">
<code>skimage.filters.threshold_sauvola(image, window_size=15, k=0.2, r=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/thresholding.py#L1030-L1087"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Applies Sauvola local threshold to an array. Sauvola is a modification of Niblack technique.</p> <p>In the original method a threshold T is calculated for every pixel in the image using the following formula:</p> <pre data-language="python">T = m(x,y) * (1 + k * ((s(x,y) / R) - 1))
</pre> <p>where m(x,y) and s(x,y) are the mean and standard deviation of pixel (x,y) neighborhood defined by a rectangular window with size w times w centered around the pixel. k is a configurable parameter that weights the effect of standard deviation. R is the maximum standard deviation of a greyscale image.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>window_sizeint, or iterable of int, optional</code> </dt>
<dd>
<p>Window size specified as a single odd integer (3, 5, 7, …), or an iterable of length <code>image.ndim</code> containing only odd integers (e.g. <code>(1, 5, 5)</code>).</p> </dd> <dt>
<code>kfloat, optional</code> </dt>
<dd>
<p>Value of the positive parameter k.</p> </dd> <dt>
<code>rfloat, optional</code> </dt>
<dd>
<p>Value of R, the dynamic range of standard deviation. If None, set to the half of the image dtype range.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>threshold(N, M) ndarray</code> </dt>
<dd>
<p>Threshold mask. All pixels with an intensity higher than this value are assumed to be foreground.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This algorithm is originally designed for text recognition.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rea1071b48c0e-1">
<code>1</code> </dt> <dd>
<p>J. Sauvola and M. Pietikainen, “Adaptive document image binarization,” Pattern Recognition 33(2), pp. 225-236, 2000. <a class="reference external" href="https://doi.org/10.1016/S0031-3203(99)00055-2">DOI:10.1016/S0031-3203(99)00055-2</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; image = data.page()
&gt;&gt;&gt; t_sauvola = threshold_sauvola(image, window_size=15, k=0.2)
&gt;&gt;&gt; binary_image = image &gt; t_sauvola
</pre> </dd>
</dl>   <h2 id="threshold-triangle">threshold_triangle</h2> <dl class="function"> <dt id="skimage.filters.threshold_triangle">
<code>skimage.filters.threshold_triangle(image, nbins=256)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/thresholding.py#L833-L907"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return threshold value based on the triangle algorithm.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(N, M[, …, P]) ndarray</code> </dt>
<dd>
<p>Grayscale input image.</p> </dd> <dt>
<code>nbinsint, optional</code> </dt>
<dd>
<p>Number of bins used to calculate histogram. This value is ignored for integer arrays.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>thresholdfloat</code> </dt>
<dd>
<p>Upper threshold value. All pixels with an intensity higher than this value are assumed to be foreground.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rb6780315cbfc-1">
<code>1</code> </dt> <dd>
<p>Zack, G. W., Rogers, W. E. and Latt, S. A., 1977, Automatic Measurement of Sister Chromatid Exchange Frequency, Journal of Histochemistry and Cytochemistry 25 (7), pp. 741-753 <a class="reference external" href="https://doi.org/10.1177/25.7.70454">DOI:10.1177/25.7.70454</a></p> </dd> <dt class="label" id="rb6780315cbfc-2">
<code>2</code> </dt> <dd>
<p>ImageJ AutoThresholder code, <a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold">http://fiji.sc/wiki/index.php/Auto_Threshold</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import camera
&gt;&gt;&gt; image = camera()
&gt;&gt;&gt; thresh = threshold_triangle(image)
&gt;&gt;&gt; binary = image &gt; thresh
</pre> </dd>
</dl>   <h2 id="threshold-yen">threshold_yen</h2> <dl class="function"> <dt id="skimage.filters.threshold_yen">
<code>skimage.filters.threshold_yen(image=None, nbins=256, *, hist=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/thresholding.py#L353-L411"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return threshold value based on Yen’s method. Either image or hist must be provided. In case hist is given, the actual histogram of the image is ignored.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(N, M) ndarray, optional</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>nbinsint, optional</code> </dt>
<dd>
<p>Number of bins used to calculate histogram. This value is ignored for integer arrays.</p> </dd> <dt>
<code>histarray, or 2-tuple of arrays, optional</code> </dt>
<dd>
<p>Histogram from which to determine the threshold, and optionally a corresponding array of bin center intensities. An alternative use of this function is to pass it only hist.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>thresholdfloat</code> </dt>
<dd>
<p>Upper threshold value. All pixels with an intensity higher than this value are assumed to be foreground.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rc5144ffaa46d-1">
<code>1</code> </dt> <dd>
<p>Yen J.C., Chang F.J., and Chang S. (1995) “A New Criterion for Automatic Multilevel Thresholding” IEEE Trans. on Image Processing, 4(3): 370-378. <a class="reference external" href="https://doi.org/10.1109/83.366472">DOI:10.1109/83.366472</a></p> </dd> <dt class="label" id="rc5144ffaa46d-2">
<code>2</code> </dt> <dd>
<p>Sezgin M. and Sankur B. (2004) “Survey over Image Thresholding Techniques and Quantitative Performance Evaluation” Journal of Electronic Imaging, 13(1): 146-165, <a class="reference external" href="https://doi.org/10.1117/1.1631315">DOI:10.1117/1.1631315</a> <a class="reference external" href="http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf">http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf</a></p> </dd> <dt class="label" id="rc5144ffaa46d-3">
<code>3</code> </dt> <dd>
<p>ImageJ AutoThresholder code, <a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold">http://fiji.sc/wiki/index.php/Auto_Threshold</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import camera
&gt;&gt;&gt; image = camera()
&gt;&gt;&gt; thresh = threshold_yen(image)
&gt;&gt;&gt; binary = image &lt;= thresh
</pre> </dd>
</dl>   <h2 id="try-all-threshold">try_all_threshold</h2> <dl class="function"> <dt id="skimage.filters.try_all_threshold">
<code>skimage.filters.try_all_threshold(image, figsize=(8, 5), verbose=True)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/thresholding.py#L86-L142"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a figure comparing the outputs of different thresholding methods.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(N, M) ndarray</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>figsizetuple, optional</code> </dt>
<dd>
<p>Figure size (in inches).</p> </dd> <dt>
<code>verbosebool, optional</code> </dt>
<dd>
<p>Print function name for each method.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>fig, axtuple</code> </dt>
<dd>
<p>Matplotlib figure and axes.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The following algorithms are used:</p> <ul class="simple"> <li>isodata</li> <li>li</li> <li>mean</li> <li>minimum</li> <li>otsu</li> <li>triangle</li> <li>yen</li> </ul> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.data import text
&gt;&gt;&gt; fig, ax = try_all_threshold(text(), figsize=(10, 6), verbose=False)
</pre> </dd>
</dl>   <h2 id="unsharp-mask">unsharp_mask</h2> <dl class="function"> <dt id="skimage.filters.unsharp_mask">
<code>skimage.filters.unsharp_mask(image, radius=1.0, amount=1.0, multichannel=False, preserve_range=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/_unsharp_mask.py#L19-L135"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Unsharp masking filter.</p> <p>The sharp details are identified as the difference between the original image and its blurred version. These details are then scaled, and added back to the original image.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image[P, …, ]M[, N][, C] ndarray</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>radiusscalar or sequence of scalars, optional</code> </dt>
<dd>
<p>If a scalar is given, then its value is used for all dimensions. If sequence is given, then there must be exactly one radius for each dimension except the last dimension for multichannel images. Note that 0 radius means no blurring, and negative values are not allowed.</p> </dd> <dt>
<code>amountscalar, optional</code> </dt>
<dd>
<p>The details will be amplified with this factor. The factor could be 0 or negative. Typically, it is a small positive number, e.g. 1.0.</p> </dd> <dt>
<code>multichannelbool, optional</code> </dt>
<dd>
<p>If True, the last <code>image</code> dimension is considered as a color channel, otherwise as spatial. Color channels are processed individually.</p> </dd> <dt>
<code>preserve_rangebool, optional</code> </dt>
<dd>
<p>Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>. Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>output[P, …, ]M[, N][, C] ndarray of float</code> </dt>
<dd>
<p>Image with unsharp mask applied.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>Unsharp masking is an image sharpening technique. It is a linear image operation, and numerically stable, unlike deconvolution which is an ill-posed problem. Because of this stability, it is often preferred over deconvolution.</p> <p>The main idea is as follows: sharp details are identified as the difference between the original image and its blurred version. These details are added back to the original image after a scaling step:</p>  <p>enhanced image = original + amount * (original - blurred)</p>  <p>When applying this filter to several color layers independently, color bleeding may occur. More visually pleasing result can be achieved by processing only the brightness/lightness/intensity channel in a suitable color space such as HSV, HSL, YUV, or YCbCr.</p> <p>Unsharp masking is described in most introductory digital image processing books. This implementation is based on <a class="reference internal" href="#re30cac9066b6-1" id="id56">[1]</a>.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="re30cac9066b6-1">
<code>1</code> </dt> <dd>
<p>Maria Petrou, Costas Petrou “Image Processing: The Fundamentals”, (2010), ed ii., page 357, ISBN 13: 9781119994398 <a class="reference external" href="https://doi.org/10.1002/9781119994398">DOI:10.1002/9781119994398</a></p> </dd> <dt class="label" id="re30cac9066b6-2">
<code>2</code> </dt> <dd>
<p>Wikipedia. Unsharp masking <a class="reference external" href="https://en.wikipedia.org/wiki/Unsharp_masking">https://en.wikipedia.org/wiki/Unsharp_masking</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; array = np.ones(shape=(5,5), dtype=np.uint8)*100
&gt;&gt;&gt; array[2,2] = 120
&gt;&gt;&gt; array
array([[100, 100, 100, 100, 100],
       [100, 100, 100, 100, 100],
       [100, 100, 120, 100, 100],
       [100, 100, 100, 100, 100],
       [100, 100, 100, 100, 100]], dtype=uint8)
&gt;&gt;&gt; np.around(unsharp_mask(array, radius=0.5, amount=2),2)
array([[0.39, 0.39, 0.39, 0.39, 0.39],
       [0.39, 0.39, 0.38, 0.39, 0.39],
       [0.39, 0.38, 0.53, 0.38, 0.39],
       [0.39, 0.39, 0.38, 0.39, 0.39],
       [0.39, 0.39, 0.39, 0.39, 0.39]])
</pre> <pre data-language="python">&gt;&gt;&gt; array = np.ones(shape=(5,5), dtype=np.int8)*100
&gt;&gt;&gt; array[2,2] = 127
&gt;&gt;&gt; np.around(unsharp_mask(array, radius=0.5, amount=2),2)
array([[0.79, 0.79, 0.79, 0.79, 0.79],
       [0.79, 0.78, 0.75, 0.78, 0.79],
       [0.79, 0.75, 1.  , 0.75, 0.79],
       [0.79, 0.78, 0.75, 0.78, 0.79],
       [0.79, 0.79, 0.79, 0.79, 0.79]])
</pre> <pre data-language="python">&gt;&gt;&gt; np.around(unsharp_mask(array, radius=0.5, amount=2, preserve_range=True), 2)
array([[100.  , 100.  ,  99.99, 100.  , 100.  ],
       [100.  ,  99.39,  95.48,  99.39, 100.  ],
       [ 99.99,  95.48, 147.59,  95.48,  99.99],
       [100.  ,  99.39,  95.48,  99.39, 100.  ],
       [100.  , 100.  ,  99.99, 100.  , 100.  ]])
</pre> </dd>
</dl>   <h2 id="wiener">wiener</h2> <dl class="function"> <dt id="skimage.filters.wiener">
<code>skimage.filters.wiener(data, impulse_response=None, filter_params={}, K=0.25, predefined_filter=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/lpi_filter.py#L207-L246"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Minimum Mean Square Error (Wiener) inverse filter.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>data(M,N) ndarray</code> </dt>
<dd>
<p>Input data.</p> </dd> <dt>
<code>Kfloat or (M,N) ndarray</code> </dt>
<dd>
<p>Ratio between power spectrum of noise and undegraded image.</p> </dd> <dt>
<code>impulse_responsecallable f(r, c, **filter_params)</code> </dt>
<dd>
<p>Impulse response of the filter. See LPIFilter2D.__init__.</p> </dd> <dt>
<code>filter_paramsdict</code> </dt>
<dd>
<p>Additional keyword parameters to the impulse_response function.</p> </dd> </dl> </dd> <dt class="field-even">Other Parameters</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>predefined_filterLPIFilter2D</code> </dt>
<dd>
<p>If you need to apply the same filter multiple times over different images, construct the LPIFilter2D and specify it here.</p> </dd> </dl> </dd> </dl> </dd>
</dl>   <h2 id="window">window</h2> <dl class="function"> <dt id="skimage.filters.window">
<code>skimage.filters.window(window_type, shape, warp_kwargs=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/_window.py#L8-L129"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return an n-dimensional window of a given size and dimensionality.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>window_typestring, float, or tuple</code> </dt>
<dd>
<p>The type of window to be created. Any window type supported by <code>scipy.signal.get_window</code> is allowed here. See notes below for a current list, or the SciPy documentation for the version of SciPy on your machine.</p> </dd> <dt>
<code>shapetuple of int or int</code> </dt>
<dd>
<p>The shape of the window along each axis. If an integer is provided, a 1D window is generated.</p> </dd> <dt>
<code>warp_kwargsdict</code> </dt>
<dd>
<p>Keyword arguments passed to <a class="reference internal" href="skimage.transform#skimage.transform.warp" title="skimage.transform.warp"><code>skimage.transform.warp</code></a> (e.g., <code>warp_kwargs={'order':3}</code> to change interpolation method).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>nd_windowndarray</code> </dt>
<dd>
<p>A window of the specified <code>shape</code>. <code>dtype</code> is <code>np.double</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This function is based on <code>scipy.signal.get_window</code> and thus can access all of the window types available to that function (e.g., <code>"hann"</code>, <code>"boxcar"</code>). Note that certain window types require parameters that have to be supplied with the window name as a tuple (e.g., <code>("tukey", 0.8)</code>). If only a float is supplied, it is interpreted as the beta parameter of the Kaiser window.</p> <p>See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.windows.get_window.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.windows.get_window.html</a> for more details.</p> <p>Note that this function generates a double precision array of the specified <code>shape</code> and can thus generate very large arrays that consume a large amount of available memory.</p> <p>The approach taken here to create nD windows is to first calculate the Euclidean distance from the center of the intended nD window to each position in the array. That distance is used to sample, with interpolation, from a 1D window returned from <code>scipy.signal.get_window</code>. The method of interpolation can be changed with the <code>order</code> keyword argument passed to <a class="reference internal" href="skimage.transform#skimage.transform.warp" title="skimage.transform.warp"><code>skimage.transform.warp</code></a>.</p> <p>Some coordinates in the output window will be outside of the original signal; these will be filled in with zeros.</p> <p>Window types: - boxcar - triang - blackman - hamming - hann - bartlett - flattop - parzen - bohman - blackmanharris - nuttall - barthann - kaiser (needs beta) - gaussian (needs standard deviation) - general_gaussian (needs power, width) - slepian (needs width) - dpss (needs normalized half-bandwidth) - chebwin (needs attenuation) - exponential (needs decay scale) - tukey (needs taper fraction)</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="ra5de09d562a4-1">
<code>1</code> </dt> <dd>
<p>Two-dimensional window design, Wikipedia, <a class="reference external" href="https://en.wikipedia.org/wiki/Two_dimensional_window_design">https://en.wikipedia.org/wiki/Two_dimensional_window_design</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <p>Return a Hann window with shape (512, 512):</p> <pre data-language="python">&gt;&gt;&gt; from skimage.filters import window
&gt;&gt;&gt; w = window('hann', (512, 512))
</pre> <p>Return a Kaiser window with beta parameter of 16 and shape (256, 256, 35):</p> <pre data-language="python">&gt;&gt;&gt; w = window(16, (256, 256, 35))
</pre> <p>Return a Tukey window with an alpha parameter of 0.8 and shape (100, 300):</p> <pre data-language="python">&gt;&gt;&gt; w = window(('tukey', 0.8), (100, 300))
</pre> </dd>
</dl>   <h2 id="lpifilter2d">LPIFilter2D</h2> <dl class="class"> <dt id="skimage.filters.LPIFilter2D">
<code>class skimage.filters.LPIFilter2D(impulse_response, **filter_params)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/lpi_filter.py#L42-L127"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3.9/library/functions.html#object" title="(in Python v3.9)"><code>object</code></a></p> <p>Linear Position-Invariant Filter (2-dimensional)</p> <dl class="method"> <dt id="skimage.filters.LPIFilter2D.__init__">
<code>__init__(impulse_response, **filter_params)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/filters/lpi_filter.py#L47-L83"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>impulse_responsecallable f(r, c, **filter_params)</code> </dt>
<dd>
<p>Function that yields the impulse response. <code>r</code> and <code>c</code> are 1-dimensional vectors that represent row and column positions, in other words coordinates are (r[0],c[0]),(r[0],c[1]) etc. <code>**filter_params</code> are passed through.</p> <p>In other words, <code>impulse_response</code> would be called like this:</p> <pre data-language="python">&gt;&gt;&gt; def impulse_response(r, c, **filter_params):
...     pass
&gt;&gt;&gt;
&gt;&gt;&gt; r = [0,0,0,1,1,1,2,2,2]
&gt;&gt;&gt; c = [0,1,2,0,1,2,0,1,2]
&gt;&gt;&gt; filter_params = {'kw1': 1, 'kw2': 2, 'kw3': 3}
&gt;&gt;&gt; impulse_response(r, c, **filter_params)
</pre> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <p>Gaussian filter: Use a 1-D gaussian in each direction without normalization coefficients.</p> <pre data-language="python">&gt;&gt;&gt; def filt_func(r, c, sigma = 1):
...     return np.exp(-np.hypot(r, c)/sigma)
&gt;&gt;&gt; filter = LPIFilter2D(filt_func)
</pre> </dd>
</dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2019 the scikit-image team<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://scikit-image.org/docs/0.18.x/api/skimage.filters.html" class="_attribution-link">https://scikit-image.org/docs/0.18.x/api/skimage.filters.html</a>
  </p>
</div>
