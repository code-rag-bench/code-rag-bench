<h1 id="module-measure">Module: measure</h1> <table class="longtable docutils align-default" id="module-skimage.measure">   <tr>
<td><p><a class="reference internal" href="#skimage.measure.approximate_polygon" title="skimage.measure.approximate_polygon"><code>skimage.measure.approximate_polygon</code></a>(coords, …)</p></td> <td><p>Approximate a polygonal chain with the specified tolerance.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.block_reduce" title="skimage.measure.block_reduce"><code>skimage.measure.block_reduce</code></a>(image, block_size)</p></td> <td><p>Downsample image by applying function <code>func</code> to local blocks.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.euler_number" title="skimage.measure.euler_number"><code>skimage.measure.euler_number</code></a>(image[, …])</p></td> <td><p>Calculate the Euler characteristic in binary image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.find_contours" title="skimage.measure.find_contours"><code>skimage.measure.find_contours</code></a>(image[, …])</p></td> <td><p>Find iso-valued contours in a 2D array for a given level value.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.grid_points_in_poly" title="skimage.measure.grid_points_in_poly"><code>skimage.measure.grid_points_in_poly</code></a>(shape, verts)</p></td> <td><p>Test whether points on a specified grid are inside a polygon.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.inertia_tensor" title="skimage.measure.inertia_tensor"><code>skimage.measure.inertia_tensor</code></a>(image[, mu])</p></td> <td><p>Compute the inertia tensor of the input image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.inertia_tensor_eigvals" title="skimage.measure.inertia_tensor_eigvals"><code>skimage.measure.inertia_tensor_eigvals</code></a>(image)</p></td> <td><p>Compute the eigenvalues of the inertia tensor of the image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.label" title="skimage.measure.label"><code>skimage.measure.label</code></a>(input[, background, …])</p></td> <td><p>Label connected regions of an integer array.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code>skimage.measure.marching_cubes</code></a>(volume[, …])</p></td> <td><p>Marching cubes algorithm to find surfaces in 3d volumetric data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.marching_cubes_classic" title="skimage.measure.marching_cubes_classic"><code>skimage.measure.marching_cubes_classic</code></a>(volume)</p></td> <td><p>Classic marching cubes algorithm to find surfaces in 3d volumetric data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.marching_cubes_lewiner" title="skimage.measure.marching_cubes_lewiner"><code>skimage.measure.marching_cubes_lewiner</code></a>(volume)</p></td> <td><p>Lewiner marching cubes algorithm to find surfaces in 3d volumetric data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code>skimage.measure.mesh_surface_area</code></a>(verts, faces)</p></td> <td><p>Compute surface area, given vertices &amp; triangular faces</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.moments" title="skimage.measure.moments"><code>skimage.measure.moments</code></a>(image[, order])</p></td> <td><p>Calculate all raw image moments up to a certain order.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.moments_central" title="skimage.measure.moments_central"><code>skimage.measure.moments_central</code></a>(image[, …])</p></td> <td><p>Calculate all central image moments up to a certain order.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.moments_coords" title="skimage.measure.moments_coords"><code>skimage.measure.moments_coords</code></a>(coords[, order])</p></td> <td><p>Calculate all raw image moments up to a certain order.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.moments_coords_central" title="skimage.measure.moments_coords_central"><code>skimage.measure.moments_coords_central</code></a>(coords)</p></td> <td><p>Calculate all central image moments up to a certain order.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.moments_hu" title="skimage.measure.moments_hu"><code>skimage.measure.moments_hu</code></a>(nu)</p></td> <td><p>Calculate Hu’s set of image moments (2D-only).</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.moments_normalized" title="skimage.measure.moments_normalized"><code>skimage.measure.moments_normalized</code></a>(mu[, order])</p></td> <td><p>Calculate all normalized central image moments up to a certain order.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.perimeter" title="skimage.measure.perimeter"><code>skimage.measure.perimeter</code></a>(image[, neighbourhood])</p></td> <td><p>Calculate total perimeter of all objects in binary image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.perimeter_crofton" title="skimage.measure.perimeter_crofton"><code>skimage.measure.perimeter_crofton</code></a>(image[, …])</p></td> <td><p>Calculate total Crofton perimeter of all objects in binary image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.points_in_poly" title="skimage.measure.points_in_poly"><code>skimage.measure.points_in_poly</code></a>(points, verts)</p></td> <td><p>Test whether points lie inside a polygon.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.profile_line" title="skimage.measure.profile_line"><code>skimage.measure.profile_line</code></a>(image, src, dst)</p></td> <td><p>Return the intensity profile of an image measured along a scan line.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.ransac" title="skimage.measure.ransac"><code>skimage.measure.ransac</code></a>(data, model_class, …)</p></td> <td><p>Fit a model to data with the RANSAC (random sample consensus) algorithm.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.regionprops" title="skimage.measure.regionprops"><code>skimage.measure.regionprops</code></a>(label_image[, …])</p></td> <td><p>Measure properties of labeled image regions.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.regionprops_table" title="skimage.measure.regionprops_table"><code>skimage.measure.regionprops_table</code></a>(label_image)</p></td> <td><p>Compute image properties and return them as a pandas-compatible table.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.shannon_entropy" title="skimage.measure.shannon_entropy"><code>skimage.measure.shannon_entropy</code></a>(image[, base])</p></td> <td><p>Calculate the Shannon entropy of an image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.subdivide_polygon" title="skimage.measure.subdivide_polygon"><code>skimage.measure.subdivide_polygon</code></a>(coords[, …])</p></td> <td><p>Subdivision of polygonal curves using B-Splines.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.CircleModel" title="skimage.measure.CircleModel"><code>skimage.measure.CircleModel</code></a>()</p></td> <td><p>Total least squares estimator for 2D circles.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.EllipseModel" title="skimage.measure.EllipseModel"><code>skimage.measure.EllipseModel</code></a>()</p></td> <td><p>Total least squares estimator for 2D ellipses.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.measure.LineModelND" title="skimage.measure.LineModelND"><code>skimage.measure.LineModelND</code></a>()</p></td> <td><p>Total least squares estimator for N-dimensional lines.</p></td> </tr>  </table>  <h2 id="approximate-polygon">approximate_polygon</h2> <dl class="function"> <dt id="skimage.measure.approximate_polygon">
<code>skimage.measure.approximate_polygon(coords, tolerance)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_polygon.py#L5-L92"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Approximate a polygonal chain with the specified tolerance.</p> <p>It is based on the Douglas-Peucker algorithm.</p> <p>Note that the approximated polygon is always within the convex hull of the original polygon.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>coords(N, 2) array</code> </dt>
<dd>
<p>Coordinate array.</p> </dd> <dt>
<code>tolerancefloat</code> </dt>
<dd>
<p>Maximum distance from original points of polygon to approximated polygonal chain. If tolerance is 0, the original coordinate array is returned.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>coords(M, 2) array</code> </dt>
<dd>
<p>Approximated polygonal chain where M &lt;= N.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rb46d085928c9-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm">https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm</a></p> </dd> </dl> </dd>
</dl>   <h2 id="block-reduce">block_reduce</h2> <dl class="function"> <dt id="skimage.measure.block_reduce">
<code>skimage.measure.block_reduce(image, block_size, func=&lt;function sum&gt;, cval=0, func_kwargs=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/block.py#L5-L87"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Downsample image by applying function <code>func</code> to local blocks.</p> <p>This function is useful for max and mean pooling, for example.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>N-dimensional input image.</p> </dd> <dt>
<code>block_sizearray_like</code> </dt>
<dd>
<p>Array containing down-sampling integer factor along each axis.</p> </dd> <dt>
<code>funccallable</code> </dt>
<dd>
<p>Function object which is used to calculate the return value for each local block. This function must implement an <code>axis</code> parameter. Primary functions are <code>numpy.sum</code>, <code>numpy.min</code>, <code>numpy.max</code>, <code>numpy.mean</code> and <code>numpy.median</code>. See also <code>func_kwargs</code>.</p> </dd> <dt>
<code>cvalfloat</code> </dt>
<dd>
<p>Constant padding value if image is not perfectly divisible by the block size.</p> </dd> <dt>
<code>func_kwargsdict</code> </dt>
<dd>
<p>Keyword arguments passed to <code>func</code>. Notably useful for passing dtype argument to <code>np.mean</code>. Takes dictionary of inputs, e.g.: <code>func_kwargs={'dtype': np.float16})</code>.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Down-sampled image with same number of dimensions as input image.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.measure import block_reduce
&gt;&gt;&gt; image = np.arange(3*3*4).reshape(3, 3, 4)
&gt;&gt;&gt; image 
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],
       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]],
       [[24, 25, 26, 27],
        [28, 29, 30, 31],
        [32, 33, 34, 35]]])
&gt;&gt;&gt; block_reduce(image, block_size=(3, 3, 1), func=np.mean)
array([[[16., 17., 18., 19.]]])
&gt;&gt;&gt; image_max1 = block_reduce(image, block_size=(1, 3, 4), func=np.max)
&gt;&gt;&gt; image_max1 
array([[[11]],
       [[23]],
       [[35]]])
&gt;&gt;&gt; image_max2 = block_reduce(image, block_size=(3, 1, 4), func=np.max)
&gt;&gt;&gt; image_max2 
array([[[27],
        [31],
        [35]]])
</pre> </dd>
</dl>   <h2 id="euler-number">euler_number</h2> <dl class="function"> <dt id="skimage.measure.euler_number">
<code>skimage.measure.euler_number(image, connectivity=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_regionprops_utils.py#L58-L183"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculate the Euler characteristic in binary image.</p> <p>For 2D objects, the Euler number is the number of objects minus the number of holes. For 3D objects, the Euler number is obtained as the number of objects plus the number of holes, minus the number of tunnels, or loops.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt><strong>image: (N, M) ndarray or (N, M, D) ndarray.</strong></dt>
<dd>
<p>2D or 3D images. If image is not binary, all values strictly greater than zero are considered as the object.</p> </dd> <dt>
<code>connectivityint, optional</code> </dt>
<dd>
<p>Maximum number of orthogonal hops to consider a pixel/voxel as a neighbor. Accepted values are ranging from 1 to input.ndim. If <code>None</code>, a full connectivity of <code>input.ndim</code> is used. 4 or 8 neighborhoods are defined for 2D images (connectivity 1 and 2, respectively). 6 or 26 neighborhoods are defined for 3D images, (connectivity 1 and 3, respectively). Connectivity 2 is not defined.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>euler_numberint</code> </dt>
<dd>
<p>Euler characteristic of the set of all objects in the image.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The Euler characteristic is an integer number that describes the topology of the set of all objects in the input image. If object is 4-connected, then background is 8-connected, and conversely.</p> <p>The computation of the Euler characteristic is based on an integral geometry formula in discretized space. In practice, a neighbourhood configuration is constructed, and a LUT is applied for each configuration. The coefficients used are the ones of Ohser et al.</p> <p>It can be useful to compute the Euler characteristic for several connectivities. A large relative difference between results for different connectivities suggests that the image resolution (with respect to the size of objects and holes) is too low.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r0d660f9fa30f-1">
<code>1</code> </dt> <dd>
<p>S. Rivollier. Analyse d’image geometrique et morphometrique par diagrammes de forme et voisinages adaptatifs generaux. PhD thesis, 2010. Ecole Nationale Superieure des Mines de Saint-Etienne. <a class="reference external" href="https://tel.archives-ouvertes.fr/tel-00560838">https://tel.archives-ouvertes.fr/tel-00560838</a></p> </dd> <dt class="label" id="r0d660f9fa30f-2">
<code>2</code> </dt> <dd>
<p>Ohser J., Nagel W., Schladitz K. (2002) The Euler Number of Discretized Sets - On the Choice of Adjacency in Homogeneous Lattices. In: Mecke K., Stoyan D. (eds) Morphology of Condensed Matter. Lecture Notes in Physics, vol 600. Springer, Berlin, Heidelberg.</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; SAMPLE = np.zeros((100,100,100));
&gt;&gt;&gt; SAMPLE[40:60, 40:60, 40:60]=1
&gt;&gt;&gt; euler_number(SAMPLE) 
1...
&gt;&gt;&gt; SAMPLE[45:55,45:55,45:55] = 0;
&gt;&gt;&gt; euler_number(SAMPLE) 
2...
&gt;&gt;&gt; SAMPLE = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0],
...                    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
...                    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
...                    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
...                    [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
...                    [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
...                    [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
...                    [1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0],
...                    [0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1],
...                    [0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]])
&gt;&gt;&gt; euler_number(SAMPLE)  # doctest:
0
&gt;&gt;&gt; euler_number(SAMPLE, connectivity=1)  # doctest:
2
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-measure-euler-number">Examples using <code>skimage.measure.euler_number</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="This example shows an illustration of the computation of the Euler number [1]_ in 2D and 3D obj...">
<div class="figure align-default" id="id52"> <img alt="Euler number" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_euler_number.html#sphx-glr-auto-examples-segmentation-plot-euler-number-py"><span class="std std-ref">Euler number</span></a></span></p> </div> </div>   <h2 id="find-contours">find_contours</h2> <dl class="function"> <dt id="skimage.measure.find_contours">
<code>skimage.measure.find_contours(image, level=None, fully_connected='low', positive_orientation='low', *, mask=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_find_contours.py#L11-L154"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find iso-valued contours in a 2D array for a given level value.</p> <p>Uses the “marching squares” method to compute a the iso-valued contours of the input 2D array for a particular level value. Array values are linearly interpolated to provide better precision for the output contours.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>image2D ndarray of double</code> </dt>
<dd>
<p>Input image in which to find contours.</p> </dd> <dt>
<code>levelfloat, optional</code> </dt>
<dd>
<p>Value along which to find contours in the array. By default, the level is set to (max(image) + min(image)) / 2</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.18: </span>This parameter is now optional.</p> </div> </dd> <dt>
<code>fully_connectedstr, {‘low’, ‘high’}</code> </dt>
<dd>
<p>Indicates whether array elements below the given level value are to be considered fully-connected (and hence elements above the value will only be face connected), or vice-versa. (See notes below for details.)</p> </dd> <dt>
<code>positive_orientationstr, {‘low’, ‘high’}</code> </dt>
<dd>
<p>Indicates whether the output contours will produce positively-oriented polygons around islands of low- or high-valued elements. If ‘low’ then contours will wind counter- clockwise around elements below the iso-value. Alternately, this means that low-valued elements are always on the left of the contour. (See below for details.)</p> </dd> <dt>
<code>mask2D ndarray of bool, or None</code> </dt>
<dd>
<p>A boolean mask, True where we want to draw contours. Note that NaN values are always excluded from the considered region (<code>mask</code> is set to <code>False</code> wherever <code>array</code> is <code>NaN</code>).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>contourslist of (n,2)-ndarrays</code> </dt>
<dd>
<p>Each contour is an ndarray of shape <code>(n, 2)</code>, consisting of n <code>(row, column)</code> coordinates along the contour.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code>skimage.measure.marching_cubes</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>The marching squares algorithm is a special case of the marching cubes algorithm <a class="reference internal" href="#r8ed60f468bf9-1" id="id4">[1]</a>. A simple explanation is available here:</p> <p><a class="reference external" href="http://users.polytech.unice.fr/~lingrand/MarchingCubes/algo.html">http://users.polytech.unice.fr/~lingrand/MarchingCubes/algo.html</a></p> <p>There is a single ambiguous case in the marching squares algorithm: when a given <code>2 x 2</code>-element square has two high-valued and two low-valued elements, each pair diagonally adjacent. (Where high- and low-valued is with respect to the contour value sought.) In this case, either the high-valued elements can be ‘connected together’ via a thin isthmus that separates the low-valued elements, or vice-versa. When elements are connected together across a diagonal, they are considered ‘fully connected’ (also known as ‘face+vertex-connected’ or ‘8-connected’). Only high-valued or low-valued elements can be fully-connected, the other set will be considered as ‘face-connected’ or ‘4-connected’. By default, low-valued elements are considered fully-connected; this can be altered with the ‘fully_connected’ parameter.</p> <p>Output contours are not guaranteed to be closed: contours which intersect the array edge or a masked-off region (either where mask is False or where array is NaN) will be left open. All other contours will be closed. (The closed-ness of a contours can be tested by checking whether the beginning point is the same as the end point.)</p> <p>Contours are oriented. By default, array values lower than the contour value are to the left of the contour and values greater than the contour value are to the right. This means that contours will wind counter-clockwise (i.e. in ‘positive orientation’) around islands of low-valued pixels. This behavior can be altered with the ‘positive_orientation’ parameter.</p> <p>The order of the contours in the output list is determined by the position of the smallest <code>x,y</code> (in lexicographical order) coordinate in the contour. This is a side-effect of how the input array is traversed, but can be relied upon.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Array coordinates/values are assumed to refer to the <em>center</em> of the array element. Take a simple example input: <code>[0, 1]</code>. The interpolated position of 0.5 in this array is midway between the 0-element (at <code>x=0</code>) and the 1-element (at <code>x=1</code>), and thus would fall at <code>x=0.5</code>.</p> </div> <p>This means that to find reasonable contours, it is best to find contours midway between the expected “light” and “dark” values. In particular, given a binarized array, <em>do not</em> choose to find contours at the low or high value of the array. This will often yield degenerate contours, especially around structures that are a single array element wide. Instead choose a middle value, as above.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r8ed60f468bf9-1">
<code>1</code> </dt> <dd>
<p>Lorensen, William and Harvey E. Cline. Marching Cubes: A High Resolution 3D Surface Construction Algorithm. Computer Graphics (SIGGRAPH 87 Proceedings) 21(4) July 1987, p. 163-170). <a class="reference external" href="https://doi.org/10.1145/37401.37422">DOI:10.1145/37401.37422</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; a = np.zeros((3, 3))
&gt;&gt;&gt; a[0, 0] = 1
&gt;&gt;&gt; a
array([[1., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.]])
&gt;&gt;&gt; find_contours(a, 0.5)
[array([[0. , 0.5],
       [0.5, 0. ]])]
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-measure-find-contours">Examples using <code>skimage.measure.find_contours</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="We use a marching squares method to find constant valued contours in an image. In skimage.measu...">
<div class="figure align-default" id="id53"> <img alt="Contour finding" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/edges/plot_contours.html#sphx-glr-auto-examples-edges-plot-contours-py"><span class="std std-ref">Contour finding</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima...">
<div class="figure align-default" id="id54"> <img alt="Measure region properties" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></span></p> </div> </div>   <h2 id="grid-points-in-poly">grid_points_in_poly</h2> <dl class="function"> <dt id="skimage.measure.grid_points_in_poly">
<code>skimage.measure.grid_points_in_poly(shape, verts)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/pnpoly.py#L4-L29"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Test whether points on a specified grid are inside a polygon.</p> <p>For each <code>(r, c)</code> coordinate on a grid, i.e. <code>(0, 0)</code>, <code>(0, 1)</code> etc., test whether that point lies inside a polygon.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>shapetuple (M, N)</code> </dt>
<dd>
<p>Shape of the grid.</p> </dd> <dt>
<code>verts(V, 2) array</code> </dt>
<dd>
<p>Specify the V vertices of the polygon, sorted either clockwise or anti-clockwise. The first point may (but does not need to be) duplicated.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>mask(M, N) ndarray of bool</code> </dt>
<dd>
<p>True where the grid falls inside the polygon.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.measure.points_in_poly" title="skimage.measure.points_in_poly"><code>points_in_poly</code></a>
</dt>
 </dl> </div> </dd>
</dl>   <h2 id="inertia-tensor">inertia_tensor</h2> <dl class="function"> <dt id="skimage.measure.inertia_tensor">
<code>skimage.measure.inertia_tensor(image, mu=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_moments.py#L379-L428"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the inertia tensor of the input image.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagearray</code> </dt>
<dd>
<p>The input image.</p> </dd> <dt>
<code>muarray, optional</code> </dt>
<dd>
<p>The pre-computed central moments of <code>image</code>. The inertia tensor computation requires the central moments of the image. If an application requires both the central moments and the inertia tensor (for example, <a class="reference internal" href="#skimage.measure.regionprops" title="skimage.measure.regionprops"><code>skimage.measure.regionprops</code></a>), then it is more efficient to pre-compute them and pass them to the inertia tensor call.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>Tarray, shape (image.ndim, image.ndim)</code> </dt>
<dd>
<p>The inertia tensor of the input image. <span class="math notranslate nohighlight">\(T_{i, j}\)</span> contains the covariance of image intensity along axes <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rfbef8c192cf5-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Moment_of_inertia#Inertia_tensor">https://en.wikipedia.org/wiki/Moment_of_inertia#Inertia_tensor</a></p> </dd> <dt class="label" id="rfbef8c192cf5-2">
<code>2</code> </dt> <dd>
<p>Bernd Jähne. Spatio-Temporal Image Processing: Theory and Scientific Applications. (Chapter 8: Tensor Methods) Springer, 1993.</p> </dd> </dl> </dd>
</dl>   <h2 id="inertia-tensor-eigvals">inertia_tensor_eigvals</h2> <dl class="function"> <dt id="skimage.measure.inertia_tensor_eigvals">
<code>skimage.measure.inertia_tensor_eigvals(image, mu=None, T=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_moments.py#L431-L469"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the eigenvalues of the inertia tensor of the image.</p> <p>The inertia tensor measures covariance of the image intensity along the image axes. (See <a class="reference internal" href="#skimage.measure.inertia_tensor" title="skimage.measure.inertia_tensor"><code>inertia_tensor</code></a>.) The relative magnitude of the eigenvalues of the tensor is thus a measure of the elongation of a (bright) object in the image.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>imagearray</code> </dt>
<dd>
<p>The input image.</p> </dd> <dt>
<code>muarray, optional</code> </dt>
<dd>
<p>The pre-computed central moments of <code>image</code>.</p> </dd> <dt>
<code>Tarray, shape (image.ndim, image.ndim)</code> </dt>
<dd>
<p>The pre-computed inertia tensor. If <code>T</code> is given, <code>mu</code> and <code>image</code> are ignored.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>eigvalslist of float, length image.ndim</code> </dt>
<dd>
<p>The eigenvalues of the inertia tensor of <code>image</code>, in descending order.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>Computing the eigenvalues requires the inertia tensor of the input image. This is much faster if the central moments (<code>mu</code>) are provided, or, alternatively, one can provide the inertia tensor (<code>T</code>) directly.</p> </dd>
</dl>   <h2 id="label">label</h2> <dl class="function"> <dt id="skimage.measure.label">
<code>skimage.measure.label(input, background=None, return_num=False, connectivity=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_label.py#L32-L120"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Label connected regions of an integer array.</p> <p>Two pixels are connected when they are neighbors and have the same value. In 2D, they can be neighbors either in a 1- or 2-connected sense. The value refers to the maximum number of orthogonal hops to consider a pixel/voxel a neighbor:</p> <pre data-language="python">1-connectivity     2-connectivity     diagonal connection close-up

     [ ]           [ ]  [ ]  [ ]             [ ]
      |               \  |  /                 |  &lt;- hop 2
[ ]--[x]--[ ]      [ ]--[x]--[ ]        [x]--[ ]
      |               /  |  \             hop 1
     [ ]           [ ]  [ ]  [ ]
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>inputndarray of dtype int</code> </dt>
<dd>
<p>Image to label.</p> </dd> <dt>
<code>backgroundint, optional</code> </dt>
<dd>
<p>Consider all pixels with this value as background pixels, and label them as 0. By default, 0-valued pixels are considered as background pixels.</p> </dd> <dt>
<code>return_numbool, optional</code> </dt>
<dd>
<p>Whether to return the number of assigned labels.</p> </dd> <dt>
<code>connectivityint, optional</code> </dt>
<dd>
<p>Maximum number of orthogonal hops to consider a pixel/voxel as a neighbor. Accepted values are ranging from 1 to input.ndim. If <code>None</code>, a full connectivity of <code>input.ndim</code> is used.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>labelsndarray of dtype int</code> </dt>
<dd>
<p>Labeled array, where all connected regions are assigned the same integer value.</p> </dd> <dt>
<code>numint, optional</code> </dt>
<dd>
<p>Number of labels, which equals the maximum label index and is only returned if return_num is <code>True</code>.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.measure.regionprops" title="skimage.measure.regionprops"><code>regionprops</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.measure.regionprops_table" title="skimage.measure.regionprops_table"><code>regionprops_table</code></a>
</dt>
 </dl> </div> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r4c017a27ed0c-1">
<code>1</code> </dt> <dd>
<p>Christophe Fiorio and Jens Gustedt, “Two linear time Union-Find strategies for image processing”, Theoretical Computer Science 154 (1996), pp. 165-181.</p> </dd> <dt class="label" id="r4c017a27ed0c-2">
<code>2</code> </dt> <dd>
<p>Kensheng Wu, Ekow Otoo and Arie Shoshani, “Optimizing connected component labeling algorithms”, Paper LBNL-56864, 2005, Lawrence Berkeley National Laboratory (University of California), <a class="reference external" href="http://repositories.cdlib.org/lbnl/LBNL-56864">http://repositories.cdlib.org/lbnl/LBNL-56864</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; x = np.eye(3).astype(int)
&gt;&gt;&gt; print(x)
[[1 0 0]
 [0 1 0]
 [0 0 1]]
&gt;&gt;&gt; print(label(x, connectivity=1))
[[1 0 0]
 [0 2 0]
 [0 0 3]]
&gt;&gt;&gt; print(label(x, connectivity=2))
[[1 0 0]
 [0 1 0]
 [0 0 1]]
&gt;&gt;&gt; print(label(x, background=-1))
[[1 2 2]
 [2 1 2]
 [2 2 1]]
&gt;&gt;&gt; x = np.array([[1, 0, 0],
...               [1, 1, 5],
...               [0, 0, 0]])
&gt;&gt;&gt; print(label(x))
[[1 0 0]
 [1 1 2]
 [0 0 0]]
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-measure-label">Examples using <code>skimage.measure.label</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima...">
<div class="figure align-default" id="id55"> <img alt="Measure region properties" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows an illustration of the computation of the Euler number [1]_ in 2D and 3D obj...">
<div class="figure align-default" id="id56"> <img alt="Euler number" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_euler_number.html#sphx-glr-auto-examples-segmentation-plot-euler-number-py"><span class="std std-ref">Euler number</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="In this example, we analyze a microscopy image of human cells. We use data provided by Jason Mo...">
<div class="figure align-default" id="id57"> <img alt="Segment human cells (in mitosis)" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/applications/plot_human_mitosis.html#sphx-glr-auto-examples-applications-plot-human-mitosis-py"><span class="std std-ref">Segment human cells (in mitosis)</span></a></span></p> </div> </div>   <h2 id="marching-cubes">marching_cubes</h2> <dl class="function"> <dt id="skimage.measure.marching_cubes">
<code>skimage.measure.marching_cubes(volume, level=None, *, spacing=(1.0, 1.0, 1.0), gradient_direction='descent', step_size=1, allow_degenerate=True, method='lewiner', mask=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_marching_cubes_lewiner.py#L11-L153"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Marching cubes algorithm to find surfaces in 3d volumetric data.</p> <p>In contrast with Lorensen et al. approach <a class="reference internal" href="#rcddcc8f5d58b-2" id="id10">[2]</a>, Lewiner et al. algorithm is faster, resolves ambiguities, and guarantees topologically correct results. Therefore, this algorithm generally a better choice.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>volume(M, N, P) array</code> </dt>
<dd>
<p>Input data volume to find isosurfaces. Will internally be converted to float32 if necessary.</p> </dd> <dt>
<code>levelfloat, optional</code> </dt>
<dd>
<p>Contour value to search for isosurfaces in <code>volume</code>. If not given or None, the average of the min and max of vol is used.</p> </dd> <dt>
<code>spacinglength-3 tuple of floats, optional</code> </dt>
<dd>
<p>Voxel spacing in spatial dimensions corresponding to numpy array indexing dimensions (M, N, P) as in <code>volume</code>.</p> </dd> <dt>
<code>gradient_directionstring, optional</code> </dt>
<dd>
<p>Controls if the mesh was generated from an isosurface with gradient descent toward objects of interest (the default), or the opposite, considering the <em>left-hand</em> rule. The two options are: * descent : Object was greater than exterior * ascent : Exterior was greater than object</p> </dd> <dt>
<code>step_sizeint, optional</code> </dt>
<dd>
<p>Step size in voxels. Default 1. Larger steps yield faster but coarser results. The result will always be topologically correct though.</p> </dd> <dt>
<code>allow_degeneratebool, optional</code> </dt>
<dd>
<p>Whether to allow degenerate (i.e. zero-area) triangles in the end-result. Default True. If False, degenerate triangles are removed, at the cost of making the algorithm slower.</p> </dd> <dt><strong>method: str, optional</strong></dt>
<dd>
<p>One of ‘lewiner’, ‘lorensen’ or ‘_lorensen’. Specify witch of Lewiner et al. or Lorensen et al. method will be used. The ‘_lorensen’ flag correspond to an old implementation that will be deprecated in version 0.19.</p> </dd> <dt>
<code>mask(M, N, P) array, optional</code> </dt>
<dd>
<p>Boolean array. The marching cube algorithm will be computed only on True elements. This will save computational time when interfaces are located within certain region of the volume M, N, P-e.g. the top half of the cube-and also allow to compute finite surfaces-i.e. open surfaces that do not end at the border of the cube.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>verts(V, 3) array</code> </dt>
<dd>
<p>Spatial coordinates for V unique mesh vertices. Coordinate order matches input <code>volume</code> (M, N, P). If <code>allow_degenerate</code> is set to True, then the presence of degenerate triangles in the mesh can make this array have duplicate vertices.</p> </dd> <dt>
<code>faces(F, 3) array</code> </dt>
<dd>
<p>Define triangular faces via referencing vertex indices from <code>verts</code>. This algorithm specifically outputs triangles, so each face has exactly three indices.</p> </dd> <dt>
<code>normals(V, 3) array</code> </dt>
<dd>
<p>The normal direction at each vertex, as calculated from the data.</p> </dd> <dt>
<code>values(V, ) array</code> </dt>
<dd>
<p>Gives a measure for the maximum value of the data in the local region near each vertex. This can be used by visualization tools to apply a colormap to the mesh.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code>skimage.measure.mesh_surface_area</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.measure.find_contours" title="skimage.measure.find_contours"><code>skimage.measure.find_contours</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>The algorithm <a class="reference internal" href="#rcddcc8f5d58b-1" id="id11">[1]</a> is an improved version of Chernyaev’s Marching Cubes 33 algorithm. It is an efficient algorithm that relies on heavy use of lookup tables to handle the many different cases, keeping the algorithm relatively easy. This implementation is written in Cython, ported from Lewiner’s C++ implementation.</p> <p>To quantify the area of an isosurface generated by this algorithm, pass verts and faces to <a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code>skimage.measure.mesh_surface_area</code></a>.</p> <p>Regarding visualization of algorithm output, to contour a volume named <code>myvolume</code> about the level 0.0, using the <code>mayavi</code> package:</p> <pre data-language="python">&gt;&gt;&gt;
&gt;&gt; from mayavi import mlab
&gt;&gt; verts, faces, _, _ = marching_cubes(myvolume, 0.0)
&gt;&gt; mlab.triangular_mesh([vert[0] for vert in verts],
                        [vert[1] for vert in verts],
                        [vert[2] for vert in verts],
                        faces)
&gt;&gt; mlab.show()
</pre> <p>Similarly using the <code>visvis</code> package:</p> <pre data-language="python">&gt;&gt;&gt;
&gt;&gt; import visvis as vv
&gt;&gt; verts, faces, normals, values = marching_cubes(myvolume, 0.0)
&gt;&gt; vv.mesh(np.fliplr(verts), faces, normals, values)
&gt;&gt; vv.use().Run()
</pre> <p>To reduce the number of triangles in the mesh for better performance, see this <a class="reference external" href="https://docs.enthought.com/mayavi/mayavi/auto/example_julia_set_decimation.html#example-julia-set-decimation">example</a> using the <code>mayavi</code> package.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rcddcc8f5d58b-1">
<code>1</code> </dt> <dd>
<p>Thomas Lewiner, Helio Lopes, Antonio Wilson Vieira and Geovan Tavares. Efficient implementation of Marching Cubes’ cases with topological guarantees. Journal of Graphics Tools 8(2) pp. 1-15 (december 2003). <a class="reference external" href="https://doi.org/10.1080/10867651.2003.10487582">DOI:10.1080/10867651.2003.10487582</a></p> </dd> <dt class="label" id="rcddcc8f5d58b-2">
<code>2</code> </dt> <dd>
<p>Lorensen, William and Harvey E. Cline. Marching Cubes: A High Resolution 3D Surface Construction Algorithm. Computer Graphics (SIGGRAPH 87 Proceedings) 21(4) July 1987, p. 163-170). <a class="reference external" href="https://doi.org/10.1145/37401.37422">DOI:10.1145/37401.37422</a></p> </dd> </dl> </dd>
</dl>   <h2 id="marching-cubes-classic">marching_cubes_classic</h2> <dl class="function"> <dt id="skimage.measure.marching_cubes_classic">
<code>skimage.measure.marching_cubes_classic(volume, level=None, spacing=(1.0, 1.0, 1.0), gradient_direction='descent')</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_marching_cubes_classic.py#L7-L111"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Classic marching cubes algorithm to find surfaces in 3d volumetric data.</p> <p>Note that the <code>marching_cubes()</code> algorithm is recommended over this algorithm, because it’s faster and produces better results.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>volume(M, N, P) array of doubles</code> </dt>
<dd>
<p>Input data volume to find isosurfaces. Will be cast to <code>np.float64</code>.</p> </dd> <dt>
<code>levelfloat</code> </dt>
<dd>
<p>Contour value to search for isosurfaces in <code>volume</code>. If not given or None, the average of the min and max of vol is used.</p> </dd> <dt>
<code>spacinglength-3 tuple of floats</code> </dt>
<dd>
<p>Voxel spacing in spatial dimensions corresponding to numpy array indexing dimensions (M, N, P) as in <code>volume</code>.</p> </dd> <dt>
<code>gradient_directionstring</code> </dt>
<dd>
<p>Controls if the mesh was generated from an isosurface with gradient descent toward objects of interest (the default), or the opposite. The two options are: * descent : Object was greater than exterior * ascent : Exterior was greater than object</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>verts(V, 3) array</code> </dt>
<dd>
<p>Spatial coordinates for V unique mesh vertices. Coordinate order matches input <code>volume</code> (M, N, P). If <code>allow_degenerate</code> is set to True, then the presence of degenerate triangles in the mesh can make this array have duplicate vertices.</p> </dd> <dt>
<code>faces(F, 3) array</code> </dt>
<dd>
<p>Define triangular faces via referencing vertex indices from <code>verts</code>. This algorithm specifically outputs triangles, so each face has exactly three indices.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code>skimage.measure.marching_cubes</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code>skimage.measure.mesh_surface_area</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>The marching cubes algorithm is implemented as described in <a class="reference internal" href="#r1e43a330a523-1" id="id14">[1]</a>. A simple explanation is available here:</p> <pre data-language="python">http://users.polytech.unice.fr/~lingrand/MarchingCubes/algo.html
</pre> <p>There are several known ambiguous cases in the marching cubes algorithm. Using point labeling as in <a class="reference internal" href="#r1e43a330a523-1" id="id15">[1]</a>, Figure 4, as shown:</p> <pre data-language="python">    v8 ------ v7
   / |       / |        y
  /  |      /  |        ^  z
v4 ------ v3   |        | /
 |  v5 ----|- v6        |/          (note: NOT right handed!)
 |  /      |  /          ----&gt; x
 | /       | /
v1 ------ v2
</pre> <p>Most notably, if v4, v8, v2, and v6 are all &gt;= <code>level</code> (or any generalization of this case) two parallel planes are generated by this algorithm, separating v4 and v8 from v2 and v6. An equally valid interpretation would be a single connected thin surface enclosing all four points. This is the best known ambiguity, though there are others.</p> <p>This algorithm does not attempt to resolve such ambiguities; it is a naive implementation of marching cubes as in <a class="reference internal" href="#r1e43a330a523-1" id="id16">[1]</a>, but may be a good beginning for work with more recent techniques (Dual Marching Cubes, Extended Marching Cubes, Cubic Marching Squares, etc.).</p> <p>Because of interactions between neighboring cubes, the isosurface(s) generated by this algorithm are NOT guaranteed to be closed, particularly for complicated contours. Furthermore, this algorithm does not guarantee a single contour will be returned. Indeed, ALL isosurfaces which cross <code>level</code> will be found, regardless of connectivity.</p> <p>The output is a triangular mesh consisting of a set of unique vertices and connecting triangles. The order of these vertices and triangles in the output list is determined by the position of the smallest <code>x,y,z</code> (in lexicographical order) coordinate in the contour. This is a side-effect of how the input array is traversed, but can be relied upon.</p> <p>The generated mesh guarantees coherent orientation as of version 0.12.</p> <p>To quantify the area of an isosurface generated by this algorithm, pass outputs directly into <a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code>skimage.measure.mesh_surface_area</code></a>.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r1e43a330a523-1">
<code>1(1,2,3)</code> </dt> <dd>
<p>Lorensen, William and Harvey E. Cline. Marching Cubes: A High Resolution 3D Surface Construction Algorithm. Computer Graphics (SIGGRAPH 87 Proceedings) 21(4) July 1987, p. 163-170). <a class="reference external" href="https://doi.org/10.1145/37401.37422">DOI:10.1145/37401.37422</a></p> </dd> </dl> </dd>
</dl>   <h2 id="marching-cubes-lewiner">marching_cubes_lewiner</h2> <dl class="function"> <dt id="skimage.measure.marching_cubes_lewiner">
<code>skimage.measure.marching_cubes_lewiner(volume, level=None, spacing=(1.0, 1.0, 1.0), gradient_direction='descent', step_size=1, allow_degenerate=True, use_classic=False, mask=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_marching_cubes_lewiner.py#L156-L277"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Lewiner marching cubes algorithm to find surfaces in 3d volumetric data.</p> <p>In contrast to <code>marching_cubes_classic()</code>, this algorithm is faster, resolves ambiguities, and guarantees topologically correct results. Therefore, this algorithm generally a better choice, unless there is a specific need for the classic algorithm.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>volume(M, N, P) array</code> </dt>
<dd>
<p>Input data volume to find isosurfaces. Will internally be converted to float32 if necessary.</p> </dd> <dt>
<code>levelfloat</code> </dt>
<dd>
<p>Contour value to search for isosurfaces in <code>volume</code>. If not given or None, the average of the min and max of vol is used.</p> </dd> <dt>
<code>spacinglength-3 tuple of floats</code> </dt>
<dd>
<p>Voxel spacing in spatial dimensions corresponding to numpy array indexing dimensions (M, N, P) as in <code>volume</code>.</p> </dd> <dt>
<code>gradient_directionstring</code> </dt>
<dd>
<p>Controls if the mesh was generated from an isosurface with gradient descent toward objects of interest (the default), or the opposite, considering the <em>left-hand</em> rule. The two options are: * descent : Object was greater than exterior * ascent : Exterior was greater than object</p> </dd> <dt>
<code>step_sizeint</code> </dt>
<dd>
<p>Step size in voxels. Default 1. Larger steps yield faster but coarser results. The result will always be topologically correct though.</p> </dd> <dt>
<code>allow_degeneratebool</code> </dt>
<dd>
<p>Whether to allow degenerate (i.e. zero-area) triangles in the end-result. Default True. If False, degenerate triangles are removed, at the cost of making the algorithm slower.</p> </dd> <dt>
<code>use_classicbool</code> </dt>
<dd>
<p>If given and True, the classic marching cubes by Lorensen (1987) is used. This option is included for reference purposes. Note that this algorithm has ambiguities and is not guaranteed to produce a topologically correct result. The results with using this option are <em>not</em> generally the same as the <code>marching_cubes_classic()</code> function.</p> </dd> <dt>
<code>mask(M, N, P) array</code> </dt>
<dd>
<p>Boolean array. The marching cube algorithm will be computed only on True elements. This will save computational time when interfaces are located within certain region of the volume M, N, P-e.g. the top half of the cube-and also allow to compute finite surfaces-i.e. open surfaces that do not end at the border of the cube.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>verts(V, 3) array</code> </dt>
<dd>
<p>Spatial coordinates for V unique mesh vertices. Coordinate order matches input <code>volume</code> (M, N, P). If <code>allow_degenerate</code> is set to True, then the presence of degenerate triangles in the mesh can make this array have duplicate vertices.</p> </dd> <dt>
<code>faces(F, 3) array</code> </dt>
<dd>
<p>Define triangular faces via referencing vertex indices from <code>verts</code>. This algorithm specifically outputs triangles, so each face has exactly three indices.</p> </dd> <dt>
<code>normals(V, 3) array</code> </dt>
<dd>
<p>The normal direction at each vertex, as calculated from the data.</p> </dd> <dt>
<code>values(V, ) array</code> </dt>
<dd>
<p>Gives a measure for the maximum value of the data in the local region near each vertex. This can be used by visualization tools to apply a colormap to the mesh.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code>skimage.measure.marching_cubes</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code>skimage.measure.mesh_surface_area</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>The algorithm [1] is an improved version of Chernyaev’s Marching Cubes 33 algorithm. It is an efficient algorithm that relies on heavy use of lookup tables to handle the many different cases, keeping the algorithm relatively easy. This implementation is written in Cython, ported from Lewiner’s C++ implementation.</p> <p>To quantify the area of an isosurface generated by this algorithm, pass verts and faces to <a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code>skimage.measure.mesh_surface_area</code></a>.</p> <p>Regarding visualization of algorithm output, to contour a volume named <code>myvolume</code> about the level 0.0, using the <code>mayavi</code> package:</p> <pre data-language="python">&gt;&gt;&gt; from mayavi import mlab 
&gt;&gt;&gt; verts, faces, normals, values = marching_cubes_lewiner(myvolume, 0.0) 
&gt;&gt;&gt; mlab.triangular_mesh([vert[0] for vert in verts],
...                      [vert[1] for vert in verts],
...                      [vert[2] for vert in verts],
...                      faces) 
&gt;&gt;&gt; mlab.show() 
</pre> <p>Similarly using the <code>visvis</code> package:</p> <pre data-language="python">&gt;&gt;&gt; import visvis as vv 
&gt;&gt;&gt; verts, faces, normals, values = marching_cubes_lewiner(myvolume, 0.0) 
&gt;&gt;&gt; vv.mesh(np.fliplr(verts), faces, normals, values) 
&gt;&gt;&gt; vv.use().Run() 
</pre> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rda8f856612d5-1">
<code>1</code> </dt> <dd>
<p>Thomas Lewiner, Helio Lopes, Antonio Wilson Vieira and Geovan Tavares. Efficient implementation of Marching Cubes’ cases with topological guarantees. Journal of Graphics Tools 8(2) pp. 1-15 (december 2003). <a class="reference external" href="https://doi.org/10.1080/10867651.2003.10487582">DOI:10.1080/10867651.2003.10487582</a></p> </dd> </dl> </dd>
</dl>   <h2 id="mesh-surface-area">mesh_surface_area</h2> <dl class="function"> <dt id="skimage.measure.mesh_surface_area">
<code>skimage.measure.mesh_surface_area(verts, faces)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_marching_cubes_classic.py#L157-L196"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute surface area, given vertices &amp; triangular faces</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>verts(V, 3) array of floats</code> </dt>
<dd>
<p>Array containing (x, y, z) coordinates for V unique mesh vertices.</p> </dd> <dt>
<code>faces(F, 3) array of ints</code> </dt>
<dd>
<p>List of length-3 lists of integers, referencing vertex coordinates as provided in <code>verts</code></p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>areafloat</code> </dt>
<dd>
<p>Surface area of mesh. Units now [coordinate units] ** 2.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code>skimage.measure.marching_cubes</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.measure.marching_cubes_classic" title="skimage.measure.marching_cubes_classic"><code>skimage.measure.marching_cubes_classic</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>The arguments expected by this function are the first two outputs from <a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code>skimage.measure.marching_cubes</code></a>. For unit correct output, ensure correct <code>spacing</code> was passed to <a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code>skimage.measure.marching_cubes</code></a>.</p> <p>This algorithm works properly only if the <code>faces</code> provided are all triangles.</p> </dd>
</dl>   <h2 id="moments">moments</h2> <dl class="function"> <dt id="skimage.measure.moments">
<code>skimage.measure.moments(image, order=3)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_moments.py#L149-L191"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculate all raw image moments up to a certain order.</p> <dl class="simple"> <dt>The following properties can be calculated from raw image moments:</dt>
<dd>
<ul class="simple"> <li>Area as: <code>M[0, 0]</code>.</li> <li>Centroid as: {<code>M[1, 0] / M[0, 0]</code>, <code>M[0, 1] / M[0, 0]</code>}.</li> </ul> </dd> </dl> <p>Note that raw moments are neither translation, scale nor rotation invariant.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagenD double or uint8 array</code> </dt>
<dd>
<p>Rasterized shape as image.</p> </dd> <dt>
<code>orderint, optional</code> </dt>
<dd>
<p>Maximum order of moments. Default is 3.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>m(order + 1, order + 1) array</code> </dt>
<dd>
<p>Raw image moments.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r3012f4679c28-1">
<code>1</code> </dt> <dd>
<p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing: Core Algorithms. Springer-Verlag, London, 2009.</p> </dd> <dt class="label" id="r3012f4679c28-2">
<code>2</code> </dt> <dd>
<p>B. Jähne. Digital Image Processing. Springer-Verlag, Berlin-Heidelberg, 6. edition, 2005.</p> </dd> <dt class="label" id="r3012f4679c28-3">
<code>3</code> </dt> <dd>
<p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image Features, from Lecture notes in computer science, p. 676. Springer, Berlin, 1993.</p> </dd> <dt class="label" id="r3012f4679c28-4">
<code>4</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; image = np.zeros((20, 20), dtype=np.double)
&gt;&gt;&gt; image[13:17, 13:17] = 1
&gt;&gt;&gt; M = moments(image)
&gt;&gt;&gt; centroid = (M[1, 0] / M[0, 0], M[0, 1] / M[0, 0])
&gt;&gt;&gt; centroid
(14.5, 14.5)
</pre> </dd>
</dl>   <h2 id="moments-central">moments_central</h2> <dl class="function"> <dt id="skimage.measure.moments_central">
<code>skimage.measure.moments_central(image, center=None, order=3, **kwargs)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_moments.py#L194-L250"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculate all central image moments up to a certain order.</p> <p>The center coordinates (cr, cc) can be calculated from the raw moments as: {<code>M[1, 0] / M[0, 0]</code>, <code>M[0, 1] / M[0, 0]</code>}.</p> <p>Note that central moments are translation invariant but not scale and rotation invariant.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagenD double or uint8 array</code> </dt>
<dd>
<p>Rasterized shape as image.</p> </dd> <dt>
<code>centertuple of float, optional</code> </dt>
<dd>
<p>Coordinates of the image centroid. This will be computed if it is not provided.</p> </dd> <dt>
<code>orderint, optional</code> </dt>
<dd>
<p>The maximum order of moments computed.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>mu(order + 1, order + 1) array</code> </dt>
<dd>
<p>Central image moments.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="re30db7550969-1">
<code>1</code> </dt> <dd>
<p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing: Core Algorithms. Springer-Verlag, London, 2009.</p> </dd> <dt class="label" id="re30db7550969-2">
<code>2</code> </dt> <dd>
<p>B. Jähne. Digital Image Processing. Springer-Verlag, Berlin-Heidelberg, 6. edition, 2005.</p> </dd> <dt class="label" id="re30db7550969-3">
<code>3</code> </dt> <dd>
<p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image Features, from Lecture notes in computer science, p. 676. Springer, Berlin, 1993.</p> </dd> <dt class="label" id="re30db7550969-4">
<code>4</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; image = np.zeros((20, 20), dtype=np.double)
&gt;&gt;&gt; image[13:17, 13:17] = 1
&gt;&gt;&gt; M = moments(image)
&gt;&gt;&gt; centroid = (M[1, 0] / M[0, 0], M[0, 1] / M[0, 0])
&gt;&gt;&gt; moments_central(image, centroid)
array([[16.,  0., 20.,  0.],
       [ 0.,  0.,  0.,  0.],
       [20.,  0., 25.,  0.],
       [ 0.,  0.,  0.,  0.]])
</pre> </dd>
</dl>   <h2 id="moments-coords">moments_coords</h2> <dl class="function"> <dt id="skimage.measure.moments_coords">
<code>skimage.measure.moments_coords(coords, order=3)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_moments.py#L7-L45"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculate all raw image moments up to a certain order.</p> <dl class="simple"> <dt>The following properties can be calculated from raw image moments:</dt>
<dd>
<ul class="simple"> <li>Area as: <code>M[0, 0]</code>.</li> <li>Centroid as: {<code>M[1, 0] / M[0, 0]</code>, <code>M[0, 1] / M[0, 0]</code>}.</li> </ul> </dd> </dl> <p>Note that raw moments are neither translation, scale nor rotation invariant.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>coords(N, D) double or uint8 array</code> </dt>
<dd>
<p>Array of N points that describe an image of D dimensionality in Cartesian space.</p> </dd> <dt>
<code>orderint, optional</code> </dt>
<dd>
<p>Maximum order of moments. Default is 3.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>M(order + 1, order + 1, …) array</code> </dt>
<dd>
<p>Raw image moments. (D dimensions)</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r1906bd878ddc-1">
<code>1</code> </dt> <dd>
<p>Johannes Kilian. Simple Image Analysis By Moments. Durham University, version 0.2, Durham, 2001.</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; coords = np.array([[row, col]
...                    for row in range(13, 17)
...                    for col in range(14, 18)], dtype=np.double)
&gt;&gt;&gt; M = moments_coords(coords)
&gt;&gt;&gt; centroid = (M[1, 0] / M[0, 0], M[0, 1] / M[0, 0])
&gt;&gt;&gt; centroid
(14.5, 15.5)
</pre> </dd>
</dl>   <h2 id="moments-coords-central">moments_coords_central</h2> <dl class="function"> <dt id="skimage.measure.moments_coords_central">
<code>skimage.measure.moments_coords_central(coords, center=None, order=3)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_moments.py#L48-L146"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculate all central image moments up to a certain order.</p> <dl class="simple"> <dt>The following properties can be calculated from raw image moments:</dt>
<dd>
<ul class="simple"> <li>Area as: <code>M[0, 0]</code>.</li> <li>Centroid as: {<code>M[1, 0] / M[0, 0]</code>, <code>M[0, 1] / M[0, 0]</code>}.</li> </ul> </dd> </dl> <p>Note that raw moments are neither translation, scale nor rotation invariant.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>coords(N, D) double or uint8 array</code> </dt>
<dd>
<p>Array of N points that describe an image of D dimensionality in Cartesian space. A tuple of coordinates as returned by <code>np.nonzero</code> is also accepted as input.</p> </dd> <dt>
<code>centertuple of float, optional</code> </dt>
<dd>
<p>Coordinates of the image centroid. This will be computed if it is not provided.</p> </dd> <dt>
<code>orderint, optional</code> </dt>
<dd>
<p>Maximum order of moments. Default is 3.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>Mc(order + 1, order + 1, …) array</code> </dt>
<dd>
<p>Central image moments. (D dimensions)</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rdba8c2d58a27-1">
<code>1</code> </dt> <dd>
<p>Johannes Kilian. Simple Image Analysis By Moments. Durham University, version 0.2, Durham, 2001.</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; coords = np.array([[row, col]
...                    for row in range(13, 17)
...                    for col in range(14, 18)])
&gt;&gt;&gt; moments_coords_central(coords)
array([[16.,  0., 20.,  0.],
       [ 0.,  0.,  0.,  0.],
       [20.,  0., 25.,  0.],
       [ 0.,  0.,  0.,  0.]])
</pre> <p>As seen above, for symmetric objects, odd-order moments (columns 1 and 3, rows 1 and 3) are zero when centered on the centroid, or center of mass, of the object (the default). If we break the symmetry by adding a new point, this no longer holds:</p> <pre data-language="python">&gt;&gt;&gt; coords2 = np.concatenate((coords, [[17, 17]]), axis=0)
&gt;&gt;&gt; np.round(moments_coords_central(coords2),
...          decimals=2)  
array([[17.  ,  0.  , 22.12, -2.49],
       [ 0.  ,  3.53,  1.73,  7.4 ],
       [25.88,  6.02, 36.63,  8.83],
       [ 4.15, 19.17, 14.8 , 39.6 ]])
</pre> <p>Image moments and central image moments are equivalent (by definition) when the center is (0, 0):</p> <pre data-language="python">&gt;&gt;&gt; np.allclose(moments_coords(coords),
...             moments_coords_central(coords, (0, 0)))
True
</pre> </dd>
</dl>   <h2 id="moments-hu">moments_hu</h2> <dl class="function"> <dt id="skimage.measure.moments_hu">
<code>skimage.measure.moments_hu(nu)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_moments.py#L308-L348"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculate Hu’s set of image moments (2D-only).</p> <p>Note that this set of moments is proofed to be translation, scale and rotation invariant.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>nu(M, M) array</code> </dt>
<dd>
<p>Normalized central image moments, where M must be &gt;= 4.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>nu(7,) array</code> </dt>
<dd>
<p>Hu’s set of image moments.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r8f5f4137a534-1">
<code>1</code> </dt> <dd>
<p>M. K. Hu, “Visual Pattern Recognition by Moment Invariants”, IRE Trans. Info. Theory, vol. IT-8, pp. 179-187, 1962</p> </dd> <dt class="label" id="r8f5f4137a534-2">
<code>2</code> </dt> <dd>
<p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing: Core Algorithms. Springer-Verlag, London, 2009.</p> </dd> <dt class="label" id="r8f5f4137a534-3">
<code>3</code> </dt> <dd>
<p>B. Jähne. Digital Image Processing. Springer-Verlag, Berlin-Heidelberg, 6. edition, 2005.</p> </dd> <dt class="label" id="r8f5f4137a534-4">
<code>4</code> </dt> <dd>
<p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image Features, from Lecture notes in computer science, p. 676. Springer, Berlin, 1993.</p> </dd> <dt class="label" id="r8f5f4137a534-5">
<code>5</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; image = np.zeros((20, 20), dtype=np.double)
&gt;&gt;&gt; image[13:17, 13:17] = 0.5
&gt;&gt;&gt; image[10:12, 10:12] = 1
&gt;&gt;&gt; mu = moments_central(image)
&gt;&gt;&gt; nu = moments_normalized(mu)
&gt;&gt;&gt; moments_hu(nu)
array([7.45370370e-01, 3.51165981e-01, 1.04049179e-01, 4.06442107e-02,
       2.64312299e-03, 2.40854582e-02, 4.33680869e-19])
</pre> </dd>
</dl>   <h2 id="moments-normalized">moments_normalized</h2> <dl class="function"> <dt id="skimage.measure.moments_normalized">
<code>skimage.measure.moments_normalized(mu, order=3)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_moments.py#L253-L305"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculate all normalized central image moments up to a certain order.</p> <p>Note that normalized central moments are translation and scale invariant but not rotation invariant.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>mu(M,[ …,] M) array</code> </dt>
<dd>
<p>Central image moments, where M must be greater than or equal to <code>order</code>.</p> </dd> <dt>
<code>orderint, optional</code> </dt>
<dd>
<p>Maximum order of moments. Default is 3.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>nu(order + 1,[ …,] order + 1) array</code> </dt>
<dd>
<p>Normalized central image moments.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rc5867b15e1bf-1">
<code>1</code> </dt> <dd>
<p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing: Core Algorithms. Springer-Verlag, London, 2009.</p> </dd> <dt class="label" id="rc5867b15e1bf-2">
<code>2</code> </dt> <dd>
<p>B. Jähne. Digital Image Processing. Springer-Verlag, Berlin-Heidelberg, 6. edition, 2005.</p> </dd> <dt class="label" id="rc5867b15e1bf-3">
<code>3</code> </dt> <dd>
<p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image Features, from Lecture notes in computer science, p. 676. Springer, Berlin, 1993.</p> </dd> <dt class="label" id="rc5867b15e1bf-4">
<code>4</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; image = np.zeros((20, 20), dtype=np.double)
&gt;&gt;&gt; image[13:17, 13:17] = 1
&gt;&gt;&gt; m = moments(image)
&gt;&gt;&gt; centroid = (m[0, 1] / m[0, 0], m[1, 0] / m[0, 0])
&gt;&gt;&gt; mu = moments_central(image, centroid)
&gt;&gt;&gt; moments_normalized(mu)
array([[       nan,        nan, 0.078125  , 0.        ],
       [       nan, 0.        , 0.        , 0.        ],
       [0.078125  , 0.        , 0.00610352, 0.        ],
       [0.        , 0.        , 0.        , 0.        ]])
</pre> </dd>
</dl>   <h2 id="perimeter">perimeter</h2> <dl class="function"> <dt id="skimage.measure.perimeter">
<code>skimage.measure.perimeter(image, neighbourhood=4)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_regionprops_utils.py#L186-L249"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculate total perimeter of all objects in binary image.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(N, M) ndarray</code> </dt>
<dd>
<p>2D binary image.</p> </dd> <dt>
<code>neighbourhood4 or 8, optional</code> </dt>
<dd>
<p>Neighborhood connectivity for border pixel determination. It is used to compute the contour. A higher neighbourhood widens the border on which the perimeter is computed.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>perimeterfloat</code> </dt>
<dd>
<p>Total perimeter of all objects in binary image.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r5745cfa18943-1">
<code>1</code> </dt> <dd>
<p>K. Benkrid, D. Crookes. Design and FPGA Implementation of a Perimeter Estimator. The Queen’s University of Belfast. <a class="reference external" href="http://www.cs.qub.ac.uk/~d.crookes/webpubs/papers/perimeter.doc">http://www.cs.qub.ac.uk/~d.crookes/webpubs/papers/perimeter.doc</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data, util
&gt;&gt;&gt; from skimage.measure import label
&gt;&gt;&gt; # coins image (binary)
&gt;&gt;&gt; img_coins = data.coins() &gt; 110
&gt;&gt;&gt; # total perimeter of all objects in the image
&gt;&gt;&gt; perimeter(img_coins, neighbourhood=4)  
7796.867...
&gt;&gt;&gt; perimeter(img_coins, neighbourhood=8)  
8806.268...
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-measure-perimeter">Examples using <code>skimage.measure.perimeter</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="In this example we show the uncertainty on calculating perimeters, comparing classic and Crofto...">
<div class="figure align-default" id="id58"> <img alt="Different perimeters" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_perimeters.html#sphx-glr-auto-examples-segmentation-plot-perimeters-py"><span class="std std-ref">Different perimeters</span></a></span></p> </div> </div>   <h2 id="perimeter-crofton">perimeter_crofton</h2> <dl class="function"> <dt id="skimage.measure.perimeter_crofton">
<code>skimage.measure.perimeter_crofton(image, directions=4)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_regionprops_utils.py#L252-L328"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculate total Crofton perimeter of all objects in binary image.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(N, M) ndarray</code> </dt>
<dd>
<p>2D image. If image is not binary, all values strictly greater than zero are considered as the object.</p> </dd> <dt>
<code>directions2 or 4, optional</code> </dt>
<dd>
<p>Number of directions used to approximate the Crofton perimeter. By default, 4 is used: it should be more accurate than 2. Computation time is the same in both cases.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>perimeterfloat</code> </dt>
<dd>
<p>Total perimeter of all objects in binary image.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This measure is based on Crofton formula [1], which is a measure from integral geometry. It is defined for general curve length evaluation via a double integral along all directions. In a discrete space, 2 or 4 directions give a quite good approximation, 4 being more accurate than 2 for more complex shapes.</p> <p>Similar to <a class="reference internal" href="#skimage.measure.perimeter" title="skimage.measure.perimeter"><code>perimeter()</code></a>, this function returns an approximation of the perimeter in continuous space.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r08d850c42e9e-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Crofton_formula">https://en.wikipedia.org/wiki/Crofton_formula</a></p> </dd> <dt class="label" id="r08d850c42e9e-2">
<code>2</code> </dt> <dd>
<p>S. Rivollier. Analyse d’image geometrique et morphometrique par diagrammes de forme et voisinages adaptatifs generaux. PhD thesis, 2010. Ecole Nationale Superieure des Mines de Saint-Etienne. <a class="reference external" href="https://tel.archives-ouvertes.fr/tel-00560838">https://tel.archives-ouvertes.fr/tel-00560838</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data, util
&gt;&gt;&gt; from skimage.measure import label
&gt;&gt;&gt; # coins image (binary)
&gt;&gt;&gt; img_coins = data.coins() &gt; 110
&gt;&gt;&gt; # total perimeter of all objects in the image
&gt;&gt;&gt; perimeter_crofton(img_coins, directions=2)  
8144.578...
&gt;&gt;&gt; perimeter_crofton(img_coins, directions=4)  
7837.077...
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-measure-perimeter-crofton">Examples using <code>skimage.measure.perimeter_crofton</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="In this example we show the uncertainty on calculating perimeters, comparing classic and Crofto...">
<div class="figure align-default" id="id59"> <img alt="Different perimeters" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAADECAMAAABz285eAAADAFBMVEX////YuPy+vr7n5+ft7e3+/v6fn5/Y2Ni4uLj8/fz7+/vf397R0dGysrKtra339/fz8/Pv7+/h4eH/rWXLy8v/9evp6en///6WlpWdnJyPj4/x8fH/+fb/9/BbW1v5+vmbmpqwsLDj4+Onp6b//fuMjIySkpLU1NTOzs7/sGvr6uq9vb1/xn/ExMR5w3qxsbG437jBwcGHh4f/s3D/0ajd3d6UlJTb29v/zJ/IyMi7u7uXl5dqpc7//Pny+/OhoaKZmZmkpKT/7NqpqKrn9eirq6r7////8uf/5c3W1tbS7NP/tnbC5MKEg4P/8eTr9Pns7Oz/vYLg8uH75OT/4cb/q2D19fX/6dWg1aDl5eWAgICKion/xI/vpaXb79uDyYRzqtH97Ozd6/T/x5bK6Mr/uXt7e3vnf3/y+fyTk5Ox3LF3dnWNu9mJy4p6r9SztbT/wIm2trZxcHBensm31Of/7t/j7/VtvW7/1a/mdne3t7fM4O//2LX/3b+Uz5TZd3f60tP/8OG2tbV0wHSa0Zvs+O2o2KiOzY/1//6Ettn2yMj98vH/2rrniYnV5fCVwN2fxuD/qFxraWr/plfmcHDSaG/B2uz2vL1AqkDCZFbskpL/o1FluWb43tyqzeOxYkvrm5xUslbk2ND/nERiYmL0tLWiXz/HZGyRUzeKc0bu28tqosHxrK2oUmLiZGWYjIJzaTniamutRjdPqWs5l2RrpmtNlMSTVW263NSwa31apabHMSnPTlT/hx5UUlB0jLKErcm5W2n/kC5RLy3Q5+Dg9/7XoJk3iLuFXjdwsYrHua27sKPQb2RDnIh9ilGu1cVvk2Fog0DJgYvYNzhacUy9v9Cb0bm/kpuYiFomfbPQ1eKljqMjg5D/ghJsf6CHYoB1trWRzqjJztusgJV9pmORSlNOgmGBb5Csn5TSinvcyb6dmm2avYdYi4V+wZ/ns7JycJOww5pOk7HGpLaWsnvUtcMsQDWRqG7YrrXE2LiiuMs8R0+Uc2nBfmqGp4qZuLQznYJpAAAgAElEQVR42uyaS2/iWBqGj7gYnIDBjh3ubcBcHJCnBBVwsAcRoBmCIhgylRAB2bSioIpoiYCElImKBVHvejYhvZqopBFdKzb5BdWLXia/ofel+gG9HpsUuVQHAkmATA+vUOJjjHXOw/d+3zkcAzDTTDPNNNNMM80000wzzTTTTDPN9NIljR/BL6MnuQSFkxXhQMW9gN7Iyz48p5RgKVihZaokxrF0VTOdrmA1vGCjc9WQhMIC0yfjKjGIvhTxa5yYzx9fTR+VisHp9GTeCbCWkUrTTMkofQExE6j9kmWiRbkTdzqLEZWtRimnBkZVc+b1et/vL8BLciRa5tO1BOT6hikVi1E8UIiqptOV/IdomXGqIuVjg5N+AcmXzgNFIqpx22FMIUNzwgl0Oj2B3XQWeFA6mzPlXoKVul+WCvz5BbOKkcU+4jPXyt/bi4BismLJB6uen1NOVMX75kHSCfeCc7ofrDLVCYdo5D4weduEe+F7MBsE1BPuEnQvGKSP0WVPVDZ3/40l/+Ngcih8R8KEAQh/rtty8PXBVyI98j8nGO3dNuohUSC9OUlivdAy9Zl4Zf8/wFQ+uBFtCwcy2zEZ4rJqnypkYyoaWkm32BDnsbmnC0ZXXz5Z2drZe71teSIY4RvP5QeByX3/156+F8eT3kcgPwdUTrWhXP6UdkP+o/SnT7WCYdVdK0TSpmmCCSfXTzc21xsHy4cLZw2z4ylgICixahQm9J6+EfP27z29FdpVX4v3liLA7U9E0pcXkUUrP2+4OC8oVS66wPmoKVppe2nhZOVL4AAQW9jaWnkCmNXEL5E8BNgo9bCVxBHmUVYBFlGgSvtg1WW7rQmw2nank+LQEOaWSLHpgdk8axDh2ycs9fWN8KPB5OPpYEUNPL74cDmmp6yAQEdYiG4PLJn+UTsCGDkJ4DkANILBRwazvXW6/ceze6e7jwWTsplUiDDVWERGA9O1dNOcEf9nzBnzc4BZLLHu0hztryiKceFD2AhgdAuH92VbXexkbUJVqau5Xq4LZ+QyAYwuE36WiEFw+b5W79Eb8/sykK8OPRl37G6t9zXYemwiYHxOu0QZ9IK5PAY8bUc7wKKBDpbx2LNBGZqX56VPyTFxBnaiq4qg3m00CWkPGXJA5qWNtb4hWz882xwPmMOd3SvtHAptroXYID8FAmVe4i+ra5dR53k5eOEvRMq0v1CpPWUeg/ohd4HDXKHFfYnQtA9rpfWdgW/HzmJjAdNY7qkhtJXqVpTngoDl8WKZkhjeB12fV/Hzms0HsTUbB02hKr1beuCCxoJu/FaiA0hVwjOAbfHSxKeU5M3xcZtTXFxGsAiOUG7J5MHEzuoPXbK3M6HkK8a5V/B2EgDCIpZs4lmq0qPAbA+RQsxLOxMD052/CGAsBCGASVqmBSY5VGoNL61MHExShEKIYOQ394XhSYFZXx7KJZbT5pjBzHGIVFwbkLxaKlrJTCQtXOWNAOY4le8uGgCMBaSyHqExg1nbGm6lqDtcf3Yw3/6jp2+Fti0SwPxHhlXmQ9nJ+L3KIpX8EYtchLH9mo9xqRG9gqL4EqeK6lmjPsVz8rGC0S00hp0Dbq09M5jcD3/p6QehHXQDU1GV8MWjNlbfDhrpYiyMGvLmaIpH4s75lp43AG/It4qErFaG4l/NjRXM4RIYVo2HY+tJVnIXETySNbpwiokkjFFqfj+mKVvtFlxfOkIgrTGRch0zVrVS75IgNPKqoAVjBLMyTObo6WCBGGvylWGaHJAtghxsz7RJDfm+brbPvyFAXqYRrs3Nk1oMzqMwKgU5Mmc3jTPHLG+N9DPd8pZ5QlVJrEWOet1xVZ8mXq6JUwKMpIPdCYERC7VuemBWdkbjAjIn4TGCWWSvnlPypeTdH8yaMR1Y/FEAk7J7vlxCzmXR8YNxnMRGBANeN8YHBi++SnE0I1F8KK22Exhb+RwD9lab0BwVcAUTcnMaWhn1q6QhTutVan2h8YE52BiVi7B8aD5juf7PT/+80k//FtrnKqAtM9Y44oIYq1fvsqVj2qAft7w68tsSJbpW4I1ttU0ZhZB4OkEVmLHNY94thEcGI3xINyQYEoHsVso0aJfguzc9fSe0Lw2KFI9Z48eRqkQAw2Pn21qkdSyASSMUny0rGWdbYjsSwFAUjnClcZVr82kMPEKv3w0JBk0XGb8BBYEENZSV/ha7qNhTcobLKWTKdmI+YBKsBObRTK7qxQIp4K7I8EsZ586GOBPrUXhxeEwRs7LxGC4gdmIeDozHCHk1FRuQckPuEsRu3TgjxmVGtG34lnctzQlUJeI0+SgwYGNlODAmXk8jrsAgK30F5tbcoSlCSma+AkPEdKOCQQOAhkcCc7D7OC4gOWDycwVGBQJieYU1QEMOSL6aP4C5GUF3N+m9+NU5umCu9vWJ7bsJTgYeBGNo7UPyUcDUT82PBAN2DwaDcX8TLHoGVCVCB8ybgjqysE53M1J55zyi0EpzmFwL595jJMyeEzJD1tPWkHZIwYt7BMlbYMJms7kj3mbTDHREXzB2BlWMZKW9w8dyEbJ2ZiAY0ouy2v5gHAsZsHy2t7d3UP98ft7GeavMy6fEcn1Bh4xRXm+DpJGii0L0ZQfWCtU+ITRUC5WNwmgzt8Bk6pnkZ+Eue2fLgNgK9wODRU374kM3KCzGl0wOUHggGOLk0QEjhMzuYCvxJortDyb8cwx0t0vekopV/g4Y1qnPG/PGfYXLmBdeBSCzeviOgYtCHgiviGBu1vfN8BcrHe6A+s+WfmDgRBEH3Z1IrnjEFG14MSoftH0y8mLg7sLAMRAM7Y+T/cFYfl0DG//qJd+b1OronFt9VZPXqeKM8UtPhTHygLR6lXWDE49wkhR+B4xOWEddJd/GBlj7legHhrRWcfEqNR7UGp25oFPm0oL5BNL3d976E8CAvZWBYHz79IAc0/zYAOubX8CI4+tFUqx5k3ybvdNyXbenV/mzGQvfgNF9AbP2Gmx+bPbNMemoVbRSxMfTQeFlDRk1ALP1ARNeePcULsByujnQSi5ogJW2fzsES7HriLkG46jfSl3N62Sia97OK9dgxGIl7z6DV18C737b7mslW0FsoS6KtbJSayprEB/B72elxmvwNG0uDQLjLiQGrJU2P66ALbEQk4syGdrxoFePYKKeTufmeczbh1m0d9y5fTX6X1qurimNLA13mYCLlYimQ0CFxRj86Cy6xiYJavCTFB0gGiwQHbvUDZJK/MiQD5QawVrXqHGHMnGtylAVZ6os9i6XJlOpVKyasnIzV5mtXE7lbq/3N+w5p5HuhnOgE51zQ4eGjjz9vs/7vM97oPIWquEumrLt+wnAVJZeUPecVimtSp7EEYGxBKJEYDRXO6rUVZVEYOJpnhL8MY3ZXObhysxolXE0+/3h8fe09vBQy7jEQ0Z8tafMLOyMMNGWUDpGAEZjblbfyFd4BGBcW44jAkMib6FcX1aXNF4kAmOjfUaxfUU0jBbHMNnaohPtZYvop5poNhsZibB4k4wR2k5KpVuGswbFOsbGHxUXahlvjAupVHu2s46cSiFfeIDJ8gafnWr5w0y2SXHRYvmhs8/qmHA21GOiyqRdYR9PAKamdqZ2TDEwTPDIwFAMRwSm42HtnVEyMD67JyhSlN1OZUBKRphsbRmg9RleUFF0lpOX2cP40sP3Zfv9IGvzEYApO3Op6qpSYKIBy9GBsUWIwIw2qks0ZGDYBOMXZ3fxSDgzqIjznuwNizKa9S540LWkYbJ01ufhY5l2zRMRWcWXZJMeYirdK+lR2iv5bEfHBVRsFzGV1CWGAqnEBBkJqv60hxdufiwUzkZhH2vegcNJyrnzlDm0jfTBcMiWYThPWqwfERsbZEjAnKwur1IITPDo1Eu0czLAlDecIAIDWiWWD0lVTZQWYtAeSYjAaHfH4cHQ7lM266f5fZkEYvqSEuVi51mXLAlkfsy5Jq3CVGKSx4EL5dgKkoDRNo2SdYyRNrIvxZhdPhjQb8U5UI/sNj4J97FSOo6zMV27U/C0O/WUsXGcjjIBJkpEbAAYExffUrkORL0Q26YtsvnY1xlVfoWbo4quJKv/GjPcFKBiIm1QxpgeXGkb5FYoFopB3Cy+LQ8b60p54WlvqivOerbCFljK43wMhFpkm41TeskW0yhrk5SunKrUc3OsWxkwRxZ32TqKEXkImNNt9W2VRGBcAcy1OECefBwmiiltRBzsTE3DE9MpJ8osU1oHky0JyrIHUw/1TJQg8BqvnKlWxDHGLdMxAQNIDw9MTf3lHlAizae7b5XUnsy1Nvtw3UQQ9CiRJIwHV1qH2NaZGoEn1lJDKCZ0aRdMtgSILBYnFNggIZW0vdUdiiKGY48LF8rvIXXX1ephOCWo/0dP83XQyvbnYpDvsAO0fIk4DzknioTLUAruDKGepCAHDzADkFP4mB8wPosbbsjQkjWR3Q9OKQImZD82YEz5ZpcAzFlDYyWaEvT2Xu6m6h7IgPGHcU0KyC+fH8ZD336QgT3A+O46PLG+60aSFzwNY4oL52RN1gjxk2yHtv4qJWa4Yyt6bMBQnjjBdrjSWwoi5oqhqXesNDeVErgybwLlNsxBzIKf/ZBnVe6FCXhibmEKVTL/Pgc/fdADyj1OQPmSBGDKemealUTMVw6T8KsvTxFlImZGDbWDuYLSDOeRbxwnmU20kfIEwcemuM9xBgait8UKOdNq9SLtk/ycgLTbx1IO7M4VPkYApvG70XIFEfPVwyT8yhsxIWCGL4x2nCFWJWwHawQtNBuETJP4bGMg3N45KwBX07LeirSXbT8JGTbKUMYATp+GbARgLnzTrSRivnqYRHBIc0dMCJgbD9XXh4nA2HEkB/ODibqABI4fhJA+an1iXQWtkvUJqtps6ACEBBMdoCldAKfD7CECMKrzN/uLA3Ok2QBu8XasgzdWX0MEJoTt1ACjMss62kLZ0j5YtlTTa1agYJwTa2uIW31pOzQgAHQDNO79MZ5EvmPVhuI6Jhk+XlyoIIP1Y9qqLxOBiWDtZqBdaBdkGvs2g1TA2vQcKNTjc9NIzviY7RAFdL+O1mN1EJX0EYAZvnGhvDgwvvgxA+MI6DDAlDbfI0eMD6u8Wc4SMBppE8Wz2+gzjrQugXrkXvciOQPaAB5UVPAKYxC73VgmAqTANJXX9RclX0tg4JiBocJJjPKtqvuWTL4e7IAh7Ad55AAUHImkUVYseUcA7XqfTC2hlE37IrCm62kdh416zkMApvxmZ3vm8EQlVaelRofzgeGOq3+UFN9wPjCldzrLtURgWKx9GElEWUAiA1TYfoB4dGlqDdDu9Job6bzQQSiM/E62D6uD5HpaNnDrNVzKFG5D1fkGdXu1wZw7PtEfk+FQwHwQUqnZ0EuuSjRWYfJxeM/BOU9sHxH6urt1BDKNew4Vnf2YBw6QgDxOYq3DKEMi387ReiGVmqru/Hu4auxk7ShVqpb+Sfo/IGAA63nygWkYrSUO3PQ0Np1DNviBQTSxiX1UtubGvUswocaRALbtJxgUFXw8hlUcLulnkwJT0WvIfGXQ3HyzrcTQ+6fqGupix/ki3fDRl7xbF4D5i+FboufrwO8ut9mhBwX4h+H2kYidGIexMucesqKM3Q/SiEeE1+F6CgcemBMNjRmbdfh0U0X/De11eFL29WI9Hf0DgJGTaaZXar9KHOrDyoPTISE+jioW3XeAEt46BCGZGHe2oAYL9Nx6WHmSvB13e/UOqUKT2Q79Fy4VEXjLtJLhgHlcXM4vHhdkbIfu8goSMFCr4DIy4vMjjRNwpSHSmhXnaouKanGursBLcgcu2gG1ChfmsZLDItUNX2ht4gce8qVyr7RYs2thRMFPb8qGMcWtTR3+9vjD8MvdIRtQM2lorQzurXa1mFUrXat7g7DopAGgUN0us3gdJKMuWUvQfKquMDBGBdvAVSMLbsk/u5ZWhoo7nNL9rQIwZzrq8quSXljRAPYqHAu5x243BfQvYZ2b33NqWrq0K5rVvXnYx78E3AT7IRODn/QB6QyvbtHnccw35d2FBZ4Cw2FoRZhyicu7M/1F5oMATE/1+dJcYFxMgIZrG9+VDKThZqRkeoulfODe6+dfb8I8aqE2X0NgXD7Ks52Ow24zjRepvpfw6gHWlFuVGh7+tXDE0EUDpnXHm/fcqnVitdj7JLaiAMyDh/fyzHCLzoWWLs80uDuIuAdSj17nclAo1W6/fizw72OAEDhhoRwuHQwHI+Ju9HszckElXB+9RsYx7bXtBYFxFZ7LDk1NTVixZDu90DrlVhV6r6TlF4AZrSonC7y89H3183wmcyUh/+H1M2pienqCev76g8TAzQT04M+vCrGfFJiLDacKz67j+ZkEbtVdAXnV2sLcHClpxtfXrS0C12gGNebB/FwSxVUmlZpPgZZAW24oqYUm0cWCwJQtvNoUjtbdUmB+t3itVq/ldykw43PC4+1XOxXKgKnpnFGXFARG1u3NP9588ew+/G2oR8/hVp+Jua7CpOwFpKyiNtHPSU3OgncvSkvllksGzHczhn7wd6sq6s/PAA2RY4bnrq7dQ2BWpsT/8MPee/i9C+pv79+8FV/rXhEeN1/trioDpuxG+4mOQuQ7sC3RVYuPZu9v/LR51zxvvrtxbXLy11+LMuzbvV+uTV5b1AwOauZfPJvcmNyQ6nleBszJjnPNcEZbd6XsVtvJ3PFJ7nKm3mVQXpBQ3Ns373+Ejz/KgJlaOAQm5VSYSup/GQoO9cM2Sbg82hRvDTV/++POxuTjgixye/ba/xbmN8vQ7kkVeun92c0sAZqyO6IFa/PPnWPnYOQ01XV3aoul0vghMCoJ9+vfvvn0T3jw909vPkqLpPBnLr5LDSkEpma0UlMglXRiSZ29Nrspj+WFIWrx/kYBZBYf/XQXUKGcoJ7ffzSfDRm7FBhNXSVyHcyU+aKmKPm6//PuhXC02yo++/G/n36Ajz98+u3/lJ19TBN5GscntqO0srQ0hAIlUzgW9dhut0uCBFp5WbE5OLiy9EIKG+QlLK2ssCcQSJc7IAJSyhVYr4IQ3twItneFKyhHXAhKuBpMhIMV1HBEhBP9Y1dPT1fdmN3cvHVm2jLd2fkDyrzP5/f8nuf7PL8fUwoY2QUODmYljRkYfibHq/IlZqzpBgrc90SfWNja6oVLERK4+9wbqUpRjZ/rN7+mgAFZPC/K12NJn3iCgQEvkOiV/1q+bUM+2KaXXMBg8xG7nkykMwOTU1ES4W2I9mNs2EVXrih3jyoyCXZbrYquXa+iO4n3vOJGrtumTgV+DFHhRMEEXYw4ymcM5oeJJ1VYlnb+DLn2ztLMEPJ7aGLpDkU6nBc7wfzAsCvFfOC3nx4MXtPktHboALcuk9XXTHaYXcyuSNHpRFnX5LG1HTUm2IX9iVra9PGL4zIG83z6EQYmARvGx5rpjnXOhHwwjVpJMOCZ81j0rHoy/ZypjwnyS6R3vpjSqK0s99iluI+MkapyRZH79pOVVWTiLa3zeLVyV2UHWjX4A1XHHPU7HPhLwAzgYCjgt6xX65Hf9VetW+RaDQ5m4BFjMKyQPV6GT9DRP1VlrccOmprjro9Z7calldL0QnFTo3uUBHUFyGP9DtfVeD1mzwEBYzAvp1dRMGDz+TrSx2yN3L2EPM+luyNPyX3rzmPmPbA6/ZIhGCA2nk3flZBiUmflgGd2JBW7GwDVZsCT5Rz3Azx6m0qhUBFFMAyMKH4fc+f7enq1Exc0LeTapyMv5uDs6cjcC1cwWADoXJ3+liEYjrd6DFJ+7FJ4aPnCvz7c79k1SBesK2h1d7ehL5+r3QtN4ECBzjmPGQPD+QVRSfntbXsH5u0ulJHG+XRwbRSWvm2jayMU9dmCzVgEOlan74HMwOSE8+knJ/75twYX9wEajcbhXr155JZZ292vLmyjZLzVhPoDyzspp2prK1Q39Jr1gz16bR58vNrFEXXhhXbcx2Rmg0zBGO7N2E9iSo8CBrg5uD4KX0I9uj5IAVN2AZMvHfaZewaGzjcj5B06MEe+/Kijg9KKbVq9yTTUrda0AEeMJr3ebB4fdlctqH8hV6q1ZrNZr7UVAmk1UQ02k8k0ZnQJTiqsXIWBSY4OEzEFk2A9t3AdU3p9+aTF3BwsmmqAhe9Uew8VDBYqhCft56wJzMBwI97zpXO+f/y0SEHpE/3jNqyFahKclWS1Vtvm7oE7KP7FNtZNvNr3DOYJ1ON5lAsNtH70MQkmYO9Bf6Zgmq3fLDzAdZKEXD3Zo9qEpa9xynFrkqJFGzFdd33hG2sKMzC/yjjmnFHFRTs5hwTz6e9byZgLdONtzXOpYtrGCymKFnbJVIWcpy+keDMpdnOhWhPpbbiKakpXkh+O2McQjDJr4a4FA5MukZBNO3lLt2kDhMObuluTShKMBLv2A8uNhSyGFpNYgY8SvB/0wb5PPhdEHnP+T+SRv1wnHrLQaDLj3qFO43KyYTP58B0dsKtRUbiEukpCvLHyzLYGpx1VYXoHAxNXEcxjajFplhcjGBhZmYSwa+VyveExLH2Hnhnql0kwkjIsnXow8saSxgzMPp+ccOzp/aLDggXykP1BgYBv2FsohDU7f/8QBO35EIIO/n1+/kYkdNE/F/os/dVsdNRFKDgWgk7HQVDAF/Pzb/ZCFwOjoQp2xauzf3sLBQkgyM8Xmh2dmIVSkyEoJwQ6yy6BSkSzr0JYEJQcC82Pzs3PHvSDIEEQ9LYqF6qIKkHaPPsYK56pjhEWW77H3WtpnYRHgjEp78PS1/RMaVoykMaKTSMCn458b0lnBib5MzmeKwV/cUC+T3449UQUIIpLjPLn3LjB47JY2byoHG19DhsUsaI47MD9ffvgTYEskRjZxGLxstlf6eu/Ql4ABW+O+V9nJkvEDWTxxDdm/psdyBLzWYFcdBOLzWFLmwD0yEyD8s2MkQdvEgWyhWxWJicMLTuclScyLm3KLAG4ez2jkRAO1bDUC1yDpa/2mnJoSUdKb2waERyzti2lzMCIk+IDsB4aJ/cRhLwXGIJ8A5oA/iEMxYNxoX5I6JpSuy82IjopiWikLdwlkhB6WQg0jA17Drgl+WYytZgzlnUnmC0pUZbTWfOAa3M68aVrgM1KdOoE6Rba/8GbPesWDUMdg/0X7W5RCX9LgMsTlObvekaYA1WfgHA02nW/4hpSMRfqe991AyM/kBjL1GKaLLW3JtEm1WxcJsCorMPA9uh67eg20E2Cab68ocFd87rlO4bKN7wkwFvNFxwea9gtpXZfhin6pE1vKqR7HDLfA9816dtcwaSWRDDNrsHvLO24e63buOK8K6FjxAgIL21vzwkB44gzfxPCYOpwMO07DMGIjwV97g3MEDXicillZw+jGet3ftTm0e4ldjmDbVztAiZOjgg8XnhYqt+HP2cxr3eKtMuoe23ZuEJok+oRuBnPra1dgmUXAQZIubxRhsesop3XDLPr4BiWFzBGM3WcS1bm5U6N43j755m8RdlGqpwc1rqA2esrQMSUf6TcJygH4Oz3AMMhDla+3nH0rqDutWzjilObCNsHYdT175yG/a96kFibdWUDcQFC3ZLJsfOQtDqOFzD+uXIfejCh4/3U22o87i3dtWlBDJDXqa8SF6PTdlPBhIUkIykBK+lYDKz0DoUkux/cSWSqhodTjqEVNBrln31E3Nc/B2EDH5pBqnhtg8TAUtajs+ikkOaVXscUGcW7Or1ZTPT7qbRgwLxelyprvvehEhN8O6B6TO11p2Ip9a9+3MzwGVXxAYgiORUQE3kCjtssD4spIB4lYWnKkWdHfItSOkFUuIXrPXCrtF+/Die0bT3bzrXHVyfQq6bY82AwCWSFlR4Mhx9+lH5+TMNYG9XfSdO8gwk1d4cWjhu97+R2lqE8Eow4LiIcqfnCKXZm9q4+ppLITxNWNh3DdrSz1EysEla41gNbbXVBOZzPgj1rTjBpqxONGJhhx6a1mUzu6cH4pyYmnaID4xKQADBNCiIvD6BfuOpx81ie0tsuHHe7C1UTYDixp5P20mfXYHGpbPFrGb5orJuO7oU6GYymZtqOq9kU2U89iJhRoDWkcz/JMKesLLZPT3KBLFmTvVv32K5xnuPrxdLSYpCuK4Vni2nAdJvV7t6BH+Xv8p1f/sQP5Je/PzuHJfL38h1h/lHi3T0VXo9h8+jrMQkXNE2Lixrn8uNjR8POlqQMUE7edoLRSJeRgq9YUYl45fplKS4O0u3Tl3VAi2Rrx2h49iNxisXFJk1fCg0YfnQI3TSQNhcnCh5v5ACZPzNTis/1vh3Ihi1C1kIHJjlaTmsxYJYEUCkKyD74TNcwpcrKB3STtxfwEbeWtH8jYydg5T/Q6PgfbEoroJQt3F5OAPKzdFMNhmek2yyADSv/OF12nRx/yJuOoRR74Kuz3cDkHvJhx+aCgCiGDwj42YKDmTk5LDYgEL0TLxZk8wW83cCIa1JowAQE+7JpLSYtH6gtLyDUrPa+QT1alCIFVCszzvwnP+0q6uEqUedhvJqG99rShTEYjCTLMdpvuE+ICVVBeS18CF1KEH00jNHr3rIQNc/mVBc5F8RacyPDDiZmcIETh8NOZ0QGJyWfyo1OCtqTEf1JcnhGiFzOdz8LT4SmwzRgkoKS6esx6S3/Z+3cQ9rOsjh+0PwSk0bzGNFEZWzSmoiT+AITTKwPog4WS7u6Kz7QJCJGbYxYgyUGTNZ3KhoZTN0ENFLwUWy3tp212llGhVJLa6fUnbZ2CtJZlxm6HejSmbK7ZWD3/vLQPH20c/3PX36X3A/n3PM959zfL6A1a3YKrYatAeVqbXY31v54dNrVcUuusTjkaJYj3Cgtd1wVrL7p0ce9WHJv7dXSgWXVTudLY9ZCZ3EQMDTewZ5wA8cxGAJZrXAPPd47TPlUcurrDBCRpPVHw9hHOAWccCq7qrErj5TADpMyA7oSyiXzA4OR7FWPSaA6iboAAA+5SURBVO2BkQn1TifHsFw4uDpMTs5ufzxk73FVFy5ZHPmdRuNwPsslV2+ifNr2OJ/SHV+7Oli4bNipxZomRqC8KVjZoZIKBwCD1XXHg58rYS30SgbGiQdeegeTHZIWminMjMyQiNkSPpHKTguJgoAWA6kCLBCYxMq8PboEfX1gvmh2lxQxwzIWN/NddHJvyXy1vdPZvhK82XDGYWeVfOONs8uD9dir50uyu2F4Na5wzrKj78wX1dDUF0THJIRXHeQ9eK7OPCHI5ttKgIONstjAxQsHGFl4ZWZwi+lJHVmo1bZpNGZEtXbl6hzKFr/Dz9vNj1lRYkjWwuLNpZ+dlWSnDvx56eYipkXx4Cfr2PydfAGIZ07A3NUVXOSYNZo2be3CSHFnEIsRciIO4EqYayUEMnzccFoM9J4vCQAmI4ITTg8Kpr84S49Rhof1ePF0YsWCUkRLJIoqd+4Z139B4mWBMnfT4sxgnAfhsFLLzZcN+Kd/Wjfeu1Mjh78jT2s3rCBsDW364eF4TJ9V3BysE7lXw203Irh0/H5gyNjBLMYvuzjAux3ki65YjW/A5ic6fJ+RQGfdndlxw7/xc4enb/9F53WQEtP94zb6N8AvhtLZxZP98AR3I9UTM7I491yL8o8C4878fMG0JhUxQjp2zZ/rdqkM56lqLIjFAMVH5R0AjGBRc1yJxgkT2oBNT1BwKVTJoDx1cVo59Botda329jc27wls39xuX0MYX6sGZxeLe4CDb7wqoQnfeE/gcx3XLAo+BkyNu1bgC+aL3DxhVboYwqsimCyORMSJTOARj3FzC2IqqdKUMF5SMIvxrWDsD4YsWFTbrut0oyp8A9a8w+WI7QU0NT2ajpvcRJnjc/3ty1PeE4xdfqh/rgfstS1u+hHaZl/gNw29QzFLax5Cc123qbWeTfXDgsGa3cGeQP6d85z2J5/84ffogjS3PjImoQhy+ez6KpE0sauAzfmMzTvFy+OLqhqlmcH2GD+Vtz+YbMGEelQZFzc4+n4EyIq7KPnExpYgtfyRHao3C0H/XPtw2ug9gXH6ofb5RSjcrAb7o75UWELgoq/cVVBg4v3ooGOuieTsDwdTcp6yA+bzP7oHShiwo8yvM0UsPuRWHZWw0jhiSTgnJDFPwgtJY3dIhQWkoHuMr8rbH0xv8ojMoc1sMjUSrQacQekMua6zxQpTmwOgXRt5OO1TUVXaH46saRGYKbC2dNZhM/jebFShTMAscwhglczseXo7MBgKgQ4oJtAxPzCdO8HV15XoQMCSQpEaEtKhIopGodHKaPFlEBpK5pIrksoowS0GqbzeQ4EpEZi38RJF9NSGCdrnRgdx4WJR1jRHrMMFewNMtJm+tPocq4+2fmlqG4EB+wVYL2iuUVrw7G9wdK4WTBvOk3rbas9kKTCYJNnZrgQO3/F2Vq8HufLPZwcD4x6xBw3juxYD5eWHAnOy2bTk8JTxGQUMu4S94UK+PM8ARjuyAU3WDwbfGXQ/ZGnMCIwRDER5vtHgKJ6rlvWgcBgPGGdMzSf3dSWGSMRgJUSJCJAY4/mVenbF4W+lY5xaJvswYOr6FTMOT4mzzIEeb8Oi8ax6IJmlglJ7L6jNC9/afGewfbtgRo5nH4eha4Ls6mcOM6r+8SLMOYwHBi2K/uJ9wUQIiVRRbmJMLNCoHqUIzwX4gsHEzrDMCNuRvjQSvnaMyqXsuNuRgBbjCdwbDKkrthVXel5gUjvdWY5qS2u65awThs20J1+zob0kH0zatfkpv6bO/NqEBqKsSpi8JmifcdUlb5m0Wyp3xtWTui8YCY3LiiRIcSF8xMOV+jyO/vnmSuy8VnErKVyce/YLKr+FntbKACYnhgbiYwn8jA5xGpXWmnhWEsngiJkt1KgurheYfI/umycYwjn2mbN5NMCYnmCavndXUqq31Wqn8UDo1RX5r9UwaOWCRr82a/RdknH2uV4BTOsgXPlVsHLV8c60aKVFrd52dXgmf/y+7wOjklcqTCB3drt+CgtvEMXWA3CIxM9YOZx0Ma8j7xSHg7+9kxIfE5KQI2MV1NdLO0LTM1hECUsqE+XEVHiBgf7UgGAyzrV2nSno8OkSlD+95eooGIdAqXMJK0OOHImXE1YSKGrXpv3afEr7Wq0CE1uPw9RleY7L4qJ1pTDkqkxfuPW05wPBeIVVArk33z2Q3qWciiRFJMokrAghj8TrILLFecA9ywdaTEgVUSbs4AmPdZ3hiUUIDLEolyrN8QZTsnsy2hMMHQkgSWOijyt1Pl11VVoH/2zc6V5MbjffQ2u0JELW6bdWv74NZn17WjHAt0ZjF+41b0+6d55Jo6s5Ea1cfdr/YWDivdI95EqYe+CVj6SUTGYSnSOuSKIm8ltiixhiyDgWQgZxClWcUUGRCMu6+GJhESOFxCSIi7p8LAbkxQH3GHoFcEO9Nl9yAzS3WNwJRrVK5XYao6X/nhFPmtqzCrcs/gtZ3xrIqk1bx52q3+K+aVy10yuNtoTJoYH8AWC8pftvGZW82pL7RCXzwkX5fUOAjwwsbc6OA/bqX21qePHK//qrF6Bu20J3js9urrqPhXhmcKoHzdoF8+HBYN7J3keD8baY3bbkPmA0arX87mSAjxQu37iBFMmrN7gh3fW/7rhpDKlc5Y0by4UBJrj7TK5Waw4NBqvx6hv6g3G/PNeviBnr8bQPAwtiMbBTDdkbDKbQKuQbbwJ9U83G384gMLbS0lLDfb+r0fevowuTiFjZVxuaQPe/GRJotO4TdYewmJ6mPcEIGwtiQ+lcWkelNKmMC4wKhCCThdbPl2bERtGTUKKQRBSTyFxafAUdY9J9LSbbrZH2BjOw9J85geGfAcG8xzuLD6wqnc4e4MGS/9p1OpX1AX769X8Bnx+6ZEiee7fUcFgw8T7PABDIY9XugSy4rJ5Oa0k/xiKKeF9EshpDKnlCCD0aA+SjoqqC8Mrw9PQwVua5EGJYI1GWIC1IYPqCAbfu3BvM6b8OtXVbMgJ9U/VL/PkJR0m7M8Dpujo85uDvTYn/00t1oIYxc0bwduir04cFc1IA/mCuOP5cYOJTIolMVoEwN1RKajxKyoOwU58yaAncGKIsTZbA4fGhkS7iMf/f3tWFOHHE8eH2I7v52NwNi242ZZJsupuQ6/aaQDZklxrDNcKJoQEhkBylKEcwpPXIIRTvwEqgLaVQ5aAtih8UIvfki7UeFrHKVXzoW18O9UGwior0xZe+VOiuSr27nejenZdey/4ectz/Pzvzy2/n47+zMxPDGIvmDcYmzMSHToQ5eeng4x+v7sUxPfrY2qNlnaUDPsa8Wn/6Zsma8I58//gI7vq9V+/+dPDSydUKsyQE69GUYqonJzO8p5QuiWNtOGD2KCUKdMS4nvYT0U5WyXcCgYQ8qfoY1UjbhIk8f8buLcxnhw4denT62Pm7V6/h7vipGz9stbbEm6lOYFbwvnfiC9NhysaeuHEU903fv/jn+WOnH31OrUqYbZ9sA446X9Bjt4a1RfSFh7KNSv9MafQWZtuuXbuePHjYWLy9D1fCgRvWKphtE2Yq3O53dqfpmLC+xS83TuGu33d78Y+HD57sXJ0wthVUrzmOsWZN33HQlL65893t3+/jdkdQ317fBzDhif3u7bh+AOfbcf/i7TM351bXlOzrEl53HONs2mHP2Znd8/PYMATMXKCclUxdmMHaf54/e3Lm7J7VCENNvAVeIUwlkF62iCTBA/js9SOsqFknNealwlgHQu376Mtb89fenbt3BXvh3v1O78l+bOe99cq9uTeuzd86YlW8tENh7CuoSDYMYZCE0LsFstZDZD4tyTpNJ3h/XjOIeGsSNMtto0QMj2focoldZ42Jwi3e7KkDvy3CwU/P3amaZUeelS2xNUiwEqxEsjeHghAODpq0hkx3ynQRT12pCISk6QqbrqrlglnLVTOv3MKaLtMdrpqur8/NRcjFizOEeSXnTJiJt221lKTaCOWKqEvI3UEzvK0DISbyMUaY1uPRAaOkB8BIopQfzUULCU5ddubJGmpM6jIar6CFv+YuI+bXhW5yEiFfCHUrGTQVbqEyOYsMqWttW0DqMEKeOOrWFDRL1lGDnEJirYviHoR0FSF/DHVh1HSVUWtoCmXILgpBhAJJhPL6wkK2cHmBlNHUUDfhTBh7XLByoioaN5hiTWyqYp2L8ZxQ7gC1MJpTtQZTGB0LkeusMVZT+ur48Q/MAXn3YbBBOLwbgDfPPH2FmV7z70RipjbZMCBqoCZVB4PBlK8KWB8ZoXwpr/kHM0UeXEPnS1GgTxh4bcL0Z1QCm1+YSpBdH8KD/09hgilynWAdCBOBbLW2SYVp95nS0pPVghpNCmISACnWZxav7nxhRmeYdofBYbqHeRJrbrfx5hWZjC8RBnbpQFGiQVJsmCwYfL49zNOrSr3CrMuvHK7ZnMfj4ULWpw26gjWr41jzaAFrnjSWm5f+Sg4xPl00JgOAimRNT6LuwaLux1n5Mjaxv1cmiWX/5iKOKlYthzUP4WWtJrFmCTu9BFJjLymYjwWTL859y+MT4c0RfjWpgbq2JoeLH1i213kQWLOZHGf29szEISI9H6axLLx48xpZdMbtfREVUDzpDOa2pA0+Yz83Lqslc+OxlV+B4jQemwkOOi6hx+BqcsG+yiSvJDP2A5SgkPeNl2xCJoQiFAveVesSFCUBR5TTUqK97O2KkpJthZTreggqKx+ZWCXDaYTiiIVXrGESsmFx1E/bWmktJJosbOv05cY0nRVsy97UshjHZOJAmJxht/qNsAjtVJkyKkuirWJmeFHwiCuj3Yjc3q5lm45YsHIOkzAs5AL5kO2dTbqM6lC29aBiXjESzcpKcyzWpHl7Jg7CHRHT+8pCLo8b1cLTftle53NKGtp/v4kaMfz8q4fG5/cVl1Bt6CkNN6vRScj2DtXX1Gtih8K0R0Lj1vuQs9lAARf/RXiXVMSIbVqKJfvDgl3CwvuvsVg2CmQEqQJrRsX8jEJYzVGVrBky+Ia8kjVFA0PebGTjWaQyQnYIpoRULUUY0BfMsaRZLAtJVpIAYdJj+8FieZjSmNIFg2vBWH24pXIho1M3RkCVLqt1Ja3VA4VCObrxLKRGq22ymMoGGgMttURvD5SNEogU63mTRbMco+Nlrc9dUk7hRuP89iIhT8XiWUOAiiAZIKnMxpjp5gDHRVul4Y1nAcVYqeA36Irc4opQaEpik9BAQpyNBQYUplOKNkb1fjeldDUwKhC0GtLG6OG8Lo4xKR1AQ+OTfCI0O5zmo8k+NKWB4EhJI4ppWksUhtW0mJiuMKBmNHk+6aenmAF/NL+J+mWWi1Y3AY2AEd5sIxbrsnDhwoULFy5cuHDhwoULFy5cuFiGvwFUNVebBEfgOwAAAABJRU5ErkJggg=="> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_perimeters.html#sphx-glr-auto-examples-segmentation-plot-perimeters-py"><span class="std std-ref">Different perimeters</span></a></span></p> </div> </div>   <h2 id="points-in-poly">points_in_poly</h2> <dl class="function"> <dt id="skimage.measure.points_in_poly">
<code>skimage.measure.points_in_poly(points, verts)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/pnpoly.py#L32-L53"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Test whether points lie inside a polygon.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>points(N, 2) array</code> </dt>
<dd>
<p>Input points, <code>(x, y)</code>.</p> </dd> <dt>
<code>verts(M, 2) array</code> </dt>
<dd>
<p>Vertices of the polygon, sorted either clockwise or anti-clockwise. The first point may (but does not need to be) duplicated.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>mask(N,) array of bool</code> </dt>
<dd>
<p>True if corresponding point is inside the polygon.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.measure.grid_points_in_poly" title="skimage.measure.grid_points_in_poly"><code>grid_points_in_poly</code></a>
</dt>
 </dl> </div> </dd>
</dl>   <h2 id="profile-line">profile_line</h2> <dl class="function"> <dt id="skimage.measure.profile_line">
<code>skimage.measure.profile_line(image, src, dst, linewidth=1, order=None, mode=None, cval=0.0, *, reduce_func=&lt;function mean&gt;)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/profile.py#L8-L127"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the intensity profile of an image measured along a scan line.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray, shape (M, N[, C])</code> </dt>
<dd>
<p>The image, either grayscale (2D array) or multichannel (3D array, where the final axis contains the channel information).</p> </dd> <dt>
<code>srcarray_like, shape (2, )</code> </dt>
<dd>
<p>The coordinates of the start point of the scan line.</p> </dd> <dt>
<code>dstarray_like, shape (2, )</code> </dt>
<dd>
<p>The coordinates of the end point of the scan line. The destination point is <em>included</em> in the profile, in contrast to standard numpy indexing.</p> </dd> <dt>
<code>linewidthint, optional</code> </dt>
<dd>
<p>Width of the scan, perpendicular to the line</p> </dd> <dt>
<code>orderint in {0, 1, 2, 3, 4, 5}, optional</code> </dt>
<dd>
<p>The order of the spline interpolation, default is 0 if image.dtype is bool and 1 otherwise. The order has to be in the range 0-5. See <a class="reference internal" href="skimage.transform#skimage.transform.warp" title="skimage.transform.warp"><code>skimage.transform.warp</code></a> for detail.</p> </dd> <dt>
<code>mode{‘constant’, ‘nearest’, ‘reflect’, ‘mirror’, ‘wrap’}, optional</code> </dt>
<dd>
<p>How to compute any values falling outside of the image.</p> </dd> <dt>
<code>cvalfloat, optional</code> </dt>
<dd>
<p>If <code>mode</code> is ‘constant’, what constant value to use outside the image.</p> </dd> <dt>
<code>reduce_funccallable, optional</code> </dt>
<dd>
<p>Function used to calculate the aggregation of pixel values perpendicular to the profile_line direction when <code>linewidth</code> &gt; 1. If set to None the unreduced array will be returned.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>return_valuearray</code> </dt>
<dd>
<p>The intensity profile along the scan line. The length of the profile is the ceil of the computed length of the scan line.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; x = np.array([[1, 1, 1, 2, 2, 2]])
&gt;&gt;&gt; img = np.vstack([np.zeros_like(x), x, x, x, np.zeros_like(x)])
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0, 0],
       [1, 1, 1, 2, 2, 2],
       [1, 1, 1, 2, 2, 2],
       [1, 1, 1, 2, 2, 2],
       [0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; profile_line(img, (2, 1), (2, 4))
array([1., 1., 2., 2.])
&gt;&gt;&gt; profile_line(img, (1, 0), (1, 6), cval=4)
array([1., 1., 1., 2., 2., 2., 4.])
</pre> <p>The destination point is included in the profile, in contrast to standard numpy indexing. For example:</p> <pre data-language="python">&gt;&gt;&gt; profile_line(img, (1, 0), (1, 6))  # The final point is out of bounds
array([1., 1., 1., 2., 2., 2., 0.])
&gt;&gt;&gt; profile_line(img, (1, 0), (1, 5))  # This accesses the full first row
array([1., 1., 1., 2., 2., 2.])
</pre> <p>For different reduce_func inputs:</p> <pre data-language="python">&gt;&gt;&gt; profile_line(img, (1, 0), (1, 3), linewidth=3, reduce_func=np.mean)
array([0.66666667, 0.66666667, 0.66666667, 1.33333333])
&gt;&gt;&gt; profile_line(img, (1, 0), (1, 3), linewidth=3, reduce_func=np.max)
array([1, 1, 1, 2])
&gt;&gt;&gt; profile_line(img, (1, 0), (1, 3), linewidth=3, reduce_func=np.sum)
array([2, 2, 2, 4])
</pre> <p>The unreduced array will be returned when <code>reduce_func</code> is None or when <code>reduce_func</code> acts on each pixel value individually.</p> <pre data-language="python">&gt;&gt;&gt; profile_line(img, (1, 2), (4, 2), linewidth=3, order=0,
...     reduce_func=None)
array([[1, 1, 2],
       [1, 1, 2],
       [1, 1, 2],
       [0, 0, 0]])
&gt;&gt;&gt; profile_line(img, (1, 0), (1, 3), linewidth=3, reduce_func=np.sqrt)
array([[1.        , 1.        , 0.        ],
       [1.        , 1.        , 0.        ],
       [1.        , 1.        , 0.        ],
       [1.41421356, 1.41421356, 0.        ]])
</pre> </dd>
</dl>   <h2 id="ransac">ransac</h2> <dl class="function"> <dt id="skimage.measure.ransac">
<code>skimage.measure.ransac(data, model_class, min_samples, residual_threshold, is_data_valid=None, is_model_valid=None, max_trials=100, stop_sample_num=inf, stop_residuals_sum=0, stop_probability=1, random_state=None, initial_inliers=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L621-L881"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit a model to data with the RANSAC (random sample consensus) algorithm.</p> <p>RANSAC is an iterative algorithm for the robust estimation of parameters from a subset of inliers from the complete data set. Each iteration performs the following tasks:</p> <ol class="arabic simple"> <li>Select <code>min_samples</code> random samples from the original data and check whether the set of data is valid (see <code>is_data_valid</code>).</li> <li>Estimate a model to the random subset (<code>model_cls.estimate(*data[random_subset]</code>) and check whether the estimated model is valid (see <code>is_model_valid</code>).</li> <li>Classify all data as inliers or outliers by calculating the residuals to the estimated model (<code>model_cls.residuals(*data)</code>) - all data samples with residuals smaller than the <code>residual_threshold</code> are considered as inliers.</li> <li>Save estimated model as best model if number of inlier samples is maximal. In case the current estimated model has the same number of inliers, it is only considered as the best model if it has less sum of residuals.</li> </ol> <p>These steps are performed either a maximum number of times or until one of the special stop criteria are met. The final model is estimated using all inlier samples of the previously determined best model.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>data[list, tuple of] (N, …) array</code> </dt>
<dd>
<p>Data set to which the model is fitted, where N is the number of data points and the remaining dimension are depending on model requirements. If the model class requires multiple input data arrays (e.g. source and destination coordinates of <code>skimage.transform.AffineTransform</code>), they can be optionally passed as tuple or list. Note, that in this case the functions <code>estimate(*data)</code>, <code>residuals(*data)</code>, <code>is_model_valid(model, *random_data)</code> and <code>is_data_valid(*random_data)</code> must all take each data array as separate arguments.</p> </dd> <dt>
<code>model_classobject</code> </dt>
<dd>
<p>Object with the following object methods:</p>  <ul class="simple"> <li><code>success = estimate(*data)</code></li> <li><code>residuals(*data)</code></li> </ul>  <p>where <code>success</code> indicates whether the model estimation succeeded (<code>True</code> or <code>None</code> for success, <code>False</code> for failure).</p> </dd> <dt>
<code>min_samplesint in range (0, N)</code> </dt>
<dd>
<p>The minimum number of data points to fit a model to.</p> </dd> <dt>
<code>residual_thresholdfloat larger than 0</code> </dt>
<dd>
<p>Maximum distance for a data point to be classified as an inlier.</p> </dd> <dt>
<code>is_data_validfunction, optional</code> </dt>
<dd>
<p>This function is called with the randomly selected data before the model is fitted to it: <code>is_data_valid(*random_data)</code>.</p> </dd> <dt>
<code>is_model_validfunction, optional</code> </dt>
<dd>
<p>This function is called with the estimated model and the randomly selected data: <code>is_model_valid(model, *random_data)</code>, .</p> </dd> <dt>
<code>max_trialsint, optional</code> </dt>
<dd>
<p>Maximum number of iterations for random sample selection.</p> </dd> <dt>
<code>stop_sample_numint, optional</code> </dt>
<dd>
<p>Stop iteration if at least this number of inliers are found.</p> </dd> <dt>
<code>stop_residuals_sumfloat, optional</code> </dt>
<dd>
<p>Stop iteration if sum of residuals is less than or equal to this threshold.</p> </dd> <dt>
<code>stop_probabilityfloat in range [0, 1], optional</code> </dt>
<dd>
<p>RANSAC iteration stops if at least one outlier-free set of the training data is sampled with <code>probability &gt;= stop_probability</code>, depending on the current best model’s inlier ratio and the number of trials. This requires to generate at least N samples (trials):</p>  <p>N &gt;= log(1 - probability) / log(1 - e**m)</p>  <p>where the probability (confidence) is typically set to a high value such as 0.99, e is the current fraction of inliers w.r.t. the total number of samples, and m is the min_samples value.</p> </dd> <dt>
<code>random_stateint, RandomState instance or None, optional</code> </dt>
<dd>
<p>If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by <code>np.random</code>.</p> </dd> <dt>
<code>initial_inliersarray-like of bool, shape (N,), optional</code> </dt>
<dd>
<p>Initial samples selection for model estimation</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>modelobject</code> </dt>
<dd>
<p>Best model with largest consensus set.</p> </dd> <dt>
<code>inliers(N, ) array</code> </dt>
<dd>
<p>Boolean mask of inliers classified as <code>True</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="radbaf2717b1f-1">
<code>1</code> </dt> <dd>
<p>“RANSAC”, Wikipedia, <a class="reference external" href="https://en.wikipedia.org/wiki/RANSAC">https://en.wikipedia.org/wiki/RANSAC</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <p>Generate ellipse data without tilt and add noise:</p> <pre data-language="python">&gt;&gt;&gt; t = np.linspace(0, 2 * np.pi, 50)
&gt;&gt;&gt; xc, yc = 20, 30
&gt;&gt;&gt; a, b = 5, 10
&gt;&gt;&gt; x = xc + a * np.cos(t)
&gt;&gt;&gt; y = yc + b * np.sin(t)
&gt;&gt;&gt; data = np.column_stack([x, y])
&gt;&gt;&gt; np.random.seed(seed=1234)
&gt;&gt;&gt; data += np.random.normal(size=data.shape)
</pre> <p>Add some faulty data:</p> <pre data-language="python">&gt;&gt;&gt; data[0] = (100, 100)
&gt;&gt;&gt; data[1] = (110, 120)
&gt;&gt;&gt; data[2] = (120, 130)
&gt;&gt;&gt; data[3] = (140, 130)
</pre> <p>Estimate ellipse model using all available data:</p> <pre data-language="python">&gt;&gt;&gt; model = EllipseModel()
&gt;&gt;&gt; model.estimate(data)
True
&gt;&gt;&gt; np.round(model.params)  
array([ 72.,  75.,  77.,  14.,   1.])
</pre> <p>Estimate ellipse model using RANSAC:</p> <pre data-language="python">&gt;&gt;&gt; ransac_model, inliers = ransac(data, EllipseModel, 20, 3, max_trials=50)
&gt;&gt;&gt; abs(np.round(ransac_model.params))
array([20., 30.,  5., 10.,  0.])
&gt;&gt;&gt; inliers 
array([False, False, False, False,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True], dtype=bool)
&gt;&gt;&gt; sum(inliers) &gt; 40
True
</pre> <p>RANSAC can be used to robustly estimate a geometric transformation. In this section, we also show how to use a proportion of the total samples, rather than an absolute number.</p> <pre data-language="python">&gt;&gt;&gt; from skimage.transform import SimilarityTransform
&gt;&gt;&gt; np.random.seed(0)
&gt;&gt;&gt; src = 100 * np.random.rand(50, 2)
&gt;&gt;&gt; model0 = SimilarityTransform(scale=0.5, rotation=1, translation=(10, 20))
&gt;&gt;&gt; dst = model0(src)
&gt;&gt;&gt; dst[0] = (10000, 10000)
&gt;&gt;&gt; dst[1] = (-100, 100)
&gt;&gt;&gt; dst[2] = (50, 50)
&gt;&gt;&gt; ratio = 0.5  # use half of the samples
&gt;&gt;&gt; min_samples = int(ratio * len(src))
&gt;&gt;&gt; model, inliers = ransac((src, dst), SimilarityTransform, min_samples, 10,
...                         initial_inliers=np.ones(len(src), dtype=bool))
&gt;&gt;&gt; inliers
array([False, False, False,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True])
</pre> </dd>
</dl>   <h2 id="regionprops">regionprops</h2> <dl class="function"> <dt id="skimage.measure.regionprops">
<code>skimage.measure.regionprops(label_image, intensity_image=None, cache=True, coordinates=None, *, extra_properties=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_regionprops.py#L867-L1159"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Measure properties of labeled image regions.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>label_image(M, N[, P]) ndarray</code> </dt>
<dd>
<p>Labeled input image. Labels with value 0 are ignored.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.14.1: </span>Previously, <code>label_image</code> was processed by <code>numpy.squeeze</code> and so any number of singleton dimensions was allowed. This resulted in inconsistent handling of images with singleton dimensions. To recover the old behaviour, use <code>regionprops(np.squeeze(label_image), ...)</code>.</p> </div> </dd> <dt>
<code>intensity_image(M, N[, P][, C]) ndarray, optional</code> </dt>
<dd>
<p>Intensity (i.e., input) image with same size as labeled image, plus optionally an extra dimension for multichannel data. Default is None.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.18.0: </span>The ability to provide an extra dimension for channels was added.</p> </div> </dd> <dt>
<code>cachebool, optional</code> </dt>
<dd>
<p>Determine whether to cache calculated properties. The computation is much faster for cached properties, whereas the memory consumption increases.</p> </dd> <dt>
<code>coordinatesDEPRECATED</code> </dt>
<dd>
<p>This argument is deprecated and will be removed in a future version of scikit-image.</p> <p>See <a class="reference internal" href="../user_guide/numpy_images#numpy-images-coordinate-conventions"><span class="std std-ref">Coordinate conventions</span></a> for more details.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 0.16.0: </span>Use “rc” coordinates everywhere. It may be sufficient to call <code>numpy.transpose</code> on your label image to get the same values as 0.15 and earlier. However, for some properties, the transformation will be less trivial. For example, the new orientation is <span class="math notranslate nohighlight">\(\frac{\pi}{2}\)</span> plus the old orientation.</p> </div> </dd> <dt>
<code>extra_propertiesIterable of callables</code> </dt>
<dd>
<p>Add extra property computation functions that are not included with skimage. The name of the property is derived from the function name, the dtype is inferred by calling the function on a small sample. If the name of an extra property clashes with the name of an existing property the extra property wil not be visible and a UserWarning is issued. A property computation function must take a region mask as its first argument. If the property requires an intensity image, it must accept the intensity image as the second argument.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>propertieslist of RegionProperties</code> </dt>
<dd>
<p>Each item describes one labeled region, and can be accessed using the attributes listed below.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.measure.label" title="skimage.measure.label"><code>label</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>The following properties can be accessed as attributes or keys:</p> <dl> <dt>
<code>areaint</code> </dt>
<dd>
<p>Number of pixels of the region.</p> </dd> <dt>
<code>bboxtuple</code> </dt>
<dd>
<p>Bounding box <code>(min_row, min_col, max_row, max_col)</code>. Pixels belonging to the bounding box are in the half-open interval <code>[min_row; max_row)</code> and <code>[min_col; max_col)</code>.</p> </dd> <dt>
<code>bbox_areaint</code> </dt>
<dd>
<p>Number of pixels of bounding box.</p> </dd> <dt>
<code>centroidarray</code> </dt>
<dd>
<p>Centroid coordinate tuple <code>(row, col)</code>.</p> </dd> <dt>
<code>convex_areaint</code> </dt>
<dd>
<p>Number of pixels of convex hull image, which is the smallest convex polygon that encloses the region.</p> </dd> <dt>
<code>convex_image(H, J) ndarray</code> </dt>
<dd>
<p>Binary convex hull image which has the same size as bounding box.</p> </dd> <dt>
<code>coords(N, 2) ndarray</code> </dt>
<dd>
<p>Coordinate list <code>(row, col)</code> of the region.</p> </dd> <dt>
<code>eccentricityfloat</code> </dt>
<dd>
<p>Eccentricity of the ellipse that has the same second-moments as the region. The eccentricity is the ratio of the focal distance (distance between focal points) over the major axis length. The value is in the interval [0, 1). When it is 0, the ellipse becomes a circle.</p> </dd> <dt>
<code>equivalent_diameterfloat</code> </dt>
<dd>
<p>The diameter of a circle with the same area as the region.</p> </dd> <dt>
<code>euler_numberint</code> </dt>
<dd>
<p>Euler characteristic of the set of non-zero pixels. Computed as number of connected components subtracted by number of holes (input.ndim connectivity). In 3D, number of connected components plus number of holes subtracted by number of tunnels.</p> </dd> <dt>
<code>extentfloat</code> </dt>
<dd>
<p>Ratio of pixels in the region to pixels in the total bounding box. Computed as <code>area / (rows * cols)</code></p> </dd> <dt>
<code>feret_diameter_maxfloat</code> </dt>
<dd>
<p>Maximum Feret’s diameter computed as the longest distance between points around a region’s convex hull contour as determined by <code>find_contours</code>. <a class="reference internal" href="#r4a29d8446b4f-5" id="id42">[5]</a></p> </dd> <dt>
<code>filled_areaint</code> </dt>
<dd>
<p>Number of pixels of the region will all the holes filled in. Describes the area of the filled_image.</p> </dd> <dt>
<code>filled_image(H, J) ndarray</code> </dt>
<dd>
<p>Binary region image with filled holes which has the same size as bounding box.</p> </dd> <dt>
<code>image(H, J) ndarray</code> </dt>
<dd>
<p>Sliced binary region image which has the same size as bounding box.</p> </dd> <dt>
<code>inertia_tensorndarray</code> </dt>
<dd>
<p>Inertia tensor of the region for the rotation around its mass.</p> </dd> <dt>
<code>inertia_tensor_eigvalstuple</code> </dt>
<dd>
<p>The eigenvalues of the inertia tensor in decreasing order.</p> </dd> <dt>
<code>intensity_imagendarray</code> </dt>
<dd>
<p>Image inside region bounding box.</p> </dd> <dt>
<code>labelint</code> </dt>
<dd>
<p>The label in the labeled input image.</p> </dd> <dt>
<code>local_centroidarray</code> </dt>
<dd>
<p>Centroid coordinate tuple <code>(row, col)</code>, relative to region bounding box.</p> </dd> <dt>
<code>major_axis_lengthfloat</code> </dt>
<dd>
<p>The length of the major axis of the ellipse that has the same normalized second central moments as the region.</p> </dd> <dt>
<code>max_intensityfloat</code> </dt>
<dd>
<p>Value with the greatest intensity in the region.</p> </dd> <dt>
<code>mean_intensityfloat</code> </dt>
<dd>
<p>Value with the mean intensity in the region.</p> </dd> <dt>
<code>min_intensityfloat</code> </dt>
<dd>
<p>Value with the least intensity in the region.</p> </dd> <dt>
<code>minor_axis_lengthfloat</code> </dt>
<dd>
<p>The length of the minor axis of the ellipse that has the same normalized second central moments as the region.</p> </dd> <dt>
<code>moments(3, 3) ndarray</code> </dt>
<dd>
<p>Spatial moments up to 3rd order:</p> <pre data-language="python">m_ij = sum{ array(row, col) * row^i * col^j }
</pre> <p>where the sum is over the <code>row</code>, <code>col</code> coordinates of the region.</p> </dd> <dt>
<code>moments_central(3, 3) ndarray</code> </dt>
<dd>
<p>Central moments (translation invariant) up to 3rd order:</p> <pre data-language="python">mu_ij = sum{ array(row, col) * (row - row_c)^i * (col - col_c)^j }
</pre> <p>where the sum is over the <code>row</code>, <code>col</code> coordinates of the region, and <code>row_c</code> and <code>col_c</code> are the coordinates of the region’s centroid.</p> </dd> <dt>
<code>moments_hutuple</code> </dt>
<dd>
<p>Hu moments (translation, scale and rotation invariant).</p> </dd> <dt>
<code>moments_normalized(3, 3) ndarray</code> </dt>
<dd>
<p>Normalized moments (translation and scale invariant) up to 3rd order:</p> <pre data-language="python">nu_ij = mu_ij / m_00^[(i+j)/2 + 1]
</pre> <p>where <code>m_00</code> is the zeroth spatial moment.</p> </dd> <dt>
<code>orientationfloat</code> </dt>
<dd>
<p>Angle between the 0th axis (rows) and the major axis of the ellipse that has the same second moments as the region, ranging from <code>-pi/2</code> to <code>pi/2</code> counter-clockwise.</p> </dd> <dt>
<code>perimeterfloat</code> </dt>
<dd>
<p>Perimeter of object which approximates the contour as a line through the centers of border pixels using a 4-connectivity.</p> </dd> <dt>
<code>perimeter_croftonfloat</code> </dt>
<dd>
<p>Perimeter of object approximated by the Crofton formula in 4 directions.</p> </dd> <dt>
<code>slicetuple of slices</code> </dt>
<dd>
<p>A slice to extract the object from the source image.</p> </dd> <dt>
<code>solidityfloat</code> </dt>
<dd>
<p>Ratio of pixels in the region to pixels of the convex hull image.</p> </dd> <dt>
<code>weighted_centroidarray</code> </dt>
<dd>
<p>Centroid coordinate tuple <code>(row, col)</code> weighted with intensity image.</p> </dd> <dt>
<code>weighted_local_centroidarray</code> </dt>
<dd>
<p>Centroid coordinate tuple <code>(row, col)</code>, relative to region bounding box, weighted with intensity image.</p> </dd> <dt>
<code>weighted_moments(3, 3) ndarray</code> </dt>
<dd>
<p>Spatial moments of intensity image up to 3rd order:</p> <pre data-language="python">wm_ij = sum{ array(row, col) * row^i * col^j }
</pre> <p>where the sum is over the <code>row</code>, <code>col</code> coordinates of the region.</p> </dd> <dt>
<code>weighted_moments_central(3, 3) ndarray</code> </dt>
<dd>
<p>Central moments (translation invariant) of intensity image up to 3rd order:</p> <pre data-language="python">wmu_ij = sum{ array(row, col) * (row - row_c)^i * (col - col_c)^j }
</pre> <p>where the sum is over the <code>row</code>, <code>col</code> coordinates of the region, and <code>row_c</code> and <code>col_c</code> are the coordinates of the region’s weighted centroid.</p> </dd> <dt>
<code>weighted_moments_hutuple</code> </dt>
<dd>
<p>Hu moments (translation, scale and rotation invariant) of intensity image.</p> </dd> <dt>
<code>weighted_moments_normalized(3, 3) ndarray</code> </dt>
<dd>
<p>Normalized moments (translation and scale invariant) of intensity image up to 3rd order:</p> <pre data-language="python">wnu_ij = wmu_ij / wm_00^[(i+j)/2 + 1]
</pre> <p>where <code>wm_00</code> is the zeroth spatial moment (intensity-weighted area).</p> </dd> </dl> <p>Each region also supports iteration, so that you can do:</p> <pre data-language="python">for prop in region:
    print(prop, region[prop])
</pre> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r4a29d8446b4f-1">
<code>1</code> </dt> <dd>
<p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing: Core Algorithms. Springer-Verlag, London, 2009.</p> </dd> <dt class="label" id="r4a29d8446b4f-2">
<code>2</code> </dt> <dd>
<p>B. Jähne. Digital Image Processing. Springer-Verlag, Berlin-Heidelberg, 6. edition, 2005.</p> </dd> <dt class="label" id="r4a29d8446b4f-3">
<code>3</code> </dt> <dd>
<p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image Features, from Lecture notes in computer science, p. 676. Springer, Berlin, 1993.</p> </dd> <dt class="label" id="r4a29d8446b4f-4">
<code>4</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p> </dd> <dt class="label" id="r4a29d8446b4f-5">
<code>5</code> </dt> <dd>
<p>W. Pabst, E. Gregorová. Characterization of particles and particle systems, pp. 27-28. ICT Prague, 2007. <a class="reference external" href="https://old.vscht.cz/sil/keramika/Characterization_of_particles/CPPS%20_English%20version_.pdf">https://old.vscht.cz/sil/keramika/Characterization_of_particles/CPPS%20_English%20version_.pdf</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data, util
&gt;&gt;&gt; from skimage.measure import label, regionprops
&gt;&gt;&gt; img = util.img_as_ubyte(data.coins()) &gt; 110
&gt;&gt;&gt; label_img = label(img, connectivity=img.ndim)
&gt;&gt;&gt; props = regionprops(label_img)
&gt;&gt;&gt; # centroid of first labeled object
&gt;&gt;&gt; props[0].centroid
(22.72987986048314, 81.91228523446583)
&gt;&gt;&gt; # centroid of first labeled object
&gt;&gt;&gt; props[0]['centroid']
(22.72987986048314, 81.91228523446583)
</pre> <p>Add custom measurements by passing functions as <code>extra_properties</code></p> <pre data-language="python">&gt;&gt;&gt; from skimage import data, util
&gt;&gt;&gt; from skimage.measure import label, regionprops
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; img = util.img_as_ubyte(data.coins()) &gt; 110
&gt;&gt;&gt; label_img = label(img, connectivity=img.ndim)
&gt;&gt;&gt; def pixelcount(regionmask):
...     return np.sum(regionmask)
&gt;&gt;&gt; props = regionprops(label_img, extra_properties=(pixelcount,))
&gt;&gt;&gt; props[0].pixelcount
7741
&gt;&gt;&gt; props[1]['pixelcount']
42
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-measure-regionprops">Examples using <code>skimage.measure.regionprops</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima...">
<div class="figure align-default" id="id60"> <img alt="Measure region properties" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></span></p> </div> </div>   <h2 id="regionprops-table">regionprops_table</h2> <dl class="function"> <dt id="skimage.measure.regionprops_table">
<code>skimage.measure.regionprops_table(label_image, intensity_image=None, properties=('label', 'bbox'), *, cache=True, separator='-', extra_properties=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_regionprops.py#L705-L864"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute image properties and return them as a pandas-compatible table.</p> <p>The table is a dictionary mapping column names to value arrays. See Notes section below for details.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.16.</span></p> </div> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>label_image(N, M[, P]) ndarray</code> </dt>
<dd>
<p>Labeled input image. Labels with value 0 are ignored.</p> </dd> <dt>
<code>intensity_image(M, N[, P][, C]) ndarray, optional</code> </dt>
<dd>
<p>Intensity (i.e., input) image with same size as labeled image, plus optionally an extra dimension for multichannel data. Default is None.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.18.0: </span>The ability to provide an extra dimension for channels was added.</p> </div> </dd> <dt>
<code>propertiestuple or list of str, optional</code> </dt>
<dd>
<p>Properties that will be included in the resulting dictionary For a list of available properties, please see <a class="reference internal" href="#skimage.measure.regionprops" title="skimage.measure.regionprops"><code>regionprops()</code></a>. Users should remember to add “label” to keep track of region identities.</p> </dd> <dt>
<code>cachebool, optional</code> </dt>
<dd>
<p>Determine whether to cache calculated properties. The computation is much faster for cached properties, whereas the memory consumption increases.</p> </dd> <dt>
<code>separatorstr, optional</code> </dt>
<dd>
<p>For non-scalar properties not listed in OBJECT_COLUMNS, each element will appear in its own column, with the index of that element separated from the property name by this separator. For example, the inertia tensor of a 2D region will appear in four columns: <code>inertia_tensor-0-0</code>, <code>inertia_tensor-0-1</code>, <code>inertia_tensor-1-0</code>, and <code>inertia_tensor-1-1</code> (where the separator is <code>-</code>).</p> <p>Object columns are those that cannot be split in this way because the number of columns would change depending on the object. For example, <code>image</code> and <code>coords</code>.</p> </dd> <dt>
<code>extra_propertiesIterable of callables</code> </dt>
<dd>
<p>Add extra property computation functions that are not included with skimage. The name of the property is derived from the function name, the dtype is inferred by calling the function on a small sample. If the name of an extra property clashes with the name of an existing property the extra property wil not be visible and a UserWarning is issued. A property computation function must take a region mask as its first argument. If the property requires an intensity image, it must accept the intensity image as the second argument.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>out_dictdict</code> </dt>
<dd>
<p>Dictionary mapping property names to an array of values of that property, one value per region. This dictionary can be used as input to pandas <code>DataFrame</code> to map property names to columns in the frame and regions to rows. If the image has no regions, the arrays will have length 0, but the correct type.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>Each column contains either a scalar property, an object property, or an element in a multidimensional array.</p> <p>Properties with scalar values for each region, such as “eccentricity”, will appear as a float or int array with that property name as key.</p> <p>Multidimensional properties <em>of fixed size</em> for a given image dimension, such as “centroid” (every centroid will have three elements in a 3D image, no matter the region size), will be split into that many columns, with the name {property_name}{separator}{element_num} (for 1D properties), {property_name}{separator}{elem_num0}{separator}{elem_num1} (for 2D properties), and so on.</p> <p>For multidimensional properties that don’t have a fixed size, such as “image” (the image of a region varies in size depending on the region size), an object array will be used, with the corresponding property name as the key.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data, util, measure
&gt;&gt;&gt; image = data.coins()
&gt;&gt;&gt; label_image = measure.label(image &gt; 110, connectivity=image.ndim)
&gt;&gt;&gt; props = measure.regionprops_table(label_image, image,
...                           properties=['label', 'inertia_tensor',
...                                       'inertia_tensor_eigvals'])
&gt;&gt;&gt; props  
{'label': array([ 1,  2, ...]), ...
 'inertia_tensor-0-0': array([  4.012...e+03,   8.51..., ...]), ...
 ...,
 'inertia_tensor_eigvals-1': array([  2.67...e+02,   2.83..., ...])}
</pre> <p>The resulting dictionary can be directly passed to pandas, if installed, to obtain a clean DataFrame:</p> <pre data-language="python">&gt;&gt;&gt; import pandas as pd  
&gt;&gt;&gt; data = pd.DataFrame(props)  
&gt;&gt;&gt; data.head()  
   label  inertia_tensor-0-0  ...  inertia_tensor_eigvals-1
0      1         4012.909888  ...                267.065503
1      2            8.514739  ...                  2.834806
2      3            0.666667  ...                  0.000000
3      4            0.000000  ...                  0.000000
4      5            0.222222  ...                  0.111111
</pre> <p>[5 rows x 7 columns]</p> <p>If we want to measure a feature that does not come as a built-in property, we can define custom functions and pass them as <code>extra_properties</code>. For example, we can create a custom function that measures the intensity quartiles in a region:</p> <pre data-language="python">&gt;&gt;&gt; from skimage import data, util, measure
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; def quartiles(regionmask, intensity):
...     return np.percentile(intensity[regionmask], q=(25, 50, 75))
&gt;&gt;&gt;
&gt;&gt;&gt; image = data.coins()
&gt;&gt;&gt; label_image = measure.label(image &gt; 110, connectivity=image.ndim)
&gt;&gt;&gt; props = measure.regionprops_table(label_image, intensity_image=image,
...                                   properties=('label',),
...                                   extra_properties=(quartiles,))
&gt;&gt;&gt; import pandas as pd 
&gt;&gt;&gt; pd.DataFrame(props).head() 
       label  quartiles-0  quartiles-1  quartiles-2
0      1       117.00        123.0        130.0
1      2       111.25        112.0        114.0
2      3       111.00        111.0        111.0
3      4       111.00        111.5        112.5
4      5       112.50        113.0        114.0
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-measure-regionprops-table">Examples using <code>skimage.measure.regionprops_table</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima...">
<div class="figure align-default" id="id61"> <img alt="Measure region properties" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></span></p> </div> </div>   <h2 id="shannon-entropy">shannon_entropy</h2> <dl class="function"> <dt id="skimage.measure.shannon_entropy">
<code>skimage.measure.shannon_entropy(image, base=2)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/entropy.py#L5-L41"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculate the Shannon entropy of an image.</p> <p>The Shannon entropy is defined as S = -sum(pk * log(pk)), where pk are frequency/probability of pixels of value k.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(N, M) ndarray</code> </dt>
<dd>
<p>Grayscale input image.</p> </dd> <dt>
<code>basefloat, optional</code> </dt>
<dd>
<p>The logarithmic base to use.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>entropyfloat</code> </dt>
 </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The returned value is measured in bits or shannon (Sh) for base=2, natural unit (nat) for base=np.e and hartley (Hart) for base=10.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rd3de3b6e4b40-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Entropy_(information_theory)">https://en.wikipedia.org/wiki/Entropy_(information_theory)</a></p> </dd> <dt class="label" id="rd3de3b6e4b40-2">
<code>2</code> </dt> <dd>
<p><a class="reference external" href="https://en.wiktionary.org/wiki/Shannon_entropy">https://en.wiktionary.org/wiki/Shannon_entropy</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; from skimage.measure import shannon_entropy
&gt;&gt;&gt; shannon_entropy(data.camera())
7.231695011055706
</pre> </dd>
</dl>   <h2 id="subdivide-polygon">subdivide_polygon</h2> <dl class="function"> <dt id="skimage.measure.subdivide_polygon">
<code>skimage.measure.subdivide_polygon(coords, degree=2, preserve_ends=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_polygon.py#L109-L168"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Subdivision of polygonal curves using B-Splines.</p> <p>Note that the resulting curve is always within the convex hull of the original polygon. Circular polygons stay closed after subdivision.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>coords(N, 2) array</code> </dt>
<dd>
<p>Coordinate array.</p> </dd> <dt>
<code>degree{1, 2, 3, 4, 5, 6, 7}, optional</code> </dt>
<dd>
<p>Degree of B-Spline. Default is 2.</p> </dd> <dt>
<code>preserve_endsbool, optional</code> </dt>
<dd>
<p>Preserve first and last coordinate of non-circular polygon. Default is False.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>coords(M, 2) array</code> </dt>
<dd>
<p>Subdivided coordinate array.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r13f3ce062a97-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="http://mrl.nyu.edu/publications/subdiv-course2000/coursenotes00.pdf">http://mrl.nyu.edu/publications/subdiv-course2000/coursenotes00.pdf</a></p> </dd> </dl> </dd>
</dl>   <h2 id="circlemodel">CircleModel</h2> <dl class="class"> <dt id="skimage.measure.CircleModel">
<code>class skimage.measure.CircleModel</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L221-L347"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.measure.fit.BaseModel</code></p> <p>Total least squares estimator for 2D circles.</p> <p>The functional model of the circle is:</p> <pre data-language="python">r**2 = (x - xc)**2 + (y - yc)**2
</pre> <p>This estimator minimizes the squared distances from all points to the circle:</p> <pre data-language="python">min{ sum((r - sqrt((x_i - xc)**2 + (y_i - yc)**2))**2) }
</pre> <p>A minimum number of 3 points is required to solve for the parameters.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; t = np.linspace(0, 2 * np.pi, 25)
&gt;&gt;&gt; xy = CircleModel().predict_xy(t, params=(2, 3, 4))
&gt;&gt;&gt; model = CircleModel()
&gt;&gt;&gt; model.estimate(xy)
True
&gt;&gt;&gt; tuple(np.round(model.params, 5))
(2.0, 3.0, 4.0)
&gt;&gt;&gt; res = model.residuals(xy)
&gt;&gt;&gt; np.abs(np.round(res, 9))
array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
       0., 0., 0., 0., 0., 0., 0., 0.])
</pre> <dl class="field-list simple"> <dt class="field-odd">Attributes</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>paramstuple</code> </dt>
<dd>
<p>Circle model parameters in the following order <code>xc</code>, <code>yc</code>, <code>r</code>.</p> </dd> </dl> </dd> </dl> <dl class="method"> <dt id="skimage.measure.CircleModel.__init__">
<code>__init__()</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L26-L27"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Initialize self. See help(type(self)) for accurate signature.</p> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.CircleModel.estimate">
<code>estimate(data)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L256-L295"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Estimate circle model from data using total least squares.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>data(N, 2) array</code> </dt>
<dd>
<p>N points with <code>(x, y)</code> coordinates, respectively.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>successbool</code> </dt>
<dd>
<p>True, if model estimation succeeds.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.CircleModel.predict_xy">
<code>predict_xy(t, params=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L323-L347"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict x- and y-coordinates using the estimated model.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>tarray</code> </dt>
<dd>
<p>Angles in circle in radians. Angles start to count from positive x-axis to positive y-axis in a right-handed system.</p> </dd> <dt>
<code>params(3, ) array, optional</code> </dt>
<dd>
<p>Optional custom parameter set.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>xy(…, 2) array</code> </dt>
<dd>
<p>Predicted x- and y-coordinates.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.CircleModel.residuals">
<code>residuals(data)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L297-L321"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Determine residuals of data to model.</p> <p>For each point the shortest distance to the circle is returned.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>data(N, 2) array</code> </dt>
<dd>
<p>N points with <code>(x, y)</code> coordinates, respectively.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>residuals(N, ) array</code> </dt>
<dd>
<p>Residual for each data point.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl>   <h2 id="ellipsemodel">EllipseModel</h2> <dl class="class"> <dt id="skimage.measure.EllipseModel">
<code>class skimage.measure.EllipseModel</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L350-L578"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.measure.fit.BaseModel</code></p> <p>Total least squares estimator for 2D ellipses.</p> <p>The functional model of the ellipse is:</p> <pre data-language="python">xt = xc + a*cos(theta)*cos(t) - b*sin(theta)*sin(t)
yt = yc + a*sin(theta)*cos(t) + b*cos(theta)*sin(t)
d = sqrt((x - xt)**2 + (y - yt)**2)
</pre> <p>where <code>(xt, yt)</code> is the closest point on the ellipse to <code>(x, y)</code>. Thus d is the shortest distance from the point to the ellipse.</p> <p>The estimator is based on a least squares minimization. The optimal solution is computed directly, no iterations are required. This leads to a simple, stable and robust fitting method.</p> <p>The <code>params</code> attribute contains the parameters in the following order:</p> <pre data-language="python">xc, yc, a, b, theta
</pre> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; xy = EllipseModel().predict_xy(np.linspace(0, 2 * np.pi, 25),
...                                params=(10, 15, 4, 8, np.deg2rad(30)))
&gt;&gt;&gt; ellipse = EllipseModel()
&gt;&gt;&gt; ellipse.estimate(xy)
True
&gt;&gt;&gt; np.round(ellipse.params, 2)
array([10.  , 15.  ,  4.  ,  8.  ,  0.52])
&gt;&gt;&gt; np.round(abs(ellipse.residuals(xy)), 5)
array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
       0., 0., 0., 0., 0., 0., 0., 0.])
</pre> <dl class="field-list simple"> <dt class="field-odd">Attributes</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>paramstuple</code> </dt>
<dd>
<p>Ellipse model parameters in the following order <code>xc</code>, <code>yc</code>, <code>a</code>, <code>b</code>, <code>theta</code>.</p> </dd> </dl> </dd> </dl> <dl class="method"> <dt id="skimage.measure.EllipseModel.__init__">
<code>__init__()</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L26-L27"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Initialize self. See help(type(self)) for accurate signature.</p> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.EllipseModel.estimate">
<code>estimate(data)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L391-L483"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Estimate circle model from data using total least squares.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>data(N, 2) array</code> </dt>
<dd>
<p>N points with <code>(x, y)</code> coordinates, respectively.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>successbool</code> </dt>
<dd>
<p>True, if model estimation succeeds.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rb82f40f15f1b-1">
<code>1</code> </dt> <dd>
<p>Halir, R.; Flusser, J. “Numerically stable direct least squares fitting of ellipses”. In Proc. 6th International Conference in Central Europe on Computer Graphics and Visualization. WSCG (Vol. 98, pp. 125-132).</p> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.EllipseModel.predict_xy">
<code>predict_xy(t, params=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L547-L578"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict x- and y-coordinates using the estimated model.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>tarray</code> </dt>
<dd>
<p>Angles in circle in radians. Angles start to count from positive x-axis to positive y-axis in a right-handed system.</p> </dd> <dt>
<code>params(5, ) array, optional</code> </dt>
<dd>
<p>Optional custom parameter set.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>xy(…, 2) array</code> </dt>
<dd>
<p>Predicted x- and y-coordinates.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.EllipseModel.residuals">
<code>residuals(data)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L485-L545"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Determine residuals of data to model.</p> <p>For each point the shortest distance to the ellipse is returned.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>data(N, 2) array</code> </dt>
<dd>
<p>N points with <code>(x, y)</code> coordinates, respectively.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>residuals(N, ) array</code> </dt>
<dd>
<p>Residual for each data point.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl>   <h2 id="linemodelnd">LineModelND</h2> <dl class="class"> <dt id="skimage.measure.LineModelND">
<code>class skimage.measure.LineModelND</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L30-L218"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.measure.fit.BaseModel</code></p> <p>Total least squares estimator for N-dimensional lines.</p> <p>In contrast to ordinary least squares line estimation, this estimator minimizes the orthogonal distances of points to the estimated line.</p> <p>Lines are defined by a point (origin) and a unit vector (direction) according to the following vector equation:</p> <pre data-language="python">X = origin + lambda * direction
</pre> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; x = np.linspace(1, 2, 25)
&gt;&gt;&gt; y = 1.5 * x + 3
&gt;&gt;&gt; lm = LineModelND()
&gt;&gt;&gt; lm.estimate(np.stack([x, y], axis=-1))
True
&gt;&gt;&gt; tuple(np.round(lm.params, 5))
(array([1.5 , 5.25]), array([0.5547 , 0.83205]))
&gt;&gt;&gt; res = lm.residuals(np.stack([x, y], axis=-1))
&gt;&gt;&gt; np.abs(np.round(res, 9))
array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
       0., 0., 0., 0., 0., 0., 0., 0.])
&gt;&gt;&gt; np.round(lm.predict_y(x[:5]), 3)
array([4.5  , 4.562, 4.625, 4.688, 4.75 ])
&gt;&gt;&gt; np.round(lm.predict_x(y[:5]), 3)
array([1.   , 1.042, 1.083, 1.125, 1.167])
</pre> <dl class="field-list simple"> <dt class="field-odd">Attributes</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>paramstuple</code> </dt>
<dd>
<p>Line model parameters in the following order <code>origin</code>, <code>direction</code>.</p> </dd> </dl> </dd> </dl> <dl class="method"> <dt id="skimage.measure.LineModelND.__init__">
<code>__init__()</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L26-L27"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Initialize self. See help(type(self)) for accurate signature.</p> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.LineModelND.estimate">
<code>estimate(data)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L66-L101"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Estimate line model from data.</p> <p>This minimizes the sum of shortest (orthogonal) distances from the given data points to the estimated line.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>data(N, dim) array</code> </dt>
<dd>
<p>N points in a space of dimensionality dim &gt;= 2.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>successbool</code> </dt>
<dd>
<p>True, if model estimation succeeds.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.LineModelND.predict">
<code>predict(x, axis=0, params=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L134-L172"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict intersection of the estimated line model with a hyperplane orthogonal to a given axis.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>x(n, 1) array</code> </dt>
<dd>
<p>Coordinates along an axis.</p> </dd> <dt>
<code>axisint</code> </dt>
<dd>
<p>Axis orthogonal to the hyperplane intersecting the line.</p> </dd> <dt>
<code>params(2, ) array, optional</code> </dt>
<dd>
<p>Optional custom parameter set in the form (<code>origin</code>, <code>direction</code>).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>data(n, m) array</code> </dt>
<dd>
<p>Predicted coordinates.</p> </dd> </dl> </dd> <dt class="field-odd">Raises</dt> <dd class="field-odd">
<dl class="simple"> <dt>ValueError</dt>
<dd>
<p>If the line is parallel to the given axis.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.LineModelND.predict_x">
<code>predict_x(y, params=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L174-L195"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict x-coordinates for 2D lines using the estimated model.</p> <p>Alias for:</p> <pre data-language="python">predict(y, axis=1)[:, 0]
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>yarray</code> </dt>
<dd>
<p>y-coordinates.</p> </dd> <dt>
<code>params(2, ) array, optional</code> </dt>
<dd>
<p>Optional custom parameter set in the form (<code>origin</code>, <code>direction</code>).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>xarray</code> </dt>
<dd>
<p>Predicted x-coordinates.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.LineModelND.predict_y">
<code>predict_y(x, params=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L197-L218"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict y-coordinates for 2D lines using the estimated model.</p> <p>Alias for:</p> <pre data-language="python">predict(x, axis=0)[:, 1]
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>xarray</code> </dt>
<dd>
<p>x-coordinates.</p> </dd> <dt>
<code>params(2, ) array, optional</code> </dt>
<dd>
<p>Optional custom parameter set in the form (<code>origin</code>, <code>direction</code>).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>yarray</code> </dt>
<dd>
<p>Predicted y-coordinates.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.LineModelND.residuals">
<code>residuals(data, params=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/fit.py#L103-L132"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Determine residuals of data to model.</p> <p>For each point, the shortest (orthogonal) distance to the line is returned. It is obtained by projecting the data onto the line.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>data(N, dim) array</code> </dt>
<dd>
<p>N points in a space of dimension dim.</p> </dd> <dt>
<code>params(2, ) array, optional</code> </dt>
<dd>
<p>Optional custom parameter set in the form (<code>origin</code>, <code>direction</code>).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>residuals(N, ) array</code> </dt>
<dd>
<p>Residual for each data point.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2019 the scikit-image team<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://scikit-image.org/docs/0.18.x/api/skimage.measure.html" class="_attribution-link">https://scikit-image.org/docs/0.18.x/api/skimage.measure.html</a>
  </p>
</div>
