<h1 id="module-restoration">Module: restoration</h1> <p id="module-skimage.restoration">Image restoration module.</p> <table class="longtable docutils align-default">   <tr>
<td><p><a class="reference internal" href="#skimage.restoration.ball_kernel" title="skimage.restoration.ball_kernel"><code>skimage.restoration.ball_kernel</code></a>(radius, ndim)</p></td> <td><p>Create a ball kernel for restoration.rolling_ball.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.restoration.calibrate_denoiser" title="skimage.restoration.calibrate_denoiser"><code>skimage.restoration.calibrate_denoiser</code></a>(…)</p></td> <td><p>Calibrate a denoising function and return optimal J-invariant version.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.restoration.cycle_spin" title="skimage.restoration.cycle_spin"><code>skimage.restoration.cycle_spin</code></a>(x, func, …)</p></td> <td><p>Cycle spinning (repeatedly apply func to shifted versions of x).</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.restoration.denoise_bilateral" title="skimage.restoration.denoise_bilateral"><code>skimage.restoration.denoise_bilateral</code></a>(image)</p></td> <td><p>Denoise image using bilateral filter.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.restoration.denoise_nl_means" title="skimage.restoration.denoise_nl_means"><code>skimage.restoration.denoise_nl_means</code></a>(image)</p></td> <td><p>Perform non-local means denoising on 2-D or 3-D grayscale images, and 2-D RGB images.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.restoration.denoise_tv_bregman" title="skimage.restoration.denoise_tv_bregman"><code>skimage.restoration.denoise_tv_bregman</code></a>(…)</p></td> <td><p>Perform total-variation denoising using split-Bregman optimization.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.restoration.denoise_tv_chambolle" title="skimage.restoration.denoise_tv_chambolle"><code>skimage.restoration.denoise_tv_chambolle</code></a>(image)</p></td> <td><p>Perform total-variation denoising on n-dimensional images.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.restoration.denoise_wavelet" title="skimage.restoration.denoise_wavelet"><code>skimage.restoration.denoise_wavelet</code></a>(image[, …])</p></td> <td><p>Perform wavelet denoising on an image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.restoration.ellipsoid_kernel" title="skimage.restoration.ellipsoid_kernel"><code>skimage.restoration.ellipsoid_kernel</code></a>(shape, …)</p></td> <td><p>Create an ellipoid kernel for restoration.rolling_ball.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.restoration.estimate_sigma" title="skimage.restoration.estimate_sigma"><code>skimage.restoration.estimate_sigma</code></a>(image[, …])</p></td> <td><p>Robust wavelet-based estimator of the (Gaussian) noise standard deviation.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.restoration.inpaint_biharmonic" title="skimage.restoration.inpaint_biharmonic"><code>skimage.restoration.inpaint_biharmonic</code></a>(…)</p></td> <td><p>Inpaint masked points in image with biharmonic equations.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.restoration.richardson_lucy" title="skimage.restoration.richardson_lucy"><code>skimage.restoration.richardson_lucy</code></a>(image, psf)</p></td> <td><p>Richardson-Lucy deconvolution.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.restoration.rolling_ball" title="skimage.restoration.rolling_ball"><code>skimage.restoration.rolling_ball</code></a>(image, *[, …])</p></td> <td><p>Estimate background intensity by rolling/translating a kernel.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.restoration.unsupervised_wiener" title="skimage.restoration.unsupervised_wiener"><code>skimage.restoration.unsupervised_wiener</code></a>(…)</p></td> <td><p>Unsupervised Wiener-Hunt deconvolution.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.restoration.unwrap_phase" title="skimage.restoration.unwrap_phase"><code>skimage.restoration.unwrap_phase</code></a>(image[, …])</p></td> <td><p>Recover the original from a wrapped phase image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.restoration.wiener" title="skimage.restoration.wiener"><code>skimage.restoration.wiener</code></a>(image, psf, balance)</p></td> <td><p>Wiener-Hunt deconvolution</p></td> </tr>  </table>  <h2 id="ball-kernel">ball_kernel</h2> <dl class="function"> <dt id="skimage.restoration.ball_kernel">
<code>skimage.restoration.ball_kernel(radius, ndim)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/restoration/rolling_ball.py#L117-L152"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a ball kernel for restoration.rolling_ball.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>radiusint</code> </dt>
<dd>
<p>Radius of the ball.</p> </dd> <dt>
<code>ndimint</code> </dt>
<dd>
<p>Number of dimensions of the ball. <code>ndim</code> should match the dimensionality of the image the kernel will be applied to.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>kernelndarray</code> </dt>
<dd>
<p>The kernel containing the surface intensity of the top half of the ellipsoid.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.restoration.rolling_ball" title="skimage.restoration.rolling_ball"><code>rolling_ball</code></a>
</dt>
 </dl> </div> </dd>
</dl>   <h2 id="calibrate-denoiser">calibrate_denoiser</h2> <dl class="function"> <dt id="skimage.restoration.calibrate_denoiser">
<code>skimage.restoration.calibrate_denoiser(image, denoise_function, denoise_parameters, *, stride=4, approximate_loss=True, extra_output=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/restoration/j_invariant.py#L161-L254"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calibrate a denoising function and return optimal J-invariant version.</p> <p>The returned function is partially evaluated with optimal parameter values set for denoising the input image.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Input data to be denoised (converted using <code>img_as_float</code>).</p> </dd> <dt>
<code>denoise_functionfunction</code> </dt>
<dd>
<p>Denoising function to be calibrated.</p> </dd> <dt>
<code>denoise_parametersdict of list</code> </dt>
<dd>
<p>Ranges of parameters for <code>denoise_function</code> to be calibrated over.</p> </dd> <dt>
<code>strideint, optional</code> </dt>
<dd>
<p>Stride used in masking procedure that converts <code>denoise_function</code> to J-invariance.</p> </dd> <dt>
<code>approximate_lossbool, optional</code> </dt>
<dd>
<p>Whether to approximate the self-supervised loss used to evaluate the denoiser by only computing it on one masked version of the image. If False, the runtime will be a factor of <code>stride**image.ndim</code> longer.</p> </dd> <dt>
<code>extra_outputbool, optional</code> </dt>
<dd>
<p>If True, return parameters and losses in addition to the calibrated denoising function</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>best_denoise_functionfunction</code> </dt>
<dd>
<p>The optimal J-invariant version of <code>denoise_function</code>.</p> </dd> <dt>
<code>If extra_output is True, the following tuple is also returned:</code> </dt>
 <dt>
<code>(parameters_tested, losses)tuple (list of dict, list of int)</code> </dt>
<dd>
<p>List of parameters tested for <code>denoise_function</code>, as a dictionary of kwargs Self-supervised loss for each set of parameters in <code>parameters_tested</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The calibration procedure uses a self-supervised mean-square-error loss to evaluate the performance of J-invariant versions of <code>denoise_function</code>. The minimizer of the self-supervised loss is also the minimizer of the ground-truth loss (i.e., the true MSE error) [1]. The returned function can be used on the original noisy image, or other images with similar characteristics.</p> <dl class="simple"> <dt>
<code>Increasing the stride increases the performance of best_denoise_function</code> </dt>
<dd>
<p>at the expense of increasing its runtime. It has no effect on the runtime of the calibration.</p> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r2b636381f652-1">
<code>1</code> </dt> <dd>
<p>J. Batson &amp; L. Royer. Noise2Self: Blind Denoising by Self-Supervision, International Conference on Machine Learning, p. 524-533 (2019).</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import color, data
&gt;&gt;&gt; from skimage.restoration import denoise_wavelet
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; img = color.rgb2gray(data.astronaut()[:50, :50])
&gt;&gt;&gt; noisy = img + 0.5 * img.std() * np.random.randn(*img.shape)
&gt;&gt;&gt; parameters = {'sigma': np.arange(0.1, 0.4, 0.02)}
&gt;&gt;&gt; denoising_function = calibrate_denoiser(noisy, denoise_wavelet,
...                                         denoise_parameters=parameters)
&gt;&gt;&gt; denoised_img = denoising_function(img)
</pre> </dd>
</dl>   <h2 id="cycle-spin">cycle_spin</h2> <dl class="function"> <dt id="skimage.restoration.cycle_spin">
<code>skimage.restoration.cycle_spin(x, func, max_shifts, shift_steps=1, num_workers=None, multichannel=False, func_kw={})</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/restoration/_cycle_spin.py#L49-L145"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Cycle spinning (repeatedly apply func to shifted versions of x).</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>xarray-like</code> </dt>
<dd>
<p>Data for input to <code>func</code>.</p> </dd> <dt>
<code>funcfunction</code> </dt>
<dd>
<p>A function to apply to circularly shifted versions of <code>x</code>. Should take <code>x</code> as its first argument. Any additional arguments can be supplied via <code>func_kw</code>.</p> </dd> <dt>
<code>max_shiftsint or tuple</code> </dt>
<dd>
<p>If an integer, shifts in <code>range(0, max_shifts+1)</code> will be used along each axis of <code>x</code>. If a tuple, <code>range(0, max_shifts[i]+1)</code> will be along axis i.</p> </dd> <dt>
<code>shift_stepsint or tuple, optional</code> </dt>
<dd>
<p>The step size for the shifts applied along axis, i, are:: <code>range((0, max_shifts[i]+1, shift_steps[i]))</code>. If an integer is provided, the same step size is used for all axes.</p> </dd> <dt>
<code>num_workersint or None, optional</code> </dt>
<dd>
<p>The number of parallel threads to use during cycle spinning. If set to <code>None</code>, the full set of available cores are used.</p> </dd> <dt>
<code>multichannelbool, optional</code> </dt>
<dd>
<p>Whether to treat the final axis as channels (no cycle shifts are performed over the channels axis).</p> </dd> <dt>
<code>func_kwdict, optional</code> </dt>
<dd>
<p>Additional keyword arguments to supply to <code>func</code>.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>avg_ynp.ndarray</code> </dt>
<dd>
<p>The output of <code>func(x, **func_kw)</code> averaged over all combinations of the specified axis shifts.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>Cycle spinning was proposed as a way to approach shift-invariance via performing several circular shifts of a shift-variant transform <a class="reference internal" href="#r67eed921dbd3-1" id="id2">[1]</a>.</p> <p>For a n-level discrete wavelet transforms, one may wish to perform all shifts up to <code>max_shifts = 2**n - 1</code>. In practice, much of the benefit can often be realized with only a small number of shifts per axis.</p> <p>For transforms such as the blockwise discrete cosine transform, one may wish to evaluate shifts up to the block size used by the transform.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r67eed921dbd3-1">
<code>1</code> </dt> <dd>
<p>R.R. Coifman and D.L. Donoho. “Translation-Invariant De-Noising”. Wavelets and Statistics, Lecture Notes in Statistics, vol.103. Springer, New York, 1995, pp.125-150. <a class="reference external" href="https://doi.org/10.1007/978-1-4612-2544-7_9">DOI:10.1007/978-1-4612-2544-7_9</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import skimage.data
&gt;&gt;&gt; from skimage import img_as_float
&gt;&gt;&gt; from skimage.restoration import denoise_wavelet, cycle_spin
&gt;&gt;&gt; img = img_as_float(skimage.data.camera())
&gt;&gt;&gt; sigma = 0.1
&gt;&gt;&gt; img = img + sigma * np.random.standard_normal(img.shape)
&gt;&gt;&gt; denoised = cycle_spin(img, func=denoise_wavelet,
...                       max_shifts=3)
</pre> </dd>
</dl>   <h2 id="denoise-bilateral">denoise_bilateral</h2> <dl class="function"> <dt id="skimage.restoration.denoise_bilateral">
<code>skimage.restoration.denoise_bilateral(image, win_size=None, sigma_color=None, sigma_spatial=1, bins=10000, mode='constant', cval=0, multichannel=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/restoration/_denoise.py#L91-L232"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Denoise image using bilateral filter.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray, shape (M, N[, 3])</code> </dt>
<dd>
<p>Input image, 2D grayscale or RGB.</p> </dd> <dt>
<code>win_sizeint</code> </dt>
<dd>
<p>Window size for filtering. If win_size is not specified, it is calculated as <code>max(5, 2 * ceil(3 * sigma_spatial) + 1)</code>.</p> </dd> <dt>
<code>sigma_colorfloat</code> </dt>
<dd>
<p>Standard deviation for grayvalue/color distance (radiometric similarity). A larger value results in averaging of pixels with larger radiometric differences. Note, that the image will be converted using the <code>img_as_float</code> function and thus the standard deviation is in respect to the range <code>[0, 1]</code>. If the value is <code>None</code> the standard deviation of the <code>image</code> will be used.</p> </dd> <dt>
<code>sigma_spatialfloat</code> </dt>
<dd>
<p>Standard deviation for range distance. A larger value results in averaging of pixels with larger spatial differences.</p> </dd> <dt>
<code>binsint</code> </dt>
<dd>
<p>Number of discrete values for Gaussian weights of color filtering. A larger value results in improved accuracy.</p> </dd> <dt>
<code>mode{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}</code> </dt>
<dd>
<p>How to handle values outside the image borders. See <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.19)"><code>numpy.pad</code></a> for detail.</p> </dd> <dt>
<code>cvalstring</code> </dt>
<dd>
<p>Used in conjunction with mode ‘constant’, the value outside the image boundaries.</p> </dd> <dt>
<code>multichannelbool</code> </dt>
<dd>
<p>Whether the last axis of the image is to be interpreted as multiple channels or another spatial dimension.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>denoisedndarray</code> </dt>
<dd>
<p>Denoised image.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This is an edge-preserving, denoising filter. It averages pixels based on their spatial closeness and radiometric similarity <a class="reference internal" href="#rb832e60bc162-1" id="id4">[1]</a>.</p> <p>Spatial closeness is measured by the Gaussian function of the Euclidean distance between two pixels and a certain standard deviation (<code>sigma_spatial</code>).</p> <p>Radiometric similarity is measured by the Gaussian function of the Euclidean distance between two color values and a certain standard deviation (<code>sigma_color</code>).</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rb832e60bc162-1">
<code>1</code> </dt> <dd>
<p>C. Tomasi and R. Manduchi. “Bilateral Filtering for Gray and Color Images.” IEEE International Conference on Computer Vision (1998) 839-846. <a class="reference external" href="https://doi.org/10.1109/ICCV.1998.710815">DOI:10.1109/ICCV.1998.710815</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data, img_as_float
&gt;&gt;&gt; astro = img_as_float(data.astronaut())
&gt;&gt;&gt; astro = astro[220:300, 220:320]
&gt;&gt;&gt; noisy = astro + 0.6 * astro.std() * np.random.random(astro.shape)
&gt;&gt;&gt; noisy = np.clip(noisy, 0, 1)
&gt;&gt;&gt; denoised = denoise_bilateral(noisy, sigma_color=0.05, sigma_spatial=15,
...                              multichannel=True)
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-restoration-denoise-bilateral">Examples using <code>skimage.restoration.denoise_bilateral</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="Rank filters are non-linear filters using local gray-level ordering to compute the filtered val...">
<div class="figure align-default" id="id45"> <img alt="Rank filters" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/applications/plot_rank_filters.html#sphx-glr-auto-examples-applications-plot-rank-filters-py"><span class="std std-ref">Rank filters</span></a></span></p> </div> </div>   <h2 id="denoise-nl-means">denoise_nl_means</h2> <dl class="function"> <dt id="skimage.restoration.denoise_nl_means">
<code>skimage.restoration.denoise_nl_means(image, patch_size=7, patch_distance=11, h=0.1, multichannel=False, fast_mode=True, sigma=0.0, *, preserve_range=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/restoration/non_local_means.py#L11-L164"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform non-local means denoising on 2-D or 3-D grayscale images, and 2-D RGB images.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image2D or 3D ndarray</code> </dt>
<dd>
<p>Input image to be denoised, which can be 2D or 3D, and grayscale or RGB (for 2D images only, see <code>multichannel</code> parameter).</p> </dd> <dt>
<code>patch_sizeint, optional</code> </dt>
<dd>
<p>Size of patches used for denoising.</p> </dd> <dt>
<code>patch_distanceint, optional</code> </dt>
<dd>
<p>Maximal distance in pixels where to search patches used for denoising.</p> </dd> <dt>
<code>hfloat, optional</code> </dt>
<dd>
<p>Cut-off distance (in gray levels). The higher h, the more permissive one is in accepting patches. A higher h results in a smoother image, at the expense of blurring features. For a Gaussian noise of standard deviation sigma, a rule of thumb is to choose the value of h to be sigma of slightly less.</p> </dd> <dt>
<code>multichannelbool, optional</code> </dt>
<dd>
<p>Whether the last axis of the image is to be interpreted as multiple channels or another spatial dimension.</p> </dd> <dt>
<code>fast_modebool, optional</code> </dt>
<dd>
<p>If True (default value), a fast version of the non-local means algorithm is used. If False, the original version of non-local means is used. See the Notes section for more details about the algorithms.</p> </dd> <dt>
<code>sigmafloat, optional</code> </dt>
<dd>
<p>The standard deviation of the (Gaussian) noise. If provided, a more robust computation of patch weights is computed that takes the expected noise variance into account (see Notes below).</p> </dd> <dt>
<code>preserve_rangebool, optional</code> </dt>
<dd>
<p>Whether to keep the original range of values. Otherwise, the input image is converted according to the conventions of <code>img_as_float</code>. Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>resultndarray</code> </dt>
<dd>
<p>Denoised image, of same shape as <code>image</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The non-local means algorithm is well suited for denoising images with specific textures. The principle of the algorithm is to average the value of a given pixel with values of other pixels in a limited neighbourhood, provided that the <em>patches</em> centered on the other pixels are similar enough to the patch centered on the pixel of interest.</p> <p>In the original version of the algorithm <a class="reference internal" href="#rc9b3919da938-1" id="id6">[1]</a>, corresponding to <code>fast=False</code>, the computational complexity is:</p> <pre data-language="python">image.size * patch_size ** image.ndim * patch_distance ** image.ndim
</pre> <p>Hence, changing the size of patches or their maximal distance has a strong effect on computing times, especially for 3-D images.</p> <p>However, the default behavior corresponds to <code>fast_mode=True</code>, for which another version of non-local means <a class="reference internal" href="#rc9b3919da938-2" id="id7">[2]</a> is used, corresponding to a complexity of:</p> <pre data-language="python">image.size * patch_distance ** image.ndim
</pre> <p>The computing time depends only weakly on the patch size, thanks to the computation of the integral of patches distances for a given shift, that reduces the number of operations <a class="reference internal" href="#rc9b3919da938-1" id="id8">[1]</a>. Therefore, this algorithm executes faster than the classic algorithm (<code>fast_mode=False</code>), at the expense of using twice as much memory. This implementation has been proven to be more efficient compared to other alternatives, see e.g. <a class="reference internal" href="#rc9b3919da938-3" id="id9">[3]</a>.</p> <p>Compared to the classic algorithm, all pixels of a patch contribute to the distance to another patch with the same weight, no matter their distance to the center of the patch. This coarser computation of the distance can result in a slightly poorer denoising performance. Moreover, for small images (images with a linear size that is only a few times the patch size), the classic algorithm can be faster due to boundary effects.</p> <p>The image is padded using the <code>reflect</code> mode of <a class="reference internal" href="skimage.util#skimage.util.pad" title="skimage.util.pad"><code>skimage.util.pad</code></a> before denoising.</p> <p>If the noise standard deviation, <code>sigma</code>, is provided a more robust computation of patch weights is used. Subtracting the known noise variance from the computed patch distances improves the estimates of patch similarity, giving a moderate improvement to denoising performance <a class="reference internal" href="#rc9b3919da938-4" id="id10">[4]</a>. It was also mentioned as an option for the fast variant of the algorithm in <a class="reference internal" href="#rc9b3919da938-3" id="id11">[3]</a>.</p> <p>When <code>sigma</code> is provided, a smaller <code>h</code> should typically be used to avoid oversmoothing. The optimal value for <code>h</code> depends on the image content and noise level, but a reasonable starting point is <code>h = 0.8 * sigma</code> when <code>fast_mode</code> is <code>True</code>, or <code>h = 0.6 * sigma</code> when <code>fast_mode</code> is <code>False</code>.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rc9b3919da938-1">
<code>1(1,2)</code> </dt> <dd>
<p>A. Buades, B. Coll, &amp; J-M. Morel. A non-local algorithm for image denoising. In CVPR 2005, Vol. 2, pp. 60-65, IEEE. <a class="reference external" href="https://doi.org/10.1109/CVPR.2005.38">DOI:10.1109/CVPR.2005.38</a></p> </dd> <dt class="label" id="rc9b3919da938-2">
<code>2</code> </dt> <dd>
<p>J. Darbon, A. Cunha, T.F. Chan, S. Osher, and G.J. Jensen, Fast nonlocal filtering applied to electron cryomicroscopy, in 5th IEEE International Symposium on Biomedical Imaging: From Nano to Macro, 2008, pp. 1331-1334. <a class="reference external" href="https://doi.org/10.1109/ISBI.2008.4541250">DOI:10.1109/ISBI.2008.4541250</a></p> </dd> <dt class="label" id="rc9b3919da938-3">
<code>3(1,2)</code> </dt> <dd>
<p>Jacques Froment. Parameter-Free Fast Pixelwise Non-Local Means Denoising. Image Processing On Line, 2014, vol. 4, pp. 300-326. <a class="reference external" href="https://doi.org/10.5201/ipol.2014.120">DOI:10.5201/ipol.2014.120</a></p> </dd> <dt class="label" id="rc9b3919da938-4">
<code>4</code> </dt> <dd>
<p>A. Buades, B. Coll, &amp; J-M. Morel. Non-Local Means Denoising. Image Processing On Line, 2011, vol. 1, pp. 208-212. <a class="reference external" href="https://doi.org/10.5201/ipol.2011.bcm_nlm">DOI:10.5201/ipol.2011.bcm_nlm</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; a = np.zeros((40, 40))
&gt;&gt;&gt; a[10:-10, 10:-10] = 1.
&gt;&gt;&gt; a += 0.3 * np.random.randn(*a.shape)
&gt;&gt;&gt; denoised_a = denoise_nl_means(a, 7, 5, 0.1)
</pre> </dd>
</dl>   <h2 id="denoise-tv-bregman">denoise_tv_bregman</h2> <dl class="function"> <dt id="skimage.restoration.denoise_tv_bregman">
<code>skimage.restoration.denoise_tv_bregman(image, weight, max_iter=100, eps=0.001, isotropic=True, *, multichannel=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/restoration/_denoise.py#L235-L312"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform total-variation denoising using split-Bregman optimization.</p> <p>Total-variation denoising (also know as total-variation regularization) tries to find an image with less total-variation under the constraint of being similar to the input image, which is controlled by the regularization parameter (<a class="reference internal" href="#rc0e3588f2bc3-1" id="id16">[1]</a>, <a class="reference internal" href="#rc0e3588f2bc3-2" id="id17">[2]</a>, <a class="reference internal" href="#rc0e3588f2bc3-3" id="id18">[3]</a>, <a class="reference internal" href="#rc0e3588f2bc3-4" id="id19">[4]</a>).</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Input data to be denoised (converted using img_as_float`).</p> </dd> <dt>
<code>weightfloat</code> </dt>
<dd>
<p>Denoising weight. The smaller the <code>weight</code>, the more denoising (at the expense of less similarity to the <code>input</code>). The regularization parameter <code>lambda</code> is chosen as <code>2 * weight</code>.</p> </dd> <dt>
<code>epsfloat, optional</code> </dt>
<dd>
<p>Relative difference of the value of the cost function that determines the stop criterion. The algorithm stops when:</p> <pre data-language="python">SUM((u(n) - u(n-1))**2) &lt; eps
</pre> </dd> <dt>
<code>max_iterint, optional</code> </dt>
<dd>
<p>Maximal number of iterations used for the optimization.</p> </dd> <dt>
<code>isotropicboolean, optional</code> </dt>
<dd>
<p>Switch between isotropic and anisotropic TV denoising.</p> </dd> <dt>
<code>multichannelbool, optional</code> </dt>
<dd>
<p>Apply total-variation denoising separately for each channel. This option should be true for color images, otherwise the denoising is also applied in the channels dimension.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>undarray</code> </dt>
<dd>
<p>Denoised image.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rc0e3588f2bc3-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Total_variation_denoising">https://en.wikipedia.org/wiki/Total_variation_denoising</a></p> </dd> <dt class="label" id="rc0e3588f2bc3-2">
<code>2</code> </dt> <dd>
<p>Tom Goldstein and Stanley Osher, “The Split Bregman Method For L1 Regularized Problems”, <a class="reference external" href="ftp://ftp.math.ucla.edu/pub/camreport/cam08-29.pdf">ftp://ftp.math.ucla.edu/pub/camreport/cam08-29.pdf</a></p> </dd> <dt class="label" id="rc0e3588f2bc3-3">
<code>3</code> </dt> <dd>
<p>Pascal Getreuer, “Rudin–Osher–Fatemi Total Variation Denoising using Split Bregman” in Image Processing On Line on 2012–05–19, <a class="reference external" href="https://www.ipol.im/pub/art/2012/g-tvd/article_lr.pdf">https://www.ipol.im/pub/art/2012/g-tvd/article_lr.pdf</a></p> </dd> <dt class="label" id="rc0e3588f2bc3-4">
<code>4</code> </dt> <dd>
<p><a class="reference external" href="https://web.math.ucsb.edu/~cgarcia/UGProjects/BregmanAlgorithms_JacquelineBush.pdf">https://web.math.ucsb.edu/~cgarcia/UGProjects/BregmanAlgorithms_JacquelineBush.pdf</a></p> </dd> </dl> </dd>
</dl>   <h2 id="denoise-tv-chambolle">denoise_tv_chambolle</h2> <dl class="function"> <dt id="skimage.restoration.denoise_tv_chambolle">
<code>skimage.restoration.denoise_tv_chambolle(image, weight=0.1, eps=0.0002, n_iter_max=200, multichannel=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/restoration/_denoise.py#L396-L479"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform total-variation denoising on n-dimensional images.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>imagendarray of ints, uints or floats</code> </dt>
<dd>
<p>Input data to be denoised. <code>image</code> can be of any numeric type, but it is cast into an ndarray of floats for the computation of the denoised image.</p> </dd> <dt>
<code>weightfloat, optional</code> </dt>
<dd>
<p>Denoising weight. The greater <code>weight</code>, the more denoising (at the expense of fidelity to <code>input</code>).</p> </dd> <dt>
<code>epsfloat, optional</code> </dt>
<dd>
<p>Relative difference of the value of the cost function that determines the stop criterion. The algorithm stops when:</p>  <p>(E_(n-1) - E_n) &lt; eps * E_0</p>  </dd> <dt>
<code>n_iter_maxint, optional</code> </dt>
<dd>
<p>Maximal number of iterations used for the optimization.</p> </dd> <dt>
<code>multichannelbool, optional</code> </dt>
<dd>
<p>Apply total-variation denoising separately for each channel. This option should be true for color images, otherwise the denoising is also applied in the channels dimension.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>outndarray</code> </dt>
<dd>
<p>Denoised image.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>Make sure to set the multichannel parameter appropriately for color images.</p> <p>The principle of total variation denoising is explained in <a class="reference external" href="https://en.wikipedia.org/wiki/Total_variation_denoising">https://en.wikipedia.org/wiki/Total_variation_denoising</a></p> <p>The principle of total variation denoising is to minimize the total variation of the image, which can be roughly described as the integral of the norm of the image gradient. Total variation denoising tends to produce “cartoon-like” images, that is, piecewise-constant images.</p> <p>This code is an implementation of the algorithm of Rudin, Fatemi and Osher that was proposed by Chambolle in <a class="reference internal" href="#r3f46bb237e10-1" id="id24">[1]</a>.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r3f46bb237e10-1">
<code>1</code> </dt> <dd>
<p>A. Chambolle, An algorithm for total variation minimization and applications, Journal of Mathematical Imaging and Vision, Springer, 2004, 20, 89-97.</p> </dd> </dl> <h4 class="rubric">Examples</h4> <p>2D example on astronaut image:</p> <pre data-language="python">&gt;&gt;&gt; from skimage import color, data
&gt;&gt;&gt; img = color.rgb2gray(data.astronaut())[:50, :50]
&gt;&gt;&gt; img += 0.5 * img.std() * np.random.randn(*img.shape)
&gt;&gt;&gt; denoised_img = denoise_tv_chambolle(img, weight=60)
</pre> <p>3D example on synthetic data:</p> <pre data-language="python">&gt;&gt;&gt; x, y, z = np.ogrid[0:20, 0:20, 0:20]
&gt;&gt;&gt; mask = (x - 22)**2 + (y - 20)**2 + (z - 17)**2 &lt; 8**2
&gt;&gt;&gt; mask = mask.astype(float)
&gt;&gt;&gt; mask += 0.2*np.random.randn(*mask.shape)
&gt;&gt;&gt; res = denoise_tv_chambolle(mask, weight=100)
</pre> </dd>
</dl>   <h2 id="denoise-wavelet">denoise_wavelet</h2> <dl class="function"> <dt id="skimage.restoration.denoise_wavelet">
<code>skimage.restoration.denoise_wavelet(image, sigma=None, wavelet='db1', mode='soft', wavelet_levels=None, multichannel=False, convert2ycbcr=False, method='BayesShrink', rescale_sigma=True)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/restoration/_denoise.py#L694-L863"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform wavelet denoising on an image.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>imagendarray ([M[, N[, …P]][, C]) of ints, uints or floats</code> </dt>
<dd>
<p>Input data to be denoised. <code>image</code> can be of any numeric type, but it is cast into an ndarray of floats for the computation of the denoised image.</p> </dd> <dt>
<code>sigmafloat or list, optional</code> </dt>
<dd>
<p>The noise standard deviation used when computing the wavelet detail coefficient threshold(s). When None (default), the noise standard deviation is estimated via the method in <a class="reference internal" href="#r3b8ec6d23a4e-2" id="id26">[2]</a>.</p> </dd> <dt>
<code>waveletstring, optional</code> </dt>
<dd>
<p>The type of wavelet to perform and can be any of the options <code>pywt.wavelist</code> outputs. The default is <code>‘db1’</code>. For example, <code>wavelet</code> can be any of <code>{'db2', 'haar', 'sym9'}</code> and many more.</p> </dd> <dt>
<code>mode{‘soft’, ‘hard’}, optional</code> </dt>
<dd>
<p>An optional argument to choose the type of denoising performed. It noted that choosing soft thresholding given additive noise finds the best approximation of the original image.</p> </dd> <dt>
<code>wavelet_levelsint or None, optional</code> </dt>
<dd>
<p>The number of wavelet decomposition levels to use. The default is three less than the maximum number of possible decomposition levels.</p> </dd> <dt>
<code>multichannelbool, optional</code> </dt>
<dd>
<p>Apply wavelet denoising separately for each channel (where channels correspond to the final axis of the array).</p> </dd> <dt>
<code>convert2ycbcrbool, optional</code> </dt>
<dd>
<p>If True and multichannel True, do the wavelet denoising in the YCbCr colorspace instead of the RGB color space. This typically results in better performance for RGB images.</p> </dd> <dt>
<code>method{‘BayesShrink’, ‘VisuShrink’}, optional</code> </dt>
<dd>
<p>Thresholding method to be used. The currently supported methods are “BayesShrink” <a class="reference internal" href="#r3b8ec6d23a4e-1" id="id27">[1]</a> and “VisuShrink” <a class="reference internal" href="#r3b8ec6d23a4e-2" id="id28">[2]</a>. Defaults to “BayesShrink”.</p> </dd> <dt>
<code>rescale_sigmabool, optional</code> </dt>
<dd>
<p>If False, no rescaling of the user-provided <code>sigma</code> will be performed. The default of <code>True</code> rescales sigma appropriately if the image is rescaled internally.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.16: </span><code>rescale_sigma</code> was introduced in 0.16</p> </div> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>outndarray</code> </dt>
<dd>
<p>Denoised image.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The wavelet domain is a sparse representation of the image, and can be thought of similarly to the frequency domain of the Fourier transform. Sparse representations have most values zero or near-zero and truly random noise is (usually) represented by many small values in the wavelet domain. Setting all values below some threshold to 0 reduces the noise in the image, but larger thresholds also decrease the detail present in the image.</p> <p>If the input is 3D, this function performs wavelet denoising on each color plane separately.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.16: </span>For floating point inputs, the original input range is maintained and there is no clipping applied to the output. Other input types will be converted to a floating point value in the range [-1, 1] or [0, 1] depending on the input image range. Unless <code>rescale_sigma = False</code>, any internal rescaling applied to the <code>image</code> will also be applied to <code>sigma</code> to maintain the same relative amplitude.</p> </div> <p>Many wavelet coefficient thresholding approaches have been proposed. By default, <code>denoise_wavelet</code> applies BayesShrink, which is an adaptive thresholding method that computes separate thresholds for each wavelet sub-band as described in <a class="reference internal" href="#r3b8ec6d23a4e-1" id="id29">[1]</a>.</p> <p>If <code>method == "VisuShrink"</code>, a single “universal threshold” is applied to all wavelet detail coefficients as described in <a class="reference internal" href="#r3b8ec6d23a4e-2" id="id30">[2]</a>. This threshold is designed to remove all Gaussian noise at a given <code>sigma</code> with high probability, but tends to produce images that appear overly smooth.</p> <p>Although any of the wavelets from <code>PyWavelets</code> can be selected, the thresholding methods assume an orthogonal wavelet transform and may not choose the threshold appropriately for biorthogonal wavelets. Orthogonal wavelets are desirable because white noise in the input remains white noise in the subbands. Biorthogonal wavelets lead to colored noise in the subbands. Additionally, the orthogonal wavelets in PyWavelets are orthonormal so that noise variance in the subbands remains identical to the noise variance of the input. Example orthogonal wavelets are the Daubechies (e.g. ‘db2’) or symmlet (e.g. ‘sym2’) families.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r3b8ec6d23a4e-1">
<code>1(1,2)</code> </dt> <dd>
<p>Chang, S. Grace, Bin Yu, and Martin Vetterli. “Adaptive wavelet thresholding for image denoising and compression.” Image Processing, IEEE Transactions on 9.9 (2000): 1532-1546. <a class="reference external" href="https://doi.org/10.1109/83.862633">DOI:10.1109/83.862633</a></p> </dd> <dt class="label" id="r3b8ec6d23a4e-2">
<code>2(1,2,3)</code> </dt> <dd>
<p>D. L. Donoho and I. M. Johnstone. “Ideal spatial adaptation by wavelet shrinkage.” Biometrika 81.3 (1994): 425-455. <a class="reference external" href="https://doi.org/10.1093/biomet/81.3.425">DOI:10.1093/biomet/81.3.425</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import color, data
&gt;&gt;&gt; img = img_as_float(data.astronaut())
&gt;&gt;&gt; img = color.rgb2gray(img)
&gt;&gt;&gt; img += 0.1 * np.random.randn(*img.shape)
&gt;&gt;&gt; img = np.clip(img, 0, 1)
&gt;&gt;&gt; denoised_img = denoise_wavelet(img, sigma=0.1, rescale_sigma=True)
</pre> </dd>
</dl>   <h2 id="ellipsoid-kernel">ellipsoid_kernel</h2> <dl class="function"> <dt id="skimage.restoration.ellipsoid_kernel">
<code>skimage.restoration.ellipsoid_kernel(shape, intensity)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/restoration/rolling_ball.py#L155-L192"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create an ellipoid kernel for restoration.rolling_ball.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>shapearraylike</code> </dt>
<dd>
<p>Length of the principal axis of the ellipsoid (excluding the intensity axis). The kernel needs to have the same dimensionality as the image it will be applied to.</p> </dd> <dt>
<code>intensityint</code> </dt>
<dd>
<p>Length of the intensity axis of the ellipsoid.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>kernelndarray</code> </dt>
<dd>
<p>The kernel containing the surface intensity of the top half of the ellipsoid.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.restoration.rolling_ball" title="skimage.restoration.rolling_ball"><code>rolling_ball</code></a>
</dt>
 </dl> </div> </dd>
</dl>  <h3 id="examples-using-skimage-restoration-ellipsoid-kernel">Examples using <code>skimage.restoration.ellipsoid_kernel</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="The rolling-ball algorithm estimates the background intensity of a grayscale image in case of u...">
<div class="figure align-default" id="id46"> <img alt="Use rolling-ball algorithm for estimating background intensity" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_rolling_ball.html#sphx-glr-auto-examples-segmentation-plot-rolling-ball-py"><span class="std std-ref">Use rolling-ball algorithm for estimating background intensity</span></a></span></p> </div> </div>   <h2 id="estimate-sigma">estimate_sigma</h2> <dl class="function"> <dt id="skimage.restoration.estimate_sigma">
<code>skimage.restoration.estimate_sigma(image, average_sigmas=False, multichannel=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/restoration/_denoise.py#L866-L923"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Robust wavelet-based estimator of the (Gaussian) noise standard deviation.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Image for which to estimate the noise standard deviation.</p> </dd> <dt>
<code>average_sigmasbool, optional</code> </dt>
<dd>
<p>If true, average the channel estimates of <code>sigma</code>. Otherwise return a list of sigmas corresponding to each channel.</p> </dd> <dt>
<code>multichannelbool</code> </dt>
<dd>
<p>Estimate sigma separately for each channel.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>sigmafloat or list</code> </dt>
<dd>
<p>Estimated noise standard deviation(s). If <code>multichannel</code> is True and <code>average_sigmas</code> is False, a separate noise estimate for each channel is returned. Otherwise, the average of the individual channel estimates is returned.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This function assumes the noise follows a Gaussian distribution. The estimation algorithm is based on the median absolute deviation of the wavelet detail coefficients as described in section 4.2 of <a class="reference internal" href="#rbc448ac95825-1" id="id33">[1]</a>.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rbc448ac95825-1">
<code>1</code> </dt> <dd>
<p>D. L. Donoho and I. M. Johnstone. “Ideal spatial adaptation by wavelet shrinkage.” Biometrika 81.3 (1994): 425-455. <a class="reference external" href="https://doi.org/10.1093/biomet/81.3.425">DOI:10.1093/biomet/81.3.425</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import skimage.data
&gt;&gt;&gt; from skimage import img_as_float
&gt;&gt;&gt; img = img_as_float(skimage.data.camera())
&gt;&gt;&gt; sigma = 0.1
&gt;&gt;&gt; img = img + sigma * np.random.standard_normal(img.shape)
&gt;&gt;&gt; sigma_hat = estimate_sigma(img, multichannel=False)
</pre> </dd>
</dl>   <h2 id="inpaint-biharmonic">inpaint_biharmonic</h2> <dl class="function"> <dt id="skimage.restoration.inpaint_biharmonic">
<code>skimage.restoration.inpaint_biharmonic(image, mask, multichannel=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/restoration/inpaint.py#L76-L152"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Inpaint masked points in image with biharmonic equations.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(M[, N[, …, P]][, C]) ndarray</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>mask(M[, N[, …, P]]) ndarray</code> </dt>
<dd>
<p>Array of pixels to be inpainted. Have to be the same shape as one of the ‘image’ channels. Unknown pixels have to be represented with 1, known pixels - with 0.</p> </dd> <dt>
<code>multichannelboolean, optional</code> </dt>
<dd>
<p>If True, the last <code>image</code> dimension is considered as a color channel, otherwise as spatial.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>out(M[, N[, …, P]][, C]) ndarray</code> </dt>
<dd>
<p>Input image with masked pixels inpainted.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r2b3da8fbc807-1">
<code>1</code> </dt> <dd>
<p>N.S.Hoang, S.B.Damelin, “On surface completion and image inpainting by biharmonic functions: numerical aspects”, <a class="reference external" href="https://arxiv.org/abs/1707.06567">arXiv:1707.06567</a></p> </dd> <dt class="label" id="r2b3da8fbc807-2">
<code>2</code> </dt> <dd>
<p>C. K. Chui and H. N. Mhaskar, MRA Contextual-Recovery Extension of Smooth Functions on Manifolds, Appl. and Comp. Harmonic Anal., 28 (2010), 104-113, <a class="reference external" href="https://doi.org/10.1016/j.acha.2009.04.004">DOI:10.1016/j.acha.2009.04.004</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; img = np.tile(np.square(np.linspace(0, 1, 5)), (5, 1))
&gt;&gt;&gt; mask = np.zeros_like(img)
&gt;&gt;&gt; mask[2, 2:] = 1
&gt;&gt;&gt; mask[1, 3:] = 1
&gt;&gt;&gt; mask[0, 4:] = 1
&gt;&gt;&gt; out = inpaint_biharmonic(img, mask)
</pre> </dd>
</dl>   <h2 id="richardson-lucy">richardson_lucy</h2> <dl class="function"> <dt id="skimage.restoration.richardson_lucy">
<code>skimage.restoration.richardson_lucy(image, psf, iterations=50, clip=True, filter_epsilon=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/restoration/deconvolution.py#L329-L385"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Richardson-Lucy deconvolution.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Input degraded image (can be N dimensional).</p> </dd> <dt>
<code>psfndarray</code> </dt>
<dd>
<p>The point spread function.</p> </dd> <dt>
<code>iterationsint, optional</code> </dt>
<dd>
<p>Number of iterations. This parameter plays the role of regularisation.</p> </dd> <dt>
<code>clipboolean, optional</code> </dt>
<dd>
<p>True by default. If true, pixel value of the result above 1 or under -1 are thresholded for skimage pipeline compatibility.</p> </dd> <dt><strong>filter_epsilon: float, optional</strong></dt>
<dd>
<p>Value below which intermediate results become 0 to avoid division by small numbers.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>im_deconvndarray</code> </dt>
<dd>
<p>The deconvolved image.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rbba3d9c89116-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Richardson%E2%80%93Lucy_deconvolution">https://en.wikipedia.org/wiki/Richardson%E2%80%93Lucy_deconvolution</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import img_as_float, data, restoration
&gt;&gt;&gt; camera = img_as_float(data.camera())
&gt;&gt;&gt; from scipy.signal import convolve2d
&gt;&gt;&gt; psf = np.ones((5, 5)) / 25
&gt;&gt;&gt; camera = convolve2d(camera, psf, 'same')
&gt;&gt;&gt; camera += 0.1 * camera.std() * np.random.standard_normal(camera.shape)
&gt;&gt;&gt; deconvolved = restoration.richardson_lucy(camera, psf, 5)
</pre> </dd>
</dl>   <h2 id="rolling-ball">rolling_ball</h2> <dl class="function"> <dt id="skimage.restoration.rolling_ball">
<code>skimage.restoration.rolling_ball(image, *, radius=100, kernel=None, nansafe=False, num_threads=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/restoration/rolling_ball.py#L6-L114"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Estimate background intensity by rolling/translating a kernel.</p> <p>This rolling ball algorithm estimates background intensity for a ndimage in case of uneven exposure. It is a generalization of the frequently used rolling ball algorithm <a class="reference internal" href="#r62497d9283b1-1" id="id38">[1]</a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>The image to be filtered.</p> </dd> <dt>
<code>radiusint, optional</code> </dt>
<dd>
<p>Radius of a ball shaped kernel to be rolled/translated in the image. Used if <code>kernel = None</code>.</p> </dd> <dt>
<code>kernelndarray, optional</code> </dt>
<dd>
<p>The kernel to be rolled/translated in the image. It must have the same number of dimensions as <code>image</code>. Kernel is filled with the intensity of the kernel at that position.</p> </dd> <dt><strong>nansafe: bool, optional</strong></dt>
<dd>
<p>If <code>False</code> (default) assumes that none of the values in <code>image</code> are <code>np.nan</code>, and uses a faster implementation.</p> </dd> <dt><strong>num_threads: int, optional</strong></dt>
<dd>
<p>The maximum number of threads to use. If <code>None</code> use the OpenMP default value; typically equal to the maximum number of virtual cores. Note: This is an upper limit to the number of threads. The exact number is determined by the system’s OpenMP library.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>backgroundndarray</code> </dt>
<dd>
<p>The estimated background of the image.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>For the pixel that has its background intensity estimated (without loss of generality at <code>center</code>) the rolling ball method centers <code>kernel</code> under it and raises the kernel until the surface touches the image umbra at some <code>pos=(y,x)</code>. The background intensity is then estimated using the image intensity at that position (<code>image[pos]</code>) plus the difference of <code>kernel[center] - kernel[pos]</code>.</p> <p>This algorithm assumes that dark pixels correspond to the background. If you have a bright background, invert the image before passing it to the function, e.g., using <code>utils.invert</code>. See the gallery example for details.</p> <p>This algorithm is sensitive to noise (in particular salt-and-pepper noise). If this is a problem in your image, you can apply mild gaussian smoothing before passing the image to this function.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r62497d9283b1-1">
<code>1</code> </dt> <dd>
<p>Sternberg, Stanley R. “Biomedical image processing.” Computer 1 (1983): 22-34. <a class="reference external" href="https://doi.org/10.1109/MC.1983.1654163">DOI:10.1109/MC.1983.1654163</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; from skimage.restoration import rolling_ball
&gt;&gt;&gt; image = data.coins()
&gt;&gt;&gt; background = rolling_ball(data.coins())
&gt;&gt;&gt; filtered_image = image - background
</pre> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; from skimage.restoration import rolling_ball, ellipsoid_kernel
&gt;&gt;&gt; image = data.coins()
&gt;&gt;&gt; kernel = ellipsoid_kernel((101, 101), 75)
&gt;&gt;&gt; background = rolling_ball(data.coins(), kernel=kernel)
&gt;&gt;&gt; filtered_image = image - background
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-restoration-rolling-ball">Examples using <code>skimage.restoration.rolling_ball</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="The rolling-ball algorithm estimates the background intensity of a grayscale image in case of u...">
<div class="figure align-default" id="id47"> <img alt="Use rolling-ball algorithm for estimating background intensity" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_rolling_ball.html#sphx-glr-auto-examples-segmentation-plot-rolling-ball-py"><span class="std std-ref">Use rolling-ball algorithm for estimating background intensity</span></a></span></p> </div> </div>   <h2 id="unsupervised-wiener">unsupervised_wiener</h2> <dl class="function"> <dt id="skimage.restoration.unsupervised_wiener">
<code>skimage.restoration.unsupervised_wiener(image, psf, reg=None, user_params=None, is_real=True, clip=True)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/restoration/deconvolution.py#L140-L326"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Unsupervised Wiener-Hunt deconvolution.</p> <p>Return the deconvolution with a Wiener-Hunt approach, where the hyperparameters are automatically estimated. The algorithm is a stochastic iterative process (Gibbs sampler) described in the reference below. See also <code>wiener</code> function.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(M, N) ndarray</code> </dt>
<dd>
<p>The input degraded image.</p> </dd> <dt>
<code>psfndarray</code> </dt>
<dd>
<p>The impulse response (input image’s space) or the transfer function (Fourier space). Both are accepted. The transfer function is automatically recognized as being complex (<code>np.iscomplexobj(psf)</code>).</p> </dd> <dt>
<code>regndarray, optional</code> </dt>
<dd>
<p>The regularisation operator. The Laplacian by default. It can be an impulse response or a transfer function, as for the psf.</p> </dd> <dt>
<code>user_paramsdict, optional</code> </dt>
<dd>
<p>Dictionary of parameters for the Gibbs sampler. See below.</p> </dd> <dt>
<code>clipboolean, optional</code> </dt>
<dd>
<p>True by default. If true, pixel values of the result above 1 or under -1 are thresholded for skimage pipeline compatibility.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>x_postmean(M, N) ndarray</code> </dt>
<dd>
<p>The deconvolved image (the posterior mean).</p> </dd> <dt>
<code>chainsdict</code> </dt>
<dd>
<p>The keys <code>noise</code> and <code>prior</code> contain the chain list of noise and prior precision respectively.</p> </dd> </dl> </dd> <dt class="field-odd">Other Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt><strong>The keys of ``user_params`` are:</strong></dt>
 <dt>
<code>thresholdfloat</code> </dt>
<dd>
<p>The stopping criterion: the norm of the difference between to successive approximated solution (empirical mean of object samples, see Notes section). 1e-4 by default.</p> </dd> <dt>
<code>burninint</code> </dt>
<dd>
<p>The number of sample to ignore to start computation of the mean. 15 by default.</p> </dd> <dt>
<code>min_iterint</code> </dt>
<dd>
<p>The minimum number of iterations. 30 by default.</p> </dd> <dt>
<code>max_iterint</code> </dt>
<dd>
<p>The maximum number of iterations if <code>threshold</code> is not satisfied. 200 by default.</p> </dd> <dt>
<code>callbackcallable (None by default)</code> </dt>
<dd>
<p>A user provided callable to which is passed, if the function exists, the current image sample for whatever purpose. The user can store the sample, or compute other moments than the mean. It has no influence on the algorithm execution and is only for inspection.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The estimated image is design as the posterior mean of a probability law (from a Bayesian analysis). The mean is defined as a sum over all the possible images weighted by their respective probability. Given the size of the problem, the exact sum is not tractable. This algorithm use of MCMC to draw image under the posterior law. The practical idea is to only draw highly probable images since they have the biggest contribution to the mean. At the opposite, the less probable images are drawn less often since their contribution is low. Finally the empirical mean of these samples give us an estimation of the mean, and an exact computation with an infinite sample set.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rc01bcdcadf9b-1">
<code>1</code> </dt> <dd>
<p>François Orieux, Jean-François Giovannelli, and Thomas Rodet, “Bayesian estimation of regularization and point spread function parameters for Wiener-Hunt deconvolution”, J. Opt. Soc. Am. A 27, 1593-1607 (2010)</p> <p><a class="reference external" href="https://www.osapublishing.org/josaa/abstract.cfm?URI=josaa-27-7-1593">https://www.osapublishing.org/josaa/abstract.cfm?URI=josaa-27-7-1593</a></p> <p><a class="reference external" href="http://research.orieux.fr/files/papers/OGR-JOSA10.pdf">http://research.orieux.fr/files/papers/OGR-JOSA10.pdf</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import color, data, restoration
&gt;&gt;&gt; img = color.rgb2gray(data.astronaut())
&gt;&gt;&gt; from scipy.signal import convolve2d
&gt;&gt;&gt; psf = np.ones((5, 5)) / 25
&gt;&gt;&gt; img = convolve2d(img, psf, 'same')
&gt;&gt;&gt; img += 0.1 * img.std() * np.random.standard_normal(img.shape)
&gt;&gt;&gt; deconvolved_img = restoration.unsupervised_wiener(img, psf)
</pre> </dd>
</dl>   <h2 id="unwrap-phase">unwrap_phase</h2> <dl class="function"> <dt id="skimage.restoration.unwrap_phase">
<code>skimage.restoration.unwrap_phase(image, wrap_around=False, seed=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/restoration/unwrap.py#L10-L113"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Recover the original from a wrapped phase image.</p> <p>From an image wrapped to lie in the interval [-pi, pi), recover the original, unwrapped image.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image1D, 2D or 3D ndarray of floats, optionally a masked array</code> </dt>
<dd>
<p>The values should be in the range [-pi, pi). If a masked array is provided, the masked entries will not be changed, and their values will not be used to guide the unwrapping of neighboring, unmasked values. Masked 1D arrays are not allowed, and will raise a <code>ValueError</code>.</p> </dd> <dt>
<code>wrap_aroundbool or sequence of bool, optional</code> </dt>
<dd>
<p>When an element of the sequence is <code>True</code>, the unwrapping process will regard the edges along the corresponding axis of the image to be connected and use this connectivity to guide the phase unwrapping process. If only a single boolean is given, it will apply to all axes. Wrap around is not supported for 1D arrays.</p> </dd> <dt>
<code>seedint, optional</code> </dt>
<dd>
<p>Unwrapping 2D or 3D images uses random initialization. This sets the seed of the PRNG to achieve deterministic behavior.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>image_unwrappedarray_like, double</code> </dt>
<dd>
<p>Unwrapped image of the same shape as the input. If the input <code>image</code> was a masked array, the mask will be preserved.</p> </dd> </dl> </dd> <dt class="field-odd">Raises</dt> <dd class="field-odd">
<dl class="simple"> <dt>ValueError</dt>
<dd>
<p>If called with a masked 1D array or called with a 1D array and <code>wrap_around=True</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r160444e59583-1">
<code>1</code> </dt> <dd>
<p>Miguel Arevallilo Herraez, David R. Burton, Michael J. Lalor, and Munther A. Gdeisat, “Fast two-dimensional phase-unwrapping algorithm based on sorting by reliability following a noncontinuous path”, Journal Applied Optics, Vol. 41, No. 35 (2002) 7437,</p> </dd> <dt class="label" id="r160444e59583-2">
<code>2</code> </dt> <dd>
<p>Abdul-Rahman, H., Gdeisat, M., Burton, D., &amp; Lalor, M., “Fast three-dimensional phase-unwrapping algorithm based on sorting by reliability following a non-continuous path. In W. Osten, C. Gorecki, &amp; E. L. Novak (Eds.), Optical Metrology (2005) 32–40, International Society for Optics and Photonics.</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; c0, c1 = np.ogrid[-1:1:128j, -1:1:128j]
&gt;&gt;&gt; image = 12 * np.pi * np.exp(-(c0**2 + c1**2))
&gt;&gt;&gt; image_wrapped = np.angle(np.exp(1j * image))
&gt;&gt;&gt; image_unwrapped = unwrap_phase(image_wrapped)
&gt;&gt;&gt; np.std(image_unwrapped - image) &lt; 1e-6   # A constant offset is normal
True
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-restoration-unwrap-phase">Examples using <code>skimage.restoration.unwrap_phase</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="Some signals can only be observed modulo 2*pi, and this can also apply to two- and three dimens...">
<div class="figure align-default" id="id48"> <img alt="Phase Unwrapping" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/filters/plot_phase_unwrap.html#sphx-glr-auto-examples-filters-plot-phase-unwrap-py"><span class="std std-ref">Phase Unwrapping</span></a></span></p> </div> </div>   <h2 id="wiener">wiener</h2> <dl class="function"> <dt id="skimage.restoration.wiener">
<code>skimage.restoration.wiener(image, psf, balance, reg=None, is_real=True, clip=True)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/restoration/deconvolution.py#L13-L137"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Wiener-Hunt deconvolution</p> <p>Return the deconvolution with a Wiener-Hunt approach (i.e. with Fourier diagonalisation).</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(M, N) ndarray</code> </dt>
<dd>
<p>Input degraded image</p> </dd> <dt>
<code>psfndarray</code> </dt>
<dd>
<p>Point Spread Function. This is assumed to be the impulse response (input image space) if the data-type is real, or the transfer function (Fourier space) if the data-type is complex. There is no constraints on the shape of the impulse response. The transfer function must be of shape <code>(M, N)</code> if <code>is_real is True</code>, <code>(M, N // 2 + 1)</code> otherwise (see <code>np.fft.rfftn</code>).</p> </dd> <dt>
<code>balancefloat</code> </dt>
<dd>
<p>The regularisation parameter value that tunes the balance between the data adequacy that improve frequency restoration and the prior adequacy that reduce frequency restoration (to avoid noise artifacts).</p> </dd> <dt>
<code>regndarray, optional</code> </dt>
<dd>
<p>The regularisation operator. The Laplacian by default. It can be an impulse response or a transfer function, as for the psf. Shape constraint is the same as for the <code>psf</code> parameter.</p> </dd> <dt>
<code>is_realboolean, optional</code> </dt>
<dd>
<p>True by default. Specify if <code>psf</code> and <code>reg</code> are provided with hermitian hypothesis, that is only half of the frequency plane is provided (due to the redundancy of Fourier transform of real signal). It’s apply only if <code>psf</code> and/or <code>reg</code> are provided as transfer function. For the hermitian property see <code>uft</code> module or <code>np.fft.rfftn</code>.</p> </dd> <dt>
<code>clipboolean, optional</code> </dt>
<dd>
<p>True by default. If True, pixel values of the result above 1 or under -1 are thresholded for skimage pipeline compatibility.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>im_deconv(M, N) ndarray</code> </dt>
<dd>
<p>The deconvolved image.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This function applies the Wiener filter to a noisy and degraded image by an impulse response (or PSF). If the data model is</p> <div class="math notranslate nohighlight"> \[y = Hx + n\]</div> <p>where <span class="math notranslate nohighlight">\(n\)</span> is noise, <span class="math notranslate nohighlight">\(H\)</span> the PSF and <span class="math notranslate nohighlight">\(x\)</span> the unknown original image, the Wiener filter is</p> <div class="math notranslate nohighlight"> \[\hat x = F^\dagger (|\Lambda_H|^2 + \lambda |\Lambda_D|^2) \Lambda_H^\dagger F y\]</div> <p>where <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(F^\dagger\)</span> are the Fourier and inverse Fourier transforms respectively, <span class="math notranslate nohighlight">\(\Lambda_H\)</span> the transfer function (or the Fourier transform of the PSF, see [Hunt] below) and <span class="math notranslate nohighlight">\(\Lambda_D\)</span> the filter to penalize the restored image frequencies (Laplacian by default, that is penalization of high frequency). The parameter <span class="math notranslate nohighlight">\(\lambda\)</span> tunes the balance between the data (that tends to increase high frequency, even those coming from noise), and the regularization.</p> <p>These methods are then specific to a prior model. Consequently, the application or the true image nature must corresponds to the prior model. By default, the prior model (Laplacian) introduce image smoothness or pixel correlation. It can also be interpreted as high-frequency penalization to compensate the instability of the solution with respect to the data (sometimes called noise amplification or “explosive” solution).</p> <p>Finally, the use of Fourier space implies a circulant property of <span class="math notranslate nohighlight">\(H\)</span>, see [Hunt].</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r78add0113d5e-1">
<code>1</code> </dt> <dd>
<p>François Orieux, Jean-François Giovannelli, and Thomas Rodet, “Bayesian estimation of regularization and point spread function parameters for Wiener-Hunt deconvolution”, J. Opt. Soc. Am. A 27, 1593-1607 (2010)</p> <p><a class="reference external" href="https://www.osapublishing.org/josaa/abstract.cfm?URI=josaa-27-7-1593">https://www.osapublishing.org/josaa/abstract.cfm?URI=josaa-27-7-1593</a></p> <p><a class="reference external" href="http://research.orieux.fr/files/papers/OGR-JOSA10.pdf">http://research.orieux.fr/files/papers/OGR-JOSA10.pdf</a></p> </dd> <dt class="label" id="r78add0113d5e-2">
<code>2</code> </dt> <dd>
<p>B. R. Hunt “A matrix theory proof of the discrete convolution theorem”, IEEE Trans. on Audio and Electroacoustics, vol. au-19, no. 4, pp. 285-288, dec. 1971</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import color, data, restoration
&gt;&gt;&gt; img = color.rgb2gray(data.astronaut())
&gt;&gt;&gt; from scipy.signal import convolve2d
&gt;&gt;&gt; psf = np.ones((5, 5)) / 25
&gt;&gt;&gt; img = convolve2d(img, psf, 'same')
&gt;&gt;&gt; img += 0.1 * img.std() * np.random.standard_normal(img.shape)
&gt;&gt;&gt; deconvolved_img = restoration.wiener(img, psf, 1100)
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2019 the scikit-image team<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://scikit-image.org/docs/0.18.x/api/skimage.restoration.html" class="_attribution-link">https://scikit-image.org/docs/0.18.x/api/skimage.restoration.html</a>
  </p>
</div>
