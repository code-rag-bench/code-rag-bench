<h1>Windowing Operations</h1> <p>pandas contains a compact set of APIs for performing windowing operations - an operation that performs an aggregation over a sliding partition of values. The API functions similarly to the <code class="docutils literal notranslate"><span class="pre">groupby</span></code> API in that <a class="reference internal" href="../reference/api/pandas.series#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> call the windowing method with necessary parameters and then subsequently call the aggregation function.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [1]: s = pd.Series(range(5))

In [2]: s.rolling(window=2).sum()
Out[2]: 
0    NaN
1    1.0
2    3.0
3    5.0
4    7.0
dtype: float64
</pre></div> </div> <p>The windows are comprised by looking back the length of the window from the current observation. The result above can be derived by taking the sum of the following windowed partitions of data:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [3]: for window in s.rolling(window=2):
   ...:     print(window)
   ...: 
0    0
dtype: int64
0    0
1    1
dtype: int64
1    1
2    2
dtype: int64
2    2
3    3
dtype: int64
3    3
4    4
dtype: int64
</pre></div> </div> <section id="overview"> <h2>Overview</h2> <p>pandas supports 4 types of windowing operations:</p> <ol class="arabic simple"> <li><p>Rolling window: Generic fixed or variable sliding window over the values.</p></li> <li><p>Weighted window: Weighted, non-rectangular window supplied by the <code class="docutils literal notranslate"><span class="pre">scipy.signal</span></code> library.</p></li> <li><p>Expanding window: Accumulating window over the values.</p></li> <li><p>Exponentially Weighted window: Accumulating and exponentially weighted window over the values.</p></li> </ol> <table class="table"> <colgroup> <col style="width: 16%"> <col style="width: 9%"> <col style="width: 15%"> <col style="width: 15%"> <col style="width: 13%"> <col style="width: 19%"> <col style="width: 15%"> </colgroup> <thead> <tr class="row-odd">
<th class="head"><p>Concept</p></th> <th class="head"><p>Method</p></th> <th class="head"><p>Returned Object</p></th> <th class="head"><p>Supports time-based windows</p></th> <th class="head"><p>Supports chained groupby</p></th> <th class="head"><p>Supports table method</p></th> <th class="head"><p>Supports online operations</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p>Rolling window</p></td> <td><p><code class="docutils literal notranslate"><span class="pre">rolling</span></code></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">Rolling</span></code></p></td> <td><p>Yes</p></td> <td><p>Yes</p></td> <td><p>Yes (as of version 1.3)</p></td> <td><p>No</p></td> </tr> <tr class="row-odd">
<td><p>Weighted window</p></td> <td><p><code class="docutils literal notranslate"><span class="pre">rolling</span></code></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">Window</span></code></p></td> <td><p>No</p></td> <td><p>No</p></td> <td><p>No</p></td> <td><p>No</p></td> </tr> <tr class="row-even">
<td><p>Expanding window</p></td> <td><p><code class="docutils literal notranslate"><span class="pre">expanding</span></code></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">Expanding</span></code></p></td> <td><p>No</p></td> <td><p>Yes</p></td> <td><p>Yes (as of version 1.3)</p></td> <td><p>No</p></td> </tr> <tr class="row-odd">
<td><p>Exponentially Weighted window</p></td> <td><p><code class="docutils literal notranslate"><span class="pre">ewm</span></code></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">ExponentialMovingWindow</span></code></p></td> <td><p>No</p></td> <td><p>Yes (as of version 1.2)</p></td> <td><p>No</p></td> <td><p>Yes (as of version 1.3)</p></td> </tr> </tbody> </table> <p>As noted above, some operations support specifying a window based on a time offset:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [4]: s = pd.Series(range(5), index=pd.date_range('2020-01-01', periods=5, freq='1D'))

In [5]: s.rolling(window='2D').sum()
Out[5]: 
2020-01-01    0.0
2020-01-02    1.0
2020-01-03    3.0
2020-01-04    5.0
2020-01-05    7.0
Freq: D, dtype: float64
</pre></div> </div> <p>Additionally, some methods support chaining a <code class="docutils literal notranslate"><span class="pre">groupby</span></code> operation with a windowing operation which will first group the data by the specified keys and then perform a windowing operation per group.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [6]: df = pd.DataFrame({'A': ['a', 'b', 'a', 'b', 'a'], 'B': range(5)})

In [7]: df.groupby('A').expanding().sum()
Out[7]: 
       B
A       
a 0  0.0
  2  2.0
  4  6.0
b 1  1.0
  3  4.0
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Windowing operations currently only support numeric data (integer and float) and will always return <code class="docutils literal notranslate"><span class="pre">float64</span></code> values.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Some windowing aggregation, <code class="docutils literal notranslate"><span class="pre">mean</span></code>, <code class="docutils literal notranslate"><span class="pre">sum</span></code>, <code class="docutils literal notranslate"><span class="pre">var</span></code> and <code class="docutils literal notranslate"><span class="pre">std</span></code> methods may suffer from numerical imprecision due to the underlying windowing algorithms accumulating sums. When values differ with magnitude <span class="math notranslate nohighlight">\(1/np.finfo(np.double).eps\)</span> this results in truncation. It must be noted, that large values may have an impact on windows, which do not include these values. <a class="reference external" href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan summation</a> is used to compute the rolling sums to preserve accuracy as much as possible.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.3.0.</span></p> </div> <p>Some windowing operations also support the <code class="docutils literal notranslate"><span class="pre">method='table'</span></code> option in the constructor which performs the windowing operation over an entire <a class="reference internal" href="../reference/api/pandas.dataframe#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> instead of a single column or row at a time. This can provide a useful performance benefit for a <a class="reference internal" href="../reference/api/pandas.dataframe#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> with many columns or rows (with the corresponding <code class="docutils literal notranslate"><span class="pre">axis</span></code> argument) or the ability to utilize other columns during the windowing operation. The <code class="docutils literal notranslate"><span class="pre">method='table'</span></code> option can only be used if <code class="docutils literal notranslate"><span class="pre">engine='numba'</span></code> is specified in the corresponding method call.</p> <p>For example, a <a class="reference external" href="https://en.wikipedia.org/wiki/Weighted_arithmetic_mean">weighted mean</a> calculation can be calculated with <code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code> by specifying a separate column of weights.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [8]: def weighted_mean(x):
   ...:     arr = np.ones((1, x.shape[1]))
   ...:     arr[:, :2] = (x[:, :2] * x[:, 2]).sum(axis=0) / x[:, 2].sum()
   ...:     return arr
   ...: 

In [9]: df = pd.DataFrame([[1, 2, 0.6], [2, 3, 0.4], [3, 4, 0.2], [4, 5, 0.7]])

In [10]: df.rolling(2, method="table", min_periods=0).apply(weighted_mean, raw=True, engine="numba")  # noqa:E501
Out[10]: 
          0         1    2
0  1.000000  2.000000  1.0
1  1.800000  2.000000  1.0
2  3.333333  2.333333  1.0
3  1.555556  7.000000  1.0
</pre></div> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.3.</span></p> </div> <p>Some windowing operations also support an <code class="docutils literal notranslate"><span class="pre">online</span></code> method after constructing a windowing object which returns a new object that supports passing in new <a class="reference internal" href="../reference/api/pandas.dataframe#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> or <a class="reference internal" href="../reference/api/pandas.series#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> objects to continue the windowing calculation with the new values (i.e. online calculations).</p> <p>The methods on this new windowing objects must call the aggregation method first to “prime” the initial state of the online calculation. Then, new <a class="reference internal" href="../reference/api/pandas.dataframe#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> or <a class="reference internal" href="../reference/api/pandas.series#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> objects can be passed in the <code class="docutils literal notranslate"><span class="pre">update</span></code> argument to continue the windowing calculation.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [11]: df = pd.DataFrame([[1, 2, 0.6], [2, 3, 0.4], [3, 4, 0.2], [4, 5, 0.7]])

In [12]: df.ewm(0.5).mean()
Out[12]: 
          0         1         2
0  1.000000  2.000000  0.600000
1  1.750000  2.750000  0.450000
2  2.615385  3.615385  0.276923
3  3.550000  4.550000  0.562500
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [13]: online_ewm = df.head(2).ewm(0.5).online()

In [14]: online_ewm.mean()
Out[14]: 
      0     1     2
0  1.00  2.00  0.60
1  1.75  2.75  0.45

In [15]: online_ewm.mean(update=df.tail(1))
Out[15]: 
          0         1         2
3  3.307692  4.307692  0.623077
</pre></div> </div> <p>All windowing operations support a <code class="docutils literal notranslate"><span class="pre">min_periods</span></code> argument that dictates the minimum amount of non-<code class="docutils literal notranslate"><span class="pre">np.nan</span></code> values a window must have; otherwise, the resulting value is <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>. <code class="docutils literal notranslate"><span class="pre">min_periods</span></code> defaults to 1 for time-based windows and <code class="docutils literal notranslate"><span class="pre">window</span></code> for fixed windows</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [16]: s = pd.Series([np.nan, 1, 2, np.nan, np.nan, 3])

In [17]: s.rolling(window=3, min_periods=1).sum()
Out[17]: 
0    NaN
1    1.0
2    3.0
3    3.0
4    2.0
5    3.0
dtype: float64

In [18]: s.rolling(window=3, min_periods=2).sum()
Out[18]: 
0    NaN
1    NaN
2    3.0
3    3.0
4    NaN
5    NaN
dtype: float64

# Equivalent to min_periods=3
In [19]: s.rolling(window=3, min_periods=None).sum()
Out[19]: 
0   NaN
1   NaN
2   NaN
3   NaN
4   NaN
5   NaN
dtype: float64
</pre></div> </div> <p>Additionally, all windowing operations supports the <code class="docutils literal notranslate"><span class="pre">aggregate</span></code> method for returning a result of multiple aggregations applied to a window.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [20]: df = pd.DataFrame({"A": range(5), "B": range(10, 15)})

In [21]: df.expanding().agg([np.sum, np.mean, np.std])
Out[21]: 
      A                    B                
    sum mean       std   sum  mean       std
0   0.0  0.0       NaN  10.0  10.0       NaN
1   1.0  0.5  0.707107  21.0  10.5  0.707107
2   3.0  1.0  1.000000  33.0  11.0  1.000000
3   6.0  1.5  1.290994  46.0  11.5  1.290994
4  10.0  2.0  1.581139  60.0  12.0  1.581139
</pre></div> </div> </section> <section id="rolling-window"> <h2>Rolling window</h2> <p>Generic rolling windows support specifying windows as a fixed number of observations or variable number of observations based on an offset. If a time based offset is provided, the corresponding time based index must be monotonic.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [22]: times = ['2020-01-01', '2020-01-03', '2020-01-04', '2020-01-05', '2020-01-29']

In [23]: s = pd.Series(range(5), index=pd.DatetimeIndex(times))

In [24]: s
Out[24]: 
2020-01-01    0
2020-01-03    1
2020-01-04    2
2020-01-05    3
2020-01-29    4
dtype: int64

# Window with 2 observations
In [25]: s.rolling(window=2).sum()
Out[25]: 
2020-01-01    NaN
2020-01-03    1.0
2020-01-04    3.0
2020-01-05    5.0
2020-01-29    7.0
dtype: float64

# Window with 2 days worth of observations
In [26]: s.rolling(window='2D').sum()
Out[26]: 
2020-01-01    0.0
2020-01-03    1.0
2020-01-04    3.0
2020-01-05    5.0
2020-01-29    4.0
dtype: float64
</pre></div> </div> <p>For all supported aggregation functions, see <a class="reference internal" href="../reference/window#api-functions-rolling"><span class="std std-ref">Rolling window functions</span></a>.</p> <section id="centering-windows"> <h3>Centering windows</h3> <p>By default the labels are set to the right edge of the window, but a <code class="docutils literal notranslate"><span class="pre">center</span></code> keyword is available so the labels can be set at the center.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [27]: s = pd.Series(range(10))

In [28]: s.rolling(window=5).mean()
Out[28]: 
0    NaN
1    NaN
2    NaN
3    NaN
4    2.0
5    3.0
6    4.0
7    5.0
8    6.0
9    7.0
dtype: float64

In [29]: s.rolling(window=5, center=True).mean()
Out[29]: 
0    NaN
1    NaN
2    2.0
3    3.0
4    4.0
5    5.0
6    6.0
7    7.0
8    NaN
9    NaN
dtype: float64
</pre></div> </div> <p>This can also be applied to datetime-like indices.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.3.0.</span></p> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [30]: df = pd.DataFrame(
   ....:     {"A": [0, 1, 2, 3, 4]}, index=pd.date_range("2020", periods=5, freq="1D")
   ....: )
   ....: 

In [31]: df
Out[31]: 
            A
2020-01-01  0
2020-01-02  1
2020-01-03  2
2020-01-04  3
2020-01-05  4

In [32]: df.rolling("2D", center=False).mean()
Out[32]: 
              A
2020-01-01  0.0
2020-01-02  0.5
2020-01-03  1.5
2020-01-04  2.5
2020-01-05  3.5

In [33]: df.rolling("2D", center=True).mean()
Out[33]: 
              A
2020-01-01  0.5
2020-01-02  1.5
2020-01-03  2.5
2020-01-04  3.5
2020-01-05  4.0
</pre></div> </div> </section> <section id="rolling-window-endpoints"> <h3>Rolling window endpoints</h3> <p>The inclusion of the interval endpoints in rolling window calculations can be specified with the <code class="docutils literal notranslate"><span class="pre">closed</span></code> parameter:</p> <table class="table"> <colgroup> <col style="width: 38%"> <col style="width: 62%"> </colgroup> <thead> <tr class="row-odd">
<th class="head"><p>Value</p></th> <th class="head"><p>Behavior</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">'right'</span></code></p></td> <td><p>close right endpoint</p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">'left'</span></code></p></td> <td><p>close left endpoint</p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">'both'</span></code></p></td> <td><p>close both endpoints</p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">'neither'</span></code></p></td> <td><p>open endpoints</p></td> </tr> </tbody> </table> <p>For example, having the right endpoint open is useful in many problems that require that there is no contamination from present information back to past information. This allows the rolling window to compute statistics “up to that point in time”, but not including that point in time.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [34]: df = pd.DataFrame(
   ....:     {"x": 1},
   ....:     index=[
   ....:         pd.Timestamp("20130101 09:00:01"),
   ....:         pd.Timestamp("20130101 09:00:02"),
   ....:         pd.Timestamp("20130101 09:00:03"),
   ....:         pd.Timestamp("20130101 09:00:04"),
   ....:         pd.Timestamp("20130101 09:00:06"),
   ....:     ],
   ....: )
   ....: 

In [35]: df["right"] = df.rolling("2s", closed="right").x.sum()  # default

In [36]: df["both"] = df.rolling("2s", closed="both").x.sum()

In [37]: df["left"] = df.rolling("2s", closed="left").x.sum()

In [38]: df["neither"] = df.rolling("2s", closed="neither").x.sum()

In [39]: df
Out[39]: 
                     x  right  both  left  neither
2013-01-01 09:00:01  1    1.0   1.0   NaN      NaN
2013-01-01 09:00:02  1    2.0   2.0   1.0      1.0
2013-01-01 09:00:03  1    2.0   3.0   2.0      1.0
2013-01-01 09:00:04  1    2.0   3.0   2.0      1.0
2013-01-01 09:00:06  1    1.0   2.0   1.0      NaN
</pre></div> </div> </section> <section id="custom-window-rolling"> <h3>Custom window rolling</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.0.</span></p> </div> <p>In addition to accepting an integer or offset as a <code class="docutils literal notranslate"><span class="pre">window</span></code> argument, <code class="docutils literal notranslate"><span class="pre">rolling</span></code> also accepts a <code class="docutils literal notranslate"><span class="pre">BaseIndexer</span></code> subclass that allows a user to define a custom method for calculating window bounds. The <code class="docutils literal notranslate"><span class="pre">BaseIndexer</span></code> subclass will need to define a <code class="docutils literal notranslate"><span class="pre">get_window_bounds</span></code> method that returns a tuple of two arrays, the first being the starting indices of the windows and second being the ending indices of the windows. Additionally, <code class="docutils literal notranslate"><span class="pre">num_values</span></code>, <code class="docutils literal notranslate"><span class="pre">min_periods</span></code>, <code class="docutils literal notranslate"><span class="pre">center</span></code>, <code class="docutils literal notranslate"><span class="pre">closed</span></code> and will automatically be passed to <code class="docutils literal notranslate"><span class="pre">get_window_bounds</span></code> and the defined method must always accept these arguments.</p> <p>For example, if we have the following <a class="reference internal" href="../reference/api/pandas.dataframe#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [40]: use_expanding = [True, False, True, False, True]

In [41]: use_expanding
Out[41]: [True, False, True, False, True]

In [42]: df = pd.DataFrame({"values": range(5)})

In [43]: df
Out[43]: 
   values
0       0
1       1
2       2
3       3
4       4
</pre></div> </div> <p>and we want to use an expanding window where <code class="docutils literal notranslate"><span class="pre">use_expanding</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code> otherwise a window of size 1, we can create the following <code class="docutils literal notranslate"><span class="pre">BaseIndexer</span></code> subclass:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [2]: from pandas.api.indexers import BaseIndexer

In [3]: class CustomIndexer(BaseIndexer):
   ...:     def get_window_bounds(self, num_values, min_periods, center, closed):
   ...:         start = np.empty(num_values, dtype=np.int64)
   ...:         end = np.empty(num_values, dtype=np.int64)
   ...:         for i in range(num_values):
   ...:             if self.use_expanding[i]:
   ...:                 start[i] = 0
   ...:                 end[i] = i + 1
   ...:             else:
   ...:                 start[i] = i
   ...:                 end[i] = i + self.window_size
   ...:         return start, end

In [4]: indexer = CustomIndexer(window_size=1, use_expanding=use_expanding)

In [5]: df.rolling(indexer).sum()
Out[5]:
    values
0     0.0
1     1.0
2     3.0
3     3.0
4    10.0
</pre></div> </div> <p>You can view other examples of <code class="docutils literal notranslate"><span class="pre">BaseIndexer</span></code> subclasses <a class="reference external" href="https://github.com/pandas-dev/pandas/blob/main/pandas/core/indexers/objects.py">here</a></p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.1.</span></p> </div> <p>One subclass of note within those examples is the <code class="docutils literal notranslate"><span class="pre">VariableOffsetWindowIndexer</span></code> that allows rolling operations over a non-fixed offset like a <code class="docutils literal notranslate"><span class="pre">BusinessDay</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [44]: from pandas.api.indexers import VariableOffsetWindowIndexer

In [45]: df = pd.DataFrame(range(10), index=pd.date_range("2020", periods=10))

In [46]: offset = pd.offsets.BDay(1)

In [47]: indexer = VariableOffsetWindowIndexer(index=df.index, offset=offset)

In [48]: df
Out[48]: 
            0
2020-01-01  0
2020-01-02  1
2020-01-03  2
2020-01-04  3
2020-01-05  4
2020-01-06  5
2020-01-07  6
2020-01-08  7
2020-01-09  8
2020-01-10  9

In [49]: df.rolling(indexer).sum()
Out[49]: 
               0
2020-01-01   0.0
2020-01-02   1.0
2020-01-03   2.0
2020-01-04   3.0
2020-01-05   7.0
2020-01-06  12.0
2020-01-07   6.0
2020-01-08   7.0
2020-01-09   8.0
2020-01-10   9.0
</pre></div> </div> <p>For some problems knowledge of the future is available for analysis. For example, this occurs when each data point is a full time series read from an experiment, and the task is to extract underlying conditions. In these cases it can be useful to perform forward-looking rolling window computations. <a class="reference internal" href="../reference/api/pandas.api.indexers.fixedforwardwindowindexer#pandas.api.indexers.FixedForwardWindowIndexer" title="pandas.api.indexers.FixedForwardWindowIndexer"><code class="xref py py-func docutils literal notranslate"><span class="pre">FixedForwardWindowIndexer</span></code></a> class is available for this purpose. This <a class="reference internal" href="../reference/api/pandas.api.indexers.baseindexer#pandas.api.indexers.BaseIndexer" title="pandas.api.indexers.BaseIndexer"><code class="xref py py-func docutils literal notranslate"><span class="pre">BaseIndexer</span></code></a> subclass implements a closed fixed-width forward-looking rolling window, and we can use it as follows:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [50]: from pandas.api.indexers import FixedForwardWindowIndexer

In [51]: indexer = FixedForwardWindowIndexer(window_size=2)

In [52]: df.rolling(indexer, min_periods=1).sum()
Out[52]: 
               0
2020-01-01   1.0
2020-01-02   3.0
2020-01-03   5.0
2020-01-04   7.0
2020-01-05   9.0
2020-01-06  11.0
2020-01-07  13.0
2020-01-08  15.0
2020-01-09  17.0
2020-01-10   9.0
</pre></div> </div> <p>We can also achieve this by using slicing, applying rolling aggregation, and then flipping the result as shown in example below:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [53]: df = pd.DataFrame(
   ....:     data=[
   ....:         [pd.Timestamp("2018-01-01 00:00:00"), 100],
   ....:         [pd.Timestamp("2018-01-01 00:00:01"), 101],
   ....:         [pd.Timestamp("2018-01-01 00:00:03"), 103],
   ....:         [pd.Timestamp("2018-01-01 00:00:04"), 111],
   ....:     ],
   ....:     columns=["time", "value"],
   ....: ).set_index("time")
   ....: 

In [54]: df
Out[54]: 
                     value
time                      
2018-01-01 00:00:00    100
2018-01-01 00:00:01    101
2018-01-01 00:00:03    103
2018-01-01 00:00:04    111

In [55]: reversed_df = df[::-1].rolling("2s").sum()[::-1]

In [56]: reversed_df
Out[56]: 
                     value
time                      
2018-01-01 00:00:00  201.0
2018-01-01 00:00:01  101.0
2018-01-01 00:00:03  214.0
2018-01-01 00:00:04  111.0
</pre></div> </div> </section> <section id="rolling-apply"> <h3>Rolling apply</h3> <p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code> function takes an extra <code class="docutils literal notranslate"><span class="pre">func</span></code> argument and performs generic rolling computations. The <code class="docutils literal notranslate"><span class="pre">func</span></code> argument should be a single function that produces a single value from an ndarray input. <code class="docutils literal notranslate"><span class="pre">raw</span></code> specifies whether the windows are cast as <a class="reference internal" href="../reference/api/pandas.series#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> objects (<code class="docutils literal notranslate"><span class="pre">raw=False</span></code>) or ndarray objects (<code class="docutils literal notranslate"><span class="pre">raw=True</span></code>).</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [57]: def mad(x):
   ....:     return np.fabs(x - x.mean()).mean()
   ....: 

In [58]: s = pd.Series(range(10))

In [59]: s.rolling(window=4).apply(mad, raw=True)
Out[59]: 
0    NaN
1    NaN
2    NaN
3    1.0
4    1.0
5    1.0
6    1.0
7    1.0
8    1.0
9    1.0
dtype: float64
</pre></div> </div> </section> <section id="numba-engine"> <h3>Numba engine</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.0.</span></p> </div> <p>Additionally, <code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code> can leverage <a class="reference external" href="https://numba.pydata.org/">Numba</a> if installed as an optional dependency. The apply aggregation can be executed using Numba by specifying <code class="docutils literal notranslate"><span class="pre">engine='numba'</span></code> and <code class="docutils literal notranslate"><span class="pre">engine_kwargs</span></code> arguments (<code class="docutils literal notranslate"><span class="pre">raw</span></code> must also be set to <code class="docutils literal notranslate"><span class="pre">True</span></code>). See <a class="reference internal" href="enhancingperf#enhancingperf-numba"><span class="std std-ref">enhancing performance with Numba</span></a> for general usage of the arguments and performance considerations.</p> <p>Numba will be applied in potentially two routines:</p> <ol class="arabic simple"> <li><p>If <code class="docutils literal notranslate"><span class="pre">func</span></code> is a standard Python function, the engine will <a class="reference external" href="https://numba.pydata.org/numba-doc/latest/user/overview.html">JIT</a> the passed function. <code class="docutils literal notranslate"><span class="pre">func</span></code> can also be a JITed function in which case the engine will not JIT the function again.</p></li> <li><p>The engine will JIT the for loop where the apply function is applied to each window.</p></li> </ol> <p>The <code class="docutils literal notranslate"><span class="pre">engine_kwargs</span></code> argument is a dictionary of keyword arguments that will be passed into the <a class="reference external" href="https://numba.pydata.org/numba-doc/latest/reference/jit-compilation.html#numba.jit">numba.jit decorator</a>. These keyword arguments will be applied to <em>both</em> the passed function (if a standard Python function) and the apply for loop over each window.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.3.0.</span></p> </div> <p><code class="docutils literal notranslate"><span class="pre">mean</span></code>, <code class="docutils literal notranslate"><span class="pre">median</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>, and <code class="docutils literal notranslate"><span class="pre">sum</span></code> also support the <code class="docutils literal notranslate"><span class="pre">engine</span></code> and <code class="docutils literal notranslate"><span class="pre">engine_kwargs</span></code> arguments.</p> </section> <section id="binary-window-functions"> <h3>Binary window functions</h3> <p><code class="xref py py-meth docutils literal notranslate"><span class="pre">cov()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">corr()</span></code> can compute moving window statistics about two <a class="reference internal" href="../reference/api/pandas.series#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> or any combination of <a class="reference internal" href="../reference/api/pandas.dataframe#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a>/<a class="reference internal" href="../reference/api/pandas.series#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> or <a class="reference internal" href="../reference/api/pandas.dataframe#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a>/<a class="reference internal" href="../reference/api/pandas.dataframe#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a>. Here is the behavior in each case:</p> <ul class="simple"> <li><p>two <a class="reference internal" href="../reference/api/pandas.series#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a>: compute the statistic for the pairing.</p></li> <li><p><a class="reference internal" href="../reference/api/pandas.dataframe#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a>/<a class="reference internal" href="../reference/api/pandas.series#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a>: compute the statistics for each column of the DataFrame with the passed Series, thus returning a DataFrame.</p></li> <li><p><a class="reference internal" href="../reference/api/pandas.dataframe#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a>/<a class="reference internal" href="../reference/api/pandas.dataframe#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a>: by default compute the statistic for matching column names, returning a DataFrame. If the keyword argument <code class="docutils literal notranslate"><span class="pre">pairwise=True</span></code> is passed then computes the statistic for each pair of columns, returning a <a class="reference internal" href="../reference/api/pandas.dataframe#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> with a <a class="reference internal" href="../reference/api/pandas.multiindex#pandas.MultiIndex" title="pandas.MultiIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiIndex</span></code></a> whose values are the dates in question (see <a class="reference internal" href="#window-corr-pairwise"><span class="std std-ref">the next section</span></a>).</p></li> </ul> <p>For example:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [60]: df = pd.DataFrame(
   ....:     np.random.randn(10, 4),
   ....:     index=pd.date_range("2020-01-01", periods=10),
   ....:     columns=["A", "B", "C", "D"],
   ....: )
   ....: 

In [61]: df = df.cumsum()

In [62]: df2 = df[:4]

In [63]: df2.rolling(window=2).corr(df2["B"])
Out[63]: 
              A    B    C    D
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02 -1.0  1.0 -1.0  1.0
2020-01-03  1.0  1.0  1.0 -1.0
2020-01-04 -1.0  1.0  1.0 -1.0
</pre></div> </div> </section> <section id="computing-rolling-pairwise-covariances-and-correlations"> <h3>Computing rolling pairwise covariances and correlations</h3> <p>In financial data analysis and other fields it’s common to compute covariance and correlation matrices for a collection of time series. Often one is also interested in moving-window covariance and correlation matrices. This can be done by passing the <code class="docutils literal notranslate"><span class="pre">pairwise</span></code> keyword argument, which in the case of <a class="reference internal" href="../reference/api/pandas.dataframe#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> inputs will yield a MultiIndexed <a class="reference internal" href="../reference/api/pandas.dataframe#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> whose <code class="docutils literal notranslate"><span class="pre">index</span></code> are the dates in question. In the case of a single DataFrame argument the <code class="docutils literal notranslate"><span class="pre">pairwise</span></code> argument can even be omitted:</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Missing values are ignored and each entry is computed using the pairwise complete observations. Please see the <a class="reference internal" href="computation#computation-covariance"><span class="std std-ref">covariance section</span></a> for <a class="reference internal" href="computation#computation-covariance-caveats"><span class="std std-ref">caveats</span></a> associated with this method of calculating covariance and correlation matrices.</p> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [64]: covs = (
   ....:     df[["B", "C", "D"]]
   ....:     .rolling(window=4)
   ....:     .cov(df[["A", "B", "C"]], pairwise=True)
   ....: )
   ....: 

In [65]: covs
Out[65]: 
                     B         C         D
2020-01-01 A       NaN       NaN       NaN
           B       NaN       NaN       NaN
           C       NaN       NaN       NaN
2020-01-02 A       NaN       NaN       NaN
           B       NaN       NaN       NaN
...                ...       ...       ...
2020-01-09 B  0.342006  0.230190  0.052849
           C  0.230190  1.575251  0.082901
2020-01-10 A -0.333945  0.006871 -0.655514
           B  0.649711  0.430860  0.469271
           C  0.430860  0.829721  0.055300

[30 rows x 3 columns]
</pre></div> </div> </section> </section> <section id="weighted-window"> <h2>Weighted window</h2> <p>The <code class="docutils literal notranslate"><span class="pre">win_type</span></code> argument in <code class="docutils literal notranslate"><span class="pre">.rolling</span></code> generates a weighted windows that are commonly used in filtering and spectral estimation. <code class="docutils literal notranslate"><span class="pre">win_type</span></code> must be string that corresponds to a <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/signal.windows.html#module-scipy.signal.windows">scipy.signal window function</a>. Scipy must be installed in order to use these windows, and supplementary arguments that the Scipy window methods take must be specified in the aggregation function.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [66]: s = pd.Series(range(10))

In [67]: s.rolling(window=5).mean()
Out[67]: 
0    NaN
1    NaN
2    NaN
3    NaN
4    2.0
5    3.0
6    4.0
7    5.0
8    6.0
9    7.0
dtype: float64

In [68]: s.rolling(window=5, win_type="triang").mean()
Out[68]: 
0    NaN
1    NaN
2    NaN
3    NaN
4    2.0
5    3.0
6    4.0
7    5.0
8    6.0
9    7.0
dtype: float64

# Supplementary Scipy arguments passed in the aggregation function
In [69]: s.rolling(window=5, win_type="gaussian").mean(std=0.1)
Out[69]: 
0    NaN
1    NaN
2    NaN
3    NaN
4    2.0
5    3.0
6    4.0
7    5.0
8    6.0
9    7.0
dtype: float64
</pre></div> </div> <p>For all supported aggregation functions, see <a class="reference internal" href="../reference/window#api-functions-window"><span class="std std-ref">Weighted window functions</span></a>.</p> </section> <section id="expanding-window"> <h2>Expanding window</h2> <p>An expanding window yields the value of an aggregation statistic with all the data available up to that point in time. Since these calculations are a special case of rolling statistics, they are implemented in pandas such that the following two calls are equivalent:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [70]: df = pd.DataFrame(range(5))

In [71]: df.rolling(window=len(df), min_periods=1).mean()
Out[71]: 
     0
0  0.0
1  0.5
2  1.0
3  1.5
4  2.0

In [72]: df.expanding(min_periods=1).mean()
Out[72]: 
     0
0  0.0
1  0.5
2  1.0
3  1.5
4  2.0
</pre></div> </div> <p>For all supported aggregation functions, see <a class="reference internal" href="../reference/window#api-functions-expanding"><span class="std std-ref">Expanding window functions</span></a>.</p> </section> <section id="exponentially-weighted-window"> <h2>Exponentially Weighted window</h2> <p>An exponentially weighted window is similar to an expanding window but with each prior point being exponentially weighted down relative to the current point.</p> <p>In general, a weighted moving average is calculated as</p> <div class="math notranslate nohighlight"> \[y_t = \frac{\sum_{i=0}^t w_i x_{t-i}}{\sum_{i=0}^t w_i},\]</div> <p>where <span class="math notranslate nohighlight">\(x_t\)</span> is the input, <span class="math notranslate nohighlight">\(y_t\)</span> is the result and the <span class="math notranslate nohighlight">\(w_i\)</span> are the weights.</p> <p>For all supported aggregation functions, see <a class="reference internal" href="../reference/window#api-functions-ewm"><span class="std std-ref">Exponentially-weighted window functions</span></a>.</p> <p>The EW functions support two variants of exponential weights. The default, <code class="docutils literal notranslate"><span class="pre">adjust=True</span></code>, uses the weights <span class="math notranslate nohighlight">\(w_i = (1 - \alpha)^i\)</span> which gives</p> <div class="math notranslate nohighlight"> \[y_t = \frac{x_t + (1 - \alpha)x_{t-1} + (1 - \alpha)^2 x_{t-2} + ... + (1 - \alpha)^t x_{0}}{1 + (1 - \alpha) + (1 - \alpha)^2 + ... + (1 - \alpha)^t}\]</div> <p>When <code class="docutils literal notranslate"><span class="pre">adjust=False</span></code> is specified, moving averages are calculated as</p> <div class="math notranslate nohighlight"> \[\begin{split}y_0 &amp;= x_0 \\ y_t &amp;= (1 - \alpha) y_{t-1} + \alpha x_t,\end{split}\]</div> <p>which is equivalent to using weights</p> <div class="math notranslate nohighlight"> \[\begin{split}w_i = \begin{cases} \alpha (1 - \alpha)^i &amp; \text{if } i &lt; t \\ (1 - \alpha)^i &amp; \text{if } i = t. \end{cases}\end{split}\]</div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>These equations are sometimes written in terms of <span class="math notranslate nohighlight">\(\alpha' = 1 - \alpha\)</span>, e.g.</p> <div class="math notranslate nohighlight"> \[y_t = \alpha' y_{t-1} + (1 - \alpha') x_t.\]</div> </div> <p>The difference between the above two variants arises because we are dealing with series which have finite history. Consider a series of infinite history, with <code class="docutils literal notranslate"><span class="pre">adjust=True</span></code>:</p> <div class="math notranslate nohighlight"> \[y_t = \frac{x_t + (1 - \alpha)x_{t-1} + (1 - \alpha)^2 x_{t-2} + ...} {1 + (1 - \alpha) + (1 - \alpha)^2 + ...}\]</div> <p>Noting that the denominator is a geometric series with initial term equal to 1 and a ratio of <span class="math notranslate nohighlight">\(1 - \alpha\)</span> we have</p> <div class="math notranslate nohighlight"> \[\begin{split}y_t &amp;= \frac{x_t + (1 - \alpha)x_{t-1} + (1 - \alpha)^2 x_{t-2} + ...} {\frac{1}{1 - (1 - \alpha)}}\\ &amp;= [x_t + (1 - \alpha)x_{t-1} + (1 - \alpha)^2 x_{t-2} + ...] \alpha \\ &amp;= \alpha x_t + [(1-\alpha)x_{t-1} + (1 - \alpha)^2 x_{t-2} + ...]\alpha \\ &amp;= \alpha x_t + (1 - \alpha)[x_{t-1} + (1 - \alpha) x_{t-2} + ...]\alpha\\ &amp;= \alpha x_t + (1 - \alpha) y_{t-1}\end{split}\]</div> <p>which is the same expression as <code class="docutils literal notranslate"><span class="pre">adjust=False</span></code> above and therefore shows the equivalence of the two variants for infinite series. When <code class="docutils literal notranslate"><span class="pre">adjust=False</span></code>, we have <span class="math notranslate nohighlight">\(y_0 = x_0\)</span> and <span class="math notranslate nohighlight">\(y_t = \alpha x_t + (1 - \alpha) y_{t-1}\)</span>. Therefore, there is an assumption that <span class="math notranslate nohighlight">\(x_0\)</span> is not an ordinary value but rather an exponentially weighted moment of the infinite series up to that point.</p> <p>One must have <span class="math notranslate nohighlight">\(0 &lt; \alpha \leq 1\)</span>, and while it is possible to pass <span class="math notranslate nohighlight">\(\alpha\)</span> directly, it’s often easier to think about either the <strong>span</strong>, <strong>center of mass (com)</strong> or <strong>half-life</strong> of an EW moment:</p> <div class="math notranslate nohighlight"> \[\begin{split}\alpha = \begin{cases} \frac{2}{s + 1}, &amp; \text{for span}\ s \geq 1\\ \frac{1}{1 + c}, &amp; \text{for center of mass}\ c \geq 0\\ 1 - \exp^{\frac{\log 0.5}{h}}, &amp; \text{for half-life}\ h &gt; 0 \end{cases}\end{split}\]</div> <p>One must specify precisely one of <strong>span</strong>, <strong>center of mass</strong>, <strong>half-life</strong> and <strong>alpha</strong> to the EW functions:</p> <ul class="simple"> <li><p><strong>Span</strong> corresponds to what is commonly called an “N-day EW moving average”.</p></li> <li><p><strong>Center of mass</strong> has a more physical interpretation and can be thought of in terms of span: <span class="math notranslate nohighlight">\(c = (s - 1) / 2\)</span>.</p></li> <li><p><strong>Half-life</strong> is the period of time for the exponential weight to reduce to one half.</p></li> <li><p><strong>Alpha</strong> specifies the smoothing factor directly.</p></li> </ul> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.1.0.</span></p> </div> <p>You can also specify <code class="docutils literal notranslate"><span class="pre">halflife</span></code> in terms of a timedelta convertible unit to specify the amount of time it takes for an observation to decay to half its value when also specifying a sequence of <code class="docutils literal notranslate"><span class="pre">times</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [73]: df = pd.DataFrame({"B": [0, 1, 2, np.nan, 4]})

In [74]: df
Out[74]: 
     B
0  0.0
1  1.0
2  2.0
3  NaN
4  4.0

In [75]: times = ["2020-01-01", "2020-01-03", "2020-01-10", "2020-01-15", "2020-01-17"]

In [76]: df.ewm(halflife="4 days", times=pd.DatetimeIndex(times)).mean()
Out[76]: 
          B
0  0.000000
1  0.585786
2  1.523889
3  1.523889
4  3.233686
</pre></div> </div> <p>The following formula is used to compute exponentially weighted mean with an input vector of times:</p> <div class="math notranslate nohighlight"> \[y_t = \frac{\sum_{i=0}^t 0.5^\frac{t_{t} - t_{i}}{\lambda} x_{t-i}}{\sum_{i=0}^t 0.5^\frac{t_{t} - t_{i}}{\lambda}},\]</div> <p>ExponentialMovingWindow also has an <code class="docutils literal notranslate"><span class="pre">ignore_na</span></code> argument, which determines how intermediate null values affect the calculation of the weights. When <code class="docutils literal notranslate"><span class="pre">ignore_na=False</span></code> (the default), weights are calculated based on absolute positions, so that intermediate null values affect the result. When <code class="docutils literal notranslate"><span class="pre">ignore_na=True</span></code>, weights are calculated by ignoring intermediate null values. For example, assuming <code class="docutils literal notranslate"><span class="pre">adjust=True</span></code>, if <code class="docutils literal notranslate"><span class="pre">ignore_na=False</span></code>, the weighted average of <code class="docutils literal notranslate"><span class="pre">3,</span> <span class="pre">NaN,</span> <span class="pre">5</span></code> would be calculated as</p> <div class="math notranslate nohighlight"> \[\frac{(1-\alpha)^2 \cdot 3 + 1 \cdot 5}{(1-\alpha)^2 + 1}.\]</div> <p>Whereas if <code class="docutils literal notranslate"><span class="pre">ignore_na=True</span></code>, the weighted average would be calculated as</p> <div class="math notranslate nohighlight"> \[\frac{(1-\alpha) \cdot 3 + 1 \cdot 5}{(1-\alpha) + 1}.\]</div> <p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">var()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">std()</span></code>, and <code class="xref py py-meth docutils literal notranslate"><span class="pre">cov()</span></code> functions have a <code class="docutils literal notranslate"><span class="pre">bias</span></code> argument, specifying whether the result should contain biased or unbiased statistics. For example, if <code class="docutils literal notranslate"><span class="pre">bias=True</span></code>, <code class="docutils literal notranslate"><span class="pre">ewmvar(x)</span></code> is calculated as <code class="docutils literal notranslate"><span class="pre">ewmvar(x)</span> <span class="pre">=</span> <span class="pre">ewma(x**2)</span> <span class="pre">-</span> <span class="pre">ewma(x)**2</span></code>; whereas if <code class="docutils literal notranslate"><span class="pre">bias=False</span></code> (the default), the biased variance statistics are scaled by debiasing factors</p> <div class="math notranslate nohighlight"> \[\frac{\left(\sum_{i=0}^t w_i\right)^2}{\left(\sum_{i=0}^t w_i\right)^2 - \sum_{i=0}^t w_i^2}.\]</div> <p>(For <span class="math notranslate nohighlight">\(w_i = 1\)</span>, this reduces to the usual <span class="math notranslate nohighlight">\(N / (N - 1)\)</span> factor, with <span class="math notranslate nohighlight">\(N = t + 1\)</span>.) See <a class="reference external" href="https://en.wikipedia.org/wiki/Weighted_arithmetic_mean#Weighted_sample_variance">Weighted Sample Variance</a> on Wikipedia for further details.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2008&ndash;2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://pandas.pydata.org/pandas-docs/version/1.4.0/user_guide/window.html" class="_attribution-link">https://pandas.pydata.org/pandas-docs/version/1.4.0/user_guide/window.html</a>
  </p>
</div>
