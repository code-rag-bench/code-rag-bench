<h1>Essential basic functionality</h1> <p>Here we discuss a lot of the essential functionality common to the pandas data structures. To begin, let’s create some example objects like we did in the <a class="reference internal" href="10min#min"><span class="std std-ref">10 minutes to pandas</span></a> section:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [1]: index = pd.date_range("1/1/2000", periods=8)

In [2]: s = pd.Series(np.random.randn(5), index=["a", "b", "c", "d", "e"])

In [3]: df = pd.DataFrame(np.random.randn(8, 3), index=index, columns=["A", "B", "C"])
</pre></div> </div> <section id="head-and-tail"> <h2>Head and tail</h2> <p>To view a small sample of a Series or DataFrame object, use the <a class="reference internal" href="../reference/api/pandas.dataframe.head#pandas.DataFrame.head" title="pandas.DataFrame.head"><code class="xref py py-meth docutils literal notranslate"><span class="pre">head()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.tail#pandas.DataFrame.tail" title="pandas.DataFrame.tail"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tail()</span></code></a> methods. The default number of elements to display is five, but you may pass a custom number.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [4]: long_series = pd.Series(np.random.randn(1000))

In [5]: long_series.head()
Out[5]: 
0   -1.157892
1   -1.344312
2    0.844885
3    1.075770
4   -0.109050
dtype: float64

In [6]: long_series.tail(3)
Out[6]: 
997   -0.289388
998   -1.020544
999    0.589993
dtype: float64
</pre></div> </div> </section> <section id="attributes-and-underlying-data"> <h2>Attributes and underlying data</h2> <p>pandas objects have a number of attributes enabling you to access the metadata</p> <ul class="simple"> <li><p><strong>shape</strong>: gives the axis dimensions of the object, consistent with ndarray</p></li> <li>
<dl class="simple"> <dt>Axis labels</dt>
<dd>
<ul> <li><p><strong>Series</strong>: <em>index</em> (only axis)</p></li> <li><p><strong>DataFrame</strong>: <em>index</em> (rows) and <em>columns</em></p></li> </ul> </dd> </dl> </li> </ul> <p>Note, <strong>these attributes can be safely assigned to</strong>!</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [7]: df[:2]
Out[7]: 
                   A         B         C
2000-01-01 -0.173215  0.119209 -1.044236
2000-01-02 -0.861849 -2.104569 -0.494929

In [8]: df.columns = [x.lower() for x in df.columns]

In [9]: df
Out[9]: 
                   a         b         c
2000-01-01 -0.173215  0.119209 -1.044236
2000-01-02 -0.861849 -2.104569 -0.494929
2000-01-03  1.071804  0.721555 -0.706771
2000-01-04 -1.039575  0.271860 -0.424972
2000-01-05  0.567020  0.276232 -1.087401
2000-01-06 -0.673690  0.113648 -1.478427
2000-01-07  0.524988  0.404705  0.577046
2000-01-08 -1.715002 -1.039268 -0.370647
</pre></div> </div> <p>pandas objects (<a class="reference internal" href="../reference/api/pandas.index#pandas.Index" title="pandas.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a>, <a class="reference internal" href="../reference/api/pandas.series#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a>, <a class="reference internal" href="../reference/api/pandas.dataframe#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a>) can be thought of as containers for arrays, which hold the actual data and do the actual computation. For many types, the underlying array is a <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.22)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>. However, pandas and 3rd party libraries may <em>extend</em> NumPy’s type system to add support for custom arrays (see <a class="reference internal" href="#basics-dtypes"><span class="std std-ref">dtypes</span></a>).</p> <p>To get the actual data inside a <a class="reference internal" href="../reference/api/pandas.index#pandas.Index" title="pandas.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a> or <a class="reference internal" href="../reference/api/pandas.series#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a>, use the <code class="docutils literal notranslate"><span class="pre">.array</span></code> property</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [10]: s.array
Out[10]: 
&lt;PandasArray&gt;
[ 0.4691122999071863, -0.2828633443286633, -1.5090585031735124,
 -1.1356323710171934,  1.2121120250208506]
Length: 5, dtype: float64

In [11]: s.index.array
Out[11]: 
&lt;PandasArray&gt;
['a', 'b', 'c', 'd', 'e']
Length: 5, dtype: object
</pre></div> </div> <p><a class="reference internal" href="../reference/api/pandas.series.array#pandas.Series.array" title="pandas.Series.array"><code class="xref py py-attr docutils literal notranslate"><span class="pre">array</span></code></a> will always be an <a class="reference internal" href="../reference/api/pandas.api.extensions.extensionarray#pandas.api.extensions.ExtensionArray" title="pandas.api.extensions.ExtensionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExtensionArray</span></code></a>. The exact details of what an <a class="reference internal" href="../reference/api/pandas.api.extensions.extensionarray#pandas.api.extensions.ExtensionArray" title="pandas.api.extensions.ExtensionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExtensionArray</span></code></a> is and why pandas uses them are a bit beyond the scope of this introduction. See <a class="reference internal" href="#basics-dtypes"><span class="std std-ref">dtypes</span></a> for more.</p> <p>If you know you need a NumPy array, use <a class="reference internal" href="../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy" title="pandas.Series.to_numpy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_numpy()</span></code></a> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">numpy.asarray()</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [12]: s.to_numpy()
Out[12]: array([ 0.4691, -0.2829, -1.5091, -1.1356,  1.2121])

In [13]: np.asarray(s)
Out[13]: array([ 0.4691, -0.2829, -1.5091, -1.1356,  1.2121])
</pre></div> </div> <p>When the Series or Index is backed by an <a class="reference internal" href="../reference/api/pandas.api.extensions.extensionarray#pandas.api.extensions.ExtensionArray" title="pandas.api.extensions.ExtensionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExtensionArray</span></code></a>, <a class="reference internal" href="../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy" title="pandas.Series.to_numpy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_numpy()</span></code></a> may involve copying data and coercing values. See <a class="reference internal" href="#basics-dtypes"><span class="std std-ref">dtypes</span></a> for more.</p> <p><a class="reference internal" href="../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy" title="pandas.Series.to_numpy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_numpy()</span></code></a> gives some control over the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> of the resulting <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.22)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>. For example, consider datetimes with timezones. NumPy doesn’t have a dtype to represent timezone-aware datetimes, so there are two possibly useful representations:</p> <ol class="arabic simple"> <li><p>An object-dtype <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.22)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> with <a class="reference internal" href="../reference/api/pandas.timestamp#pandas.Timestamp" title="pandas.Timestamp"><code class="xref py py-class docutils literal notranslate"><span class="pre">Timestamp</span></code></a> objects, each with the correct <code class="docutils literal notranslate"><span class="pre">tz</span></code></p></li> <li><p>A <code class="docutils literal notranslate"><span class="pre">datetime64[ns]</span></code> -dtype <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.22)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>, where the values have been converted to UTC and the timezone discarded</p></li> </ol> <p>Timezones may be preserved with <code class="docutils literal notranslate"><span class="pre">dtype=object</span></code></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [14]: ser = pd.Series(pd.date_range("2000", periods=2, tz="CET"))

In [15]: ser.to_numpy(dtype=object)
Out[15]: 
array([Timestamp('2000-01-01 00:00:00+0100', tz='CET'),
       Timestamp('2000-01-02 00:00:00+0100', tz='CET')], dtype=object)
</pre></div> </div> <p>Or thrown away with <code class="docutils literal notranslate"><span class="pre">dtype='datetime64[ns]'</span></code></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [16]: ser.to_numpy(dtype="datetime64[ns]")
Out[16]: 
array(['1999-12-31T23:00:00.000000000', '2000-01-01T23:00:00.000000000'],
      dtype='datetime64[ns]')
</pre></div> </div> <p>Getting the “raw data” inside a <a class="reference internal" href="../reference/api/pandas.dataframe#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> is possibly a bit more complex. When your <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> only has a single data type for all the columns, <a class="reference internal" href="../reference/api/pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy" title="pandas.DataFrame.to_numpy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.to_numpy()</span></code></a> will return the underlying data:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [17]: df.to_numpy()
Out[17]: 
array([[-0.1732,  0.1192, -1.0442],
       [-0.8618, -2.1046, -0.4949],
       [ 1.0718,  0.7216, -0.7068],
       [-1.0396,  0.2719, -0.425 ],
       [ 0.567 ,  0.2762, -1.0874],
       [-0.6737,  0.1136, -1.4784],
       [ 0.525 ,  0.4047,  0.577 ],
       [-1.715 , -1.0393, -0.3706]])
</pre></div> </div> <p>If a DataFrame contains homogeneously-typed data, the ndarray can actually be modified in-place, and the changes will be reflected in the data structure. For heterogeneous data (e.g. some of the DataFrame’s columns are not all the same dtype), this will not be the case. The values attribute itself, unlike the axis labels, cannot be assigned to.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>When working with heterogeneous data, the dtype of the resulting ndarray will be chosen to accommodate all of the data involved. For example, if strings are involved, the result will be of object dtype. If there are only floats and integers, the resulting array will be of float dtype.</p> </div> <p>In the past, pandas recommended <a class="reference internal" href="../reference/api/pandas.series.values#pandas.Series.values" title="pandas.Series.values"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Series.values</span></code></a> or <a class="reference internal" href="../reference/api/pandas.dataframe.values#pandas.DataFrame.values" title="pandas.DataFrame.values"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataFrame.values</span></code></a> for extracting the data from a Series or DataFrame. You’ll still find references to these in old code bases and online. Going forward, we recommend avoiding <code class="docutils literal notranslate"><span class="pre">.values</span></code> and using <code class="docutils literal notranslate"><span class="pre">.array</span></code> or <code class="docutils literal notranslate"><span class="pre">.to_numpy()</span></code>. <code class="docutils literal notranslate"><span class="pre">.values</span></code> has the following drawbacks:</p> <ol class="arabic simple"> <li><p>When your Series contains an <a class="reference internal" href="https://pandas.pydata.org/pandas-docs/version/1.4.0/development/extending.html#extending-extension-types"><span class="std std-ref">extension type</span></a>, it’s unclear whether <a class="reference internal" href="../reference/api/pandas.series.values#pandas.Series.values" title="pandas.Series.values"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Series.values</span></code></a> returns a NumPy array or the extension array. <a class="reference internal" href="../reference/api/pandas.series.array#pandas.Series.array" title="pandas.Series.array"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Series.array</span></code></a> will always return an <a class="reference internal" href="../reference/api/pandas.api.extensions.extensionarray#pandas.api.extensions.ExtensionArray" title="pandas.api.extensions.ExtensionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExtensionArray</span></code></a>, and will never copy data. <a class="reference internal" href="../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy" title="pandas.Series.to_numpy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Series.to_numpy()</span></code></a> will always return a NumPy array, potentially at the cost of copying / coercing values.</p></li> <li><p>When your DataFrame contains a mixture of data types, <a class="reference internal" href="../reference/api/pandas.dataframe.values#pandas.DataFrame.values" title="pandas.DataFrame.values"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataFrame.values</span></code></a> may involve copying data and coercing values to a common dtype, a relatively expensive operation. <a class="reference internal" href="../reference/api/pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy" title="pandas.DataFrame.to_numpy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.to_numpy()</span></code></a>, being a method, makes it clearer that the returned NumPy array may not be a view on the same data in the DataFrame.</p></li> </ol> </section> <section id="accelerated-operations"> <h2>Accelerated operations</h2> <p>pandas has support for accelerating certain types of binary numerical and boolean operations using the <code class="docutils literal notranslate"><span class="pre">numexpr</span></code> library and the <code class="docutils literal notranslate"><span class="pre">bottleneck</span></code> libraries.</p> <p>These libraries are especially useful when dealing with large data sets, and provide large speedups. <code class="docutils literal notranslate"><span class="pre">numexpr</span></code> uses smart chunking, caching, and multiple cores. <code class="docutils literal notranslate"><span class="pre">bottleneck</span></code> is a set of specialized cython routines that are especially fast when dealing with arrays that have <code class="docutils literal notranslate"><span class="pre">nans</span></code>.</p> <p>Here is a sample (using 100 column x 100,000 row <code class="docutils literal notranslate"><span class="pre">DataFrames</span></code>):</p> <table class="colwidths-given table"> <colgroup> <col style="width: 25%"> <col style="width: 25%"> <col style="width: 25%"> <col style="width: 25%"> </colgroup> <thead> <tr class="row-odd">
<th class="head"><p>Operation</p></th> <th class="head"><p>0.11.0 (ms)</p></th> <th class="head"><p>Prior Version (ms)</p></th> <th class="head"><p>Ratio to Prior</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">df1</span> <span class="pre">&gt;</span> <span class="pre">df2</span></code></p></td> <td><p>13.32</p></td> <td><p>125.35</p></td> <td><p>0.1063</p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">df1</span> <span class="pre">*</span> <span class="pre">df2</span></code></p></td> <td><p>21.71</p></td> <td><p>36.63</p></td> <td><p>0.5928</p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">df1</span> <span class="pre">+</span> <span class="pre">df2</span></code></p></td> <td><p>22.04</p></td> <td><p>36.50</p></td> <td><p>0.6039</p></td> </tr> </tbody> </table> <p>You are highly encouraged to install both libraries. See the section <a class="reference internal" href="https://pandas.pydata.org/pandas-docs/version/1.4.0/getting_started/install.html#install-recommended-dependencies"><span class="std std-ref">Recommended Dependencies</span></a> for more installation info.</p> <p>These are both enabled to be used by default, you can control this by setting the options:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">pd.set_option("compute.use_bottleneck", False)
pd.set_option("compute.use_numexpr", False)
</pre></div> </div> </section> <section id="flexible-binary-operations"> <h2>Flexible binary operations</h2> <p>With binary operations between pandas data structures, there are two key points of interest:</p> <ul class="simple"> <li><p>Broadcasting behavior between higher- (e.g. DataFrame) and lower-dimensional (e.g. Series) objects.</p></li> <li><p>Missing data in computations.</p></li> </ul> <p>We will demonstrate how to manage these issues independently, though they can be handled simultaneously.</p> <section id="matching-broadcasting-behavior"> <h3>Matching / broadcasting behavior</h3> <p>DataFrame has the methods <a class="reference internal" href="../reference/api/pandas.dataframe.add#pandas.DataFrame.add" title="pandas.DataFrame.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code></a>, <a class="reference internal" href="../reference/api/pandas.dataframe.sub#pandas.DataFrame.sub" title="pandas.DataFrame.sub"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sub()</span></code></a>, <a class="reference internal" href="../reference/api/pandas.dataframe.mul#pandas.DataFrame.mul" title="pandas.DataFrame.mul"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mul()</span></code></a>, <a class="reference internal" href="../reference/api/pandas.dataframe.div#pandas.DataFrame.div" title="pandas.DataFrame.div"><code class="xref py py-meth docutils literal notranslate"><span class="pre">div()</span></code></a> and related functions <a class="reference internal" href="../reference/api/pandas.dataframe.radd#pandas.DataFrame.radd" title="pandas.DataFrame.radd"><code class="xref py py-meth docutils literal notranslate"><span class="pre">radd()</span></code></a>, <a class="reference internal" href="../reference/api/pandas.dataframe.rsub#pandas.DataFrame.rsub" title="pandas.DataFrame.rsub"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rsub()</span></code></a>, … for carrying out binary operations. For broadcasting behavior, Series input is of primary interest. Using these functions, you can use to either match on the <em>index</em> or <em>columns</em> via the <strong>axis</strong> keyword:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [18]: df = pd.DataFrame(
   ....:     {
   ....:         "one": pd.Series(np.random.randn(3), index=["a", "b", "c"]),
   ....:         "two": pd.Series(np.random.randn(4), index=["a", "b", "c", "d"]),
   ....:         "three": pd.Series(np.random.randn(3), index=["b", "c", "d"]),
   ....:     }
   ....: )
   ....: 

In [19]: df
Out[19]: 
        one       two     three
a  1.394981  1.772517       NaN
b  0.343054  1.912123 -0.050390
c  0.695246  1.478369  1.227435
d       NaN  0.279344 -0.613172

In [20]: row = df.iloc[1]

In [21]: column = df["two"]

In [22]: df.sub(row, axis="columns")
Out[22]: 
        one       two     three
a  1.051928 -0.139606       NaN
b  0.000000  0.000000  0.000000
c  0.352192 -0.433754  1.277825
d       NaN -1.632779 -0.562782

In [23]: df.sub(row, axis=1)
Out[23]: 
        one       two     three
a  1.051928 -0.139606       NaN
b  0.000000  0.000000  0.000000
c  0.352192 -0.433754  1.277825
d       NaN -1.632779 -0.562782

In [24]: df.sub(column, axis="index")
Out[24]: 
        one  two     three
a -0.377535  0.0       NaN
b -1.569069  0.0 -1.962513
c -0.783123  0.0 -0.250933
d       NaN  0.0 -0.892516

In [25]: df.sub(column, axis=0)
Out[25]: 
        one  two     three
a -0.377535  0.0       NaN
b -1.569069  0.0 -1.962513
c -0.783123  0.0 -0.250933
d       NaN  0.0 -0.892516
</pre></div> </div> <p>Furthermore you can align a level of a MultiIndexed DataFrame with a Series.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [26]: dfmi = df.copy()

In [27]: dfmi.index = pd.MultiIndex.from_tuples(
   ....:     [(1, "a"), (1, "b"), (1, "c"), (2, "a")], names=["first", "second"]
   ....: )
   ....: 

In [28]: dfmi.sub(column, axis=0, level="second")
Out[28]: 
                   one       two     three
first second                              
1     a      -0.377535  0.000000       NaN
      b      -1.569069  0.000000 -1.962513
      c      -0.783123  0.000000 -0.250933
2     a            NaN -1.493173 -2.385688
</pre></div> </div> <p>Series and Index also support the <a class="reference external" href="https://docs.python.org/3/library/functions.html#divmod" title="(in Python v3.10)"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a> builtin. This function takes the floor division and modulo operation at the same time returning a two-tuple of the same type as the left hand side. For example:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [29]: s = pd.Series(np.arange(10))

In [30]: s
Out[30]: 
0    0
1    1
2    2
3    3
4    4
5    5
6    6
7    7
8    8
9    9
dtype: int64

In [31]: div, rem = divmod(s, 3)

In [32]: div
Out[32]: 
0    0
1    0
2    0
3    1
4    1
5    1
6    2
7    2
8    2
9    3
dtype: int64

In [33]: rem
Out[33]: 
0    0
1    1
2    2
3    0
4    1
5    2
6    0
7    1
8    2
9    0
dtype: int64

In [34]: idx = pd.Index(np.arange(10))

In [35]: idx
Out[35]: Int64Index([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype='int64')

In [36]: div, rem = divmod(idx, 3)

In [37]: div
Out[37]: Int64Index([0, 0, 0, 1, 1, 1, 2, 2, 2, 3], dtype='int64')

In [38]: rem
Out[38]: Int64Index([0, 1, 2, 0, 1, 2, 0, 1, 2, 0], dtype='int64')
</pre></div> </div> <p>We can also do elementwise <a class="reference external" href="https://docs.python.org/3/library/functions.html#divmod" title="(in Python v3.10)"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [39]: div, rem = divmod(s, [2, 2, 3, 3, 4, 4, 5, 5, 6, 6])

In [40]: div
Out[40]: 
0    0
1    0
2    0
3    1
4    1
5    1
6    1
7    1
8    1
9    1
dtype: int64

In [41]: rem
Out[41]: 
0    0
1    1
2    2
3    0
4    0
5    1
6    1
7    2
8    2
9    3
dtype: int64
</pre></div> </div> </section> <section id="missing-data-operations-with-fill-values"> <h3>Missing data / operations with fill values</h3> <p>In Series and DataFrame, the arithmetic functions have the option of inputting a <em>fill_value</em>, namely a value to substitute when at most one of the values at a location are missing. For example, when adding two DataFrame objects, you may wish to treat NaN as 0 unless both DataFrames are missing that value, in which case the result will be NaN (you can later replace NaN with some other value using <code class="docutils literal notranslate"><span class="pre">fillna</span></code> if you wish).</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [42]: df
Out[42]: 
        one       two     three
a  1.394981  1.772517       NaN
b  0.343054  1.912123 -0.050390
c  0.695246  1.478369  1.227435
d       NaN  0.279344 -0.613172

In [43]: df2
Out[43]: 
        one       two     three
a  1.394981  1.772517  1.000000
b  0.343054  1.912123 -0.050390
c  0.695246  1.478369  1.227435
d       NaN  0.279344 -0.613172

In [44]: df + df2
Out[44]: 
        one       two     three
a  2.789963  3.545034       NaN
b  0.686107  3.824246 -0.100780
c  1.390491  2.956737  2.454870
d       NaN  0.558688 -1.226343

In [45]: df.add(df2, fill_value=0)
Out[45]: 
        one       two     three
a  2.789963  3.545034  1.000000
b  0.686107  3.824246 -0.100780
c  1.390491  2.956737  2.454870
d       NaN  0.558688 -1.226343
</pre></div> </div> </section> <section id="flexible-comparisons"> <h3>Flexible comparisons</h3> <p>Series and DataFrame have the binary comparison methods <code class="docutils literal notranslate"><span class="pre">eq</span></code>, <code class="docutils literal notranslate"><span class="pre">ne</span></code>, <code class="docutils literal notranslate"><span class="pre">lt</span></code>, <code class="docutils literal notranslate"><span class="pre">gt</span></code>, <code class="docutils literal notranslate"><span class="pre">le</span></code>, and <code class="docutils literal notranslate"><span class="pre">ge</span></code> whose behavior is analogous to the binary arithmetic operations described above:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [46]: df.gt(df2)
Out[46]: 
     one    two  three
a  False  False  False
b  False  False  False
c  False  False  False
d  False  False  False

In [47]: df2.ne(df)
Out[47]: 
     one    two  three
a  False  False   True
b  False  False  False
c  False  False  False
d   True  False  False
</pre></div> </div> <p>These operations produce a pandas object of the same type as the left-hand-side input that is of dtype <code class="docutils literal notranslate"><span class="pre">bool</span></code>. These <code class="docutils literal notranslate"><span class="pre">boolean</span></code> objects can be used in indexing operations, see the section on <a class="reference internal" href="indexing#indexing-boolean"><span class="std std-ref">Boolean indexing</span></a>.</p> </section> <section id="boolean-reductions"> <h3>Boolean reductions</h3> <p>You can apply the reductions: <a class="reference internal" href="../reference/api/pandas.dataframe.empty#pandas.DataFrame.empty" title="pandas.DataFrame.empty"><code class="xref py py-attr docutils literal notranslate"><span class="pre">empty</span></code></a>, <a class="reference internal" href="../reference/api/pandas.dataframe.any#pandas.DataFrame.any" title="pandas.DataFrame.any"><code class="xref py py-meth docutils literal notranslate"><span class="pre">any()</span></code></a>, <a class="reference internal" href="../reference/api/pandas.dataframe.all#pandas.DataFrame.all" title="pandas.DataFrame.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all()</span></code></a>, and <a class="reference internal" href="../reference/api/pandas.dataframe.bool#pandas.DataFrame.bool" title="pandas.DataFrame.bool"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bool()</span></code></a> to provide a way to summarize a boolean result.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [48]: (df &gt; 0).all()
Out[48]: 
one      False
two       True
three    False
dtype: bool

In [49]: (df &gt; 0).any()
Out[49]: 
one      True
two      True
three    True
dtype: bool
</pre></div> </div> <p>You can reduce to a final boolean value.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [50]: (df &gt; 0).any().any()
Out[50]: True
</pre></div> </div> <p>You can test if a pandas object is empty, via the <a class="reference internal" href="../reference/api/pandas.dataframe.empty#pandas.DataFrame.empty" title="pandas.DataFrame.empty"><code class="xref py py-attr docutils literal notranslate"><span class="pre">empty</span></code></a> property.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [51]: df.empty
Out[51]: False

In [52]: pd.DataFrame(columns=list("ABC")).empty
Out[52]: True
</pre></div> </div> <p>To evaluate single-element pandas objects in a boolean context, use the method <a class="reference internal" href="../reference/api/pandas.dataframe.bool#pandas.DataFrame.bool" title="pandas.DataFrame.bool"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bool()</span></code></a>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [53]: pd.Series([True]).bool()
Out[53]: True

In [54]: pd.Series([False]).bool()
Out[54]: False

In [55]: pd.DataFrame([[True]]).bool()
Out[55]: True

In [56]: pd.DataFrame([[False]]).bool()
Out[56]: False
</pre></div> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>You might be tempted to do the following:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">&gt;&gt;&gt; if df:
...     pass
</pre></div> </div> <p>Or</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">&gt;&gt;&gt; df and df2
</pre></div> </div> <p>These will both raise errors, as you are trying to compare multiple values.:</p> <div class="highlight-default notranslate">
<div class="highlight"><pre data-language="python">ValueError: The truth value of an array is ambiguous. Use a.empty, a.any() or a.all().
</pre></div> </div> </div> <p>See <a class="reference internal" href="gotchas#gotchas-truth"><span class="std std-ref">gotchas</span></a> for a more detailed discussion.</p> </section> <section id="comparing-if-objects-are-equivalent"> <h3>Comparing if objects are equivalent</h3> <p>Often you may find that there is more than one way to compute the same result. As a simple example, consider <code class="docutils literal notranslate"><span class="pre">df</span> <span class="pre">+</span> <span class="pre">df</span></code> and <code class="docutils literal notranslate"><span class="pre">df</span> <span class="pre">*</span> <span class="pre">2</span></code>. To test that these two computations produce the same result, given the tools shown above, you might imagine using <code class="docutils literal notranslate"><span class="pre">(df</span> <span class="pre">+</span> <span class="pre">df</span> <span class="pre">==</span> <span class="pre">df</span> <span class="pre">*</span> <span class="pre">2).all()</span></code>. But in fact, this expression is False:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [57]: df + df == df * 2
Out[57]: 
     one   two  three
a   True  True  False
b   True  True   True
c   True  True   True
d  False  True   True

In [58]: (df + df == df * 2).all()
Out[58]: 
one      False
two       True
three    False
dtype: bool
</pre></div> </div> <p>Notice that the boolean DataFrame <code class="docutils literal notranslate"><span class="pre">df</span> <span class="pre">+</span> <span class="pre">df</span> <span class="pre">==</span> <span class="pre">df</span> <span class="pre">*</span> <span class="pre">2</span></code> contains some False values! This is because NaNs do not compare as equals:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [59]: np.nan == np.nan
Out[59]: False
</pre></div> </div> <p>So, NDFrames (such as Series and DataFrames) have an <a class="reference internal" href="../reference/api/pandas.dataframe.equals#pandas.DataFrame.equals" title="pandas.DataFrame.equals"><code class="xref py py-meth docutils literal notranslate"><span class="pre">equals()</span></code></a> method for testing equality, with NaNs in corresponding locations treated as equal.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [60]: (df + df).equals(df * 2)
Out[60]: True
</pre></div> </div> <p>Note that the Series or DataFrame index needs to be in the same order for equality to be True:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [61]: df1 = pd.DataFrame({"col": ["foo", 0, np.nan]})

In [62]: df2 = pd.DataFrame({"col": [np.nan, 0, "foo"]}, index=[2, 1, 0])

In [63]: df1.equals(df2)
Out[63]: False

In [64]: df1.equals(df2.sort_index())
Out[64]: True
</pre></div> </div> </section> <section id="comparing-array-like-objects"> <h3>Comparing array-like objects</h3> <p>You can conveniently perform element-wise comparisons when comparing a pandas data structure with a scalar value:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [65]: pd.Series(["foo", "bar", "baz"]) == "foo"
Out[65]: 
0     True
1    False
2    False
dtype: bool

In [66]: pd.Index(["foo", "bar", "baz"]) == "foo"
Out[66]: array([ True, False, False])
</pre></div> </div> <p>pandas also handles element-wise comparisons between different array-like objects of the same length:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [67]: pd.Series(["foo", "bar", "baz"]) == pd.Index(["foo", "bar", "qux"])
Out[67]: 
0     True
1     True
2    False
dtype: bool

In [68]: pd.Series(["foo", "bar", "baz"]) == np.array(["foo", "bar", "qux"])
Out[68]: 
0     True
1     True
2    False
dtype: bool
</pre></div> </div> <p>Trying to compare <code class="docutils literal notranslate"><span class="pre">Index</span></code> or <code class="docutils literal notranslate"><span class="pre">Series</span></code> objects of different lengths will raise a ValueError:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [55]: pd.Series(['foo', 'bar', 'baz']) == pd.Series(['foo', 'bar'])
ValueError: Series lengths must match to compare

In [56]: pd.Series(['foo', 'bar', 'baz']) == pd.Series(['foo'])
ValueError: Series lengths must match to compare
</pre></div> </div> <p>Note that this is different from the NumPy behavior where a comparison can be broadcast:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [69]: np.array([1, 2, 3]) == np.array([2])
Out[69]: array([False,  True, False])
</pre></div> </div> <p>or it can return False if broadcasting can not be done:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [70]: np.array([1, 2, 3]) == np.array([1, 2])
Out[70]: False
</pre></div> </div> </section> <section id="combining-overlapping-data-sets"> <h3>Combining overlapping data sets</h3> <p>A problem occasionally arising is the combination of two similar data sets where values in one are preferred over the other. An example would be two data series representing a particular economic indicator where one is considered to be of “higher quality”. However, the lower quality series might extend further back in history or have more complete data coverage. As such, we would like to combine two DataFrame objects where missing values in one DataFrame are conditionally filled with like-labeled values from the other DataFrame. The function implementing this operation is <a class="reference internal" href="../reference/api/pandas.dataframe.combine_first#pandas.DataFrame.combine_first" title="pandas.DataFrame.combine_first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">combine_first()</span></code></a>, which we illustrate:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [71]: df1 = pd.DataFrame(
   ....:     {"A": [1.0, np.nan, 3.0, 5.0, np.nan], "B": [np.nan, 2.0, 3.0, np.nan, 6.0]}
   ....: )
   ....: 

In [72]: df2 = pd.DataFrame(
   ....:     {
   ....:         "A": [5.0, 2.0, 4.0, np.nan, 3.0, 7.0],
   ....:         "B": [np.nan, np.nan, 3.0, 4.0, 6.0, 8.0],
   ....:     }
   ....: )
   ....: 

In [73]: df1
Out[73]: 
     A    B
0  1.0  NaN
1  NaN  2.0
2  3.0  3.0
3  5.0  NaN
4  NaN  6.0

In [74]: df2
Out[74]: 
     A    B
0  5.0  NaN
1  2.0  NaN
2  4.0  3.0
3  NaN  4.0
4  3.0  6.0
5  7.0  8.0

In [75]: df1.combine_first(df2)
Out[75]: 
     A    B
0  1.0  NaN
1  2.0  2.0
2  3.0  3.0
3  5.0  4.0
4  3.0  6.0
5  7.0  8.0
</pre></div> </div> </section> <section id="general-dataframe-combine"> <h3>General DataFrame combine</h3> <p>The <a class="reference internal" href="../reference/api/pandas.dataframe.combine_first#pandas.DataFrame.combine_first" title="pandas.DataFrame.combine_first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">combine_first()</span></code></a> method above calls the more general <a class="reference internal" href="../reference/api/pandas.dataframe.combine#pandas.DataFrame.combine" title="pandas.DataFrame.combine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.combine()</span></code></a>. This method takes another DataFrame and a combiner function, aligns the input DataFrame and then passes the combiner function pairs of Series (i.e., columns whose names are the same).</p> <p>So, for instance, to reproduce <a class="reference internal" href="../reference/api/pandas.dataframe.combine_first#pandas.DataFrame.combine_first" title="pandas.DataFrame.combine_first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">combine_first()</span></code></a> as above:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [76]: def combiner(x, y):
   ....:     return np.where(pd.isna(x), y, x)
   ....: 

In [77]: df1.combine(df2, combiner)
Out[77]: 
     A    B
0  1.0  NaN
1  2.0  2.0
2  3.0  3.0
3  5.0  4.0
4  3.0  6.0
5  7.0  8.0
</pre></div> </div> </section> </section> <section id="descriptive-statistics"> <h2>Descriptive statistics</h2> <p>There exists a large number of methods for computing descriptive statistics and other related operations on <a class="reference internal" href="../reference/series#api-series-stats"><span class="std std-ref">Series</span></a>, <a class="reference internal" href="../reference/frame#api-dataframe-stats"><span class="std std-ref">DataFrame</span></a>. Most of these are aggregations (hence producing a lower-dimensional result) like <a class="reference internal" href="../reference/api/pandas.dataframe.sum#pandas.DataFrame.sum" title="pandas.DataFrame.sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sum()</span></code></a>, <a class="reference internal" href="../reference/api/pandas.dataframe.mean#pandas.DataFrame.mean" title="pandas.DataFrame.mean"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mean()</span></code></a>, and <a class="reference internal" href="../reference/api/pandas.dataframe.quantile#pandas.DataFrame.quantile" title="pandas.DataFrame.quantile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quantile()</span></code></a>, but some of them, like <a class="reference internal" href="../reference/api/pandas.dataframe.cumsum#pandas.DataFrame.cumsum" title="pandas.DataFrame.cumsum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cumsum()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.cumprod#pandas.DataFrame.cumprod" title="pandas.DataFrame.cumprod"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cumprod()</span></code></a>, produce an object of the same size. Generally speaking, these methods take an <strong>axis</strong> argument, just like <em>ndarray.{sum, std, …}</em>, but the axis can be specified by name or integer:</p> <ul class="simple"> <li><p><strong>Series</strong>: no axis argument needed</p></li> <li><p><strong>DataFrame</strong>: “index” (axis=0, default), “columns” (axis=1)</p></li> </ul> <p>For example:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [78]: df
Out[78]: 
        one       two     three
a  1.394981  1.772517       NaN
b  0.343054  1.912123 -0.050390
c  0.695246  1.478369  1.227435
d       NaN  0.279344 -0.613172

In [79]: df.mean(0)
Out[79]: 
one      0.811094
two      1.360588
three    0.187958
dtype: float64

In [80]: df.mean(1)
Out[80]: 
a    1.583749
b    0.734929
c    1.133683
d   -0.166914
dtype: float64
</pre></div> </div> <p>All such methods have a <code class="docutils literal notranslate"><span class="pre">skipna</span></code> option signaling whether to exclude missing data (<code class="docutils literal notranslate"><span class="pre">True</span></code> by default):</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [81]: df.sum(0, skipna=False)
Out[81]: 
one           NaN
two      5.442353
three         NaN
dtype: float64

In [82]: df.sum(axis=1, skipna=True)
Out[82]: 
a    3.167498
b    2.204786
c    3.401050
d   -0.333828
dtype: float64
</pre></div> </div> <p>Combined with the broadcasting / arithmetic behavior, one can describe various statistical procedures, like standardization (rendering data zero mean and standard deviation of 1), very concisely:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [83]: ts_stand = (df - df.mean()) / df.std()

In [84]: ts_stand.std()
Out[84]: 
one      1.0
two      1.0
three    1.0
dtype: float64

In [85]: xs_stand = df.sub(df.mean(1), axis=0).div(df.std(1), axis=0)

In [86]: xs_stand.std(1)
Out[86]: 
a    1.0
b    1.0
c    1.0
d    1.0
dtype: float64
</pre></div> </div> <p>Note that methods like <a class="reference internal" href="../reference/api/pandas.dataframe.cumsum#pandas.DataFrame.cumsum" title="pandas.DataFrame.cumsum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cumsum()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.cumprod#pandas.DataFrame.cumprod" title="pandas.DataFrame.cumprod"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cumprod()</span></code></a> preserve the location of <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values. This is somewhat different from <a class="reference internal" href="../reference/api/pandas.dataframe.expanding#pandas.DataFrame.expanding" title="pandas.DataFrame.expanding"><code class="xref py py-meth docutils literal notranslate"><span class="pre">expanding()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.rolling#pandas.DataFrame.rolling" title="pandas.DataFrame.rolling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rolling()</span></code></a> since <code class="docutils literal notranslate"><span class="pre">NaN</span></code> behavior is furthermore dictated by a <code class="docutils literal notranslate"><span class="pre">min_periods</span></code> parameter.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [87]: df.cumsum()
Out[87]: 
        one       two     three
a  1.394981  1.772517       NaN
b  1.738035  3.684640 -0.050390
c  2.433281  5.163008  1.177045
d       NaN  5.442353  0.563873
</pre></div> </div> <p>Here is a quick reference summary table of common functions. Each also takes an optional <code class="docutils literal notranslate"><span class="pre">level</span></code> parameter which applies only if the object has a <a class="reference internal" href="advanced#advanced-hierarchical"><span class="std std-ref">hierarchical index</span></a>.</p> <table class="colwidths-given table"> <colgroup> <col style="width: 20%"> <col style="width: 80%"> </colgroup> <thead> <tr class="row-odd">
<th class="head"><p>Function</p></th> <th class="head"><p>Description</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">count</span></code></p></td> <td><p>Number of non-NA observations</p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">sum</span></code></p></td> <td><p>Sum of values</p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">mean</span></code></p></td> <td><p>Mean of values</p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">mad</span></code></p></td> <td><p>Mean absolute deviation</p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">median</span></code></p></td> <td><p>Arithmetic median of values</p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">min</span></code></p></td> <td><p>Minimum</p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">max</span></code></p></td> <td><p>Maximum</p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">mode</span></code></p></td> <td><p>Mode</p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">abs</span></code></p></td> <td><p>Absolute Value</p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">prod</span></code></p></td> <td><p>Product of values</p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">std</span></code></p></td> <td><p>Bessel-corrected sample standard deviation</p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">var</span></code></p></td> <td><p>Unbiased variance</p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">sem</span></code></p></td> <td><p>Standard error of the mean</p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">skew</span></code></p></td> <td><p>Sample skewness (3rd moment)</p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">kurt</span></code></p></td> <td><p>Sample kurtosis (4th moment)</p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">quantile</span></code></p></td> <td><p>Sample quantile (value at %)</p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">cumsum</span></code></p></td> <td><p>Cumulative sum</p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">cumprod</span></code></p></td> <td><p>Cumulative product</p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">cummax</span></code></p></td> <td><p>Cumulative maximum</p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">cummin</span></code></p></td> <td><p>Cumulative minimum</p></td> </tr> </tbody> </table> <p>Note that by chance some NumPy methods, like <code class="docutils literal notranslate"><span class="pre">mean</span></code>, <code class="docutils literal notranslate"><span class="pre">std</span></code>, and <code class="docutils literal notranslate"><span class="pre">sum</span></code>, will exclude NAs on Series input by default:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [88]: np.mean(df["one"])
Out[88]: 0.8110935116651192

In [89]: np.mean(df["one"].to_numpy())
Out[89]: nan
</pre></div> </div> <p><a class="reference internal" href="../reference/api/pandas.series.nunique#pandas.Series.nunique" title="pandas.Series.nunique"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Series.nunique()</span></code></a> will return the number of unique non-NA values in a Series:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [90]: series = pd.Series(np.random.randn(500))

In [91]: series[20:500] = np.nan

In [92]: series[10:20] = 5

In [93]: series.nunique()
Out[93]: 11
</pre></div> </div> <section id="summarizing-data-describe"> <h3>Summarizing data: describe</h3> <p>There is a convenient <a class="reference internal" href="../reference/api/pandas.dataframe.describe#pandas.DataFrame.describe" title="pandas.DataFrame.describe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">describe()</span></code></a> function which computes a variety of summary statistics about a Series or the columns of a DataFrame (excluding NAs of course):</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [94]: series = pd.Series(np.random.randn(1000))

In [95]: series[::2] = np.nan

In [96]: series.describe()
Out[96]: 
count    500.000000
mean      -0.021292
std        1.015906
min       -2.683763
25%       -0.699070
50%       -0.069718
75%        0.714483
max        3.160915
dtype: float64

In [97]: frame = pd.DataFrame(np.random.randn(1000, 5), columns=["a", "b", "c", "d", "e"])

In [98]: frame.iloc[::2] = np.nan

In [99]: frame.describe()
Out[99]: 
                a           b           c           d           e
count  500.000000  500.000000  500.000000  500.000000  500.000000
mean     0.033387    0.030045   -0.043719   -0.051686    0.005979
std      1.017152    0.978743    1.025270    1.015988    1.006695
min     -3.000951   -2.637901   -3.303099   -3.159200   -3.188821
25%     -0.647623   -0.576449   -0.712369   -0.691338   -0.691115
50%      0.047578   -0.021499   -0.023888   -0.032652   -0.025363
75%      0.729907    0.775880    0.618896    0.670047    0.649748
max      2.740139    2.752332    3.004229    2.728702    3.240991
</pre></div> </div> <p>You can select specific percentiles to include in the output:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [100]: series.describe(percentiles=[0.05, 0.25, 0.75, 0.95])
Out[100]: 
count    500.000000
mean      -0.021292
std        1.015906
min       -2.683763
5%        -1.645423
25%       -0.699070
50%       -0.069718
75%        0.714483
95%        1.711409
max        3.160915
dtype: float64
</pre></div> </div> <p>By default, the median is always included.</p> <p>For a non-numerical Series object, <a class="reference internal" href="../reference/api/pandas.series.describe#pandas.Series.describe" title="pandas.Series.describe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">describe()</span></code></a> will give a simple summary of the number of unique values and most frequently occurring values:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [101]: s = pd.Series(["a", "a", "b", "b", "a", "a", np.nan, "c", "d", "a"])

In [102]: s.describe()
Out[102]: 
count     9
unique    4
top       a
freq      5
dtype: object
</pre></div> </div> <p>Note that on a mixed-type DataFrame object, <a class="reference internal" href="../reference/api/pandas.dataframe.describe#pandas.DataFrame.describe" title="pandas.DataFrame.describe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">describe()</span></code></a> will restrict the summary to include only numerical columns or, if none are, only categorical columns:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [103]: frame = pd.DataFrame({"a": ["Yes", "Yes", "No", "No"], "b": range(4)})

In [104]: frame.describe()
Out[104]: 
              b
count  4.000000
mean   1.500000
std    1.290994
min    0.000000
25%    0.750000
50%    1.500000
75%    2.250000
max    3.000000
</pre></div> </div> <p>This behavior can be controlled by providing a list of types as <code class="docutils literal notranslate"><span class="pre">include</span></code>/<code class="docutils literal notranslate"><span class="pre">exclude</span></code> arguments. The special value <code class="docutils literal notranslate"><span class="pre">all</span></code> can also be used:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [105]: frame.describe(include=["object"])
Out[105]: 
          a
count     4
unique    2
top     Yes
freq      2

In [106]: frame.describe(include=["number"])
Out[106]: 
              b
count  4.000000
mean   1.500000
std    1.290994
min    0.000000
25%    0.750000
50%    1.500000
75%    2.250000
max    3.000000

In [107]: frame.describe(include="all")
Out[107]: 
          a         b
count     4  4.000000
unique    2       NaN
top     Yes       NaN
freq      2       NaN
mean    NaN  1.500000
std     NaN  1.290994
min     NaN  0.000000
25%     NaN  0.750000
50%     NaN  1.500000
75%     NaN  2.250000
max     NaN  3.000000
</pre></div> </div> <p>That feature relies on <a class="reference internal" href="#basics-selectdtypes"><span class="std std-ref">select_dtypes</span></a>. Refer to there for details about accepted inputs.</p> </section> <section id="index-of-min-max-values"> <h3>Index of min/max values</h3> <p>The <a class="reference internal" href="../reference/api/pandas.dataframe.idxmin#pandas.DataFrame.idxmin" title="pandas.DataFrame.idxmin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">idxmin()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.idxmax#pandas.DataFrame.idxmax" title="pandas.DataFrame.idxmax"><code class="xref py py-meth docutils literal notranslate"><span class="pre">idxmax()</span></code></a> functions on Series and DataFrame compute the index labels with the minimum and maximum corresponding values:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [108]: s1 = pd.Series(np.random.randn(5))

In [109]: s1
Out[109]: 
0    1.118076
1   -0.352051
2   -1.242883
3   -1.277155
4   -0.641184
dtype: float64

In [110]: s1.idxmin(), s1.idxmax()
Out[110]: (3, 0)

In [111]: df1 = pd.DataFrame(np.random.randn(5, 3), columns=["A", "B", "C"])

In [112]: df1
Out[112]: 
          A         B         C
0 -0.327863 -0.946180 -0.137570
1 -0.186235 -0.257213 -0.486567
2 -0.507027 -0.871259 -0.111110
3  2.000339 -2.430505  0.089759
4 -0.321434 -0.033695  0.096271

In [113]: df1.idxmin(axis=0)
Out[113]: 
A    2
B    3
C    1
dtype: int64

In [114]: df1.idxmax(axis=1)
Out[114]: 
0    C
1    A
2    C
3    A
4    C
dtype: object
</pre></div> </div> <p>When there are multiple rows (or columns) matching the minimum or maximum value, <a class="reference internal" href="../reference/api/pandas.dataframe.idxmin#pandas.DataFrame.idxmin" title="pandas.DataFrame.idxmin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">idxmin()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.idxmax#pandas.DataFrame.idxmax" title="pandas.DataFrame.idxmax"><code class="xref py py-meth docutils literal notranslate"><span class="pre">idxmax()</span></code></a> return the first matching index:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [115]: df3 = pd.DataFrame([2, 1, 1, 3, np.nan], columns=["A"], index=list("edcba"))

In [116]: df3
Out[116]: 
     A
e  2.0
d  1.0
c  1.0
b  3.0
a  NaN

In [117]: df3["A"].idxmin()
Out[117]: 'd'
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code class="docutils literal notranslate"><span class="pre">idxmin</span></code> and <code class="docutils literal notranslate"><span class="pre">idxmax</span></code> are called <code class="docutils literal notranslate"><span class="pre">argmin</span></code> and <code class="docutils literal notranslate"><span class="pre">argmax</span></code> in NumPy.</p> </div> </section> <section id="value-counts-histogramming-mode"> <h3>Value counts (histogramming) / mode</h3> <p>The <a class="reference internal" href="../reference/api/pandas.series.value_counts#pandas.Series.value_counts" title="pandas.Series.value_counts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">value_counts()</span></code></a> Series method and top-level function computes a histogram of a 1D array of values. It can also be used as a function on regular arrays:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [118]: data = np.random.randint(0, 7, size=50)

In [119]: data
Out[119]: 
array([6, 6, 2, 3, 5, 3, 2, 5, 4, 5, 4, 3, 4, 5, 0, 2, 0, 4, 2, 0, 3, 2,
       2, 5, 6, 5, 3, 4, 6, 4, 3, 5, 6, 4, 3, 6, 2, 6, 6, 2, 3, 4, 2, 1,
       6, 2, 6, 1, 5, 4])

In [120]: s = pd.Series(data)

In [121]: s.value_counts()
Out[121]: 
6    10
2    10
4     9
3     8
5     8
0     3
1     2
dtype: int64

In [122]: pd.value_counts(data)
Out[122]: 
6    10
2    10
4     9
3     8
5     8
0     3
1     2
dtype: int64
</pre></div> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.1.0.</span></p> </div> <p>The <a class="reference internal" href="../reference/api/pandas.dataframe.value_counts#pandas.DataFrame.value_counts" title="pandas.DataFrame.value_counts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">value_counts()</span></code></a> method can be used to count combinations across multiple columns. By default all columns are used but a subset can be selected using the <code class="docutils literal notranslate"><span class="pre">subset</span></code> argument.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [123]: data = {"a": [1, 2, 3, 4], "b": ["x", "x", "y", "y"]}

In [124]: frame = pd.DataFrame(data)

In [125]: frame.value_counts()
Out[125]: 
a  b
1  x    1
2  x    1
3  y    1
4  y    1
dtype: int64
</pre></div> </div> <p>Similarly, you can get the most frequently occurring value(s), i.e. the mode, of the values in a Series or DataFrame:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [126]: s5 = pd.Series([1, 1, 3, 3, 3, 5, 5, 7, 7, 7])

In [127]: s5.mode()
Out[127]: 
0    3
1    7
dtype: int64

In [128]: df5 = pd.DataFrame(
   .....:     {
   .....:         "A": np.random.randint(0, 7, size=50),
   .....:         "B": np.random.randint(-10, 15, size=50),
   .....:     }
   .....: )
   .....: 

In [129]: df5.mode()
Out[129]: 
     A   B
0  1.0  -9
1  NaN  10
2  NaN  13
</pre></div> </div> </section> <section id="discretization-and-quantiling"> <h3>Discretization and quantiling</h3> <p>Continuous values can be discretized using the <a class="reference internal" href="../reference/api/pandas.cut#pandas.cut" title="pandas.cut"><code class="xref py py-func docutils literal notranslate"><span class="pre">cut()</span></code></a> (bins based on values) and <a class="reference internal" href="../reference/api/pandas.qcut#pandas.qcut" title="pandas.qcut"><code class="xref py py-func docutils literal notranslate"><span class="pre">qcut()</span></code></a> (bins based on sample quantiles) functions:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [130]: arr = np.random.randn(20)

In [131]: factor = pd.cut(arr, 4)

In [132]: factor
Out[132]: 
[(-0.251, 0.464], (-0.968, -0.251], (0.464, 1.179], (-0.251, 0.464], (-0.968, -0.251], ..., (-0.251, 0.464], (-0.968, -0.251], (-0.968, -0.251], (-0.968, -0.251], (-0.968, -0.251]]
Length: 20
Categories (4, interval[float64, right]): [(-0.968, -0.251] &lt; (-0.251, 0.464] &lt; (0.464, 1.179] &lt;
                                           (1.179, 1.893]]

In [133]: factor = pd.cut(arr, [-5, -1, 0, 1, 5])

In [134]: factor
Out[134]: 
[(0, 1], (-1, 0], (0, 1], (0, 1], (-1, 0], ..., (-1, 0], (-1, 0], (-1, 0], (-1, 0], (-1, 0]]
Length: 20
Categories (4, interval[int64, right]): [(-5, -1] &lt; (-1, 0] &lt; (0, 1] &lt; (1, 5]]
</pre></div> </div> <p><a class="reference internal" href="../reference/api/pandas.qcut#pandas.qcut" title="pandas.qcut"><code class="xref py py-func docutils literal notranslate"><span class="pre">qcut()</span></code></a> computes sample quantiles. For example, we could slice up some normally distributed data into equal-size quartiles like so:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [135]: arr = np.random.randn(30)

In [136]: factor = pd.qcut(arr, [0, 0.25, 0.5, 0.75, 1])

In [137]: factor
Out[137]: 
[(0.569, 1.184], (-2.278, -0.301], (-2.278, -0.301], (0.569, 1.184], (0.569, 1.184], ..., (-0.301, 0.569], (1.184, 2.346], (1.184, 2.346], (-0.301, 0.569], (-2.278, -0.301]]
Length: 30
Categories (4, interval[float64, right]): [(-2.278, -0.301] &lt; (-0.301, 0.569] &lt; (0.569, 1.184] &lt;
                                           (1.184, 2.346]]

In [138]: pd.value_counts(factor)
Out[138]: 
(-2.278, -0.301]    8
(1.184, 2.346]      8
(-0.301, 0.569]     7
(0.569, 1.184]      7
dtype: int64
</pre></div> </div> <p>We can also pass infinite values to define the bins:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [139]: arr = np.random.randn(20)

In [140]: factor = pd.cut(arr, [-np.inf, 0, np.inf])

In [141]: factor
Out[141]: 
[(-inf, 0.0], (0.0, inf], (0.0, inf], (-inf, 0.0], (-inf, 0.0], ..., (-inf, 0.0], (-inf, 0.0], (-inf, 0.0], (0.0, inf], (0.0, inf]]
Length: 20
Categories (2, interval[float64, right]): [(-inf, 0.0] &lt; (0.0, inf]]
</pre></div> </div> </section> </section> <section id="function-application"> <h2>Function application</h2> <p>To apply your own or another library’s functions to pandas objects, you should be aware of the three methods below. The appropriate method to use depends on whether your function expects to operate on an entire <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> or <code class="docutils literal notranslate"><span class="pre">Series</span></code>, row- or column-wise, or elementwise.</p> <ol class="arabic simple"> <li><p><a class="reference internal" href="#tablewise-function-application">Tablewise Function Application</a>: <a class="reference internal" href="../reference/api/pandas.dataframe.pipe#pandas.DataFrame.pipe" title="pandas.DataFrame.pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pipe()</span></code></a></p></li> <li><p><a class="reference internal" href="#row-or-column-wise-function-application">Row or Column-wise Function Application</a>: <a class="reference internal" href="../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply" title="pandas.DataFrame.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code></a></p></li> <li><p><a class="reference internal" href="#aggregation-api">Aggregation API</a>: <a class="reference internal" href="../reference/api/pandas.dataframe.agg#pandas.DataFrame.agg" title="pandas.DataFrame.agg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">agg()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.transform#pandas.DataFrame.transform" title="pandas.DataFrame.transform"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform()</span></code></a></p></li> <li><p><a class="reference internal" href="#applying-elementwise-functions">Applying Elementwise Functions</a>: <a class="reference internal" href="../reference/api/pandas.dataframe.applymap#pandas.DataFrame.applymap" title="pandas.DataFrame.applymap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">applymap()</span></code></a></p></li> </ol> <section id="tablewise-function-application"> <h3>Tablewise function application</h3> <p><code class="docutils literal notranslate"><span class="pre">DataFrames</span></code> and <code class="docutils literal notranslate"><span class="pre">Series</span></code> can be passed into functions. However, if the function needs to be called in a chain, consider using the <a class="reference internal" href="../reference/api/pandas.dataframe.pipe#pandas.DataFrame.pipe" title="pandas.DataFrame.pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pipe()</span></code></a> method.</p> <p>First some setup:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [142]: def extract_city_name(df):
   .....:     """
   .....:     Chicago, IL -&gt; Chicago for city_name column
   .....:     """
   .....:     df["city_name"] = df["city_and_code"].str.split(",").str.get(0)
   .....:     return df
   .....: 

In [143]: def add_country_name(df, country_name=None):
   .....:     """
   .....:     Chicago -&gt; Chicago-US for city_name column
   .....:     """
   .....:     col = "city_name"
   .....:     df["city_and_country"] = df[col] + country_name
   .....:     return df
   .....: 

In [144]: df_p = pd.DataFrame({"city_and_code": ["Chicago, IL"]})
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">extract_city_name</span></code> and <code class="docutils literal notranslate"><span class="pre">add_country_name</span></code> are functions taking and returning <code class="docutils literal notranslate"><span class="pre">DataFrames</span></code>.</p> <p>Now compare the following:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [145]: add_country_name(extract_city_name(df_p), country_name="US")
Out[145]: 
  city_and_code city_name city_and_country
0   Chicago, IL   Chicago        ChicagoUS
</pre></div> </div> <p>Is equivalent to:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [146]: df_p.pipe(extract_city_name).pipe(add_country_name, country_name="US")
Out[146]: 
  city_and_code city_name city_and_country
0   Chicago, IL   Chicago        ChicagoUS
</pre></div> </div> <p>pandas encourages the second style, which is known as method chaining. <code class="docutils literal notranslate"><span class="pre">pipe</span></code> makes it easy to use your own or another library’s functions in method chains, alongside pandas’ methods.</p> <p>In the example above, the functions <code class="docutils literal notranslate"><span class="pre">extract_city_name</span></code> and <code class="docutils literal notranslate"><span class="pre">add_country_name</span></code> each expected a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> as the first positional argument. What if the function you wish to apply takes its data as, say, the second argument? In this case, provide <code class="docutils literal notranslate"><span class="pre">pipe</span></code> with a tuple of <code class="docutils literal notranslate"><span class="pre">(callable,</span> <span class="pre">data_keyword)</span></code>. <code class="docutils literal notranslate"><span class="pre">.pipe</span></code> will route the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> to the argument specified in the tuple.</p> <p>For example, we can fit a regression using statsmodels. Their API expects a formula first and a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> as the second argument, <code class="docutils literal notranslate"><span class="pre">data</span></code>. We pass in the function, keyword pair <code class="docutils literal notranslate"><span class="pre">(sm.ols,</span> <span class="pre">'data')</span></code> to <code class="docutils literal notranslate"><span class="pre">pipe</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [147]: import statsmodels.formula.api as sm

In [148]: bb = pd.read_csv("data/baseball.csv", index_col="id")

In [149]: (
   .....:     bb.query("h &gt; 0")
   .....:     .assign(ln_h=lambda df: np.log(df.h))
   .....:     .pipe((sm.ols, "data"), "hr ~ ln_h + year + g + C(lg)")
   .....:     .fit()
   .....:     .summary()
   .....: )
   .....: 
Out[149]: 
&lt;class 'statsmodels.iolib.summary.Summary'&gt;
"""
                            OLS Regression Results                            
==============================================================================
Dep. Variable:                     hr   R-squared:                       0.685
Model:                            OLS   Adj. R-squared:                  0.665
Method:                 Least Squares   F-statistic:                     34.28
Date:                Sat, 22 Jan 2022   Prob (F-statistic):           3.48e-15
Time:                        10:50:02   Log-Likelihood:                -205.92
No. Observations:                  68   AIC:                             421.8
Df Residuals:                      63   BIC:                             432.9
Df Model:                           4                                         
Covariance Type:            nonrobust                                         
===============================================================================
                  coef    std err          t      P&gt;|t|      [0.025      0.975]
-------------------------------------------------------------------------------
Intercept   -8484.7720   4664.146     -1.819      0.074   -1.78e+04     835.780
C(lg)[T.NL]    -2.2736      1.325     -1.716      0.091      -4.922       0.375
ln_h           -1.3542      0.875     -1.547      0.127      -3.103       0.395
year            4.2277      2.324      1.819      0.074      -0.417       8.872
g               0.1841      0.029      6.258      0.000       0.125       0.243
==============================================================================
Omnibus:                       10.875   Durbin-Watson:                   1.999
Prob(Omnibus):                  0.004   Jarque-Bera (JB):               17.298
Skew:                           0.537   Prob(JB):                     0.000175
Kurtosis:                       5.225   Cond. No.                     1.49e+07
==============================================================================

Notes:
[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.
[2] The condition number is large, 1.49e+07. This might indicate that there are
strong multicollinearity or other numerical problems.
"""
</pre></div> </div> <p>The pipe method is inspired by unix pipes and more recently <a class="reference external" href="https://github.com/tidyverse/dplyr">dplyr</a> and <a class="reference external" href="https://github.com/tidyverse/magrittr">magrittr</a>, which have introduced the popular <code class="docutils literal notranslate"><span class="pre">(%&gt;%)</span></code> (read pipe) operator for <a class="reference external" href="https://www.r-project.org">R</a>. The implementation of <code class="docutils literal notranslate"><span class="pre">pipe</span></code> here is quite clean and feels right at home in Python. We encourage you to view the source code of <a class="reference internal" href="../reference/api/pandas.dataframe.pipe#pandas.DataFrame.pipe" title="pandas.DataFrame.pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pipe()</span></code></a>.</p> </section> <section id="row-or-column-wise-function-application"> <h3>Row or column-wise function application</h3> <p>Arbitrary functions can be applied along the axes of a DataFrame using the <a class="reference internal" href="../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply" title="pandas.DataFrame.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code></a> method, which, like the descriptive statistics methods, takes an optional <code class="docutils literal notranslate"><span class="pre">axis</span></code> argument:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [150]: df.apply(np.mean)
Out[150]: 
one      0.811094
two      1.360588
three    0.187958
dtype: float64

In [151]: df.apply(np.mean, axis=1)
Out[151]: 
a    1.583749
b    0.734929
c    1.133683
d   -0.166914
dtype: float64

In [152]: df.apply(lambda x: x.max() - x.min())
Out[152]: 
one      1.051928
two      1.632779
three    1.840607
dtype: float64

In [153]: df.apply(np.cumsum)
Out[153]: 
        one       two     three
a  1.394981  1.772517       NaN
b  1.738035  3.684640 -0.050390
c  2.433281  5.163008  1.177045
d       NaN  5.442353  0.563873

In [154]: df.apply(np.exp)
Out[154]: 
        one       two     three
a  4.034899  5.885648       NaN
b  1.409244  6.767440  0.950858
c  2.004201  4.385785  3.412466
d       NaN  1.322262  0.541630
</pre></div> </div> <p>The <a class="reference internal" href="../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply" title="pandas.DataFrame.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code></a> method will also dispatch on a string method name.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [155]: df.apply("mean")
Out[155]: 
one      0.811094
two      1.360588
three    0.187958
dtype: float64

In [156]: df.apply("mean", axis=1)
Out[156]: 
a    1.583749
b    0.734929
c    1.133683
d   -0.166914
dtype: float64
</pre></div> </div> <p>The return type of the function passed to <a class="reference internal" href="../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply" title="pandas.DataFrame.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code></a> affects the type of the final output from <code class="docutils literal notranslate"><span class="pre">DataFrame.apply</span></code> for the default behaviour:</p> <ul class="simple"> <li><p>If the applied function returns a <code class="docutils literal notranslate"><span class="pre">Series</span></code>, the final output is a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>. The columns match the index of the <code class="docutils literal notranslate"><span class="pre">Series</span></code> returned by the applied function.</p></li> <li><p>If the applied function returns any other type, the final output is a <code class="docutils literal notranslate"><span class="pre">Series</span></code>.</p></li> </ul> <p>This default behaviour can be overridden using the <code class="docutils literal notranslate"><span class="pre">result_type</span></code>, which accepts three options: <code class="docutils literal notranslate"><span class="pre">reduce</span></code>, <code class="docutils literal notranslate"><span class="pre">broadcast</span></code>, and <code class="docutils literal notranslate"><span class="pre">expand</span></code>. These will determine how list-likes return values expand (or not) to a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p> <p><a class="reference internal" href="../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply" title="pandas.DataFrame.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code></a> combined with some cleverness can be used to answer many questions about a data set. For example, suppose we wanted to extract the date where the maximum value for each column occurred:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [157]: tsdf = pd.DataFrame(
   .....:     np.random.randn(1000, 3),
   .....:     columns=["A", "B", "C"],
   .....:     index=pd.date_range("1/1/2000", periods=1000),
   .....: )
   .....: 

In [158]: tsdf.apply(lambda x: x.idxmax())
Out[158]: 
A   2000-08-06
B   2001-01-18
C   2001-07-18
dtype: datetime64[ns]
</pre></div> </div> <p>You may also pass additional arguments and keyword arguments to the <a class="reference internal" href="../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply" title="pandas.DataFrame.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code></a> method. For instance, consider the following function you would like to apply:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">def subtract_and_divide(x, sub, divide=1):
    return (x - sub) / divide
</pre></div> </div> <p>You may then apply this function as follows:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">df.apply(subtract_and_divide, args=(5,), divide=3)
</pre></div> </div> <p>Another useful feature is the ability to pass Series methods to carry out some Series operation on each column or row:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [159]: tsdf
Out[159]: 
                   A         B         C
2000-01-01 -0.158131 -0.232466  0.321604
2000-01-02 -1.810340 -3.105758  0.433834
2000-01-03 -1.209847 -1.156793 -0.136794
2000-01-04       NaN       NaN       NaN
2000-01-05       NaN       NaN       NaN
2000-01-06       NaN       NaN       NaN
2000-01-07       NaN       NaN       NaN
2000-01-08 -0.653602  0.178875  1.008298
2000-01-09  1.007996  0.462824  0.254472
2000-01-10  0.307473  0.600337  1.643950

In [160]: tsdf.apply(pd.Series.interpolate)
Out[160]: 
                   A         B         C
2000-01-01 -0.158131 -0.232466  0.321604
2000-01-02 -1.810340 -3.105758  0.433834
2000-01-03 -1.209847 -1.156793 -0.136794
2000-01-04 -1.098598 -0.889659  0.092225
2000-01-05 -0.987349 -0.622526  0.321243
2000-01-06 -0.876100 -0.355392  0.550262
2000-01-07 -0.764851 -0.088259  0.779280
2000-01-08 -0.653602  0.178875  1.008298
2000-01-09  1.007996  0.462824  0.254472
2000-01-10  0.307473  0.600337  1.643950
</pre></div> </div> <p>Finally, <a class="reference internal" href="../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply" title="pandas.DataFrame.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code></a> takes an argument <code class="docutils literal notranslate"><span class="pre">raw</span></code> which is False by default, which converts each row or column into a Series before applying the function. When set to True, the passed function will instead receive an ndarray object, which has positive performance implications if you do not need the indexing functionality.</p> </section> <section id="aggregation-api"> <h3>Aggregation API</h3> <p>The aggregation API allows one to express possibly multiple aggregation operations in a single concise way. This API is similar across pandas objects, see <a class="reference internal" href="groupby#groupby-aggregate"><span class="std std-ref">groupby API</span></a>, the <a class="reference internal" href="window#window-overview"><span class="std std-ref">window API</span></a>, and the <a class="reference internal" href="timeseries#timeseries-aggregate"><span class="std std-ref">resample API</span></a>. The entry point for aggregation is <a class="reference internal" href="../reference/api/pandas.dataframe.aggregate#pandas.DataFrame.aggregate" title="pandas.DataFrame.aggregate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.aggregate()</span></code></a>, or the alias <a class="reference internal" href="../reference/api/pandas.dataframe.agg#pandas.DataFrame.agg" title="pandas.DataFrame.agg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.agg()</span></code></a>.</p> <p>We will use a similar starting frame from above:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [161]: tsdf = pd.DataFrame(
   .....:     np.random.randn(10, 3),
   .....:     columns=["A", "B", "C"],
   .....:     index=pd.date_range("1/1/2000", periods=10),
   .....: )
   .....: 

In [162]: tsdf.iloc[3:7] = np.nan

In [163]: tsdf
Out[163]: 
                   A         B         C
2000-01-01  1.257606  1.004194  0.167574
2000-01-02 -0.749892  0.288112 -0.757304
2000-01-03 -0.207550 -0.298599  0.116018
2000-01-04       NaN       NaN       NaN
2000-01-05       NaN       NaN       NaN
2000-01-06       NaN       NaN       NaN
2000-01-07       NaN       NaN       NaN
2000-01-08  0.814347 -0.257623  0.869226
2000-01-09 -0.250663 -1.206601  0.896839
2000-01-10  2.169758 -1.333363  0.283157
</pre></div> </div> <p>Using a single function is equivalent to <a class="reference internal" href="../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply" title="pandas.DataFrame.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code></a>. You can also pass named methods as strings. These will return a <code class="docutils literal notranslate"><span class="pre">Series</span></code> of the aggregated output:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [164]: tsdf.agg(np.sum)
Out[164]: 
A    3.033606
B   -1.803879
C    1.575510
dtype: float64

In [165]: tsdf.agg("sum")
Out[165]: 
A    3.033606
B   -1.803879
C    1.575510
dtype: float64

# these are equivalent to a ``.sum()`` because we are aggregating
# on a single function
In [166]: tsdf.sum()
Out[166]: 
A    3.033606
B   -1.803879
C    1.575510
dtype: float64
</pre></div> </div> <p>Single aggregations on a <code class="docutils literal notranslate"><span class="pre">Series</span></code> this will return a scalar value:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [167]: tsdf["A"].agg("sum")
Out[167]: 3.033606102414146
</pre></div> </div> <section id="aggregating-with-multiple-functions"> <h4>Aggregating with multiple functions</h4> <p>You can pass multiple aggregation arguments as a list. The results of each of the passed functions will be a row in the resulting <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>. These are naturally named from the aggregation function.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [168]: tsdf.agg(["sum"])
Out[168]: 
            A         B        C
sum  3.033606 -1.803879  1.57551
</pre></div> </div> <p>Multiple functions yield multiple rows:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [169]: tsdf.agg(["sum", "mean"])
Out[169]: 
             A         B         C
sum   3.033606 -1.803879  1.575510
mean  0.505601 -0.300647  0.262585
</pre></div> </div> <p>On a <code class="docutils literal notranslate"><span class="pre">Series</span></code>, multiple functions return a <code class="docutils literal notranslate"><span class="pre">Series</span></code>, indexed by the function names:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [170]: tsdf["A"].agg(["sum", "mean"])
Out[170]: 
sum     3.033606
mean    0.505601
Name: A, dtype: float64
</pre></div> </div> <p>Passing a <code class="docutils literal notranslate"><span class="pre">lambda</span></code> function will yield a <code class="docutils literal notranslate"><span class="pre">&lt;lambda&gt;</span></code> named row:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [171]: tsdf["A"].agg(["sum", lambda x: x.mean()])
Out[171]: 
sum         3.033606
&lt;lambda&gt;    0.505601
Name: A, dtype: float64
</pre></div> </div> <p>Passing a named function will yield that name for the row:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [172]: def mymean(x):
   .....:     return x.mean()
   .....: 

In [173]: tsdf["A"].agg(["sum", mymean])
Out[173]: 
sum       3.033606
mymean    0.505601
Name: A, dtype: float64
</pre></div> </div> </section> <section id="aggregating-with-a-dict"> <h4>Aggregating with a dict</h4> <p>Passing a dictionary of column names to a scalar or a list of scalars, to <code class="docutils literal notranslate"><span class="pre">DataFrame.agg</span></code> allows you to customize which functions are applied to which columns. Note that the results are not in any particular order, you can use an <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code> instead to guarantee ordering.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [174]: tsdf.agg({"A": "mean", "B": "sum"})
Out[174]: 
A    0.505601
B   -1.803879
dtype: float64
</pre></div> </div> <p>Passing a list-like will generate a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> output. You will get a matrix-like output of all of the aggregators. The output will consist of all unique functions. Those that are not noted for a particular column will be <code class="docutils literal notranslate"><span class="pre">NaN</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [175]: tsdf.agg({"A": ["mean", "min"], "B": "sum"})
Out[175]: 
             A         B
mean  0.505601       NaN
min  -0.749892       NaN
sum        NaN -1.803879
</pre></div> </div> </section> <section id="mixed-dtypes"> <h4>Mixed dtypes</h4> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 1.4.0: </span>Attempting to determine which columns cannot be aggregated and silently dropping them from the results is deprecated and will be removed in a future version. If any porition of the columns or operations provided fail, the call to <code class="docutils literal notranslate"><span class="pre">.agg</span></code> will raise.</p> </div> <p>When presented with mixed dtypes that cannot aggregate, <code class="docutils literal notranslate"><span class="pre">.agg</span></code> will only take the valid aggregations. This is similar to how <code class="docutils literal notranslate"><span class="pre">.groupby.agg</span></code> works.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [176]: mdf = pd.DataFrame(
   .....:     {
   .....:         "A": [1, 2, 3],
   .....:         "B": [1.0, 2.0, 3.0],
   .....:         "C": ["foo", "bar", "baz"],
   .....:         "D": pd.date_range("20130101", periods=3),
   .....:     }
   .....: )
   .....: 

In [177]: mdf.dtypes
Out[177]: 
A             int64
B           float64
C            object
D    datetime64[ns]
dtype: object
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [178]: mdf.agg(["min", "sum"])
Out[178]: 
     A    B          C          D
min  1  1.0        bar 2013-01-01
sum  6  6.0  foobarbaz        NaT
</pre></div> </div> </section> <section id="custom-describe"> <h4>Custom describe</h4> <p>With <code class="docutils literal notranslate"><span class="pre">.agg()</span></code> it is possible to easily create a custom describe function, similar to the built in <a class="reference internal" href="#basics-describe"><span class="std std-ref">describe function</span></a>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [179]: from functools import partial

In [180]: q_25 = partial(pd.Series.quantile, q=0.25)

In [181]: q_25.__name__ = "25%"

In [182]: q_75 = partial(pd.Series.quantile, q=0.75)

In [183]: q_75.__name__ = "75%"

In [184]: tsdf.agg(["count", "mean", "std", "min", q_25, "median", q_75, "max"])
Out[184]: 
               A         B         C
count   6.000000  6.000000  6.000000
mean    0.505601 -0.300647  0.262585
std     1.103362  0.887508  0.606860
min    -0.749892 -1.333363 -0.757304
25%    -0.239885 -0.979600  0.128907
median  0.303398 -0.278111  0.225365
75%     1.146791  0.151678  0.722709
max     2.169758  1.004194  0.896839
</pre></div> </div> </section> </section> <section id="transform-api"> <h3>Transform API</h3> <p>The <a class="reference internal" href="../reference/api/pandas.dataframe.transform#pandas.DataFrame.transform" title="pandas.DataFrame.transform"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform()</span></code></a> method returns an object that is indexed the same (same size) as the original. This API allows you to provide <em>multiple</em> operations at the same time rather than one-by-one. Its API is quite similar to the <code class="docutils literal notranslate"><span class="pre">.agg</span></code> API.</p> <p>We create a frame similar to the one used in the above sections.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [185]: tsdf = pd.DataFrame(
   .....:     np.random.randn(10, 3),
   .....:     columns=["A", "B", "C"],
   .....:     index=pd.date_range("1/1/2000", periods=10),
   .....: )
   .....: 

In [186]: tsdf.iloc[3:7] = np.nan

In [187]: tsdf
Out[187]: 
                   A         B         C
2000-01-01 -0.428759 -0.864890 -0.675341
2000-01-02 -0.168731  1.338144 -1.279321
2000-01-03 -1.621034  0.438107  0.903794
2000-01-04       NaN       NaN       NaN
2000-01-05       NaN       NaN       NaN
2000-01-06       NaN       NaN       NaN
2000-01-07       NaN       NaN       NaN
2000-01-08  0.254374 -1.240447 -0.201052
2000-01-09 -0.157795  0.791197 -1.144209
2000-01-10 -0.030876  0.371900  0.061932
</pre></div> </div> <p>Transform the entire frame. <code class="docutils literal notranslate"><span class="pre">.transform()</span></code> allows input functions as: a NumPy function, a string function name or a user defined function.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [188]: tsdf.transform(np.abs)
Out[188]: 
                   A         B         C
2000-01-01  0.428759  0.864890  0.675341
2000-01-02  0.168731  1.338144  1.279321
2000-01-03  1.621034  0.438107  0.903794
2000-01-04       NaN       NaN       NaN
2000-01-05       NaN       NaN       NaN
2000-01-06       NaN       NaN       NaN
2000-01-07       NaN       NaN       NaN
2000-01-08  0.254374  1.240447  0.201052
2000-01-09  0.157795  0.791197  1.144209
2000-01-10  0.030876  0.371900  0.061932

In [189]: tsdf.transform("abs")
Out[189]: 
                   A         B         C
2000-01-01  0.428759  0.864890  0.675341
2000-01-02  0.168731  1.338144  1.279321
2000-01-03  1.621034  0.438107  0.903794
2000-01-04       NaN       NaN       NaN
2000-01-05       NaN       NaN       NaN
2000-01-06       NaN       NaN       NaN
2000-01-07       NaN       NaN       NaN
2000-01-08  0.254374  1.240447  0.201052
2000-01-09  0.157795  0.791197  1.144209
2000-01-10  0.030876  0.371900  0.061932

In [190]: tsdf.transform(lambda x: x.abs())
Out[190]: 
                   A         B         C
2000-01-01  0.428759  0.864890  0.675341
2000-01-02  0.168731  1.338144  1.279321
2000-01-03  1.621034  0.438107  0.903794
2000-01-04       NaN       NaN       NaN
2000-01-05       NaN       NaN       NaN
2000-01-06       NaN       NaN       NaN
2000-01-07       NaN       NaN       NaN
2000-01-08  0.254374  1.240447  0.201052
2000-01-09  0.157795  0.791197  1.144209
2000-01-10  0.030876  0.371900  0.061932
</pre></div> </div> <p>Here <a class="reference internal" href="../reference/api/pandas.dataframe.transform#pandas.DataFrame.transform" title="pandas.DataFrame.transform"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform()</span></code></a> received a single function; this is equivalent to a <a class="reference external" href="https://numpy.org/doc/stable/reference/ufuncs.html">ufunc</a> application.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [191]: np.abs(tsdf)
Out[191]: 
                   A         B         C
2000-01-01  0.428759  0.864890  0.675341
2000-01-02  0.168731  1.338144  1.279321
2000-01-03  1.621034  0.438107  0.903794
2000-01-04       NaN       NaN       NaN
2000-01-05       NaN       NaN       NaN
2000-01-06       NaN       NaN       NaN
2000-01-07       NaN       NaN       NaN
2000-01-08  0.254374  1.240447  0.201052
2000-01-09  0.157795  0.791197  1.144209
2000-01-10  0.030876  0.371900  0.061932
</pre></div> </div> <p>Passing a single function to <code class="docutils literal notranslate"><span class="pre">.transform()</span></code> with a <code class="docutils literal notranslate"><span class="pre">Series</span></code> will yield a single <code class="docutils literal notranslate"><span class="pre">Series</span></code> in return.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [192]: tsdf["A"].transform(np.abs)
Out[192]: 
2000-01-01    0.428759
2000-01-02    0.168731
2000-01-03    1.621034
2000-01-04         NaN
2000-01-05         NaN
2000-01-06         NaN
2000-01-07         NaN
2000-01-08    0.254374
2000-01-09    0.157795
2000-01-10    0.030876
Freq: D, Name: A, dtype: float64
</pre></div> </div> <section id="transform-with-multiple-functions"> <h4>Transform with multiple functions</h4> <p>Passing multiple functions will yield a column MultiIndexed DataFrame. The first level will be the original frame column names; the second level will be the names of the transforming functions.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [193]: tsdf.transform([np.abs, lambda x: x + 1])
Out[193]: 
                   A                   B                   C          
            absolute  &lt;lambda&gt;  absolute  &lt;lambda&gt;  absolute  &lt;lambda&gt;
2000-01-01  0.428759  0.571241  0.864890  0.135110  0.675341  0.324659
2000-01-02  0.168731  0.831269  1.338144  2.338144  1.279321 -0.279321
2000-01-03  1.621034 -0.621034  0.438107  1.438107  0.903794  1.903794
2000-01-04       NaN       NaN       NaN       NaN       NaN       NaN
2000-01-05       NaN       NaN       NaN       NaN       NaN       NaN
2000-01-06       NaN       NaN       NaN       NaN       NaN       NaN
2000-01-07       NaN       NaN       NaN       NaN       NaN       NaN
2000-01-08  0.254374  1.254374  1.240447 -0.240447  0.201052  0.798948
2000-01-09  0.157795  0.842205  0.791197  1.791197  1.144209 -0.144209
2000-01-10  0.030876  0.969124  0.371900  1.371900  0.061932  1.061932
</pre></div> </div> <p>Passing multiple functions to a Series will yield a DataFrame. The resulting column names will be the transforming functions.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [194]: tsdf["A"].transform([np.abs, lambda x: x + 1])
Out[194]: 
            absolute  &lt;lambda&gt;
2000-01-01  0.428759  0.571241
2000-01-02  0.168731  0.831269
2000-01-03  1.621034 -0.621034
2000-01-04       NaN       NaN
2000-01-05       NaN       NaN
2000-01-06       NaN       NaN
2000-01-07       NaN       NaN
2000-01-08  0.254374  1.254374
2000-01-09  0.157795  0.842205
2000-01-10  0.030876  0.969124
</pre></div> </div> </section> <section id="transforming-with-a-dict"> <h4>Transforming with a dict</h4> <p>Passing a dict of functions will allow selective transforming per column.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [195]: tsdf.transform({"A": np.abs, "B": lambda x: x + 1})
Out[195]: 
                   A         B
2000-01-01  0.428759  0.135110
2000-01-02  0.168731  2.338144
2000-01-03  1.621034  1.438107
2000-01-04       NaN       NaN
2000-01-05       NaN       NaN
2000-01-06       NaN       NaN
2000-01-07       NaN       NaN
2000-01-08  0.254374 -0.240447
2000-01-09  0.157795  1.791197
2000-01-10  0.030876  1.371900
</pre></div> </div> <p>Passing a dict of lists will generate a MultiIndexed DataFrame with these selective transforms.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [196]: tsdf.transform({"A": np.abs, "B": [lambda x: x + 1, "sqrt"]})
Out[196]: 
                   A         B          
            absolute  &lt;lambda&gt;      sqrt
2000-01-01  0.428759  0.135110       NaN
2000-01-02  0.168731  2.338144  1.156782
2000-01-03  1.621034  1.438107  0.661897
2000-01-04       NaN       NaN       NaN
2000-01-05       NaN       NaN       NaN
2000-01-06       NaN       NaN       NaN
2000-01-07       NaN       NaN       NaN
2000-01-08  0.254374 -0.240447       NaN
2000-01-09  0.157795  1.791197  0.889493
2000-01-10  0.030876  1.371900  0.609836
</pre></div> </div> </section> </section> <section id="applying-elementwise-functions"> <h3>Applying elementwise functions</h3> <p>Since not all functions can be vectorized (accept NumPy arrays and return another array or value), the methods <a class="reference internal" href="../reference/api/pandas.dataframe.applymap#pandas.DataFrame.applymap" title="pandas.DataFrame.applymap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">applymap()</span></code></a> on DataFrame and analogously <a class="reference internal" href="../reference/api/pandas.series.map#pandas.Series.map" title="pandas.Series.map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">map()</span></code></a> on Series accept any Python function taking a single value and returning a single value. For example:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [197]: df4
Out[197]: 
        one       two     three
a  1.394981  1.772517       NaN
b  0.343054  1.912123 -0.050390
c  0.695246  1.478369  1.227435
d       NaN  0.279344 -0.613172

In [198]: def f(x):
   .....:     return len(str(x))
   .....: 

In [199]: df4["one"].map(f)
Out[199]: 
a    18
b    19
c    18
d     3
Name: one, dtype: int64

In [200]: df4.applymap(f)
Out[200]: 
   one  two  three
a   18   17      3
b   19   18     20
c   18   18     16
d    3   19     19
</pre></div> </div> <p><a class="reference internal" href="../reference/api/pandas.series.map#pandas.Series.map" title="pandas.Series.map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Series.map()</span></code></a> has an additional feature; it can be used to easily “link” or “map” values defined by a secondary series. This is closely related to <a class="reference internal" href="merging#merging"><span class="std std-ref">merging/joining functionality</span></a>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [201]: s = pd.Series(
   .....:     ["six", "seven", "six", "seven", "six"], index=["a", "b", "c", "d", "e"]
   .....: )
   .....: 

In [202]: t = pd.Series({"six": 6.0, "seven": 7.0})

In [203]: s
Out[203]: 
a      six
b    seven
c      six
d    seven
e      six
dtype: object

In [204]: s.map(t)
Out[204]: 
a    6.0
b    7.0
c    6.0
d    7.0
e    6.0
dtype: float64
</pre></div> </div> </section> </section> <section id="reindexing-and-altering-labels"> <h2>Reindexing and altering labels</h2> <p><a class="reference internal" href="../reference/api/pandas.series.reindex#pandas.Series.reindex" title="pandas.Series.reindex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reindex()</span></code></a> is the fundamental data alignment method in pandas. It is used to implement nearly all other features relying on label-alignment functionality. To <em>reindex</em> means to conform the data to match a given set of labels along a particular axis. This accomplishes several things:</p> <ul class="simple"> <li><p>Reorders the existing data to match a new set of labels</p></li> <li><p>Inserts missing value (NA) markers in label locations where no data for that label existed</p></li> <li><p>If specified, <strong>fill</strong> data for missing labels using logic (highly relevant to working with time series data)</p></li> </ul> <p>Here is a simple example:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [205]: s = pd.Series(np.random.randn(5), index=["a", "b", "c", "d", "e"])

In [206]: s
Out[206]: 
a    1.695148
b    1.328614
c    1.234686
d   -0.385845
e   -1.326508
dtype: float64

In [207]: s.reindex(["e", "b", "f", "d"])
Out[207]: 
e   -1.326508
b    1.328614
f         NaN
d   -0.385845
dtype: float64
</pre></div> </div> <p>Here, the <code class="docutils literal notranslate"><span class="pre">f</span></code> label was not contained in the Series and hence appears as <code class="docutils literal notranslate"><span class="pre">NaN</span></code> in the result.</p> <p>With a DataFrame, you can simultaneously reindex the index and columns:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [208]: df
Out[208]: 
        one       two     three
a  1.394981  1.772517       NaN
b  0.343054  1.912123 -0.050390
c  0.695246  1.478369  1.227435
d       NaN  0.279344 -0.613172

In [209]: df.reindex(index=["c", "f", "b"], columns=["three", "two", "one"])
Out[209]: 
      three       two       one
c  1.227435  1.478369  0.695246
f       NaN       NaN       NaN
b -0.050390  1.912123  0.343054
</pre></div> </div> <p>You may also use <code class="docutils literal notranslate"><span class="pre">reindex</span></code> with an <code class="docutils literal notranslate"><span class="pre">axis</span></code> keyword:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [210]: df.reindex(["c", "f", "b"], axis="index")
Out[210]: 
        one       two     three
c  0.695246  1.478369  1.227435
f       NaN       NaN       NaN
b  0.343054  1.912123 -0.050390
</pre></div> </div> <p>Note that the <code class="docutils literal notranslate"><span class="pre">Index</span></code> objects containing the actual axis labels can be <strong>shared</strong> between objects. So if we have a Series and a DataFrame, the following can be done:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [211]: rs = s.reindex(df.index)

In [212]: rs
Out[212]: 
a    1.695148
b    1.328614
c    1.234686
d   -0.385845
dtype: float64

In [213]: rs.index is df.index
Out[213]: True
</pre></div> </div> <p>This means that the reindexed Series’s index is the same Python object as the DataFrame’s index.</p> <p><a class="reference internal" href="../reference/api/pandas.dataframe.reindex#pandas.DataFrame.reindex" title="pandas.DataFrame.reindex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.reindex()</span></code></a> also supports an “axis-style” calling convention, where you specify a single <code class="docutils literal notranslate"><span class="pre">labels</span></code> argument and the <code class="docutils literal notranslate"><span class="pre">axis</span></code> it applies to.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [214]: df.reindex(["c", "f", "b"], axis="index")
Out[214]: 
        one       two     three
c  0.695246  1.478369  1.227435
f       NaN       NaN       NaN
b  0.343054  1.912123 -0.050390

In [215]: df.reindex(["three", "two", "one"], axis="columns")
Out[215]: 
      three       two       one
a       NaN  1.772517  1.394981
b -0.050390  1.912123  0.343054
c  1.227435  1.478369  0.695246
d -0.613172  0.279344       NaN
</pre></div> </div> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="advanced#advanced"><span class="std std-ref">MultiIndex / Advanced Indexing</span></a> is an even more concise way of doing reindexing.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>When writing performance-sensitive code, there is a good reason to spend some time becoming a reindexing ninja: <strong>many operations are faster on pre-aligned data</strong>. Adding two unaligned DataFrames internally triggers a reindexing step. For exploratory analysis you will hardly notice the difference (because <code class="docutils literal notranslate"><span class="pre">reindex</span></code> has been heavily optimized), but when CPU cycles matter sprinkling a few explicit <code class="docutils literal notranslate"><span class="pre">reindex</span></code> calls here and there can have an impact.</p> </div> <section id="reindexing-to-align-with-another-object"> <h3>Reindexing to align with another object</h3> <p>You may wish to take an object and reindex its axes to be labeled the same as another object. While the syntax for this is straightforward albeit verbose, it is a common enough operation that the <a class="reference internal" href="../reference/api/pandas.dataframe.reindex_like#pandas.DataFrame.reindex_like" title="pandas.DataFrame.reindex_like"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reindex_like()</span></code></a> method is available to make this simpler:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [216]: df2
Out[216]: 
        one       two
a  1.394981  1.772517
b  0.343054  1.912123
c  0.695246  1.478369

In [217]: df3
Out[217]: 
        one       two
a  0.583888  0.051514
b -0.468040  0.191120
c -0.115848 -0.242634

In [218]: df.reindex_like(df2)
Out[218]: 
        one       two
a  1.394981  1.772517
b  0.343054  1.912123
c  0.695246  1.478369
</pre></div> </div> </section> <section id="aligning-objects-with-each-other-with-align"> <h3>Aligning objects with each other with <code class="docutils literal notranslate"><span class="pre">align</span></code>
</h3> <p>The <a class="reference internal" href="../reference/api/pandas.series.align#pandas.Series.align" title="pandas.Series.align"><code class="xref py py-meth docutils literal notranslate"><span class="pre">align()</span></code></a> method is the fastest way to simultaneously align two objects. It supports a <code class="docutils literal notranslate"><span class="pre">join</span></code> argument (related to <a class="reference internal" href="merging#merging"><span class="std std-ref">joining and merging</span></a>):</p> <blockquote> <div>
<ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">join='outer'</span></code>: take the union of the indexes (default)</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">join='left'</span></code>: use the calling object’s index</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">join='right'</span></code>: use the passed object’s index</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">join='inner'</span></code>: intersect the indexes</p></li> </ul> </div>
</blockquote> <p>It returns a tuple with both of the reindexed Series:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [219]: s = pd.Series(np.random.randn(5), index=["a", "b", "c", "d", "e"])

In [220]: s1 = s[:4]

In [221]: s2 = s[1:]

In [222]: s1.align(s2)
Out[222]: 
(a   -0.186646
 b   -1.692424
 c   -0.303893
 d   -1.425662
 e         NaN
 dtype: float64,
 a         NaN
 b   -1.692424
 c   -0.303893
 d   -1.425662
 e    1.114285
 dtype: float64)

In [223]: s1.align(s2, join="inner")
Out[223]: 
(b   -1.692424
 c   -0.303893
 d   -1.425662
 dtype: float64,
 b   -1.692424
 c   -0.303893
 d   -1.425662
 dtype: float64)

In [224]: s1.align(s2, join="left")
Out[224]: 
(a   -0.186646
 b   -1.692424
 c   -0.303893
 d   -1.425662
 dtype: float64,
 a         NaN
 b   -1.692424
 c   -0.303893
 d   -1.425662
 dtype: float64)
</pre></div> </div> <p id="basics-df-join">For DataFrames, the join method will be applied to both the index and the columns by default:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [225]: df.align(df2, join="inner")
Out[225]: 
(        one       two
 a  1.394981  1.772517
 b  0.343054  1.912123
 c  0.695246  1.478369,
         one       two
 a  1.394981  1.772517
 b  0.343054  1.912123
 c  0.695246  1.478369)
</pre></div> </div> <p>You can also pass an <code class="docutils literal notranslate"><span class="pre">axis</span></code> option to only align on the specified axis:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [226]: df.align(df2, join="inner", axis=0)
Out[226]: 
(        one       two     three
 a  1.394981  1.772517       NaN
 b  0.343054  1.912123 -0.050390
 c  0.695246  1.478369  1.227435,
         one       two
 a  1.394981  1.772517
 b  0.343054  1.912123
 c  0.695246  1.478369)
</pre></div> </div> <p id="basics-align-frame-series">If you pass a Series to <a class="reference internal" href="../reference/api/pandas.dataframe.align#pandas.DataFrame.align" title="pandas.DataFrame.align"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.align()</span></code></a>, you can choose to align both objects either on the DataFrame’s index or columns using the <code class="docutils literal notranslate"><span class="pre">axis</span></code> argument:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [227]: df.align(df2.iloc[0], axis=1)
Out[227]: 
(        one     three       two
 a  1.394981       NaN  1.772517
 b  0.343054 -0.050390  1.912123
 c  0.695246  1.227435  1.478369
 d       NaN -0.613172  0.279344,
 one      1.394981
 three         NaN
 two      1.772517
 Name: a, dtype: float64)
</pre></div> </div> </section> <section id="filling-while-reindexing"> <h3>Filling while reindexing</h3> <p><a class="reference internal" href="../reference/api/pandas.series.reindex#pandas.Series.reindex" title="pandas.Series.reindex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reindex()</span></code></a> takes an optional parameter <code class="docutils literal notranslate"><span class="pre">method</span></code> which is a filling method chosen from the following table:</p> <table class="colwidths-given table"> <colgroup> <col style="width: 38%"> <col style="width: 63%"> </colgroup> <thead> <tr class="row-odd">
<th class="head"><p>Method</p></th> <th class="head"><p>Action</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p>pad / ffill</p></td> <td><p>Fill values forward</p></td> </tr> <tr class="row-odd">
<td><p>bfill / backfill</p></td> <td><p>Fill values backward</p></td> </tr> <tr class="row-even">
<td><p>nearest</p></td> <td><p>Fill from the nearest index value</p></td> </tr> </tbody> </table> <p>We illustrate these fill methods on a simple Series:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [228]: rng = pd.date_range("1/3/2000", periods=8)

In [229]: ts = pd.Series(np.random.randn(8), index=rng)

In [230]: ts2 = ts[[0, 3, 6]]

In [231]: ts
Out[231]: 
2000-01-03    0.183051
2000-01-04    0.400528
2000-01-05   -0.015083
2000-01-06    2.395489
2000-01-07    1.414806
2000-01-08    0.118428
2000-01-09    0.733639
2000-01-10   -0.936077
Freq: D, dtype: float64

In [232]: ts2
Out[232]: 
2000-01-03    0.183051
2000-01-06    2.395489
2000-01-09    0.733639
Freq: 3D, dtype: float64

In [233]: ts2.reindex(ts.index)
Out[233]: 
2000-01-03    0.183051
2000-01-04         NaN
2000-01-05         NaN
2000-01-06    2.395489
2000-01-07         NaN
2000-01-08         NaN
2000-01-09    0.733639
2000-01-10         NaN
Freq: D, dtype: float64

In [234]: ts2.reindex(ts.index, method="ffill")
Out[234]: 
2000-01-03    0.183051
2000-01-04    0.183051
2000-01-05    0.183051
2000-01-06    2.395489
2000-01-07    2.395489
2000-01-08    2.395489
2000-01-09    0.733639
2000-01-10    0.733639
Freq: D, dtype: float64

In [235]: ts2.reindex(ts.index, method="bfill")
Out[235]: 
2000-01-03    0.183051
2000-01-04    2.395489
2000-01-05    2.395489
2000-01-06    2.395489
2000-01-07    0.733639
2000-01-08    0.733639
2000-01-09    0.733639
2000-01-10         NaN
Freq: D, dtype: float64

In [236]: ts2.reindex(ts.index, method="nearest")
Out[236]: 
2000-01-03    0.183051
2000-01-04    0.183051
2000-01-05    2.395489
2000-01-06    2.395489
2000-01-07    2.395489
2000-01-08    0.733639
2000-01-09    0.733639
2000-01-10    0.733639
Freq: D, dtype: float64
</pre></div> </div> <p>These methods require that the indexes are <strong>ordered</strong> increasing or decreasing.</p> <p>Note that the same result could have been achieved using <a class="reference internal" href="missing_data#missing-data-fillna"><span class="std std-ref">fillna</span></a> (except for <code class="docutils literal notranslate"><span class="pre">method='nearest'</span></code>) or <a class="reference internal" href="missing_data#missing-data-interpolate"><span class="std std-ref">interpolate</span></a>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [237]: ts2.reindex(ts.index).fillna(method="ffill")
Out[237]: 
2000-01-03    0.183051
2000-01-04    0.183051
2000-01-05    0.183051
2000-01-06    2.395489
2000-01-07    2.395489
2000-01-08    2.395489
2000-01-09    0.733639
2000-01-10    0.733639
Freq: D, dtype: float64
</pre></div> </div> <p><a class="reference internal" href="../reference/api/pandas.series.reindex#pandas.Series.reindex" title="pandas.Series.reindex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reindex()</span></code></a> will raise a ValueError if the index is not monotonically increasing or decreasing. <a class="reference internal" href="../reference/api/pandas.series.fillna#pandas.Series.fillna" title="pandas.Series.fillna"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fillna()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.series.interpolate#pandas.Series.interpolate" title="pandas.Series.interpolate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">interpolate()</span></code></a> will not perform any checks on the order of the index.</p> </section> <section id="limits-on-filling-while-reindexing"> <h3>Limits on filling while reindexing</h3> <p>The <code class="docutils literal notranslate"><span class="pre">limit</span></code> and <code class="docutils literal notranslate"><span class="pre">tolerance</span></code> arguments provide additional control over filling while reindexing. Limit specifies the maximum count of consecutive matches:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [238]: ts2.reindex(ts.index, method="ffill", limit=1)
Out[238]: 
2000-01-03    0.183051
2000-01-04    0.183051
2000-01-05         NaN
2000-01-06    2.395489
2000-01-07    2.395489
2000-01-08         NaN
2000-01-09    0.733639
2000-01-10    0.733639
Freq: D, dtype: float64
</pre></div> </div> <p>In contrast, tolerance specifies the maximum distance between the index and indexer values:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [239]: ts2.reindex(ts.index, method="ffill", tolerance="1 day")
Out[239]: 
2000-01-03    0.183051
2000-01-04    0.183051
2000-01-05         NaN
2000-01-06    2.395489
2000-01-07    2.395489
2000-01-08         NaN
2000-01-09    0.733639
2000-01-10    0.733639
Freq: D, dtype: float64
</pre></div> </div> <p>Notice that when used on a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>, <code class="docutils literal notranslate"><span class="pre">TimedeltaIndex</span></code> or <code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code>, <code class="docutils literal notranslate"><span class="pre">tolerance</span></code> will coerced into a <code class="docutils literal notranslate"><span class="pre">Timedelta</span></code> if possible. This allows you to specify tolerance with appropriate strings.</p> </section> <section id="dropping-labels-from-an-axis"> <h3>Dropping labels from an axis</h3> <p>A method closely related to <code class="docutils literal notranslate"><span class="pre">reindex</span></code> is the <a class="reference internal" href="../reference/api/pandas.dataframe.drop#pandas.DataFrame.drop" title="pandas.DataFrame.drop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">drop()</span></code></a> function. It removes a set of labels from an axis:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [240]: df
Out[240]: 
        one       two     three
a  1.394981  1.772517       NaN
b  0.343054  1.912123 -0.050390
c  0.695246  1.478369  1.227435
d       NaN  0.279344 -0.613172

In [241]: df.drop(["a", "d"], axis=0)
Out[241]: 
        one       two     three
b  0.343054  1.912123 -0.050390
c  0.695246  1.478369  1.227435

In [242]: df.drop(["one"], axis=1)
Out[242]: 
        two     three
a  1.772517       NaN
b  1.912123 -0.050390
c  1.478369  1.227435
d  0.279344 -0.613172
</pre></div> </div> <p>Note that the following also works, but is a bit less obvious / clean:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [243]: df.reindex(df.index.difference(["a", "d"]))
Out[243]: 
        one       two     three
b  0.343054  1.912123 -0.050390
c  0.695246  1.478369  1.227435
</pre></div> </div> </section> <section id="renaming-mapping-labels"> <h3>Renaming / mapping labels</h3> <p>The <a class="reference internal" href="../reference/api/pandas.dataframe.rename#pandas.DataFrame.rename" title="pandas.DataFrame.rename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rename()</span></code></a> method allows you to relabel an axis based on some mapping (a dict or Series) or an arbitrary function.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [244]: s
Out[244]: 
a   -0.186646
b   -1.692424
c   -0.303893
d   -1.425662
e    1.114285
dtype: float64

In [245]: s.rename(str.upper)
Out[245]: 
A   -0.186646
B   -1.692424
C   -0.303893
D   -1.425662
E    1.114285
dtype: float64
</pre></div> </div> <p>If you pass a function, it must return a value when called with any of the labels (and must produce a set of unique values). A dict or Series can also be used:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [246]: df.rename(
   .....:     columns={"one": "foo", "two": "bar"},
   .....:     index={"a": "apple", "b": "banana", "d": "durian"},
   .....: )
   .....: 
Out[246]: 
             foo       bar     three
apple   1.394981  1.772517       NaN
banana  0.343054  1.912123 -0.050390
c       0.695246  1.478369  1.227435
durian       NaN  0.279344 -0.613172
</pre></div> </div> <p>If the mapping doesn’t include a column/index label, it isn’t renamed. Note that extra labels in the mapping don’t throw an error.</p> <p><a class="reference internal" href="../reference/api/pandas.dataframe.rename#pandas.DataFrame.rename" title="pandas.DataFrame.rename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.rename()</span></code></a> also supports an “axis-style” calling convention, where you specify a single <code class="docutils literal notranslate"><span class="pre">mapper</span></code> and the <code class="docutils literal notranslate"><span class="pre">axis</span></code> to apply that mapping to.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [247]: df.rename({"one": "foo", "two": "bar"}, axis="columns")
Out[247]: 
        foo       bar     three
a  1.394981  1.772517       NaN
b  0.343054  1.912123 -0.050390
c  0.695246  1.478369  1.227435
d       NaN  0.279344 -0.613172

In [248]: df.rename({"a": "apple", "b": "banana", "d": "durian"}, axis="index")
Out[248]: 
             one       two     three
apple   1.394981  1.772517       NaN
banana  0.343054  1.912123 -0.050390
c       0.695246  1.478369  1.227435
durian       NaN  0.279344 -0.613172
</pre></div> </div> <p>The <a class="reference internal" href="../reference/api/pandas.dataframe.rename#pandas.DataFrame.rename" title="pandas.DataFrame.rename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rename()</span></code></a> method also provides an <code class="docutils literal notranslate"><span class="pre">inplace</span></code> named parameter that is by default <code class="docutils literal notranslate"><span class="pre">False</span></code> and copies the underlying data. Pass <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code> to rename the data in place.</p> <p>Finally, <a class="reference internal" href="../reference/api/pandas.series.rename#pandas.Series.rename" title="pandas.Series.rename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rename()</span></code></a> also accepts a scalar or list-like for altering the <code class="docutils literal notranslate"><span class="pre">Series.name</span></code> attribute.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [249]: s.rename("scalar-name")
Out[249]: 
a   -0.186646
b   -1.692424
c   -0.303893
d   -1.425662
e    1.114285
Name: scalar-name, dtype: float64
</pre></div> </div> <p id="basics-rename-axis">The methods <a class="reference internal" href="../reference/api/pandas.dataframe.rename_axis#pandas.DataFrame.rename_axis" title="pandas.DataFrame.rename_axis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.rename_axis()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.series.rename_axis#pandas.Series.rename_axis" title="pandas.Series.rename_axis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Series.rename_axis()</span></code></a> allow specific names of a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> to be changed (as opposed to the labels).</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [250]: df = pd.DataFrame(
   .....:     {"x": [1, 2, 3, 4, 5, 6], "y": [10, 20, 30, 40, 50, 60]},
   .....:     index=pd.MultiIndex.from_product(
   .....:         [["a", "b", "c"], [1, 2]], names=["let", "num"]
   .....:     ),
   .....: )
   .....: 

In [251]: df
Out[251]: 
         x   y
let num       
a   1    1  10
    2    2  20
b   1    3  30
    2    4  40
c   1    5  50
    2    6  60

In [252]: df.rename_axis(index={"let": "abc"})
Out[252]: 
         x   y
abc num       
a   1    1  10
    2    2  20
b   1    3  30
    2    4  40
c   1    5  50
    2    6  60

In [253]: df.rename_axis(index=str.upper)
Out[253]: 
         x   y
LET NUM       
a   1    1  10
    2    2  20
b   1    3  30
    2    4  40
c   1    5  50
    2    6  60
</pre></div> </div> </section> </section> <section id="iteration"> <h2>Iteration</h2> <p>The behavior of basic iteration over pandas objects depends on the type. When iterating over a Series, it is regarded as array-like, and basic iteration produces the values. DataFrames follow the dict-like convention of iterating over the “keys” of the objects.</p> <p>In short, basic iteration (<code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">object</span></code>) produces:</p> <ul class="simple"> <li><p><strong>Series</strong>: values</p></li> <li><p><strong>DataFrame</strong>: column labels</p></li> </ul> <p>Thus, for example, iterating over a DataFrame gives you the column names:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [254]: df = pd.DataFrame(
   .....:     {"col1": np.random.randn(3), "col2": np.random.randn(3)}, index=["a", "b", "c"]
   .....: )
   .....: 

In [255]: for col in df:
   .....:     print(col)
   .....: 
col1
col2
</pre></div> </div> <p>pandas objects also have the dict-like <a class="reference internal" href="../reference/api/pandas.dataframe.items#pandas.DataFrame.items" title="pandas.DataFrame.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code></a> method to iterate over the (key, value) pairs.</p> <p>To iterate over the rows of a DataFrame, you can use the following methods:</p> <ul class="simple"> <li><p><a class="reference internal" href="../reference/api/pandas.dataframe.iterrows#pandas.DataFrame.iterrows" title="pandas.DataFrame.iterrows"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iterrows()</span></code></a>: Iterate over the rows of a DataFrame as (index, Series) pairs. This converts the rows to Series objects, which can change the dtypes and has some performance implications.</p></li> <li><p><a class="reference internal" href="../reference/api/pandas.dataframe.itertuples#pandas.DataFrame.itertuples" title="pandas.DataFrame.itertuples"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itertuples()</span></code></a>: Iterate over the rows of a DataFrame as namedtuples of the values. This is a lot faster than <a class="reference internal" href="../reference/api/pandas.dataframe.iterrows#pandas.DataFrame.iterrows" title="pandas.DataFrame.iterrows"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iterrows()</span></code></a>, and is in most cases preferable to use to iterate over the values of a DataFrame.</p></li> </ul> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Iterating through pandas objects is generally <strong>slow</strong>. In many cases, iterating manually over the rows is not needed and can be avoided with one of the following approaches:</p> <ul class="simple"> <li><p>Look for a <em>vectorized</em> solution: many operations can be performed using built-in methods or NumPy functions, (boolean) indexing, …</p></li> <li><p>When you have a function that cannot work on the full DataFrame/Series at once, it is better to use <a class="reference internal" href="../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply" title="pandas.DataFrame.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code></a> instead of iterating over the values. See the docs on <a class="reference internal" href="#basics-apply"><span class="std std-ref">function application</span></a>.</p></li> <li><p>If you need to do iterative manipulations on the values but performance is important, consider writing the inner loop with cython or numba. See the <a class="reference internal" href="enhancingperf#enhancingperf"><span class="std std-ref">enhancing performance</span></a> section for some examples of this approach.</p></li> </ul> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>You should <strong>never modify</strong> something you are iterating over. This is not guaranteed to work in all cases. Depending on the data types, the iterator returns a copy and not a view, and writing to it will have no effect!</p> <p>For example, in the following case setting the value has no effect:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [256]: df = pd.DataFrame({"a": [1, 2, 3], "b": ["a", "b", "c"]})

In [257]: for index, row in df.iterrows():
   .....:     row["a"] = 10
   .....: 

In [258]: df
Out[258]: 
   a  b
0  1  a
1  2  b
2  3  c
</pre></div> </div> </div> <section id="items"> <h3>items</h3> <p>Consistent with the dict-like interface, <a class="reference internal" href="../reference/api/pandas.dataframe.items#pandas.DataFrame.items" title="pandas.DataFrame.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code></a> iterates through key-value pairs:</p> <ul class="simple"> <li><p><strong>Series</strong>: (index, scalar value) pairs</p></li> <li><p><strong>DataFrame</strong>: (column, Series) pairs</p></li> </ul> <p>For example:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [259]: for label, ser in df.items():
   .....:     print(label)
   .....:     print(ser)
   .....: 
a
0    1
1    2
2    3
Name: a, dtype: int64
b
0    a
1    b
2    c
Name: b, dtype: object
</pre></div> </div> </section> <section id="iterrows"> <h3>iterrows</h3> <p><a class="reference internal" href="../reference/api/pandas.dataframe.iterrows#pandas.DataFrame.iterrows" title="pandas.DataFrame.iterrows"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iterrows()</span></code></a> allows you to iterate through the rows of a DataFrame as Series objects. It returns an iterator yielding each index value along with a Series containing the data in each row:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [260]: for row_index, row in df.iterrows():
   .....:     print(row_index, row, sep="\n")
   .....: 
0
a    1
b    a
Name: 0, dtype: object
1
a    2
b    b
Name: 1, dtype: object
2
a    3
b    c
Name: 2, dtype: object
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Because <a class="reference internal" href="../reference/api/pandas.dataframe.iterrows#pandas.DataFrame.iterrows" title="pandas.DataFrame.iterrows"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iterrows()</span></code></a> returns a Series for each row, it does <strong>not</strong> preserve dtypes across the rows (dtypes are preserved across columns for DataFrames). For example,</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [261]: df_orig = pd.DataFrame([[1, 1.5]], columns=["int", "float"])

In [262]: df_orig.dtypes
Out[262]: 
int        int64
float    float64
dtype: object

In [263]: row = next(df_orig.iterrows())[1]

In [264]: row
Out[264]: 
int      1.0
float    1.5
Name: 0, dtype: float64
</pre></div> </div> <p>All values in <code class="docutils literal notranslate"><span class="pre">row</span></code>, returned as a Series, are now upcasted to floats, also the original integer value in column <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [265]: row["int"].dtype
Out[265]: dtype('float64')

In [266]: df_orig["int"].dtype
Out[266]: dtype('int64')
</pre></div> </div> <p>To preserve dtypes while iterating over the rows, it is better to use <a class="reference internal" href="../reference/api/pandas.dataframe.itertuples#pandas.DataFrame.itertuples" title="pandas.DataFrame.itertuples"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itertuples()</span></code></a> which returns namedtuples of the values and which is generally much faster than <a class="reference internal" href="../reference/api/pandas.dataframe.iterrows#pandas.DataFrame.iterrows" title="pandas.DataFrame.iterrows"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iterrows()</span></code></a>.</p> </div> <p>For instance, a contrived way to transpose the DataFrame would be:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [267]: df2 = pd.DataFrame({"x": [1, 2, 3], "y": [4, 5, 6]})

In [268]: print(df2)
   x  y
0  1  4
1  2  5
2  3  6

In [269]: print(df2.T)
   0  1  2
x  1  2  3
y  4  5  6

In [270]: df2_t = pd.DataFrame({idx: values for idx, values in df2.iterrows()})

In [271]: print(df2_t)
   0  1  2
x  1  2  3
y  4  5  6
</pre></div> </div> </section> <section id="itertuples"> <h3>itertuples</h3> <p>The <a class="reference internal" href="../reference/api/pandas.dataframe.itertuples#pandas.DataFrame.itertuples" title="pandas.DataFrame.itertuples"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itertuples()</span></code></a> method will return an iterator yielding a namedtuple for each row in the DataFrame. The first element of the tuple will be the row’s corresponding index value, while the remaining values are the row values.</p> <p>For instance:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [272]: for row in df.itertuples():
   .....:     print(row)
   .....: 
Pandas(Index=0, a=1, b='a')
Pandas(Index=1, a=2, b='b')
Pandas(Index=2, a=3, b='c')
</pre></div> </div> <p>This method does not convert the row to a Series object; it merely returns the values inside a namedtuple. Therefore, <a class="reference internal" href="../reference/api/pandas.dataframe.itertuples#pandas.DataFrame.itertuples" title="pandas.DataFrame.itertuples"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itertuples()</span></code></a> preserves the data type of the values and is generally faster as <a class="reference internal" href="../reference/api/pandas.dataframe.iterrows#pandas.DataFrame.iterrows" title="pandas.DataFrame.iterrows"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iterrows()</span></code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The column names will be renamed to positional names if they are invalid Python identifiers, repeated, or start with an underscore. With a large number of columns (&gt;255), regular tuples are returned.</p> </div> </section> </section> <section id="dt-accessor"> <h2>.dt accessor</h2> <p><code class="docutils literal notranslate"><span class="pre">Series</span></code> has an accessor to succinctly return datetime like properties for the <em>values</em> of the Series, if it is a datetime/period like Series. This will return a Series, indexed like the existing Series.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># datetime
In [273]: s = pd.Series(pd.date_range("20130101 09:10:12", periods=4))

In [274]: s
Out[274]: 
0   2013-01-01 09:10:12
1   2013-01-02 09:10:12
2   2013-01-03 09:10:12
3   2013-01-04 09:10:12
dtype: datetime64[ns]

In [275]: s.dt.hour
Out[275]: 
0    9
1    9
2    9
3    9
dtype: int64

In [276]: s.dt.second
Out[276]: 
0    12
1    12
2    12
3    12
dtype: int64

In [277]: s.dt.day
Out[277]: 
0    1
1    2
2    3
3    4
dtype: int64
</pre></div> </div> <p>This enables nice expressions like this:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [278]: s[s.dt.day == 2]
Out[278]: 
1   2013-01-02 09:10:12
dtype: datetime64[ns]
</pre></div> </div> <p>You can easily produces tz aware transformations:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [279]: stz = s.dt.tz_localize("US/Eastern")

In [280]: stz
Out[280]: 
0   2013-01-01 09:10:12-05:00
1   2013-01-02 09:10:12-05:00
2   2013-01-03 09:10:12-05:00
3   2013-01-04 09:10:12-05:00
dtype: datetime64[ns, US/Eastern]

In [281]: stz.dt.tz
Out[281]: &lt;DstTzInfo 'US/Eastern' LMT-1 day, 19:04:00 STD&gt;
</pre></div> </div> <p>You can also chain these types of operations:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [282]: s.dt.tz_localize("UTC").dt.tz_convert("US/Eastern")
Out[282]: 
0   2013-01-01 04:10:12-05:00
1   2013-01-02 04:10:12-05:00
2   2013-01-03 04:10:12-05:00
3   2013-01-04 04:10:12-05:00
dtype: datetime64[ns, US/Eastern]
</pre></div> </div> <p>You can also format datetime values as strings with <a class="reference internal" href="../reference/api/pandas.series.dt.strftime#pandas.Series.dt.strftime" title="pandas.Series.dt.strftime"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Series.dt.strftime()</span></code></a> which supports the same format as the standard <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime.strftime" title="(in Python v3.10)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">strftime()</span></code></a>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># DatetimeIndex
In [283]: s = pd.Series(pd.date_range("20130101", periods=4))

In [284]: s
Out[284]: 
0   2013-01-01
1   2013-01-02
2   2013-01-03
3   2013-01-04
dtype: datetime64[ns]

In [285]: s.dt.strftime("%Y/%m/%d")
Out[285]: 
0    2013/01/01
1    2013/01/02
2    2013/01/03
3    2013/01/04
dtype: object
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># PeriodIndex
In [286]: s = pd.Series(pd.period_range("20130101", periods=4))

In [287]: s
Out[287]: 
0    2013-01-01
1    2013-01-02
2    2013-01-03
3    2013-01-04
dtype: period[D]

In [288]: s.dt.strftime("%Y/%m/%d")
Out[288]: 
0    2013/01/01
1    2013/01/02
2    2013/01/03
3    2013/01/04
dtype: object
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">.dt</span></code> accessor works for period and timedelta dtypes.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># period
In [289]: s = pd.Series(pd.period_range("20130101", periods=4, freq="D"))

In [290]: s
Out[290]: 
0    2013-01-01
1    2013-01-02
2    2013-01-03
3    2013-01-04
dtype: period[D]

In [291]: s.dt.year
Out[291]: 
0    2013
1    2013
2    2013
3    2013
dtype: int64

In [292]: s.dt.day
Out[292]: 
0    1
1    2
2    3
3    4
dtype: int64
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># timedelta
In [293]: s = pd.Series(pd.timedelta_range("1 day 00:00:05", periods=4, freq="s"))

In [294]: s
Out[294]: 
0   1 days 00:00:05
1   1 days 00:00:06
2   1 days 00:00:07
3   1 days 00:00:08
dtype: timedelta64[ns]

In [295]: s.dt.days
Out[295]: 
0    1
1    1
2    1
3    1
dtype: int64

In [296]: s.dt.seconds
Out[296]: 
0    5
1    6
2    7
3    8
dtype: int64

In [297]: s.dt.components
Out[297]: 
   days  hours  minutes  seconds  milliseconds  microseconds  nanoseconds
0     1      0        0        5             0             0            0
1     1      0        0        6             0             0            0
2     1      0        0        7             0             0            0
3     1      0        0        8             0             0            0
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code class="docutils literal notranslate"><span class="pre">Series.dt</span></code> will raise a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> if you access with a non-datetime-like values.</p> </div> </section> <section id="vectorized-string-methods"> <h2>Vectorized string methods</h2> <p>Series is equipped with a set of string processing methods that make it easy to operate on each element of the array. Perhaps most importantly, these methods exclude missing/NA values automatically. These are accessed via the Series’s <code class="docutils literal notranslate"><span class="pre">str</span></code> attribute and generally have names matching the equivalent (scalar) built-in string methods. For example:</p> <blockquote> <div>
<div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [298]: s = pd.Series(
   .....:     ["A", "B", "C", "Aaba", "Baca", np.nan, "CABA", "dog", "cat"], dtype="string"
   .....: )
   .....: 

In [299]: s.str.lower()
Out[299]: 
0       a
1       b
2       c
3    aaba
4    baca
5    &lt;NA&gt;
6    caba
7     dog
8     cat
dtype: string
</pre></div> </div> </div>
</blockquote> <p>Powerful pattern-matching methods are provided as well, but note that pattern-matching generally uses <a class="reference external" href="https://docs.python.org/3/library/re.html">regular expressions</a> by default (and in some cases always uses them).</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Prior to pandas 1.0, string methods were only available on <code class="docutils literal notranslate"><span class="pre">object</span></code> -dtype <code class="docutils literal notranslate"><span class="pre">Series</span></code>. pandas 1.0 added the <a class="reference internal" href="../reference/api/pandas.stringdtype#pandas.StringDtype" title="pandas.StringDtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">StringDtype</span></code></a> which is dedicated to strings. See <a class="reference internal" href="text#text-types"><span class="std std-ref">Text data types</span></a> for more.</p> </div> <p>Please see <a class="reference internal" href="text#text-string-methods"><span class="std std-ref">Vectorized String Methods</span></a> for a complete description.</p> </section> <section id="sorting"> <h2>Sorting</h2> <p>pandas supports three kinds of sorting: sorting by index labels, sorting by column values, and sorting by a combination of both.</p> <section id="by-index"> <h3>By index</h3> <p>The <a class="reference internal" href="../reference/api/pandas.series.sort_index#pandas.Series.sort_index" title="pandas.Series.sort_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Series.sort_index()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.sort_index#pandas.DataFrame.sort_index" title="pandas.DataFrame.sort_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.sort_index()</span></code></a> methods are used to sort a pandas object by its index levels.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [300]: df = pd.DataFrame(
   .....:     {
   .....:         "one": pd.Series(np.random.randn(3), index=["a", "b", "c"]),
   .....:         "two": pd.Series(np.random.randn(4), index=["a", "b", "c", "d"]),
   .....:         "three": pd.Series(np.random.randn(3), index=["b", "c", "d"]),
   .....:     }
   .....: )
   .....: 

In [301]: unsorted_df = df.reindex(
   .....:     index=["a", "d", "c", "b"], columns=["three", "two", "one"]
   .....: )
   .....: 

In [302]: unsorted_df
Out[302]: 
      three       two       one
a       NaN -1.152244  0.562973
d -0.252916 -0.109597       NaN
c  1.273388 -0.167123  0.640382
b -0.098217  0.009797 -1.299504

# DataFrame
In [303]: unsorted_df.sort_index()
Out[303]: 
      three       two       one
a       NaN -1.152244  0.562973
b -0.098217  0.009797 -1.299504
c  1.273388 -0.167123  0.640382
d -0.252916 -0.109597       NaN

In [304]: unsorted_df.sort_index(ascending=False)
Out[304]: 
      three       two       one
d -0.252916 -0.109597       NaN
c  1.273388 -0.167123  0.640382
b -0.098217  0.009797 -1.299504
a       NaN -1.152244  0.562973

In [305]: unsorted_df.sort_index(axis=1)
Out[305]: 
        one     three       two
a  0.562973       NaN -1.152244
d       NaN -0.252916 -0.109597
c  0.640382  1.273388 -0.167123
b -1.299504 -0.098217  0.009797

# Series
In [306]: unsorted_df["three"].sort_index()
Out[306]: 
a         NaN
b   -0.098217
c    1.273388
d   -0.252916
Name: three, dtype: float64
</pre></div> </div> <div class="versionadded" id="basics-sort-index-key"> <p><span class="versionmodified added">New in version 1.1.0.</span></p> </div> <p>Sorting by index also supports a <code class="docutils literal notranslate"><span class="pre">key</span></code> parameter that takes a callable function to apply to the index being sorted. For <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> objects, the key is applied per-level to the levels specified by <code class="docutils literal notranslate"><span class="pre">level</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [307]: s1 = pd.DataFrame({"a": ["B", "a", "C"], "b": [1, 2, 3], "c": [2, 3, 4]}).set_index(
   .....:     list("ab")
   .....: )
   .....: 

In [308]: s1
Out[308]: 
     c
a b   
B 1  2
a 2  3
C 3  4
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [309]: s1.sort_index(level="a")
Out[309]: 
     c
a b   
B 1  2
C 3  4
a 2  3

In [310]: s1.sort_index(level="a", key=lambda idx: idx.str.lower())
Out[310]: 
     c
a b   
a 2  3
B 1  2
C 3  4
</pre></div> </div> <p>For information on key sorting by value, see <a class="reference internal" href="#basics-sort-value-key"><span class="std std-ref">value sorting</span></a>.</p> </section> <section id="by-values"> <h3>By values</h3> <p>The <a class="reference internal" href="../reference/api/pandas.series.sort_values#pandas.Series.sort_values" title="pandas.Series.sort_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Series.sort_values()</span></code></a> method is used to sort a <code class="docutils literal notranslate"><span class="pre">Series</span></code> by its values. The <a class="reference internal" href="../reference/api/pandas.dataframe.sort_values#pandas.DataFrame.sort_values" title="pandas.DataFrame.sort_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.sort_values()</span></code></a> method is used to sort a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> by its column or row values. The optional <code class="docutils literal notranslate"><span class="pre">by</span></code> parameter to <a class="reference internal" href="../reference/api/pandas.dataframe.sort_values#pandas.DataFrame.sort_values" title="pandas.DataFrame.sort_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.sort_values()</span></code></a> may used to specify one or more columns to use to determine the sorted order.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [311]: df1 = pd.DataFrame(
   .....:     {"one": [2, 1, 1, 1], "two": [1, 3, 2, 4], "three": [5, 4, 3, 2]}
   .....: )
   .....: 

In [312]: df1.sort_values(by="two")
Out[312]: 
   one  two  three
0    2    1      5
2    1    2      3
1    1    3      4
3    1    4      2
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">by</span></code> parameter can take a list of column names, e.g.:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [313]: df1[["one", "two", "three"]].sort_values(by=["one", "two"])
Out[313]: 
   one  two  three
2    1    2      3
1    1    3      4
3    1    4      2
0    2    1      5
</pre></div> </div> <p>These methods have special treatment of NA values via the <code class="docutils literal notranslate"><span class="pre">na_position</span></code> argument:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [314]: s[2] = np.nan

In [315]: s.sort_values()
Out[315]: 
0       A
3    Aaba
1       B
4    Baca
6    CABA
8     cat
7     dog
2    &lt;NA&gt;
5    &lt;NA&gt;
dtype: string

In [316]: s.sort_values(na_position="first")
Out[316]: 
2    &lt;NA&gt;
5    &lt;NA&gt;
0       A
3    Aaba
1       B
4    Baca
6    CABA
8     cat
7     dog
dtype: string
</pre></div> </div> <div class="versionadded" id="basics-sort-value-key"> <p><span class="versionmodified added">New in version 1.1.0.</span></p> </div> <p>Sorting also supports a <code class="docutils literal notranslate"><span class="pre">key</span></code> parameter that takes a callable function to apply to the values being sorted.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [317]: s1 = pd.Series(["B", "a", "C"])
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [318]: s1.sort_values()
Out[318]: 
0    B
2    C
1    a
dtype: object

In [319]: s1.sort_values(key=lambda x: x.str.lower())
Out[319]: 
1    a
0    B
2    C
dtype: object
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">key</span></code> will be given the <a class="reference internal" href="../reference/api/pandas.series#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> of values and should return a <code class="docutils literal notranslate"><span class="pre">Series</span></code> or array of the same shape with the transformed values. For <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> objects, the key is applied per column, so the key should still expect a Series and return a Series, e.g.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [320]: df = pd.DataFrame({"a": ["B", "a", "C"], "b": [1, 2, 3]})
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [321]: df.sort_values(by="a")
Out[321]: 
   a  b
0  B  1
2  C  3
1  a  2

In [322]: df.sort_values(by="a", key=lambda col: col.str.lower())
Out[322]: 
   a  b
1  a  2
0  B  1
2  C  3
</pre></div> </div> <p>The name or type of each column can be used to apply different functions to different columns.</p> </section> <section id="by-indexes-and-values"> <h3>By indexes and values</h3> <p>Strings passed as the <code class="docutils literal notranslate"><span class="pre">by</span></code> parameter to <a class="reference internal" href="../reference/api/pandas.dataframe.sort_values#pandas.DataFrame.sort_values" title="pandas.DataFrame.sort_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.sort_values()</span></code></a> may refer to either columns or index level names.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># Build MultiIndex
In [323]: idx = pd.MultiIndex.from_tuples(
   .....:     [("a", 1), ("a", 2), ("a", 2), ("b", 2), ("b", 1), ("b", 1)]
   .....: )
   .....: 

In [324]: idx.names = ["first", "second"]

# Build DataFrame
In [325]: df_multi = pd.DataFrame({"A": np.arange(6, 0, -1)}, index=idx)

In [326]: df_multi
Out[326]: 
              A
first second   
a     1       6
      2       5
      2       4
b     2       3
      1       2
      1       1
</pre></div> </div> <p>Sort by ‘second’ (index) and ‘A’ (column)</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [327]: df_multi.sort_values(by=["second", "A"])
Out[327]: 
              A
first second   
b     1       1
      1       2
a     1       6
b     2       3
a     2       4
      2       5
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If a string matches both a column name and an index level name then a warning is issued and the column takes precedence. This will result in an ambiguity error in a future version.</p> </div> </section> <section id="searchsorted"> <h3>searchsorted</h3> <p>Series has the <a class="reference internal" href="../reference/api/pandas.series.searchsorted#pandas.Series.searchsorted" title="pandas.Series.searchsorted"><code class="xref py py-meth docutils literal notranslate"><span class="pre">searchsorted()</span></code></a> method, which works similarly to <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.searchsorted.html#numpy.ndarray.searchsorted" title="(in NumPy v1.22)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">numpy.ndarray.searchsorted()</span></code></a>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [328]: ser = pd.Series([1, 2, 3])

In [329]: ser.searchsorted([0, 3])
Out[329]: array([0, 2])

In [330]: ser.searchsorted([0, 4])
Out[330]: array([0, 3])

In [331]: ser.searchsorted([1, 3], side="right")
Out[331]: array([1, 3])

In [332]: ser.searchsorted([1, 3], side="left")
Out[332]: array([0, 2])

In [333]: ser = pd.Series([3, 1, 2])

In [334]: ser.searchsorted([0, 3], sorter=np.argsort(ser))
Out[334]: array([0, 2])
</pre></div> </div> </section> <section id="smallest-largest-values"> <h3>smallest / largest values</h3> <p><code class="docutils literal notranslate"><span class="pre">Series</span></code> has the <a class="reference internal" href="../reference/api/pandas.series.nsmallest#pandas.Series.nsmallest" title="pandas.Series.nsmallest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">nsmallest()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.series.nlargest#pandas.Series.nlargest" title="pandas.Series.nlargest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">nlargest()</span></code></a> methods which return the smallest or largest <span class="math notranslate nohighlight">\(n\)</span> values. For a large <code class="docutils literal notranslate"><span class="pre">Series</span></code> this can be much faster than sorting the entire Series and calling <code class="docutils literal notranslate"><span class="pre">head(n)</span></code> on the result.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [335]: s = pd.Series(np.random.permutation(10))

In [336]: s
Out[336]: 
0    2
1    0
2    3
3    7
4    1
5    5
6    9
7    6
8    8
9    4
dtype: int64

In [337]: s.sort_values()
Out[337]: 
1    0
4    1
0    2
2    3
9    4
5    5
7    6
3    7
8    8
6    9
dtype: int64

In [338]: s.nsmallest(3)
Out[338]: 
1    0
4    1
0    2
dtype: int64

In [339]: s.nlargest(3)
Out[339]: 
6    9
8    8
3    7
dtype: int64
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> also has the <code class="docutils literal notranslate"><span class="pre">nlargest</span></code> and <code class="docutils literal notranslate"><span class="pre">nsmallest</span></code> methods.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [340]: df = pd.DataFrame(
   .....:     {
   .....:         "a": [-2, -1, 1, 10, 8, 11, -1],
   .....:         "b": list("abdceff"),
   .....:         "c": [1.0, 2.0, 4.0, 3.2, np.nan, 3.0, 4.0],
   .....:     }
   .....: )
   .....: 

In [341]: df.nlargest(3, "a")
Out[341]: 
    a  b    c
5  11  f  3.0
3  10  c  3.2
4   8  e  NaN

In [342]: df.nlargest(5, ["a", "c"])
Out[342]: 
    a  b    c
5  11  f  3.0
3  10  c  3.2
4   8  e  NaN
2   1  d  4.0
6  -1  f  4.0

In [343]: df.nsmallest(3, "a")
Out[343]: 
   a  b    c
0 -2  a  1.0
1 -1  b  2.0
6 -1  f  4.0

In [344]: df.nsmallest(5, ["a", "c"])
Out[344]: 
   a  b    c
0 -2  a  1.0
1 -1  b  2.0
6 -1  f  4.0
2  1  d  4.0
4  8  e  NaN
</pre></div> </div> </section> <section id="sorting-by-a-multiindex-column"> <h3>Sorting by a MultiIndex column</h3> <p>You must be explicit about sorting when the column is a MultiIndex, and fully specify all levels to <code class="docutils literal notranslate"><span class="pre">by</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [345]: df1.columns = pd.MultiIndex.from_tuples(
   .....:     [("a", "one"), ("a", "two"), ("b", "three")]
   .....: )
   .....: 

In [346]: df1.sort_values(by=("a", "two"))
Out[346]: 
    a         b
  one two three
0   2   1     5
2   1   2     3
1   1   3     4
3   1   4     2
</pre></div> </div> </section> </section> <section id="copying"> <h2>Copying</h2> <p>The <a class="reference internal" href="../reference/api/pandas.dataframe.copy#pandas.DataFrame.copy" title="pandas.DataFrame.copy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code></a> method on pandas objects copies the underlying data (though not the axis indexes, since they are immutable) and returns a new object. Note that <strong>it is seldom necessary to copy objects</strong>. For example, there are only a handful of ways to alter a DataFrame <em>in-place</em>:</p> <ul class="simple"> <li><p>Inserting, deleting, or modifying a column.</p></li> <li><p>Assigning to the <code class="docutils literal notranslate"><span class="pre">index</span></code> or <code class="docutils literal notranslate"><span class="pre">columns</span></code> attributes.</p></li> <li><p>For homogeneous data, directly modifying the values via the <code class="docutils literal notranslate"><span class="pre">values</span></code> attribute or advanced indexing.</p></li> </ul> <p>To be clear, no pandas method has the side effect of modifying your data; almost every method returns a new object, leaving the original object untouched. If the data is modified, it is because you did so explicitly.</p> </section> <section id="dtypes"> <h2>dtypes</h2> <p>For the most part, pandas uses NumPy arrays and dtypes for Series or individual columns of a DataFrame. NumPy provides support for <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">timedelta64[ns]</span></code> and <code class="docutils literal notranslate"><span class="pre">datetime64[ns]</span></code> (note that NumPy does not support timezone-aware datetimes).</p> <p>pandas and third-party libraries <em>extend</em> NumPy’s type system in a few places. This section describes the extensions pandas has made internally. See <a class="reference internal" href="https://pandas.pydata.org/pandas-docs/version/1.4.0/development/extending.html#extending-extension-types"><span class="std std-ref">Extension types</span></a> for how to write your own extension that works with pandas. See <a class="reference internal" href="https://pandas.pydata.org/pandas-docs/version/1.4.0/ecosystem.html#ecosystem-extensions"><span class="std std-ref">Extension data types</span></a> for a list of third-party libraries that have implemented an extension.</p> <p>The following table lists all of pandas extension types. For methods requiring <code class="docutils literal notranslate"><span class="pre">dtype</span></code> arguments, strings can be specified as indicated. See the respective documentation sections for more on each type.</p> <table class="table"> <colgroup> <col style="width: 30%"> <col style="width: 9%"> <col style="width: 7%"> <col style="width: 5%"> <col style="width: 7%"> <col style="width: 19%"> <col style="width: 24%"> </colgroup> <thead> <tr class="row-odd">
<th class="head"><p>Kind of Data</p></th> <th class="head" colspan="2"><p>Data Type</p></th> <th class="head" colspan="2"><p>Scalar</p></th> <th class="head"><p>Array</p></th> <th class="head"><p>String Aliases</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p><a class="reference internal" href="timeseries#timeseries-timezone"><span class="std std-ref">tz-aware datetime</span></a></p></td> <td colspan="2"><p><a class="reference internal" href="../reference/api/pandas.datetimetzdtype#pandas.DatetimeTZDtype" title="pandas.DatetimeTZDtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">DatetimeTZDtype</span></code></a></p></td> <td colspan="2"><p><a class="reference internal" href="../reference/api/pandas.timestamp#pandas.Timestamp" title="pandas.Timestamp"><code class="xref py py-class docutils literal notranslate"><span class="pre">Timestamp</span></code></a></p></td> <td><p><a class="reference internal" href="../reference/api/pandas.arrays.datetimearray#pandas.arrays.DatetimeArray" title="pandas.arrays.DatetimeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">arrays.DatetimeArray</span></code></a></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">'datetime64[ns,</span> <span class="pre">&lt;tz&gt;]'</span></code></p></td> </tr> <tr class="row-odd">
<td><p><a class="reference internal" href="categorical#categorical"><span class="std std-ref">Categorical</span></a></p></td> <td colspan="2"><p><a class="reference internal" href="../reference/api/pandas.categoricaldtype#pandas.CategoricalDtype" title="pandas.CategoricalDtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoricalDtype</span></code></a></p></td> <td colspan="2"><p>(none)</p></td> <td><p><a class="reference internal" href="../reference/api/pandas.categorical#pandas.Categorical" title="pandas.Categorical"><code class="xref py py-class docutils literal notranslate"><span class="pre">Categorical</span></code></a></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">'category'</span></code></p></td> </tr> <tr class="row-even">
<td><p><a class="reference internal" href="timeseries#timeseries-periods"><span class="std std-ref">period (time spans)</span></a></p></td> <td colspan="2"><p><a class="reference internal" href="../reference/api/pandas.perioddtype#pandas.PeriodDtype" title="pandas.PeriodDtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">PeriodDtype</span></code></a></p></td> <td colspan="2"><p><a class="reference internal" href="../reference/api/pandas.period#pandas.Period" title="pandas.Period"><code class="xref py py-class docutils literal notranslate"><span class="pre">Period</span></code></a></p></td> <td><p><a class="reference internal" href="../reference/api/pandas.arrays.periodarray#pandas.arrays.PeriodArray" title="pandas.arrays.PeriodArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">arrays.PeriodArray</span></code></a> <code class="docutils literal notranslate"><span class="pre">'Period[&lt;freq&gt;]'</span></code></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">'period[&lt;freq&gt;]'</span></code>,</p></td> </tr> <tr class="row-odd">
<td><p><a class="reference internal" href="sparse#sparse"><span class="std std-ref">sparse</span></a></p></td> <td colspan="2"><p><a class="reference internal" href="../reference/api/pandas.sparsedtype#pandas.SparseDtype" title="pandas.SparseDtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">SparseDtype</span></code></a></p></td> <td colspan="2"><p>(none)</p></td> <td><p><a class="reference internal" href="../reference/api/pandas.arrays.sparsearray#pandas.arrays.SparseArray" title="pandas.arrays.SparseArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">arrays.SparseArray</span></code></a></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">'Sparse'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Sparse[int]'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Sparse[float]'</span></code></p></td> </tr> <tr class="row-even">
<td><p><a class="reference internal" href="advanced#advanced-intervalindex"><span class="std std-ref">intervals</span></a></p></td> <td colspan="2"><p><a class="reference internal" href="../reference/api/pandas.intervaldtype#pandas.IntervalDtype" title="pandas.IntervalDtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntervalDtype</span></code></a></p></td> <td colspan="2"><p><a class="reference internal" href="../reference/api/pandas.interval#pandas.Interval" title="pandas.Interval"><code class="xref py py-class docutils literal notranslate"><span class="pre">Interval</span></code></a></p></td> <td><p><a class="reference internal" href="../reference/api/pandas.arrays.intervalarray#pandas.arrays.IntervalArray" title="pandas.arrays.IntervalArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">arrays.IntervalArray</span></code></a></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">'interval'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Interval'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Interval[&lt;numpy_dtype&gt;]'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Interval[datetime64[ns,</span> <span class="pre">&lt;tz&gt;]]'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Interval[timedelta64[&lt;freq&gt;]]'</span></code></p></td> </tr> <tr class="row-odd">
<td><p><a class="reference internal" href="integer_na#integer-na"><span class="std std-ref">nullable integer</span></a></p></td> <td colspan="2"><p><a class="reference internal" href="../reference/api/pandas.int64dtype#pandas.Int64Dtype" title="pandas.Int64Dtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">Int64Dtype</span></code></a>, …</p></td> <td colspan="2"><p>(none)</p></td> <td><p><a class="reference internal" href="../reference/api/pandas.arrays.integerarray#pandas.arrays.IntegerArray" title="pandas.arrays.IntegerArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">arrays.IntegerArray</span></code></a></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">'Int8'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Int16'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Int32'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Int64'</span></code>, <code class="docutils literal notranslate"><span class="pre">'UInt8'</span></code>, <code class="docutils literal notranslate"><span class="pre">'UInt16'</span></code>, <code class="docutils literal notranslate"><span class="pre">'UInt32'</span></code>, <code class="docutils literal notranslate"><span class="pre">'UInt64'</span></code></p></td> </tr> <tr class="row-even">
<td><p><a class="reference internal" href="text#text"><span class="std std-ref">Strings</span></a></p></td> <td colspan="2"><p><a class="reference internal" href="../reference/api/pandas.stringdtype#pandas.StringDtype" title="pandas.StringDtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">StringDtype</span></code></a></p></td> <td colspan="2"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a></p></td> <td><p><a class="reference internal" href="../reference/api/pandas.arrays.stringarray#pandas.arrays.StringArray" title="pandas.arrays.StringArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">arrays.StringArray</span></code></a></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">'string'</span></code></p></td> </tr> <tr class="row-odd">
<td><p><a class="reference internal" href="../reference/arrays#api-arrays-bool"><span class="std std-ref">Boolean (with NA)</span></a></p></td> <td colspan="2"><p><a class="reference internal" href="../reference/api/pandas.booleandtype#pandas.BooleanDtype" title="pandas.BooleanDtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">BooleanDtype</span></code></a></p></td> <td colspan="2"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a></p></td> <td><p><a class="reference internal" href="../reference/api/pandas.arrays.booleanarray#pandas.arrays.BooleanArray" title="pandas.arrays.BooleanArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">arrays.BooleanArray</span></code></a></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">'boolean'</span></code></p></td> </tr> </tbody> </table> <p>pandas has two ways to store strings.</p> <ol class="arabic simple"> <li><p><code class="docutils literal notranslate"><span class="pre">object</span></code> dtype, which can hold any Python object, including strings.</p></li> <li><p><a class="reference internal" href="../reference/api/pandas.stringdtype#pandas.StringDtype" title="pandas.StringDtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">StringDtype</span></code></a>, which is dedicated to strings.</p></li> </ol> <p>Generally, we recommend using <a class="reference internal" href="../reference/api/pandas.stringdtype#pandas.StringDtype" title="pandas.StringDtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">StringDtype</span></code></a>. See <a class="reference internal" href="text#text-types"><span class="std std-ref">Text data types</span></a> for more.</p> <p>Finally, arbitrary objects may be stored using the <code class="docutils literal notranslate"><span class="pre">object</span></code> dtype, but should be avoided to the extent possible (for performance and interoperability with other libraries and methods. See <a class="reference internal" href="#basics-object-conversion"><span class="std std-ref">object conversion</span></a>).</p> <p>A convenient <a class="reference internal" href="../reference/api/pandas.dataframe.dtypes#pandas.DataFrame.dtypes" title="pandas.DataFrame.dtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dtypes</span></code></a> attribute for DataFrame returns a Series with the data type of each column.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [347]: dft = pd.DataFrame(
   .....:     {
   .....:         "A": np.random.rand(3),
   .....:         "B": 1,
   .....:         "C": "foo",
   .....:         "D": pd.Timestamp("20010102"),
   .....:         "E": pd.Series([1.0] * 3).astype("float32"),
   .....:         "F": False,
   .....:         "G": pd.Series([1] * 3, dtype="int8"),
   .....:     }
   .....: )
   .....: 

In [348]: dft
Out[348]: 
          A  B    C          D    E      F  G
0  0.035962  1  foo 2001-01-02  1.0  False  1
1  0.701379  1  foo 2001-01-02  1.0  False  1
2  0.281885  1  foo 2001-01-02  1.0  False  1

In [349]: dft.dtypes
Out[349]: 
A           float64
B             int64
C            object
D    datetime64[ns]
E           float32
F              bool
G              int8
dtype: object
</pre></div> </div> <p>On a <code class="docutils literal notranslate"><span class="pre">Series</span></code> object, use the <a class="reference internal" href="../reference/api/pandas.series.dtype#pandas.Series.dtype" title="pandas.Series.dtype"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dtype</span></code></a> attribute.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [350]: dft["A"].dtype
Out[350]: dtype('float64')
</pre></div> </div> <p>If a pandas object contains data with multiple dtypes <em>in a single column</em>, the dtype of the column will be chosen to accommodate all of the data types (<code class="docutils literal notranslate"><span class="pre">object</span></code> is the most general).</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># these ints are coerced to floats
In [351]: pd.Series([1, 2, 3, 4, 5, 6.0])
Out[351]: 
0    1.0
1    2.0
2    3.0
3    4.0
4    5.0
5    6.0
dtype: float64

# string data forces an ``object`` dtype
In [352]: pd.Series([1, 2, 3, 6.0, "foo"])
Out[352]: 
0      1
1      2
2      3
3    6.0
4    foo
dtype: object
</pre></div> </div> <p>The number of columns of each type in a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> can be found by calling <code class="docutils literal notranslate"><span class="pre">DataFrame.dtypes.value_counts()</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [353]: dft.dtypes.value_counts()
Out[353]: 
float64           1
int64             1
object            1
datetime64[ns]    1
float32           1
bool              1
int8              1
dtype: int64
</pre></div> </div> <p>Numeric dtypes will propagate and can coexist in DataFrames. If a dtype is passed (either directly via the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> keyword, a passed <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>, or a passed <code class="docutils literal notranslate"><span class="pre">Series</span></code>), then it will be preserved in DataFrame operations. Furthermore, different numeric dtypes will <strong>NOT</strong> be combined. The following example will give you a taste.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [354]: df1 = pd.DataFrame(np.random.randn(8, 1), columns=["A"], dtype="float32")

In [355]: df1
Out[355]: 
          A
0  0.224364
1  1.890546
2  0.182879
3  0.787847
4 -0.188449
5  0.667715
6 -0.011736
7 -0.399073

In [356]: df1.dtypes
Out[356]: 
A    float32
dtype: object

In [357]: df2 = pd.DataFrame(
   .....:     {
   .....:         "A": pd.Series(np.random.randn(8), dtype="float16"),
   .....:         "B": pd.Series(np.random.randn(8)),
   .....:         "C": pd.Series(np.array(np.random.randn(8), dtype="uint8")),
   .....:     }
   .....: )
   .....: 

In [358]: df2
Out[358]: 
          A         B    C
0  0.823242  0.256090    0
1  1.607422  1.426469    0
2 -0.333740 -0.416203  255
3 -0.063477  1.139976    0
4 -1.014648 -1.193477    0
5  0.678711  0.096706    0
6 -0.040863 -1.956850    1
7 -0.357422 -0.714337    0

In [359]: df2.dtypes
Out[359]: 
A    float16
B    float64
C      uint8
dtype: object
</pre></div> </div> <section id="defaults"> <h3>defaults</h3> <p>By default integer types are <code class="docutils literal notranslate"><span class="pre">int64</span></code> and float types are <code class="docutils literal notranslate"><span class="pre">float64</span></code>, <em>regardless</em> of platform (32-bit or 64-bit). The following will all result in <code class="docutils literal notranslate"><span class="pre">int64</span></code> dtypes.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [360]: pd.DataFrame([1, 2], columns=["a"]).dtypes
Out[360]: 
a    int64
dtype: object

In [361]: pd.DataFrame({"a": [1, 2]}).dtypes
Out[361]: 
a    int64
dtype: object

In [362]: pd.DataFrame({"a": 1}, index=list(range(2))).dtypes
Out[362]: 
a    int64
dtype: object
</pre></div> </div> <p>Note that Numpy will choose <em>platform-dependent</em> types when creating arrays. The following <strong>WILL</strong> result in <code class="docutils literal notranslate"><span class="pre">int32</span></code> on 32-bit platform.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [363]: frame = pd.DataFrame(np.array([1, 2]))
</pre></div> </div> </section> <section id="upcasting"> <h3>upcasting</h3> <p>Types can potentially be <em>upcasted</em> when combined with other types, meaning they are promoted from the current type (e.g. <code class="docutils literal notranslate"><span class="pre">int</span></code> to <code class="docutils literal notranslate"><span class="pre">float</span></code>).</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [364]: df3 = df1.reindex_like(df2).fillna(value=0.0) + df2

In [365]: df3
Out[365]: 
          A         B      C
0  1.047606  0.256090    0.0
1  3.497968  1.426469    0.0
2 -0.150862 -0.416203  255.0
3  0.724370  1.139976    0.0
4 -1.203098 -1.193477    0.0
5  1.346426  0.096706    0.0
6 -0.052599 -1.956850    1.0
7 -0.756495 -0.714337    0.0

In [366]: df3.dtypes
Out[366]: 
A    float32
B    float64
C    float64
dtype: object
</pre></div> </div> <p><a class="reference internal" href="../reference/api/pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy" title="pandas.DataFrame.to_numpy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.to_numpy()</span></code></a> will return the <em>lower-common-denominator</em> of the dtypes, meaning the dtype that can accommodate <strong>ALL</strong> of the types in the resulting homogeneous dtyped NumPy array. This can force some <em>upcasting</em>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [367]: df3.to_numpy().dtype
Out[367]: dtype('float64')
</pre></div> </div> </section> <section id="astype"> <h3>astype</h3> <p id="basics-cast">You can use the <a class="reference internal" href="../reference/api/pandas.dataframe.astype#pandas.DataFrame.astype" title="pandas.DataFrame.astype"><code class="xref py py-meth docutils literal notranslate"><span class="pre">astype()</span></code></a> method to explicitly convert dtypes from one to another. These will by default return a copy, even if the dtype was unchanged (pass <code class="docutils literal notranslate"><span class="pre">copy=False</span></code> to change this behavior). In addition, they will raise an exception if the astype operation is invalid.</p> <p>Upcasting is always according to the <strong>NumPy</strong> rules. If two different dtypes are involved in an operation, then the more <em>general</em> one will be used as the result of the operation.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [368]: df3
Out[368]: 
          A         B      C
0  1.047606  0.256090    0.0
1  3.497968  1.426469    0.0
2 -0.150862 -0.416203  255.0
3  0.724370  1.139976    0.0
4 -1.203098 -1.193477    0.0
5  1.346426  0.096706    0.0
6 -0.052599 -1.956850    1.0
7 -0.756495 -0.714337    0.0

In [369]: df3.dtypes
Out[369]: 
A    float32
B    float64
C    float64
dtype: object

# conversion of dtypes
In [370]: df3.astype("float32").dtypes
Out[370]: 
A    float32
B    float32
C    float32
dtype: object
</pre></div> </div> <p>Convert a subset of columns to a specified type using <a class="reference internal" href="../reference/api/pandas.dataframe.astype#pandas.DataFrame.astype" title="pandas.DataFrame.astype"><code class="xref py py-meth docutils literal notranslate"><span class="pre">astype()</span></code></a>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [371]: dft = pd.DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [7, 8, 9]})

In [372]: dft[["a", "b"]] = dft[["a", "b"]].astype(np.uint8)

In [373]: dft
Out[373]: 
   a  b  c
0  1  4  7
1  2  5  8
2  3  6  9

In [374]: dft.dtypes
Out[374]: 
a    uint8
b    uint8
c    int64
dtype: object
</pre></div> </div> <p>Convert certain columns to a specific dtype by passing a dict to <a class="reference internal" href="../reference/api/pandas.dataframe.astype#pandas.DataFrame.astype" title="pandas.DataFrame.astype"><code class="xref py py-meth docutils literal notranslate"><span class="pre">astype()</span></code></a>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [375]: dft1 = pd.DataFrame({"a": [1, 0, 1], "b": [4, 5, 6], "c": [7, 8, 9]})

In [376]: dft1 = dft1.astype({"a": np.bool_, "c": np.float64})

In [377]: dft1
Out[377]: 
       a  b    c
0   True  4  7.0
1  False  5  8.0
2   True  6  9.0

In [378]: dft1.dtypes
Out[378]: 
a       bool
b      int64
c    float64
dtype: object
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>When trying to convert a subset of columns to a specified type using <a class="reference internal" href="../reference/api/pandas.dataframe.astype#pandas.DataFrame.astype" title="pandas.DataFrame.astype"><code class="xref py py-meth docutils literal notranslate"><span class="pre">astype()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.loc#pandas.DataFrame.loc" title="pandas.DataFrame.loc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loc()</span></code></a>, upcasting occurs.</p> <p><a class="reference internal" href="../reference/api/pandas.dataframe.loc#pandas.DataFrame.loc" title="pandas.DataFrame.loc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loc()</span></code></a> tries to fit in what we are assigning to the current dtypes, while <code class="docutils literal notranslate"><span class="pre">[]</span></code> will overwrite them taking the dtype from the right hand side. Therefore the following piece of code produces the unintended result.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [379]: dft = pd.DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [7, 8, 9]})

In [380]: dft.loc[:, ["a", "b"]].astype(np.uint8).dtypes
Out[380]: 
a    uint8
b    uint8
dtype: object

In [381]: dft.loc[:, ["a", "b"]] = dft.loc[:, ["a", "b"]].astype(np.uint8)

In [382]: dft.dtypes
Out[382]: 
a    int64
b    int64
c    int64
dtype: object
</pre></div> </div> </div> </section> <section id="object-conversion"> <h3>object conversion</h3> <p>pandas offers various functions to try to force conversion of types from the <code class="docutils literal notranslate"><span class="pre">object</span></code> dtype to other types. In cases where the data is already of the correct type, but stored in an <code class="docutils literal notranslate"><span class="pre">object</span></code> array, the <a class="reference internal" href="../reference/api/pandas.dataframe.infer_objects#pandas.DataFrame.infer_objects" title="pandas.DataFrame.infer_objects"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.infer_objects()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.series.infer_objects#pandas.Series.infer_objects" title="pandas.Series.infer_objects"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Series.infer_objects()</span></code></a> methods can be used to soft convert to the correct type.</p> <blockquote> <div>
<div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [383]: import datetime

In [384]: df = pd.DataFrame(
   .....:     [
   .....:         [1, 2],
   .....:         ["a", "b"],
   .....:         [datetime.datetime(2016, 3, 2), datetime.datetime(2016, 3, 2)],
   .....:     ]
   .....: )
   .....: 

In [385]: df = df.T

In [386]: df
Out[386]: 
   0  1          2
0  1  a 2016-03-02
1  2  b 2016-03-02

In [387]: df.dtypes
Out[387]: 
0            object
1            object
2    datetime64[ns]
dtype: object
</pre></div> </div> </div>
</blockquote> <p>Because the data was transposed the original inference stored all columns as object, which <code class="docutils literal notranslate"><span class="pre">infer_objects</span></code> will correct.</p> <blockquote> <div>
<div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [388]: df.infer_objects().dtypes
Out[388]: 
0             int64
1            object
2    datetime64[ns]
dtype: object
</pre></div> </div> </div>
</blockquote> <p>The following functions are available for one dimensional object arrays or scalars to perform hard conversion of objects to a specified type:</p> <ul> <li>
<p><a class="reference internal" href="../reference/api/pandas.to_numeric#pandas.to_numeric" title="pandas.to_numeric"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_numeric()</span></code></a> (conversion to numeric dtypes)</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [389]: m = ["1.1", 2, 3]

In [390]: pd.to_numeric(m)
Out[390]: array([1.1, 2. , 3. ])
</pre></div> </div> </li> <li>
<p><a class="reference internal" href="../reference/api/pandas.to_datetime#pandas.to_datetime" title="pandas.to_datetime"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_datetime()</span></code></a> (conversion to datetime objects)</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [391]: import datetime

In [392]: m = ["2016-07-09", datetime.datetime(2016, 3, 2)]

In [393]: pd.to_datetime(m)
Out[393]: DatetimeIndex(['2016-07-09', '2016-03-02'], dtype='datetime64[ns]', freq=None)
</pre></div> </div> </li> <li>
<p><a class="reference internal" href="../reference/api/pandas.to_timedelta#pandas.to_timedelta" title="pandas.to_timedelta"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_timedelta()</span></code></a> (conversion to timedelta objects)</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [394]: m = ["5us", pd.Timedelta("1day")]

In [395]: pd.to_timedelta(m)
Out[395]: TimedeltaIndex(['0 days 00:00:00.000005', '1 days 00:00:00'], dtype='timedelta64[ns]', freq=None)
</pre></div> </div> </li> </ul> <p>To force a conversion, we can pass in an <code class="docutils literal notranslate"><span class="pre">errors</span></code> argument, which specifies how pandas should deal with elements that cannot be converted to desired dtype or object. By default, <code class="docutils literal notranslate"><span class="pre">errors='raise'</span></code>, meaning that any errors encountered will be raised during the conversion process. However, if <code class="docutils literal notranslate"><span class="pre">errors='coerce'</span></code>, these errors will be ignored and pandas will convert problematic elements to <code class="docutils literal notranslate"><span class="pre">pd.NaT</span></code> (for datetime and timedelta) or <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> (for numeric). This might be useful if you are reading in data which is mostly of the desired dtype (e.g. numeric, datetime), but occasionally has non-conforming elements intermixed that you want to represent as missing:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [396]: import datetime

In [397]: m = ["apple", datetime.datetime(2016, 3, 2)]

In [398]: pd.to_datetime(m, errors="coerce")
Out[398]: DatetimeIndex(['NaT', '2016-03-02'], dtype='datetime64[ns]', freq=None)

In [399]: m = ["apple", 2, 3]

In [400]: pd.to_numeric(m, errors="coerce")
Out[400]: array([nan,  2.,  3.])

In [401]: m = ["apple", pd.Timedelta("1day")]

In [402]: pd.to_timedelta(m, errors="coerce")
Out[402]: TimedeltaIndex([NaT, '1 days'], dtype='timedelta64[ns]', freq=None)
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">errors</span></code> parameter has a third option of <code class="docutils literal notranslate"><span class="pre">errors='ignore'</span></code>, which will simply return the passed in data if it encounters any errors with the conversion to a desired data type:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [403]: import datetime

In [404]: m = ["apple", datetime.datetime(2016, 3, 2)]

In [405]: pd.to_datetime(m, errors="ignore")
Out[405]: Index(['apple', 2016-03-02 00:00:00], dtype='object')

In [406]: m = ["apple", 2, 3]

In [407]: pd.to_numeric(m, errors="ignore")
Out[407]: array(['apple', 2, 3], dtype=object)

In [408]: m = ["apple", pd.Timedelta("1day")]

In [409]: pd.to_timedelta(m, errors="ignore")
Out[409]: array(['apple', Timedelta('1 days 00:00:00')], dtype=object)
</pre></div> </div> <p>In addition to object conversion, <a class="reference internal" href="../reference/api/pandas.to_numeric#pandas.to_numeric" title="pandas.to_numeric"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_numeric()</span></code></a> provides another argument <code class="docutils literal notranslate"><span class="pre">downcast</span></code>, which gives the option of downcasting the newly (or already) numeric data to a smaller dtype, which can conserve memory:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [410]: m = ["1", 2, 3]

In [411]: pd.to_numeric(m, downcast="integer")  # smallest signed int dtype
Out[411]: array([1, 2, 3], dtype=int8)

In [412]: pd.to_numeric(m, downcast="signed")  # same as 'integer'
Out[412]: array([1, 2, 3], dtype=int8)

In [413]: pd.to_numeric(m, downcast="unsigned")  # smallest unsigned int dtype
Out[413]: array([1, 2, 3], dtype=uint8)

In [414]: pd.to_numeric(m, downcast="float")  # smallest float dtype
Out[414]: array([1., 2., 3.], dtype=float32)
</pre></div> </div> <p>As these methods apply only to one-dimensional arrays, lists or scalars; they cannot be used directly on multi-dimensional objects such as DataFrames. However, with <a class="reference internal" href="../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply" title="pandas.DataFrame.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code></a>, we can “apply” the function over each column efficiently:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [415]: import datetime

In [416]: df = pd.DataFrame([["2016-07-09", datetime.datetime(2016, 3, 2)]] * 2, dtype="O")

In [417]: df
Out[417]: 
            0                    1
0  2016-07-09  2016-03-02 00:00:00
1  2016-07-09  2016-03-02 00:00:00

In [418]: df.apply(pd.to_datetime)
Out[418]: 
           0          1
0 2016-07-09 2016-03-02
1 2016-07-09 2016-03-02

In [419]: df = pd.DataFrame([["1.1", 2, 3]] * 2, dtype="O")

In [420]: df
Out[420]: 
     0  1  2
0  1.1  2  3
1  1.1  2  3

In [421]: df.apply(pd.to_numeric)
Out[421]: 
     0  1  2
0  1.1  2  3
1  1.1  2  3

In [422]: df = pd.DataFrame([["5us", pd.Timedelta("1day")]] * 2, dtype="O")

In [423]: df
Out[423]: 
     0                1
0  5us  1 days 00:00:00
1  5us  1 days 00:00:00

In [424]: df.apply(pd.to_timedelta)
Out[424]: 
                       0      1
0 0 days 00:00:00.000005 1 days
1 0 days 00:00:00.000005 1 days
</pre></div> </div> </section> <section id="gotchas"> <h3>gotchas</h3> <p>Performing selection operations on <code class="docutils literal notranslate"><span class="pre">integer</span></code> type data can easily upcast the data to <code class="docutils literal notranslate"><span class="pre">floating</span></code>. The dtype of the input data will be preserved in cases where <code class="docutils literal notranslate"><span class="pre">nans</span></code> are not introduced. See also <a class="reference internal" href="gotchas#gotchas-intna"><span class="std std-ref">Support for integer NA</span></a>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [425]: dfi = df3.astype("int32")

In [426]: dfi["E"] = 1

In [427]: dfi
Out[427]: 
   A  B    C  E
0  1  0    0  1
1  3  1    0  1
2  0  0  255  1
3  0  1    0  1
4 -1 -1    0  1
5  1  0    0  1
6  0 -1    1  1
7  0  0    0  1

In [428]: dfi.dtypes
Out[428]: 
A    int32
B    int32
C    int32
E    int64
dtype: object

In [429]: casted = dfi[dfi &gt; 0]

In [430]: casted
Out[430]: 
     A    B      C  E
0  1.0  NaN    NaN  1
1  3.0  1.0    NaN  1
2  NaN  NaN  255.0  1
3  NaN  1.0    NaN  1
4  NaN  NaN    NaN  1
5  1.0  NaN    NaN  1
6  NaN  NaN    1.0  1
7  NaN  NaN    NaN  1

In [431]: casted.dtypes
Out[431]: 
A    float64
B    float64
C    float64
E      int64
dtype: object
</pre></div> </div> <p>While float dtypes are unchanged.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [432]: dfa = df3.copy()

In [433]: dfa["A"] = dfa["A"].astype("float32")

In [434]: dfa.dtypes
Out[434]: 
A    float32
B    float64
C    float64
dtype: object

In [435]: casted = dfa[df2 &gt; 0]

In [436]: casted
Out[436]: 
          A         B      C
0  1.047606  0.256090    NaN
1  3.497968  1.426469    NaN
2       NaN       NaN  255.0
3       NaN  1.139976    NaN
4       NaN       NaN    NaN
5  1.346426  0.096706    NaN
6       NaN       NaN    1.0
7       NaN       NaN    NaN

In [437]: casted.dtypes
Out[437]: 
A    float32
B    float64
C    float64
dtype: object
</pre></div> </div> </section> </section> <section id="selecting-columns-based-on-dtype"> <h2>Selecting columns based on <code class="docutils literal notranslate"><span class="pre">dtype</span></code>
</h2> <p id="basics-selectdtypes">The <a class="reference internal" href="../reference/api/pandas.dataframe.select_dtypes#pandas.DataFrame.select_dtypes" title="pandas.DataFrame.select_dtypes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_dtypes()</span></code></a> method implements subsetting of columns based on their <code class="docutils literal notranslate"><span class="pre">dtype</span></code>.</p> <p>First, let’s create a <a class="reference internal" href="../reference/api/pandas.dataframe#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> with a slew of different dtypes:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [438]: df = pd.DataFrame(
   .....:     {
   .....:         "string": list("abc"),
   .....:         "int64": list(range(1, 4)),
   .....:         "uint8": np.arange(3, 6).astype("u1"),
   .....:         "float64": np.arange(4.0, 7.0),
   .....:         "bool1": [True, False, True],
   .....:         "bool2": [False, True, False],
   .....:         "dates": pd.date_range("now", periods=3),
   .....:         "category": pd.Series(list("ABC")).astype("category"),
   .....:     }
   .....: )
   .....: 

In [439]: df["tdeltas"] = df.dates.diff()

In [440]: df["uint64"] = np.arange(3, 6).astype("u8")

In [441]: df["other_dates"] = pd.date_range("20130101", periods=3)

In [442]: df["tz_aware_dates"] = pd.date_range("20130101", periods=3, tz="US/Eastern")

In [443]: df
Out[443]: 
  string  int64  uint8  float64  bool1  bool2                      dates category tdeltas  uint64 other_dates            tz_aware_dates
0      a      1      3      4.0   True  False 2022-01-22 10:50:03.741897        A     NaT       3  2013-01-01 2013-01-01 00:00:00-05:00
1      b      2      4      5.0  False   True 2022-01-23 10:50:03.741897        B  1 days       4  2013-01-02 2013-01-02 00:00:00-05:00
2      c      3      5      6.0   True  False 2022-01-24 10:50:03.741897        C  1 days       5  2013-01-03 2013-01-03 00:00:00-05:00
</pre></div> </div> <p>And the dtypes:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [444]: df.dtypes
Out[444]: 
string                                object
int64                                  int64
uint8                                  uint8
float64                              float64
bool1                                   bool
bool2                                   bool
dates                         datetime64[ns]
category                            category
tdeltas                      timedelta64[ns]
uint64                                uint64
other_dates                   datetime64[ns]
tz_aware_dates    datetime64[ns, US/Eastern]
dtype: object
</pre></div> </div> <p><a class="reference internal" href="../reference/api/pandas.dataframe.select_dtypes#pandas.DataFrame.select_dtypes" title="pandas.DataFrame.select_dtypes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_dtypes()</span></code></a> has two parameters <code class="docutils literal notranslate"><span class="pre">include</span></code> and <code class="docutils literal notranslate"><span class="pre">exclude</span></code> that allow you to say “give me the columns <em>with</em> these dtypes” (<code class="docutils literal notranslate"><span class="pre">include</span></code>) and/or “give the columns <em>without</em> these dtypes” (<code class="docutils literal notranslate"><span class="pre">exclude</span></code>).</p> <p>For example, to select <code class="docutils literal notranslate"><span class="pre">bool</span></code> columns:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [445]: df.select_dtypes(include=[bool])
Out[445]: 
   bool1  bool2
0   True  False
1  False   True
2   True  False
</pre></div> </div> <p>You can also pass the name of a dtype in the <a class="reference external" href="https://numpy.org/doc/stable/reference/arrays.scalars.html">NumPy dtype hierarchy</a>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [446]: df.select_dtypes(include=["bool"])
Out[446]: 
   bool1  bool2
0   True  False
1  False   True
2   True  False
</pre></div> </div> <p><a class="reference internal" href="../reference/api/pandas.dataframe.select_dtypes#pandas.DataFrame.select_dtypes" title="pandas.DataFrame.select_dtypes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_dtypes()</span></code></a> also works with generic dtypes as well.</p> <p>For example, to select all numeric and boolean columns while excluding unsigned integers:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [447]: df.select_dtypes(include=["number", "bool"], exclude=["unsignedinteger"])
Out[447]: 
   int64  float64  bool1  bool2 tdeltas
0      1      4.0   True  False     NaT
1      2      5.0  False   True  1 days
2      3      6.0   True  False  1 days
</pre></div> </div> <p>To select string columns you must use the <code class="docutils literal notranslate"><span class="pre">object</span></code> dtype:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [448]: df.select_dtypes(include=["object"])
Out[448]: 
  string
0      a
1      b
2      c
</pre></div> </div> <p>To see all the child dtypes of a generic <code class="docutils literal notranslate"><span class="pre">dtype</span></code> like <code class="docutils literal notranslate"><span class="pre">numpy.number</span></code> you can define a function that returns a tree of child dtypes:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [449]: def subdtypes(dtype):
   .....:     subs = dtype.__subclasses__()
   .....:     if not subs:
   .....:         return dtype
   .....:     return [dtype, [subdtypes(dt) for dt in subs]]
   .....: 
</pre></div> </div> <p>All NumPy dtypes are subclasses of <code class="docutils literal notranslate"><span class="pre">numpy.generic</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [450]: subdtypes(np.generic)
Out[450]: 
[numpy.generic,
 [[numpy.number,
   [[numpy.integer,
     [[numpy.signedinteger,
       [numpy.int8,
        numpy.int16,
        numpy.int32,
        numpy.int64,
        numpy.longlong,
        numpy.timedelta64]],
      [numpy.unsignedinteger,
       [numpy.uint8,
        numpy.uint16,
        numpy.uint32,
        numpy.uint64,
        numpy.ulonglong]]]],
    [numpy.inexact,
     [[numpy.floating,
       [numpy.float16, numpy.float32, numpy.float64, numpy.float128]],
      [numpy.complexfloating,
       [numpy.complex64, numpy.complex128, numpy.complex256]]]]]],
  [numpy.flexible,
   [[numpy.character, [numpy.bytes_, numpy.str_]],
    [numpy.void, [numpy.record]]]],
  numpy.bool_,
  numpy.datetime64,
  numpy.object_]]
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>pandas also defines the types <code class="docutils literal notranslate"><span class="pre">category</span></code>, and <code class="docutils literal notranslate"><span class="pre">datetime64[ns,</span> <span class="pre">tz]</span></code>, which are not integrated into the normal NumPy hierarchy and won’t show up with the above function.</p> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2008&ndash;2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://pandas.pydata.org/pandas-docs/version/1.4.0/user_guide/basics.html" class="_attribution-link">https://pandas.pydata.org/pandas-docs/version/1.4.0/user_guide/basics.html</a>
  </p>
</div>
