<h1>Working with missing data</h1> <p>In this section, we will discuss missing (also referred to as NA) values in pandas.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The choice of using <code class="docutils literal notranslate"><span class="pre">NaN</span></code> internally to denote missing data was largely for simplicity and performance reasons. Starting from pandas 1.0, some optional data types start experimenting with a native <code class="docutils literal notranslate"><span class="pre">NA</span></code> scalar using a mask-based approach. See <a class="reference internal" href="#missing-data-na"><span class="std std-ref">here</span></a> for more.</p> </div> <p>See the <a class="reference internal" href="cookbook#cookbook-missing-data"><span class="std std-ref">cookbook</span></a> for some advanced strategies.</p> <section id="values-considered-missing"> <h2>Values considered “missing”</h2> <p>As data comes in many shapes and forms, pandas aims to be flexible with regard to handling missing data. While <code class="docutils literal notranslate"><span class="pre">NaN</span></code> is the default missing value marker for reasons of computational speed and convenience, we need to be able to easily detect this value with data of different types: floating point, integer, boolean, and general object. In many cases, however, the Python <code class="docutils literal notranslate"><span class="pre">None</span></code> will arise and we wish to also consider that “missing” or “not available” or “NA”.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you want to consider <code class="docutils literal notranslate"><span class="pre">inf</span></code> and <code class="docutils literal notranslate"><span class="pre">-inf</span></code> to be “NA” in computations, you can set <code class="docutils literal notranslate"><span class="pre">pandas.options.mode.use_inf_as_na</span> <span class="pre">=</span> <span class="pre">True</span></code>.</p> </div> <div class="highlight-ipython notranslate" id="missing-isna">
<div class="highlight"><pre data-language="python">In [1]: df = pd.DataFrame(
   ...:     np.random.randn(5, 3),
   ...:     index=["a", "c", "e", "f", "h"],
   ...:     columns=["one", "two", "three"],
   ...: )
   ...: 

In [2]: df["four"] = "bar"

In [3]: df["five"] = df["one"] &gt; 0

In [4]: df
Out[4]: 
        one       two     three four   five
a  0.469112 -0.282863 -1.509059  bar   True
c -1.135632  1.212112 -0.173215  bar  False
e  0.119209 -1.044236 -0.861849  bar   True
f -2.104569 -0.494929  1.071804  bar  False
h  0.721555 -0.706771 -1.039575  bar   True

In [5]: df2 = df.reindex(["a", "b", "c", "d", "e", "f", "g", "h"])

In [6]: df2
Out[6]: 
        one       two     three four   five
a  0.469112 -0.282863 -1.509059  bar   True
b       NaN       NaN       NaN  NaN    NaN
c -1.135632  1.212112 -0.173215  bar  False
d       NaN       NaN       NaN  NaN    NaN
e  0.119209 -1.044236 -0.861849  bar   True
f -2.104569 -0.494929  1.071804  bar  False
g       NaN       NaN       NaN  NaN    NaN
h  0.721555 -0.706771 -1.039575  bar   True
</pre></div> </div> <p>To make detecting missing values easier (and across different array dtypes), pandas provides the <a class="reference internal" href="../reference/api/pandas.isna#pandas.isna" title="pandas.isna"><code class="xref py py-func docutils literal notranslate"><span class="pre">isna()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.notna#pandas.notna" title="pandas.notna"><code class="xref py py-func docutils literal notranslate"><span class="pre">notna()</span></code></a> functions, which are also methods on Series and DataFrame objects:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [7]: df2["one"]
Out[7]: 
a    0.469112
b         NaN
c   -1.135632
d         NaN
e    0.119209
f   -2.104569
g         NaN
h    0.721555
Name: one, dtype: float64

In [8]: pd.isna(df2["one"])
Out[8]: 
a    False
b     True
c    False
d     True
e    False
f    False
g     True
h    False
Name: one, dtype: bool

In [9]: df2["four"].notna()
Out[9]: 
a     True
b    False
c     True
d    False
e     True
f     True
g    False
h     True
Name: four, dtype: bool

In [10]: df2.isna()
Out[10]: 
     one    two  three   four   five
a  False  False  False  False  False
b   True   True   True   True   True
c  False  False  False  False  False
d   True   True   True   True   True
e  False  False  False  False  False
f  False  False  False  False  False
g   True   True   True   True   True
h  False  False  False  False  False
</pre></div> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>One has to be mindful that in Python (and NumPy), the <code class="docutils literal notranslate"><span class="pre">nan's</span></code> don’t compare equal, but <code class="docutils literal notranslate"><span class="pre">None's</span></code> <strong>do</strong>. Note that pandas/NumPy uses the fact that <code class="docutils literal notranslate"><span class="pre">np.nan</span> <span class="pre">!=</span> <span class="pre">np.nan</span></code>, and treats <code class="docutils literal notranslate"><span class="pre">None</span></code> like <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [11]: None == None  # noqa: E711
Out[11]: True

In [12]: np.nan == np.nan
Out[12]: False
</pre></div> </div> <p>So as compared to above, a scalar equality comparison versus a <code class="docutils literal notranslate"><span class="pre">None/np.nan</span></code> doesn’t provide useful information.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [13]: df2["one"] == np.nan
Out[13]: 
a    False
b    False
c    False
d    False
e    False
f    False
g    False
h    False
Name: one, dtype: bool
</pre></div> </div> </div> <section id="integer-dtypes-and-missing-data"> <h3>Integer dtypes and missing data</h3> <p>Because <code class="docutils literal notranslate"><span class="pre">NaN</span></code> is a float, a column of integers with even one missing values is cast to floating-point dtype (see <a class="reference internal" href="gotchas#gotchas-intna"><span class="std std-ref">Support for integer NA</span></a> for more). pandas provides a nullable integer array, which can be used by explicitly requesting the dtype:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [14]: pd.Series([1, 2, np.nan, 4], dtype=pd.Int64Dtype())
Out[14]: 
0       1
1       2
2    &lt;NA&gt;
3       4
dtype: Int64
</pre></div> </div> <p>Alternatively, the string alias <code class="docutils literal notranslate"><span class="pre">dtype='Int64'</span></code> (note the capital <code class="docutils literal notranslate"><span class="pre">"I"</span></code>) can be used.</p> <p>See <a class="reference internal" href="integer_na#integer-na"><span class="std std-ref">Nullable integer data type</span></a> for more.</p> </section> <section id="datetimes"> <h3>Datetimes</h3> <p>For datetime64[ns] types, <code class="docutils literal notranslate"><span class="pre">NaT</span></code> represents missing values. This is a pseudo-native sentinel value that can be represented by NumPy in a singular dtype (datetime64[ns]). pandas objects provide compatibility between <code class="docutils literal notranslate"><span class="pre">NaT</span></code> and <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [15]: df2 = df.copy()

In [16]: df2["timestamp"] = pd.Timestamp("20120101")

In [17]: df2
Out[17]: 
        one       two     three four   five  timestamp
a  0.469112 -0.282863 -1.509059  bar   True 2012-01-01
c -1.135632  1.212112 -0.173215  bar  False 2012-01-01
e  0.119209 -1.044236 -0.861849  bar   True 2012-01-01
f -2.104569 -0.494929  1.071804  bar  False 2012-01-01
h  0.721555 -0.706771 -1.039575  bar   True 2012-01-01

In [18]: df2.loc[["a", "c", "h"], ["one", "timestamp"]] = np.nan

In [19]: df2
Out[19]: 
        one       two     three four   five  timestamp
a       NaN -0.282863 -1.509059  bar   True        NaT
c       NaN  1.212112 -0.173215  bar  False        NaT
e  0.119209 -1.044236 -0.861849  bar   True 2012-01-01
f -2.104569 -0.494929  1.071804  bar  False 2012-01-01
h       NaN -0.706771 -1.039575  bar   True        NaT

In [20]: df2.dtypes.value_counts()
Out[20]: 
float64           3
object            1
bool              1
datetime64[ns]    1
dtype: int64
</pre></div> </div> </section> </section> <section id="inserting-missing-data"> <h2>Inserting missing data</h2> <p>You can insert missing values by simply assigning to containers. The actual missing value used will be chosen based on the dtype.</p> <p>For example, numeric containers will always use <code class="docutils literal notranslate"><span class="pre">NaN</span></code> regardless of the missing value type chosen:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [21]: s = pd.Series([1, 2, 3])

In [22]: s.loc[0] = None

In [23]: s
Out[23]: 
0    NaN
1    2.0
2    3.0
dtype: float64
</pre></div> </div> <p>Likewise, datetime containers will always use <code class="docutils literal notranslate"><span class="pre">NaT</span></code>.</p> <p>For object containers, pandas will use the value given:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [24]: s = pd.Series(["a", "b", "c"])

In [25]: s.loc[0] = None

In [26]: s.loc[1] = np.nan

In [27]: s
Out[27]: 
0    None
1     NaN
2       c
dtype: object
</pre></div> </div> </section> <section id="calculations-with-missing-data"> <h2>Calculations with missing data</h2> <p>Missing values propagate naturally through arithmetic operations between pandas objects.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [28]: a
Out[28]: 
        one       two
a       NaN -0.282863
c       NaN  1.212112
e  0.119209 -1.044236
f -2.104569 -0.494929
h -2.104569 -0.706771

In [29]: b
Out[29]: 
        one       two     three
a       NaN -0.282863 -1.509059
c       NaN  1.212112 -0.173215
e  0.119209 -1.044236 -0.861849
f -2.104569 -0.494929  1.071804
h       NaN -0.706771 -1.039575

In [30]: a + b
Out[30]: 
        one  three       two
a       NaN    NaN -0.565727
c       NaN    NaN  2.424224
e  0.238417    NaN -2.088472
f -4.209138    NaN -0.989859
h       NaN    NaN -1.413542
</pre></div> </div> <p>The descriptive statistics and computational methods discussed in the <a class="reference internal" href="basics#basics-stats"><span class="std std-ref">data structure overview</span></a> (and listed <a class="reference internal" href="../reference/series#api-series-stats"><span class="std std-ref">here</span></a> and <a class="reference internal" href="../reference/frame#api-dataframe-stats"><span class="std std-ref">here</span></a>) are all written to account for missing data. For example:</p> <ul class="simple"> <li><p>When summing data, NA (missing) values will be treated as zero.</p></li> <li><p>If the data are all NA, the result will be 0.</p></li> <li><p>Cumulative methods like <a class="reference internal" href="../reference/api/pandas.dataframe.cumsum#pandas.DataFrame.cumsum" title="pandas.DataFrame.cumsum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cumsum()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.cumprod#pandas.DataFrame.cumprod" title="pandas.DataFrame.cumprod"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cumprod()</span></code></a> ignore NA values by default, but preserve them in the resulting arrays. To override this behaviour and include NA values, use <code class="docutils literal notranslate"><span class="pre">skipna=False</span></code>.</p></li> </ul> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [31]: df
Out[31]: 
        one       two     three
a       NaN -0.282863 -1.509059
c       NaN  1.212112 -0.173215
e  0.119209 -1.044236 -0.861849
f -2.104569 -0.494929  1.071804
h       NaN -0.706771 -1.039575

In [32]: df["one"].sum()
Out[32]: -1.9853605075978744

In [33]: df.mean(1)
Out[33]: 
a   -0.895961
c    0.519449
e   -0.595625
f   -0.509232
h   -0.873173
dtype: float64

In [34]: df.cumsum()
Out[34]: 
        one       two     three
a       NaN -0.282863 -1.509059
c       NaN  0.929249 -1.682273
e  0.119209 -0.114987 -2.544122
f -1.985361 -0.609917 -1.472318
h       NaN -1.316688 -2.511893

In [35]: df.cumsum(skipna=False)
Out[35]: 
   one       two     three
a  NaN -0.282863 -1.509059
c  NaN  0.929249 -1.682273
e  NaN -0.114987 -2.544122
f  NaN -0.609917 -1.472318
h  NaN -1.316688 -2.511893
</pre></div> </div> </section> <section id="sum-prod-of-empties-nans"> <h2>Sum/prod of empties/nans</h2> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This behavior is now standard as of v0.22.0 and is consistent with the default in <code class="docutils literal notranslate"><span class="pre">numpy</span></code>; previously sum/prod of all-NA or empty Series/DataFrames would return NaN. See <a class="reference internal" href="https://pandas.pydata.org/pandas-docs/version/1.4.0/whatsnew/v0.22.0.html#whatsnew-0220"><span class="std std-ref">v0.22.0 whatsnew</span></a> for more.</p> </div> <p>The sum of an empty or all-NA Series or column of a DataFrame is 0.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [36]: pd.Series([np.nan]).sum()
Out[36]: 0.0

In [37]: pd.Series([], dtype="float64").sum()
Out[37]: 0.0
</pre></div> </div> <p>The product of an empty or all-NA Series or column of a DataFrame is 1.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [38]: pd.Series([np.nan]).prod()
Out[38]: 1.0

In [39]: pd.Series([], dtype="float64").prod()
Out[39]: 1.0
</pre></div> </div> </section> <section id="na-values-in-groupby"> <h2>NA values in GroupBy</h2> <p>NA groups in GroupBy are automatically excluded. This behavior is consistent with R, for example:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [40]: df
Out[40]: 
        one       two     three
a       NaN -0.282863 -1.509059
c       NaN  1.212112 -0.173215
e  0.119209 -1.044236 -0.861849
f -2.104569 -0.494929  1.071804
h       NaN -0.706771 -1.039575

In [41]: df.groupby("one").mean()
Out[41]: 
                two     three
one                          
-2.104569 -0.494929  1.071804
 0.119209 -1.044236 -0.861849
</pre></div> </div> <p>See the groupby section <a class="reference internal" href="groupby#groupby-missing"><span class="std std-ref">here</span></a> for more information.</p> <section id="cleaning-filling-missing-data"> <h3>Cleaning / filling missing data</h3> <p>pandas objects are equipped with various data manipulation methods for dealing with missing data.</p> </section> </section> <section id="filling-missing-values-fillna"> <h2>Filling missing values: fillna</h2> <p><a class="reference internal" href="../reference/api/pandas.dataframe.fillna#pandas.DataFrame.fillna" title="pandas.DataFrame.fillna"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fillna()</span></code></a> can “fill in” NA values with non-NA data in a couple of ways, which we illustrate:</p> <p><strong>Replace NA with a scalar value</strong></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [42]: df2
Out[42]: 
        one       two     three four   five  timestamp
a       NaN -0.282863 -1.509059  bar   True        NaT
c       NaN  1.212112 -0.173215  bar  False        NaT
e  0.119209 -1.044236 -0.861849  bar   True 2012-01-01
f -2.104569 -0.494929  1.071804  bar  False 2012-01-01
h       NaN -0.706771 -1.039575  bar   True        NaT

In [43]: df2.fillna(0)
Out[43]: 
        one       two     three four   five            timestamp
a  0.000000 -0.282863 -1.509059  bar   True                    0
c  0.000000  1.212112 -0.173215  bar  False                    0
e  0.119209 -1.044236 -0.861849  bar   True  2012-01-01 00:00:00
f -2.104569 -0.494929  1.071804  bar  False  2012-01-01 00:00:00
h  0.000000 -0.706771 -1.039575  bar   True                    0

In [44]: df2["one"].fillna("missing")
Out[44]: 
a     missing
c     missing
e    0.119209
f   -2.104569
h     missing
Name: one, dtype: object
</pre></div> </div> <p><strong>Fill gaps forward or backward</strong></p> <p>Using the same filling arguments as <a class="reference internal" href="basics#basics-reindexing"><span class="std std-ref">reindexing</span></a>, we can propagate non-NA values forward or backward:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [45]: df
Out[45]: 
        one       two     three
a       NaN -0.282863 -1.509059
c       NaN  1.212112 -0.173215
e  0.119209 -1.044236 -0.861849
f -2.104569 -0.494929  1.071804
h       NaN -0.706771 -1.039575

In [46]: df.fillna(method="pad")
Out[46]: 
        one       two     three
a       NaN -0.282863 -1.509059
c       NaN  1.212112 -0.173215
e  0.119209 -1.044236 -0.861849
f -2.104569 -0.494929  1.071804
h -2.104569 -0.706771 -1.039575
</pre></div> </div> <p id="missing-data-fillna-limit"><strong>Limit the amount of filling</strong></p> <p>If we only want consecutive gaps filled up to a certain number of data points, we can use the <code class="docutils literal notranslate"><span class="pre">limit</span></code> keyword:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [47]: df
Out[47]: 
   one       two     three
a  NaN -0.282863 -1.509059
c  NaN  1.212112 -0.173215
e  NaN       NaN       NaN
f  NaN       NaN       NaN
h  NaN -0.706771 -1.039575

In [48]: df.fillna(method="pad", limit=1)
Out[48]: 
   one       two     three
a  NaN -0.282863 -1.509059
c  NaN  1.212112 -0.173215
e  NaN  1.212112 -0.173215
f  NaN       NaN       NaN
h  NaN -0.706771 -1.039575
</pre></div> </div> <p>To remind you, these are the available filling methods:</p> <table class="colwidths-given table"> <colgroup> <col style="width: 38%"> <col style="width: 63%"> </colgroup> <thead> <tr class="row-odd">
<th class="head"><p>Method</p></th> <th class="head"><p>Action</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p>pad / ffill</p></td> <td><p>Fill values forward</p></td> </tr> <tr class="row-odd">
<td><p>bfill / backfill</p></td> <td><p>Fill values backward</p></td> </tr> </tbody> </table> <p>With time series data, using pad/ffill is extremely common so that the “last known value” is available at every time point.</p> <p><a class="reference internal" href="../reference/api/pandas.dataframe.ffill#pandas.DataFrame.ffill" title="pandas.DataFrame.ffill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ffill()</span></code></a> is equivalent to <code class="docutils literal notranslate"><span class="pre">fillna(method='ffill')</span></code> and <a class="reference internal" href="../reference/api/pandas.dataframe.bfill#pandas.DataFrame.bfill" title="pandas.DataFrame.bfill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bfill()</span></code></a> is equivalent to <code class="docutils literal notranslate"><span class="pre">fillna(method='bfill')</span></code></p> </section> <section id="filling-with-a-pandasobject"> <h2>Filling with a PandasObject</h2> <p>You can also fillna using a dict or Series that is alignable. The labels of the dict or index of the Series must match the columns of the frame you wish to fill. The use case of this is to fill a DataFrame with the mean of that column.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [49]: dff = pd.DataFrame(np.random.randn(10, 3), columns=list("ABC"))

In [50]: dff.iloc[3:5, 0] = np.nan

In [51]: dff.iloc[4:6, 1] = np.nan

In [52]: dff.iloc[5:8, 2] = np.nan

In [53]: dff
Out[53]: 
          A         B         C
0  0.271860 -0.424972  0.567020
1  0.276232 -1.087401 -0.673690
2  0.113648 -1.478427  0.524988
3       NaN  0.577046 -1.715002
4       NaN       NaN -1.157892
5 -1.344312       NaN       NaN
6 -0.109050  1.643563       NaN
7  0.357021 -0.674600       NaN
8 -0.968914 -1.294524  0.413738
9  0.276662 -0.472035 -0.013960

In [54]: dff.fillna(dff.mean())
Out[54]: 
          A         B         C
0  0.271860 -0.424972  0.567020
1  0.276232 -1.087401 -0.673690
2  0.113648 -1.478427  0.524988
3 -0.140857  0.577046 -1.715002
4 -0.140857 -0.401419 -1.157892
5 -1.344312 -0.401419 -0.293543
6 -0.109050  1.643563 -0.293543
7  0.357021 -0.674600 -0.293543
8 -0.968914 -1.294524  0.413738
9  0.276662 -0.472035 -0.013960

In [55]: dff.fillna(dff.mean()["B":"C"])
Out[55]: 
          A         B         C
0  0.271860 -0.424972  0.567020
1  0.276232 -1.087401 -0.673690
2  0.113648 -1.478427  0.524988
3       NaN  0.577046 -1.715002
4       NaN -0.401419 -1.157892
5 -1.344312 -0.401419 -0.293543
6 -0.109050  1.643563 -0.293543
7  0.357021 -0.674600 -0.293543
8 -0.968914 -1.294524  0.413738
9  0.276662 -0.472035 -0.013960
</pre></div> </div> <p>Same result as above, but is aligning the ‘fill’ value which is a Series in this case.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [56]: dff.where(pd.notna(dff), dff.mean(), axis="columns")
Out[56]: 
          A         B         C
0  0.271860 -0.424972  0.567020
1  0.276232 -1.087401 -0.673690
2  0.113648 -1.478427  0.524988
3 -0.140857  0.577046 -1.715002
4 -0.140857 -0.401419 -1.157892
5 -1.344312 -0.401419 -0.293543
6 -0.109050  1.643563 -0.293543
7  0.357021 -0.674600 -0.293543
8 -0.968914 -1.294524  0.413738
9  0.276662 -0.472035 -0.013960
</pre></div> </div> </section> <section id="dropping-axis-labels-with-missing-data-dropna"> <h2>Dropping axis labels with missing data: dropna</h2> <p>You may wish to simply exclude labels from a data set which refer to missing data. To do this, use <a class="reference internal" href="../reference/api/pandas.dataframe.dropna#pandas.DataFrame.dropna" title="pandas.DataFrame.dropna"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dropna()</span></code></a>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [57]: df
Out[57]: 
   one       two     three
a  NaN -0.282863 -1.509059
c  NaN  1.212112 -0.173215
e  NaN  0.000000  0.000000
f  NaN  0.000000  0.000000
h  NaN -0.706771 -1.039575

In [58]: df.dropna(axis=0)
Out[58]: 
Empty DataFrame
Columns: [one, two, three]
Index: []

In [59]: df.dropna(axis=1)
Out[59]: 
        two     three
a -0.282863 -1.509059
c  1.212112 -0.173215
e  0.000000  0.000000
f  0.000000  0.000000
h -0.706771 -1.039575

In [60]: df["one"].dropna()
Out[60]: Series([], Name: one, dtype: float64)
</pre></div> </div> <p>An equivalent <a class="reference internal" href="../reference/api/pandas.series.dropna#pandas.Series.dropna" title="pandas.Series.dropna"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dropna()</span></code></a> is available for Series. DataFrame.dropna has considerably more options than Series.dropna, which can be examined <a class="reference internal" href="../reference/frame#api-dataframe-missing"><span class="std std-ref">in the API</span></a>.</p> </section> <section id="interpolation"> <h2>Interpolation</h2> <p>Both Series and DataFrame objects have <a class="reference internal" href="../reference/api/pandas.dataframe.interpolate#pandas.DataFrame.interpolate" title="pandas.DataFrame.interpolate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">interpolate()</span></code></a> that, by default, performs linear interpolation at missing data points.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [61]: ts
Out[61]: 
2000-01-31    0.469112
2000-02-29         NaN
2000-03-31         NaN
2000-04-28         NaN
2000-05-31         NaN
                ...   
2007-12-31   -6.950267
2008-01-31   -7.904475
2008-02-29   -6.441779
2008-03-31   -8.184940
2008-04-30   -9.011531
Freq: BM, Length: 100, dtype: float64

In [62]: ts.count()
Out[62]: 66

In [63]: ts.plot()
Out[63]: &lt;AxesSubplot:&gt;
</pre></div> </div> <img alt="../_images/series_before_interpolate.png" src="data:image/png;base64,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"> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [64]: ts.interpolate()
Out[64]: 
2000-01-31    0.469112
2000-02-29    0.434469
2000-03-31    0.399826
2000-04-28    0.365184
2000-05-31    0.330541
                ...   
2007-12-31   -6.950267
2008-01-31   -7.904475
2008-02-29   -6.441779
2008-03-31   -8.184940
2008-04-30   -9.011531
Freq: BM, Length: 100, dtype: float64

In [65]: ts.interpolate().count()
Out[65]: 100

In [66]: ts.interpolate().plot()
Out[66]: &lt;AxesSubplot:&gt;
</pre></div> </div> <img alt="../_images/series_interpolate.png" src="data:image/png;base64,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"> <p>Index aware interpolation is available via the <code class="docutils literal notranslate"><span class="pre">method</span></code> keyword:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [67]: ts2
Out[67]: 
2000-01-31    0.469112
2000-02-29         NaN
2002-07-31   -5.785037
2005-01-31         NaN
2008-04-30   -9.011531
dtype: float64

In [68]: ts2.interpolate()
Out[68]: 
2000-01-31    0.469112
2000-02-29   -2.657962
2002-07-31   -5.785037
2005-01-31   -7.398284
2008-04-30   -9.011531
dtype: float64

In [69]: ts2.interpolate(method="time")
Out[69]: 
2000-01-31    0.469112
2000-02-29    0.270241
2002-07-31   -5.785037
2005-01-31   -7.190866
2008-04-30   -9.011531
dtype: float64
</pre></div> </div> <p>For a floating-point index, use <code class="docutils literal notranslate"><span class="pre">method='values'</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [70]: ser
Out[70]: 
0.0      0.0
1.0      NaN
10.0    10.0
dtype: float64

In [71]: ser.interpolate()
Out[71]: 
0.0      0.0
1.0      5.0
10.0    10.0
dtype: float64

In [72]: ser.interpolate(method="values")
Out[72]: 
0.0      0.0
1.0      1.0
10.0    10.0
dtype: float64
</pre></div> </div> <p>You can also interpolate with a DataFrame:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [73]: df = pd.DataFrame(
   ....:     {
   ....:         "A": [1, 2.1, np.nan, 4.7, 5.6, 6.8],
   ....:         "B": [0.25, np.nan, np.nan, 4, 12.2, 14.4],
   ....:     }
   ....: )
   ....: 

In [74]: df
Out[74]: 
     A      B
0  1.0   0.25
1  2.1    NaN
2  NaN    NaN
3  4.7   4.00
4  5.6  12.20
5  6.8  14.40

In [75]: df.interpolate()
Out[75]: 
     A      B
0  1.0   0.25
1  2.1   1.50
2  3.4   2.75
3  4.7   4.00
4  5.6  12.20
5  6.8  14.40
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">method</span></code> argument gives access to fancier interpolation methods. If you have <a class="reference external" href="https://scipy.org/">scipy</a> installed, you can pass the name of a 1-d interpolation routine to <code class="docutils literal notranslate"><span class="pre">method</span></code>. You’ll want to consult the full scipy interpolation <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/interpolate.html#univariate-interpolation">documentation</a> and reference <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/tutorial/interpolate.html">guide</a> for details. The appropriate interpolation method will depend on the type of data you are working with.</p> <ul class="simple"> <li><p>If you are dealing with a time series that is growing at an increasing rate, <code class="docutils literal notranslate"><span class="pre">method='quadratic'</span></code> may be appropriate.</p></li> <li><p>If you have values approximating a cumulative distribution function, then <code class="docutils literal notranslate"><span class="pre">method='pchip'</span></code> should work well.</p></li> <li><p>To fill missing values with goal of smooth plotting, consider <code class="docutils literal notranslate"><span class="pre">method='akima'</span></code>.</p></li> </ul> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>These methods require <code class="docutils literal notranslate"><span class="pre">scipy</span></code>.</p> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [76]: df.interpolate(method="barycentric")
Out[76]: 
      A       B
0  1.00   0.250
1  2.10  -7.660
2  3.53  -4.515
3  4.70   4.000
4  5.60  12.200
5  6.80  14.400

In [77]: df.interpolate(method="pchip")
Out[77]: 
         A          B
0  1.00000   0.250000
1  2.10000   0.672808
2  3.43454   1.928950
3  4.70000   4.000000
4  5.60000  12.200000
5  6.80000  14.400000

In [78]: df.interpolate(method="akima")
Out[78]: 
          A          B
0  1.000000   0.250000
1  2.100000  -0.873316
2  3.406667   0.320034
3  4.700000   4.000000
4  5.600000  12.200000
5  6.800000  14.400000
</pre></div> </div> <p>When interpolating via a polynomial or spline approximation, you must also specify the degree or order of the approximation:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [79]: df.interpolate(method="spline", order=2)
Out[79]: 
          A          B
0  1.000000   0.250000
1  2.100000  -0.428598
2  3.404545   1.206900
3  4.700000   4.000000
4  5.600000  12.200000
5  6.800000  14.400000

In [80]: df.interpolate(method="polynomial", order=2)
Out[80]: 
          A          B
0  1.000000   0.250000
1  2.100000  -2.703846
2  3.451351  -1.453846
3  4.700000   4.000000
4  5.600000  12.200000
5  6.800000  14.400000
</pre></div> </div> <p>Compare several methods:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [81]: np.random.seed(2)

In [82]: ser = pd.Series(np.arange(1, 10.1, 0.25) ** 2 + np.random.randn(37))

In [83]: missing = np.array([4, 13, 14, 15, 16, 17, 18, 20, 29])

In [84]: ser[missing] = np.nan

In [85]: methods = ["linear", "quadratic", "cubic"]

In [86]: df = pd.DataFrame({m: ser.interpolate(method=m) for m in methods})

In [87]: df.plot()
Out[87]: &lt;AxesSubplot:&gt;
</pre></div> </div> <img alt="../_images/compare_interpolations.png" src="data:image/png;base64,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"> <p>Another use case is interpolation at <em>new</em> values. Suppose you have 100 observations from some distribution. And let’s suppose that you’re particularly interested in what’s happening around the middle. You can mix pandas’ <code class="docutils literal notranslate"><span class="pre">reindex</span></code> and <code class="docutils literal notranslate"><span class="pre">interpolate</span></code> methods to interpolate at the new values.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [88]: ser = pd.Series(np.sort(np.random.uniform(size=100)))

# interpolate at new_index
In [89]: new_index = ser.index.union(pd.Index([49.25, 49.5, 49.75, 50.25, 50.5, 50.75]))

In [90]: interp_s = ser.reindex(new_index).interpolate(method="pchip")

In [91]: interp_s[49:51]
Out[91]: 
49.00    0.471410
49.25    0.476841
49.50    0.481780
49.75    0.485998
50.00    0.489266
50.25    0.491814
50.50    0.493995
50.75    0.495763
51.00    0.497074
dtype: float64
</pre></div> </div> <section id="interpolation-limits"> <h3>Interpolation limits</h3> <p>Like other pandas fill methods, <a class="reference internal" href="../reference/api/pandas.dataframe.interpolate#pandas.DataFrame.interpolate" title="pandas.DataFrame.interpolate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">interpolate()</span></code></a> accepts a <code class="docutils literal notranslate"><span class="pre">limit</span></code> keyword argument. Use this argument to limit the number of consecutive <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values filled since the last valid observation:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [92]: ser = pd.Series([np.nan, np.nan, 5, np.nan, np.nan, np.nan, 13, np.nan, np.nan])

In [93]: ser
Out[93]: 
0     NaN
1     NaN
2     5.0
3     NaN
4     NaN
5     NaN
6    13.0
7     NaN
8     NaN
dtype: float64

# fill all consecutive values in a forward direction
In [94]: ser.interpolate()
Out[94]: 
0     NaN
1     NaN
2     5.0
3     7.0
4     9.0
5    11.0
6    13.0
7    13.0
8    13.0
dtype: float64

# fill one consecutive value in a forward direction
In [95]: ser.interpolate(limit=1)
Out[95]: 
0     NaN
1     NaN
2     5.0
3     7.0
4     NaN
5     NaN
6    13.0
7    13.0
8     NaN
dtype: float64
</pre></div> </div> <p>By default, <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values are filled in a <code class="docutils literal notranslate"><span class="pre">forward</span></code> direction. Use <code class="docutils literal notranslate"><span class="pre">limit_direction</span></code> parameter to fill <code class="docutils literal notranslate"><span class="pre">backward</span></code> or from <code class="docutils literal notranslate"><span class="pre">both</span></code> directions.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># fill one consecutive value backwards
In [96]: ser.interpolate(limit=1, limit_direction="backward")
Out[96]: 
0     NaN
1     5.0
2     5.0
3     NaN
4     NaN
5    11.0
6    13.0
7     NaN
8     NaN
dtype: float64

# fill one consecutive value in both directions
In [97]: ser.interpolate(limit=1, limit_direction="both")
Out[97]: 
0     NaN
1     5.0
2     5.0
3     7.0
4     NaN
5    11.0
6    13.0
7    13.0
8     NaN
dtype: float64

# fill all consecutive values in both directions
In [98]: ser.interpolate(limit_direction="both")
Out[98]: 
0     5.0
1     5.0
2     5.0
3     7.0
4     9.0
5    11.0
6    13.0
7    13.0
8    13.0
dtype: float64
</pre></div> </div> <p>By default, <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values are filled whether they are inside (surrounded by) existing valid values, or outside existing valid values. The <code class="docutils literal notranslate"><span class="pre">limit_area</span></code> parameter restricts filling to either inside or outside values.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># fill one consecutive inside value in both directions
In [99]: ser.interpolate(limit_direction="both", limit_area="inside", limit=1)
Out[99]: 
0     NaN
1     NaN
2     5.0
3     7.0
4     NaN
5    11.0
6    13.0
7     NaN
8     NaN
dtype: float64

# fill all consecutive outside values backward
In [100]: ser.interpolate(limit_direction="backward", limit_area="outside")
Out[100]: 
0     5.0
1     5.0
2     5.0
3     NaN
4     NaN
5     NaN
6    13.0
7     NaN
8     NaN
dtype: float64

# fill all consecutive outside values in both directions
In [101]: ser.interpolate(limit_direction="both", limit_area="outside")
Out[101]: 
0     5.0
1     5.0
2     5.0
3     NaN
4     NaN
5     NaN
6    13.0
7    13.0
8    13.0
dtype: float64
</pre></div> </div> </section> </section> <section id="replacing-generic-values"> <h2>Replacing generic values</h2> <p>Often times we want to replace arbitrary values with other values.</p> <p><a class="reference internal" href="../reference/api/pandas.series.replace#pandas.Series.replace" title="pandas.Series.replace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">replace()</span></code></a> in Series and <a class="reference internal" href="../reference/api/pandas.dataframe.replace#pandas.DataFrame.replace" title="pandas.DataFrame.replace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">replace()</span></code></a> in DataFrame provides an efficient yet flexible way to perform such replacements.</p> <p>For a Series, you can replace a single value or a list of values by another value:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [102]: ser = pd.Series([0.0, 1.0, 2.0, 3.0, 4.0])

In [103]: ser.replace(0, 5)
Out[103]: 
0    5.0
1    1.0
2    2.0
3    3.0
4    4.0
dtype: float64
</pre></div> </div> <p>You can replace a list of values by a list of other values:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [104]: ser.replace([0, 1, 2, 3, 4], [4, 3, 2, 1, 0])
Out[104]: 
0    4.0
1    3.0
2    2.0
3    1.0
4    0.0
dtype: float64
</pre></div> </div> <p>You can also specify a mapping dict:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [105]: ser.replace({0: 10, 1: 100})
Out[105]: 
0     10.0
1    100.0
2      2.0
3      3.0
4      4.0
dtype: float64
</pre></div> </div> <p>For a DataFrame, you can specify individual values by column:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [106]: df = pd.DataFrame({"a": [0, 1, 2, 3, 4], "b": [5, 6, 7, 8, 9]})

In [107]: df.replace({"a": 0, "b": 5}, 100)
Out[107]: 
     a    b
0  100  100
1    1    6
2    2    7
3    3    8
4    4    9
</pre></div> </div> <p>Instead of replacing with specified values, you can treat all given values as missing and interpolate over them:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [108]: ser.replace([1, 2, 3], method="pad")
Out[108]: 
0    0.0
1    0.0
2    0.0
3    0.0
4    4.0
dtype: float64
</pre></div> </div> </section> <section id="string-regular-expression-replacement"> <h2>String/regular expression replacement</h2> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Python strings prefixed with the <code class="docutils literal notranslate"><span class="pre">r</span></code> character such as <code class="docutils literal notranslate"><span class="pre">r'hello</span> <span class="pre">world'</span></code> are so-called “raw” strings. They have different semantics regarding backslashes than strings without this prefix. Backslashes in raw strings will be interpreted as an escaped backslash, e.g., <code class="docutils literal notranslate"><span class="pre">r'\'</span> <span class="pre">==</span> <span class="pre">'\\'</span></code>. You should <a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals">read about them</a> if this is unclear.</p> </div> <p>Replace the ‘.’ with <code class="docutils literal notranslate"><span class="pre">NaN</span></code> (str -&gt; str):</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [109]: d = {"a": list(range(4)), "b": list("ab.."), "c": ["a", "b", np.nan, "d"]}

In [110]: df = pd.DataFrame(d)

In [111]: df.replace(".", np.nan)
Out[111]: 
   a    b    c
0  0    a    a
1  1    b    b
2  2  NaN  NaN
3  3  NaN    d
</pre></div> </div> <p>Now do it with a regular expression that removes surrounding whitespace (regex -&gt; regex):</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [112]: df.replace(r"\s*\.\s*", np.nan, regex=True)
Out[112]: 
   a    b    c
0  0    a    a
1  1    b    b
2  2  NaN  NaN
3  3  NaN    d
</pre></div> </div> <p>Replace a few different values (list -&gt; list):</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [113]: df.replace(["a", "."], ["b", np.nan])
Out[113]: 
   a    b    c
0  0    b    b
1  1    b    b
2  2  NaN  NaN
3  3  NaN    d
</pre></div> </div> <p>list of regex -&gt; list of regex:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [114]: df.replace([r"\.", r"(a)"], ["dot", r"\1stuff"], regex=True)
Out[114]: 
   a       b       c
0  0  astuff  astuff
1  1       b       b
2  2     dot     NaN
3  3     dot       d
</pre></div> </div> <p>Only search in column <code class="docutils literal notranslate"><span class="pre">'b'</span></code> (dict -&gt; dict):</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [115]: df.replace({"b": "."}, {"b": np.nan})
Out[115]: 
   a    b    c
0  0    a    a
1  1    b    b
2  2  NaN  NaN
3  3  NaN    d
</pre></div> </div> <p>Same as the previous example, but use a regular expression for searching instead (dict of regex -&gt; dict):</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [116]: df.replace({"b": r"\s*\.\s*"}, {"b": np.nan}, regex=True)
Out[116]: 
   a    b    c
0  0    a    a
1  1    b    b
2  2  NaN  NaN
3  3  NaN    d
</pre></div> </div> <p>You can pass nested dictionaries of regular expressions that use <code class="docutils literal notranslate"><span class="pre">regex=True</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [117]: df.replace({"b": {"b": r""}}, regex=True)
Out[117]: 
   a  b    c
0  0  a    a
1  1       b
2  2  .  NaN
3  3  .    d
</pre></div> </div> <p>Alternatively, you can pass the nested dictionary like so:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [118]: df.replace(regex={"b": {r"\s*\.\s*": np.nan}})
Out[118]: 
   a    b    c
0  0    a    a
1  1    b    b
2  2  NaN  NaN
3  3  NaN    d
</pre></div> </div> <p>You can also use the group of a regular expression match when replacing (dict of regex -&gt; dict of regex), this works for lists as well.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [119]: df.replace({"b": r"\s*(\.)\s*"}, {"b": r"\1ty"}, regex=True)
Out[119]: 
   a    b    c
0  0    a    a
1  1    b    b
2  2  .ty  NaN
3  3  .ty    d
</pre></div> </div> <p>You can pass a list of regular expressions, of which those that match will be replaced with a scalar (list of regex -&gt; regex).</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [120]: df.replace([r"\s*\.\s*", r"a|b"], np.nan, regex=True)
Out[120]: 
   a   b    c
0  0 NaN  NaN
1  1 NaN  NaN
2  2 NaN  NaN
3  3 NaN    d
</pre></div> </div> <p>All of the regular expression examples can also be passed with the <code class="docutils literal notranslate"><span class="pre">to_replace</span></code> argument as the <code class="docutils literal notranslate"><span class="pre">regex</span></code> argument. In this case the <code class="docutils literal notranslate"><span class="pre">value</span></code> argument must be passed explicitly by name or <code class="docutils literal notranslate"><span class="pre">regex</span></code> must be a nested dictionary. The previous example, in this case, would then be:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [121]: df.replace(regex=[r"\s*\.\s*", r"a|b"], value=np.nan)
Out[121]: 
   a   b    c
0  0 NaN  NaN
1  1 NaN  NaN
2  2 NaN  NaN
3  3 NaN    d
</pre></div> </div> <p>This can be convenient if you do not want to pass <code class="docutils literal notranslate"><span class="pre">regex=True</span></code> every time you want to use a regular expression.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Anywhere in the above <code class="docutils literal notranslate"><span class="pre">replace</span></code> examples that you see a regular expression a compiled regular expression is valid as well.</p> </div> </section> <section id="numeric-replacement"> <h2>Numeric replacement</h2> <p><a class="reference internal" href="../reference/api/pandas.dataframe.replace#pandas.DataFrame.replace" title="pandas.DataFrame.replace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">replace()</span></code></a> is similar to <a class="reference internal" href="../reference/api/pandas.dataframe.fillna#pandas.DataFrame.fillna" title="pandas.DataFrame.fillna"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fillna()</span></code></a>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [122]: df = pd.DataFrame(np.random.randn(10, 2))

In [123]: df[np.random.rand(df.shape[0]) &gt; 0.5] = 1.5

In [124]: df.replace(1.5, np.nan)
Out[124]: 
          0         1
0 -0.844214 -1.021415
1  0.432396 -0.323580
2  0.423825  0.799180
3  1.262614  0.751965
4       NaN       NaN
5       NaN       NaN
6 -0.498174 -1.060799
7  0.591667 -0.183257
8  1.019855 -1.482465
9       NaN       NaN
</pre></div> </div> <p>Replacing more than one value is possible by passing a list.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [125]: df00 = df.iloc[0, 0]

In [126]: df.replace([1.5, df00], [np.nan, "a"])
Out[126]: 
          0         1
0         a -1.021415
1  0.432396 -0.323580
2  0.423825  0.799180
3  1.262614  0.751965
4       NaN       NaN
5       NaN       NaN
6 -0.498174 -1.060799
7  0.591667 -0.183257
8  1.019855 -1.482465
9       NaN       NaN

In [127]: df[1].dtype
Out[127]: dtype('float64')
</pre></div> </div> <p>You can also operate on the DataFrame in place:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [128]: df.replace(1.5, np.nan, inplace=True)
</pre></div> </div> <section id="missing-data-casting-rules-and-indexing"> <h3>Missing data casting rules and indexing</h3> <p>While pandas supports storing arrays of integer and boolean type, these types are not capable of storing missing data. Until we can switch to using a native NA type in NumPy, we’ve established some “casting rules”. When a reindexing operation introduces missing data, the Series will be cast according to the rules introduced in the table below.</p> <table class="colwidths-given table"> <colgroup> <col style="width: 50%"> <col style="width: 50%"> </colgroup> <thead> <tr class="row-odd">
<th class="head"><p>data type</p></th> <th class="head"><p>Cast to</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p>integer</p></td> <td><p>float</p></td> </tr> <tr class="row-odd">
<td><p>boolean</p></td> <td><p>object</p></td> </tr> <tr class="row-even">
<td><p>float</p></td> <td><p>no cast</p></td> </tr> <tr class="row-odd">
<td><p>object</p></td> <td><p>no cast</p></td> </tr> </tbody> </table> <p>For example:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [129]: s = pd.Series(np.random.randn(5), index=[0, 2, 4, 6, 7])

In [130]: s &gt; 0
Out[130]: 
0    True
2    True
4    True
6    True
7    True
dtype: bool

In [131]: (s &gt; 0).dtype
Out[131]: dtype('bool')

In [132]: crit = (s &gt; 0).reindex(list(range(8)))

In [133]: crit
Out[133]: 
0    True
1     NaN
2    True
3     NaN
4    True
5     NaN
6    True
7    True
dtype: object

In [134]: crit.dtype
Out[134]: dtype('O')
</pre></div> </div> <p>Ordinarily NumPy will complain if you try to use an object array (even if it contains boolean values) instead of a boolean array to get or set values from an ndarray (e.g. selecting values based on some criteria). If a boolean vector contains NAs, an exception will be generated:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [135]: reindexed = s.reindex(list(range(8))).fillna(0)

In [136]: reindexed[crit]
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Input In [136], in &lt;module&gt;
----&gt; 1 reindexed[crit]

File /pandas/pandas/core/series.py:980, in Series.__getitem__(self, key)
    977 if is_iterator(key):
    978     key = list(key)
--&gt; 980 if com.is_bool_indexer(key):
    981     key = check_bool_indexer(self.index, key)
    982     key = np.asarray(key, dtype=bool)

File /pandas/pandas/core/common.py:144, in is_bool_indexer(key)
    140     na_msg = "Cannot mask with non-boolean array containing NA / NaN values"
    141     if lib.infer_dtype(key) == "boolean" and isna(key).any():
    142         # Don't raise on e.g. ["A", "B", np.nan], see
    143         #  test_loc_getitem_list_of_labels_categoricalindex_with_na
--&gt; 144         raise ValueError(na_msg)
    145     return False
    146 return True

ValueError: Cannot mask with non-boolean array containing NA / NaN values
</pre></div> </div> <p>However, these can be filled in using <a class="reference internal" href="../reference/api/pandas.dataframe.fillna#pandas.DataFrame.fillna" title="pandas.DataFrame.fillna"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fillna()</span></code></a> and it will work fine:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [137]: reindexed[crit.fillna(False)]
Out[137]: 
0    0.126504
2    0.696198
4    0.697416
6    0.601516
7    0.003659
dtype: float64

In [138]: reindexed[crit.fillna(True)]
Out[138]: 
0    0.126504
1    0.000000
2    0.696198
3    0.000000
4    0.697416
5    0.000000
6    0.601516
7    0.003659
dtype: float64
</pre></div> </div> <p>pandas provides a nullable integer dtype, but you must explicitly request it when creating the series or column. Notice that we use a capital “I” in the <code class="docutils literal notranslate"><span class="pre">dtype="Int64"</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [139]: s = pd.Series([0, 1, np.nan, 3, 4], dtype="Int64")

In [140]: s
Out[140]: 
0       0
1       1
2    &lt;NA&gt;
3       3
4       4
dtype: Int64
</pre></div> </div> <p>See <a class="reference internal" href="integer_na#integer-na"><span class="std std-ref">Nullable integer data type</span></a> for more.</p> </section> </section> <section id="experimental-na-scalar-to-denote-missing-values"> <h2>Experimental <code class="docutils literal notranslate"><span class="pre">NA</span></code> scalar to denote missing values</h2> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Experimental: the behaviour of <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> can still change without warning.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.0.0.</span></p> </div> <p>Starting from pandas 1.0, an experimental <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> value (singleton) is available to represent scalar missing values. At this moment, it is used in the nullable <a class="reference internal" href="integer_na"><span class="doc">integer</span></a>, boolean and <a class="reference internal" href="text#text-types"><span class="std std-ref">dedicated string</span></a> data types as the missing value indicator.</p> <p>The goal of <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> is provide a “missing” indicator that can be used consistently across data types (instead of <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.NaT</span></code> depending on the data type).</p> <p>For example, when having missing values in a Series with the nullable integer dtype, it will use <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [141]: s = pd.Series([1, 2, None], dtype="Int64")

In [142]: s
Out[142]: 
0       1
1       2
2    &lt;NA&gt;
dtype: Int64

In [143]: s[2]
Out[143]: &lt;NA&gt;

In [144]: s[2] is pd.NA
Out[144]: True
</pre></div> </div> <p>Currently, pandas does not yet use those data types by default (when creating a DataFrame or Series, or when reading in data), so you need to specify the dtype explicitly. An easy way to convert to those dtypes is explained <a class="reference internal" href="#missing-data-na-conversion"><span class="std std-ref">here</span></a>.</p> <section id="propagation-in-arithmetic-and-comparison-operations"> <h3>Propagation in arithmetic and comparison operations</h3> <p>In general, missing values <em>propagate</em> in operations involving <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code>. When one of the operands is unknown, the outcome of the operation is also unknown.</p> <p>For example, <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> propagates in arithmetic operations, similarly to <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [145]: pd.NA + 1
Out[145]: &lt;NA&gt;

In [146]: "a" * pd.NA
Out[146]: &lt;NA&gt;
</pre></div> </div> <p>There are a few special cases when the result is known, even when one of the operands is <code class="docutils literal notranslate"><span class="pre">NA</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [147]: pd.NA ** 0
Out[147]: 1

In [148]: 1 ** pd.NA
Out[148]: 1
</pre></div> </div> <p>In equality and comparison operations, <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> also propagates. This deviates from the behaviour of <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>, where comparisons with <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> always return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [149]: pd.NA == 1
Out[149]: &lt;NA&gt;

In [150]: pd.NA == pd.NA
Out[150]: &lt;NA&gt;

In [151]: pd.NA &lt; 2.5
Out[151]: &lt;NA&gt;
</pre></div> </div> <p>To check if a value is equal to <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code>, the <a class="reference internal" href="../reference/api/pandas.isna#pandas.isna" title="pandas.isna"><code class="xref py py-func docutils literal notranslate"><span class="pre">isna()</span></code></a> function can be used:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [152]: pd.isna(pd.NA)
Out[152]: True
</pre></div> </div> <p>An exception on this basic propagation rule are <em>reductions</em> (such as the mean or the minimum), where pandas defaults to skipping missing values. See <a class="reference internal" href="#missing-data-calculations"><span class="std std-ref">above</span></a> for more.</p> </section> <section id="logical-operations"> <h3>Logical operations</h3> <p>For logical operations, <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> follows the rules of the <a class="reference external" href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a> (or <em>Kleene logic</em>, similarly to R, SQL and Julia). This logic means to only propagate missing values when it is logically required.</p> <p>For example, for the logical “or” operation (<code class="docutils literal notranslate"><span class="pre">|</span></code>), if one of the operands is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we already know the result will be <code class="docutils literal notranslate"><span class="pre">True</span></code>, regardless of the other value (so regardless the missing value would be <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>). In this case, <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> does not propagate:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [153]: True | False
Out[153]: True

In [154]: True | pd.NA
Out[154]: True

In [155]: pd.NA | True
Out[155]: True
</pre></div> </div> <p>On the other hand, if one of the operands is <code class="docutils literal notranslate"><span class="pre">False</span></code>, the result depends on the value of the other operand. Therefore, in this case <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> propagates:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [156]: False | True
Out[156]: True

In [157]: False | False
Out[157]: False

In [158]: False | pd.NA
Out[158]: &lt;NA&gt;
</pre></div> </div> <p>The behaviour of the logical “and” operation (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>) can be derived using similar logic (where now <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> will not propagate if one of the operands is already <code class="docutils literal notranslate"><span class="pre">False</span></code>):</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [159]: False &amp; True
Out[159]: False

In [160]: False &amp; False
Out[160]: False

In [161]: False &amp; pd.NA
Out[161]: False
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [162]: True &amp; True
Out[162]: True

In [163]: True &amp; False
Out[163]: False

In [164]: True &amp; pd.NA
Out[164]: &lt;NA&gt;
</pre></div> </div> </section> <section id="na-in-a-boolean-context"> <h3>
<code class="docutils literal notranslate"><span class="pre">NA</span></code> in a boolean context</h3> <p>Since the actual value of an NA is unknown, it is ambiguous to convert NA to a boolean value. The following raises an error:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [165]: bool(pd.NA)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Input In [165], in &lt;module&gt;
----&gt; 1 bool(pd.NA)

File /pandas/pandas/_libs/missing.pyx:382, in pandas._libs.missing.NAType.__bool__()

TypeError: boolean value of NA is ambiguous
</pre></div> </div> <p>This also means that <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> cannot be used in a context where it is evaluated to a boolean, such as <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">condition:</span> <span class="pre">...</span></code> where <code class="docutils literal notranslate"><span class="pre">condition</span></code> can potentially be <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code>. In such cases, <a class="reference internal" href="../reference/api/pandas.isna#pandas.isna" title="pandas.isna"><code class="xref py py-func docutils literal notranslate"><span class="pre">isna()</span></code></a> can be used to check for <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> or <code class="docutils literal notranslate"><span class="pre">condition</span></code> being <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> can be avoided, for example by filling missing values beforehand.</p> <p>A similar situation occurs when using Series or DataFrame objects in <code class="docutils literal notranslate"><span class="pre">if</span></code> statements, see <a class="reference internal" href="gotchas#gotchas-truth"><span class="std std-ref">Using if/truth statements with pandas</span></a>.</p> </section> <section id="numpy-ufuncs"> <h3>NumPy ufuncs</h3> <p><code class="xref py py-attr docutils literal notranslate"><span class="pre">pandas.NA</span></code> implements NumPy’s <code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code> protocol. Most ufuncs work with <code class="docutils literal notranslate"><span class="pre">NA</span></code>, and generally return <code class="docutils literal notranslate"><span class="pre">NA</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [166]: np.log(pd.NA)
Out[166]: &lt;NA&gt;

In [167]: np.add(pd.NA, 1)
Out[167]: &lt;NA&gt;
</pre></div> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Currently, ufuncs involving an ndarray and <code class="docutils literal notranslate"><span class="pre">NA</span></code> will return an object-dtype filled with NA values.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [168]: a = np.array([1, 2, 3])

In [169]: np.greater(a, pd.NA)
Out[169]: array([&lt;NA&gt;, &lt;NA&gt;, &lt;NA&gt;], dtype=object)
</pre></div> </div> <p>The return type here may change to return a different array type in the future.</p> </div> <p>See <a class="reference internal" href="dsintro#dsintro-numpy-interop"><span class="std std-ref">DataFrame interoperability with NumPy functions</span></a> for more on ufuncs.</p> </section> <section id="conversion"> <h3>Conversion</h3> <p>If you have a DataFrame or Series using traditional types that have missing data represented using <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>, there are convenience methods <a class="reference internal" href="../reference/api/pandas.series.convert_dtypes#pandas.Series.convert_dtypes" title="pandas.Series.convert_dtypes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">convert_dtypes()</span></code></a> in Series and <a class="reference internal" href="../reference/api/pandas.dataframe.convert_dtypes#pandas.DataFrame.convert_dtypes" title="pandas.DataFrame.convert_dtypes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">convert_dtypes()</span></code></a> in DataFrame that can convert data to use the newer dtypes for integers, strings and booleans listed <a class="reference internal" href="basics#basics-dtypes"><span class="std std-ref">here</span></a>. This is especially helpful after reading in data sets when letting the readers such as <a class="reference internal" href="../reference/api/pandas.read_csv#pandas.read_csv" title="pandas.read_csv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.read_excel#pandas.read_excel" title="pandas.read_excel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_excel()</span></code></a> infer default dtypes.</p> <p>In this example, while the dtypes of all columns are changed, we show the results for the first 10 columns.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [170]: bb = pd.read_csv("data/baseball.csv", index_col="id")

In [171]: bb[bb.columns[:10]].dtypes
Out[171]: 
player    object
year       int64
stint      int64
team      object
lg        object
g          int64
ab         int64
r          int64
h          int64
X2b        int64
dtype: object
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [172]: bbn = bb.convert_dtypes()

In [173]: bbn[bbn.columns[:10]].dtypes
Out[173]: 
player    string
year       Int64
stint      Int64
team      string
lg        string
g          Int64
ab         Int64
r          Int64
h          Int64
X2b        Int64
dtype: object
</pre></div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2008&ndash;2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://pandas.pydata.org/pandas-docs/version/1.4.0/user_guide/missing_data.html" class="_attribution-link">https://pandas.pydata.org/pandas-docs/version/1.4.0/user_guide/missing_data.html</a>
  </p>
</div>
