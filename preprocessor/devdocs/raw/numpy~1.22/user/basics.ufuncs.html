<h1 id="ufuncs-basics">Universal functions (ufunc) basics</h1> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="../reference/ufuncs#ufuncs"><span class="std std-ref">Universal functions (ufunc)</span></a></p> </div> <p>A universal function (or <a class="reference internal" href="../glossary#term-ufunc"><span class="xref std std-term">ufunc</span></a> for short) is a function that operates on <a class="reference internal" href="../reference/generated/numpy.ndarray#numpy.ndarray" title="numpy.ndarray"><code>ndarrays</code></a> in an element-by-element fashion, supporting <a class="reference internal" href="#ufuncs-broadcasting"><span class="std std-ref">array broadcasting</span></a>, <a class="reference internal" href="#ufuncs-casting"><span class="std std-ref">type casting</span></a>, and several other standard features. That is, a ufunc is a “<a class="reference internal" href="../glossary#term-vectorization"><span class="xref std std-term">vectorized</span></a>” wrapper for a function that takes a fixed number of specific inputs and produces a fixed number of specific outputs.</p> <p>In NumPy, universal functions are instances of the <a class="reference internal" href="../reference/generated/numpy.ufunc#numpy.ufunc" title="numpy.ufunc"><code>numpy.ufunc</code></a> class. Many of the built-in functions are implemented in compiled C code. The basic ufuncs operate on scalars, but there is also a generalized kind for which the basic elements are sub-arrays (vectors, matrices, etc.), and broadcasting is done over other dimensions. The simplest example is the addition operator:</p> <pre data-language="python">&gt;&gt;&gt; np.array([0,2,3,4]) + np.array([1,1,-1,2])
array([1, 3, 2, 6])
</pre> <p>One can also produce custom <a class="reference internal" href="../reference/generated/numpy.ufunc#numpy.ufunc" title="numpy.ufunc"><code>numpy.ufunc</code></a> instances using the <a class="reference internal" href="../reference/generated/numpy.frompyfunc#numpy.frompyfunc" title="numpy.frompyfunc"><code>numpy.frompyfunc</code></a> factory function.</p> <section id="ufunc-methods"> <h2>Ufunc methods</h2> <p>All ufuncs have four methods. They can be found at <a class="reference internal" href="../reference/ufuncs#ufuncs-methods"><span class="std std-ref">Methods</span></a>. However, these methods only make sense on scalar ufuncs that take two input arguments and return one output argument. Attempting to call these methods on other ufuncs will cause a <a class="reference external" href="https://docs.python.org/dev/library/exceptions.html#ValueError" title="(in Python v3.11)"><code>ValueError</code></a>.</p> <p>The reduce-like methods all take an <em>axis</em> keyword, a <em>dtype</em> keyword, and an <em>out</em> keyword, and the arrays must all have dimension &gt;= 1. The <em>axis</em> keyword specifies the axis of the array over which the reduction will take place (with negative values counting backwards). Generally, it is an integer, though for <a class="reference internal" href="../reference/generated/numpy.ufunc.reduce#numpy.ufunc.reduce" title="numpy.ufunc.reduce"><code>numpy.ufunc.reduce</code></a>, it can also be a tuple of <code>int</code> to reduce over several axes at once, or <code>None</code>, to reduce over all axes. For example:</p> <pre data-language="python">&gt;&gt;&gt; x = np.arange(9).reshape(3,3)
&gt;&gt;&gt; x
array([[0, 1, 2],
      [3, 4, 5],
      [6, 7, 8]])
&gt;&gt;&gt; np.add.reduce(x, 1)
array([ 3, 12, 21])
&gt;&gt;&gt; np.add.reduce(x, (0, 1))
36
</pre> <p>The <em>dtype</em> keyword allows you to manage a very common problem that arises when naively using <a class="reference internal" href="../reference/generated/numpy.ufunc.reduce#numpy.ufunc.reduce" title="numpy.ufunc.reduce"><code>ufunc.reduce</code></a>. Sometimes you may have an array of a certain data type and wish to add up all of its elements, but the result does not fit into the data type of the array. This commonly happens if you have an array of single-byte integers. The <em>dtype</em> keyword allows you to alter the data type over which the reduction takes place (and therefore the type of the output). Thus, you can ensure that the output is a data type with precision large enough to handle your output. The responsibility of altering the reduce type is mostly up to you. There is one exception: if no <em>dtype</em> is given for a reduction on the “add” or “multiply” operations, then if the input type is an integer (or Boolean) data-type and smaller than the size of the <a class="reference internal" href="../reference/arrays.scalars#numpy.int_" title="numpy.int_"><code>numpy.int_</code></a> data type, it will be internally upcast to the <a class="reference internal" href="../reference/arrays.scalars#numpy.int_" title="numpy.int_"><code>int_</code></a> (or <a class="reference internal" href="../reference/arrays.scalars#numpy.uint" title="numpy.uint"><code>numpy.uint</code></a>) data-type. In the previous example:</p> <pre data-language="python">&gt;&gt;&gt; x.dtype
dtype('int64')
&gt;&gt;&gt; np.multiply.reduce(x, dtype=float)
array([ 0., 28., 80.])
</pre> <p>Finally, the <em>out</em> keyword allows you to provide an output array (for single-output ufuncs, which are currently the only ones supported; for future extension, however, a tuple with a single argument can be passed in). If <em>out</em> is given, the <em>dtype</em> argument is ignored. Considering <code>x</code> from the previous example:</p> <pre data-language="python">&gt;&gt;&gt; y = np.zeros(3, dtype=int)
&gt;&gt;&gt; y
array([0, 0, 0])
&gt;&gt;&gt; np.multiply.reduce(x, dtype=float, out=y)
array([ 0, 28, 80])     # dtype argument is ignored
</pre> <p>Ufuncs also have a fifth method, <a class="reference internal" href="../reference/generated/numpy.ufunc.at#numpy.ufunc.at" title="numpy.ufunc.at"><code>numpy.ufunc.at</code></a>, that allows in place operations to be performed using advanced indexing. No <a class="reference internal" href="#use-of-internal-buffers"><span class="std std-ref">buffering</span></a> is used on the dimensions where advanced indexing is used, so the advanced index can list an item more than once and the operation will be performed on the result of the previous operation for that item.</p> </section> <section id="output-type-determination"> <h2 id="ufuncs-output-type">Output type determination</h2> <p>The output of the ufunc (and its methods) is not necessarily an <a class="reference internal" href="../reference/generated/numpy.ndarray#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a>, if all input arguments are not <a class="reference internal" href="../reference/generated/numpy.ndarray#numpy.ndarray" title="numpy.ndarray"><code>ndarrays</code></a>. Indeed, if any input defines an <a class="reference internal" href="../reference/arrays.classes#numpy.class.__array_ufunc__" title="numpy.class.__array_ufunc__"><code>__array_ufunc__</code></a> method, control will be passed completely to that function, i.e., the ufunc is <a class="reference internal" href="#ufuncs-overrides"><span class="std std-ref">overridden</span></a>.</p> <p>If none of the inputs overrides the ufunc, then all output arrays will be passed to the <a class="reference internal" href="../reference/arrays.classes#numpy.class.__array_prepare__" title="numpy.class.__array_prepare__"><code>__array_prepare__</code></a> and <a class="reference internal" href="../reference/arrays.classes#numpy.class.__array_wrap__" title="numpy.class.__array_wrap__"><code>__array_wrap__</code></a> methods of the input (besides <a class="reference internal" href="../reference/generated/numpy.ndarray#numpy.ndarray" title="numpy.ndarray"><code>ndarrays</code></a>, and scalars) that defines it <strong>and</strong> has the highest <a class="reference internal" href="../reference/arrays.classes#numpy.class.__array_priority__" title="numpy.class.__array_priority__"><code>__array_priority__</code></a> of any other input to the universal function. The default <a class="reference internal" href="../reference/arrays.classes#numpy.class.__array_priority__" title="numpy.class.__array_priority__"><code>__array_priority__</code></a> of the ndarray is 0.0, and the default <a class="reference internal" href="../reference/arrays.classes#numpy.class.__array_priority__" title="numpy.class.__array_priority__"><code>__array_priority__</code></a> of a subtype is 0.0. Matrices have <a class="reference internal" href="../reference/arrays.classes#numpy.class.__array_priority__" title="numpy.class.__array_priority__"><code>__array_priority__</code></a> equal to 10.0.</p> <p>All ufuncs can also take output arguments. If necessary, output will be cast to the data-type(s) of the provided output array(s). If a class with an <a class="reference internal" href="../reference/arrays.classes#numpy.class.__array__" title="numpy.class.__array__"><code>__array__</code></a> method is used for the output, results will be written to the object returned by <a class="reference internal" href="../reference/arrays.classes#numpy.class.__array__" title="numpy.class.__array__"><code>__array__</code></a>. Then, if the class also has an <a class="reference internal" href="../reference/arrays.classes#numpy.class.__array_prepare__" title="numpy.class.__array_prepare__"><code>__array_prepare__</code></a> method, it is called so metadata may be determined based on the context of the ufunc (the context consisting of the ufunc itself, the arguments passed to the ufunc, and the ufunc domain.) The array object returned by <a class="reference internal" href="../reference/arrays.classes#numpy.class.__array_prepare__" title="numpy.class.__array_prepare__"><code>__array_prepare__</code></a> is passed to the ufunc for computation. Finally, if the class also has an <a class="reference internal" href="../reference/arrays.classes#numpy.class.__array_wrap__" title="numpy.class.__array_wrap__"><code>__array_wrap__</code></a> method, the returned <a class="reference internal" href="../reference/generated/numpy.ndarray#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a> result will be passed to that method just before passing control back to the caller.</p> </section> <section id="broadcasting"> <h2 id="ufuncs-broadcasting">Broadcasting</h2> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="basics.broadcasting"><span class="doc">Broadcasting basics</span></a></p> </div> <p id="index-0">Each universal function takes array inputs and produces array outputs by performing the core function element-wise on the inputs (where an element is generally a scalar, but can be a vector or higher-order sub-array for generalized ufuncs). Standard <a class="reference internal" href="basics.broadcasting#general-broadcasting-rules"><span class="std std-ref">broadcasting rules</span></a> are applied so that inputs not sharing exactly the same shapes can still be usefully operated on.</p> <p>By these rules, if an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the <a class="reference internal" href="../glossary#term-ufunc"><span class="xref std std-term">ufunc</span></a> will simply not step along that dimension (the <a class="reference internal" href="../reference/arrays.ndarray#memory-layout"><span class="std std-ref">stride</span></a> will be 0 for that dimension).</p> </section> <section id="type-casting-rules"> <h2 id="ufuncs-casting">Type casting rules</h2> <div class="admonition note" id="index-1"> <p class="admonition-title">Note</p> <p>In NumPy 1.6.0, a type promotion API was created to encapsulate the mechanism for determining output types. See the functions <a class="reference internal" href="../reference/generated/numpy.result_type#numpy.result_type" title="numpy.result_type"><code>numpy.result_type</code></a>, <a class="reference internal" href="../reference/generated/numpy.promote_types#numpy.promote_types" title="numpy.promote_types"><code>numpy.promote_types</code></a>, and <a class="reference internal" href="../reference/generated/numpy.min_scalar_type#numpy.min_scalar_type" title="numpy.min_scalar_type"><code>numpy.min_scalar_type</code></a> for more details.</p> </div> <p>At the core of every ufunc is a one-dimensional strided loop that implements the actual function for a specific type combination. When a ufunc is created, it is given a static list of inner loops and a corresponding list of type signatures over which the ufunc operates. The ufunc machinery uses this list to determine which inner loop to use for a particular case. You can inspect the <a class="reference internal" href="../reference/generated/numpy.ufunc.types#numpy.ufunc.types" title="numpy.ufunc.types"><code>.types</code></a> attribute for a particular ufunc to see which type combinations have a defined inner loop and which output type they produce (<a class="reference internal" href="../reference/arrays.scalars#arrays-scalars-character-codes"><span class="std std-ref">character codes</span></a> are used in said output for brevity).</p> <p>Casting must be done on one or more of the inputs whenever the ufunc does not have a core loop implementation for the input types provided. If an implementation for the input types cannot be found, then the algorithm searches for an implementation with a type signature to which all of the inputs can be cast “safely.” The first one it finds in its internal list of loops is selected and performed, after all necessary type casting. Recall that internal copies during ufuncs (even for casting) are limited to the size of an internal buffer (which is user settable).</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Universal functions in NumPy are flexible enough to have mixed type signatures. Thus, for example, a universal function could be defined that works with floating-point and integer values. See <a class="reference internal" href="../reference/generated/numpy.ldexp#numpy.ldexp" title="numpy.ldexp"><code>numpy.ldexp</code></a> for an example.</p> </div> <p>By the above description, the casting rules are essentially implemented by the question of when a data type can be cast “safely” to another data type. The answer to this question can be determined in Python with a function call: <a class="reference internal" href="../reference/generated/numpy.can_cast#numpy.can_cast" title="numpy.can_cast"><code>can_cast(fromtype, totype)</code></a>. The example below shows the results of this call for the 24 internally supported types on the author’s 64-bit system. You can generate this table for your system with the code given in the example.</p> <h4 class="rubric">Example</h4> <p>Code segment showing the “can cast safely” table for a 64-bit system. Generally the output depends on the system; your system might result in a different table.</p> <pre data-language="python">&gt;&gt;&gt; mark = {False: ' -', True: ' Y'}
&gt;&gt;&gt; def print_table(ntypes):
...     print('X ' + ' '.join(ntypes))
...     for row in ntypes:
...         print(row, end='')
...         for col in ntypes:
...             print(mark[np.can_cast(row, col)], end='')
...         print()
...
&gt;&gt;&gt; print_table(np.typecodes['All'])
X ? b h i l q p B H I L Q P e f d g F D G S U V O M m
? Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y - Y
b - Y Y Y Y Y Y - - - - - - Y Y Y Y Y Y Y Y Y Y Y - Y
h - - Y Y Y Y Y - - - - - - - Y Y Y Y Y Y Y Y Y Y - Y
i - - - Y Y Y Y - - - - - - - - Y Y - Y Y Y Y Y Y - Y
l - - - - Y Y Y - - - - - - - - Y Y - Y Y Y Y Y Y - Y
q - - - - Y Y Y - - - - - - - - Y Y - Y Y Y Y Y Y - Y
p - - - - Y Y Y - - - - - - - - Y Y - Y Y Y Y Y Y - Y
B - - Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y Y - Y
H - - - Y Y Y Y - Y Y Y Y Y - Y Y Y Y Y Y Y Y Y Y - Y
I - - - - Y Y Y - - Y Y Y Y - - Y Y - Y Y Y Y Y Y - Y
L - - - - - - - - - - Y Y Y - - Y Y - Y Y Y Y Y Y - -
Q - - - - - - - - - - Y Y Y - - Y Y - Y Y Y Y Y Y - -
P - - - - - - - - - - Y Y Y - - Y Y - Y Y Y Y Y Y - -
e - - - - - - - - - - - - - Y Y Y Y Y Y Y Y Y Y Y - -
f - - - - - - - - - - - - - - Y Y Y Y Y Y Y Y Y Y - -
d - - - - - - - - - - - - - - - Y Y - Y Y Y Y Y Y - -
g - - - - - - - - - - - - - - - - Y - - Y Y Y Y Y - -
F - - - - - - - - - - - - - - - - - Y Y Y Y Y Y Y - -
D - - - - - - - - - - - - - - - - - - Y Y Y Y Y Y - -
G - - - - - - - - - - - - - - - - - - - Y Y Y Y Y - -
S - - - - - - - - - - - - - - - - - - - - Y Y Y Y - -
U - - - - - - - - - - - - - - - - - - - - - Y Y Y - -
V - - - - - - - - - - - - - - - - - - - - - - Y Y - -
O - - - - - - - - - - - - - - - - - - - - - - - Y - -
M - - - - - - - - - - - - - - - - - - - - - - Y Y Y -
m - - - - - - - - - - - - - - - - - - - - - - Y Y - Y
</pre> <p>You should note that, while included in the table for completeness, the ‘S’, ‘U’, and ‘V’ types cannot be operated on by ufuncs. Also, note that on a 32-bit system the integer types may have different sizes, resulting in a slightly altered table.</p> <p>Mixed scalar-array operations use a different set of casting rules that ensure that a scalar cannot “upcast” an array unless the scalar is of a fundamentally different kind of data (i.e., under a different hierarchy in the data-type hierarchy) than the array. This rule enables you to use scalar constants in your code (which, as Python types, are interpreted accordingly in ufuncs) without worrying about whether the precision of the scalar constant will cause upcasting on your large (small precision) array.</p> </section> <section id="use-of-internal-buffers"> <h2 id="id1">Use of internal buffers</h2> <p id="index-2">Internally, buffers are used for misaligned data, swapped data, and data that has to be converted from one data type to another. The size of internal buffers is settable on a per-thread basis. There can be up to <span class="math notranslate nohighlight">\(2 (n_{\mathrm{inputs}} + n_{\mathrm{outputs}})\)</span> buffers of the specified size created to handle the data from all the inputs and outputs of a ufunc. The default size of a buffer is 10,000 elements. Whenever buffer-based calculation would be needed, but all input arrays are smaller than the buffer size, those misbehaved or incorrectly-typed arrays will be copied before the calculation proceeds. Adjusting the size of the buffer may therefore alter the speed at which ufunc calculations of various sorts are completed. A simple interface for setting this variable is accessible using the function <a class="reference internal" href="../reference/generated/numpy.setbufsize#numpy.setbufsize" title="numpy.setbufsize"><code>numpy.setbufsize</code></a>.</p> </section> <section id="error-handling"> <h2>Error handling</h2> <p id="index-3">Universal functions can trip special floating-point status registers in your hardware (such as divide-by-zero). If available on your platform, these registers will be regularly checked during calculation. Error handling is controlled on a per-thread basis, and can be configured using the functions <a class="reference internal" href="../reference/generated/numpy.seterr#numpy.seterr" title="numpy.seterr"><code>numpy.seterr</code></a> and <a class="reference internal" href="../reference/generated/numpy.seterrcall#numpy.seterrcall" title="numpy.seterrcall"><code>numpy.seterrcall</code></a>.</p> </section> <section id="overriding-ufunc-behavior"> <h2 id="ufuncs-overrides">Overriding ufunc behavior</h2> <p>Classes (including ndarray subclasses) can override how ufuncs act on them by defining certain special methods. For details, see <a class="reference internal" href="../reference/arrays.classes#arrays-classes"><span class="std std-ref">Standard array subclasses</span></a>.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/user/basics.ufuncs.html" class="_attribution-link">https://numpy.org/doc/1.22/user/basics.ufuncs.html</a>
  </p>
</div>
