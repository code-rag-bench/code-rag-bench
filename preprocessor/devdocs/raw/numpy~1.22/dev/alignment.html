<h1 id="alignment">Memory Alignment</h1> <section id="numpy-alignment-goals"> <h2>NumPy alignment goals</h2> <p>There are three use-cases related to memory alignment in NumPy (as of 1.14):</p>  <ol class="arabic simple"> <li>Creating <a class="reference internal" href="../glossary#term-structured-data-type"><span class="xref std std-term">structured datatypes</span></a> with <a class="reference internal" href="../glossary#term-field"><span class="xref std std-term">fields</span></a> aligned like in a C-struct.</li> <li>Speeding up copy operations by using <a class="reference internal" href="../reference/arrays.scalars#numpy.uint" title="numpy.uint"><code>uint</code></a> assignment in instead of <code>memcpy</code>.</li> <li>Guaranteeing safe aligned access for ufuncs/setitem/casting code.</li> </ol>  <p>NumPy uses two different forms of alignment to achieve these goals: “True alignment” and “Uint alignment”.</p> <p>“True” alignment refers to the architecture-dependent alignment of an equivalent C-type in C. For example, in x64 systems <a class="reference internal" href="../reference/arrays.scalars#numpy.float64" title="numpy.float64"><code>float64</code></a> is equivalent to <code>double</code> in C. On most systems, this has either an alignment of 4 or 8 bytes (and this can be controlled in GCC by the option <code>malign-double</code>). A variable is aligned in memory if its memory offset is a multiple of its alignment. On some systems (eg. sparc) memory alignment is required; on others, it gives a speedup.</p> <p>“Uint” alignment depends on the size of a datatype. It is defined to be the “True alignment” of the uint used by NumPy’s copy-code to copy the datatype, or undefined/unaligned if there is no equivalent uint. Currently, NumPy uses <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>, and <code>uint64</code> to copy data of size 1, 2, 4, 8, 16 bytes respectively, and all other sized datatypes cannot be uint-aligned.</p> <p>For example, on a (typical Linux x64 GCC) system, the NumPy <a class="reference internal" href="../reference/arrays.scalars#numpy.complex64" title="numpy.complex64"><code>complex64</code></a> datatype is implemented as <code>struct { float real, imag; }</code>. This has “true” alignment of 4 and “uint” alignment of 8 (equal to the true alignment of <code>uint64</code>).</p> <dl> <dt>Some cases where uint and true alignment are different (default GCC Linux):</dt>
<dd>
<table class="table">  <thead> <tr>
<th class="head"><p>arch</p></th> <th class="head"><p>type</p></th> <th class="head"><p>true-aln</p></th> <th class="head"><p>uint-aln</p></th> </tr> </thead>  <tr>
<td><p>x86_64</p></td> <td><p>complex64</p></td> <td><p>4</p></td> <td><p>8</p></td> </tr> <tr>
<td><p>x86_64</p></td> <td><p>float128</p></td> <td><p>16</p></td> <td><p>8</p></td> </tr> <tr>
<td><p>x86</p></td> <td><p>float96</p></td> <td><p>4</p></td> <td><p>-</p></td> </tr>  </table> </dd> </dl> </section> <section id="variables-in-numpy-which-control-and-describe-alignment"> <h2>Variables in NumPy which control and describe alignment</h2> <p>There are 4 relevant uses of the word <code>align</code> used in NumPy:</p>  <ul class="simple"> <li>The <a class="reference internal" href="../reference/generated/numpy.dtype.alignment#numpy.dtype.alignment" title="numpy.dtype.alignment"><code>dtype.alignment</code></a> attribute (<code>descr-&gt;alignment</code> in C). This is meant to reflect the “true alignment” of the type. It has arch-dependent default values for all datatypes, except for the structured types created with <code>align=True</code> as described below.</li> <li>The <code>ALIGNED</code> flag of an ndarray, computed in <code>IsAligned</code> and checked by <a class="reference internal" href="../reference/c-api/array#c.PyArray_ISALIGNED" title="PyArray_ISALIGNED"><code>PyArray_ISALIGNED</code></a>. This is computed from <a class="reference internal" href="../reference/generated/numpy.dtype.alignment#numpy.dtype.alignment" title="numpy.dtype.alignment"><code>dtype.alignment</code></a>. It is set to <code>True</code> if every item in the array is at a memory location consistent with <a class="reference internal" href="../reference/generated/numpy.dtype.alignment#numpy.dtype.alignment" title="numpy.dtype.alignment"><code>dtype.alignment</code></a>, which is the case if the <code>data ptr</code> and all strides of the array are multiples of that alignment.</li> <li>The <code>align</code> keyword of the dtype constructor, which only affects <a class="reference internal" href="../user/basics.rec#structured-arrays"><span class="std std-ref">Structured arrays</span></a>. If the structure’s field offsets are not manually provided, NumPy determines offsets automatically. In that case, <code>align=True</code> pads the structure so that each field is “true” aligned in memory and sets <a class="reference internal" href="../reference/generated/numpy.dtype.alignment#numpy.dtype.alignment" title="numpy.dtype.alignment"><code>dtype.alignment</code></a> to be the largest of the field “true” alignments. This is like what C-structs usually do. Otherwise if offsets or itemsize were manually provided <code>align=True</code> simply checks that all the fields are “true” aligned and that the total itemsize is a multiple of the largest field alignment. In either case <a class="reference internal" href="../reference/generated/numpy.dtype.isalignedstruct#numpy.dtype.isalignedstruct" title="numpy.dtype.isalignedstruct"><code>dtype.isalignedstruct</code></a> is also set to True.</li> <li>
<code>IsUintAligned</code> is used to determine if an ndarray is “uint aligned” in an analogous way to how <code>IsAligned</code> checks for true alignment.</li> </ul>  </section> <section id="consequences-of-alignment"> <h2>Consequences of alignment</h2> <p>Here is how the variables above are used:</p>  <ol class="arabic simple"> <li>Creating aligned structs: To know how to offset a field when <code>align=True</code>, NumPy looks up <code>field.dtype.alignment</code>. This includes fields that are nested structured arrays.</li> <li>Ufuncs: If the <code>ALIGNED</code> flag of an array is False, ufuncs will buffer/cast the array before evaluation. This is needed since ufunc inner loops access raw elements directly, which might fail on some archs if the elements are not true-aligned.</li> <li>Getitem/setitem/copyswap function: Similar to ufuncs, these functions generally have two code paths. If <code>ALIGNED</code> is False they will use a code path that buffers the arguments so they are true-aligned.</li> <li>Strided copy code: Here, “uint alignment” is used instead. If the itemsize of an array is equal to 1, 2, 4, 8 or 16 bytes and the array is uint aligned then instead NumPy will do <code>*(uintN*)dst) = *(uintN*)src)</code> for appropriate N. Otherwise, NumPy copies by doing <code>memcpy(dst, src, N)</code>.</li> <li>Nditer code: Since this often calls the strided copy code, it must check for “uint alignment”.</li> <li>Cast code: This checks for “true” alignment, as it does <code>*dst = CASTFUNC(*src)</code> if aligned. Otherwise, it does <code>memmove(srcval, src); dstval = CASTFUNC(srcval); memmove(dst, dstval)</code> where dstval/srcval are aligned.</li> </ol>  <p>Note that the strided-copy and strided-cast code are deeply intertwined and so any arrays being processed by them must be both uint and true aligned, even though the copy-code only needs uint alignment and the cast code only true alignment. If there is ever a big rewrite of this code it would be good to allow them to use different alignments.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/dev/alignment.html" class="_attribution-link">https://numpy.org/doc/1.22/dev/alignment.html</a>
  </p>
</div>
