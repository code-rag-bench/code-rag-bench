<h1>Using F2PY bindings in Python</h1> <p>All wrappers for Fortran/C routines, common blocks, or for Fortran 90 module data generated by F2PY are exposed to Python as <code>fortran</code> type objects. Routine wrappers are callable <code>fortran</code> type objects while wrappers to Fortran data have attributes referring to data objects.</p> <p>All <code>fortran</code> type objects have an attribute <code>_cpointer</code> that contains a <code>CObject</code> referring to the C pointer of the corresponding Fortran/C function or variable at the C level. Such <code>CObjects</code> can be used as a callback argument for F2PY generated functions to bypass the Python C/API layer for calling Python functions from Fortran or C when the computational aspects of such functions are implemented in C or Fortran and wrapped with F2PY (or any other tool capable of providing the <code>CObject</code> of a function).</p> <p>Consider a Fortran 77 file <code>`ftype.f</code>:</p>  <pre data-language="fortran">C FILE: FTYPE.F
      SUBROUTINE FOO(N)
      INTEGER N
Cf2py integer optional,intent(in) :: n = 13
      REAL A,X
      COMMON /DATA/ A,X(3)
      PRINT*, "IN FOO: N=",N," A=",A," X=[",X(1),X(2),X(3),"]"
      END
C END OF FTYPE.F
</pre>  <p>and a wrapper built using <code>f2py -c ftype.f -m ftype</code>.</p> <p>In Python:</p>  <pre data-language="python">&gt;&gt;&gt; import ftype
&gt;&gt;&gt; print(ftype.__doc__)
This module 'ftype' is auto-generated with f2py (version:2).
Functions:
  foo(n=13)
COMMON blocks:
  /data/ a,x(3)
.
&gt;&gt;&gt; type(ftype.foo), type(ftype.data)
(&lt;class 'fortran'&gt;, &lt;class 'fortran'&gt;)
&gt;&gt;&gt; ftype.foo()
 IN FOO: N= 13 A=  0. X=[  0.  0.  0.]
&gt;&gt;&gt; ftype.data.a = 3
&gt;&gt;&gt; ftype.data.x = [1,2,3]
&gt;&gt;&gt; ftype.foo()
 IN FOO: N= 13 A=  3. X=[  1.  2.  3.]
&gt;&gt;&gt; ftype.data.x[1] = 45  
&gt;&gt;&gt; ftype.foo(24)
 IN FOO: N= 24 A=  3. X=[  1.  45.  3.]
&gt;&gt;&gt; ftype.data.x
array([  1.,  45.,   3.], dtype=float32)
</pre>  <section id="scalar-arguments"> <h2>Scalar arguments</h2> <p>In general, a scalar argument for a F2PY generated wrapper function can be an ordinary Python scalar (integer, float, complex number) as well as an arbitrary sequence object (list, tuple, array, string) of scalars. In the latter case, the first element of the sequence object is passed to Fortran routine as a scalar argument.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <ul class="simple"> <li>
<p>When type-casting is required and there is possible loss of information via narrowing e.g. when type-casting float to integer or complex to float, F2PY <em>does not</em> raise an exception.</p> <ul> <li>For complex to real type-casting only the real part of a complex number is used.</li> </ul> </li> <li>
<code>intent(inout)</code> scalar arguments are assumed to be array objects in order to have <em>in situ</em> changes be effective. It is recommended to use arrays with proper type but also other types work.</li> </ul> </div> <p>Consider the following Fortran 77 code:</p>  <pre data-language="fortran">C FILE: SCALAR.F
      SUBROUTINE FOO(A,B)
      REAL*8 A, B
Cf2py intent(in) a
Cf2py intent(inout) b
      PRINT*, "    A=",A," B=",B
      PRINT*, "INCREMENT A AND B"
      A = A + 1D0
      B = B + 1D0
      PRINT*, "NEW A=",A," B=",B
      END
C END OF FILE SCALAR.F
</pre>  <p>and wrap it using <code>f2py -c -m scalar scalar.f</code>.</p> <p>In Python:</p>  <pre data-language="python">&gt;&gt;&gt; import scalar
&gt;&gt;&gt; print(scalar.foo.__doc__)
foo(a,b)

Wrapper for ``foo``.

Parameters
----------
a : input float
b : in/output rank-0 array(float,'d')
 
&gt;&gt;&gt; scalar.foo(2, 3)   
     A=  2. B=  3.
 INCREMENT A AND B
 NEW A=  3. B=  4.
&gt;&gt;&gt; import numpy
&gt;&gt;&gt; a = numpy.array(2)   # these are integer rank-0 arrays
&gt;&gt;&gt; b = numpy.array(3)
&gt;&gt;&gt; scalar.foo(a, b)
     A=  2. B=  3.
 INCREMENT A AND B
 NEW A=  3. B=  4.
&gt;&gt;&gt; print(a, b)          # note that only b is changed in situ
2 4
</pre>  </section> <section id="string-arguments"> <h2>String arguments</h2> <p>F2PY generated wrapper functions accept almost any Python object as a string argument, since <code>str</code> is applied for non-string objects. Exceptions are NumPy arrays that must have type code <code>'c'</code> or <code>'1'</code> when used as string arguments.</p> <p>A string can have an arbitrary length when used as a string argument for an F2PY generated wrapper function. If the length is greater than expected, the string is truncated silently. If the length is smaller than expected, additional memory is allocated and filled with <code>\0</code>.</p> <p>Because Python strings are immutable, an <code>intent(inout)</code> argument expects an array version of a string in order to have <em>in situ</em> changes be effective.</p> <p>Consider the following Fortran 77 code:</p>  <pre data-language="fortran">C FILE: STRING.F
      SUBROUTINE FOO(A,B,C,D)
      CHARACTER*5 A, B
      CHARACTER*(*) C,D
Cf2py intent(in) a,c
Cf2py intent(inout) b,d
      PRINT*, "A=",A
      PRINT*, "B=",B
      PRINT*, "C=",C
      PRINT*, "D=",D
      PRINT*, "CHANGE A,B,C,D"
      A(1:1) = 'A'
      B(1:1) = 'B'
      C(1:1) = 'C'
      D(1:1) = 'D'
      PRINT*, "A=",A
      PRINT*, "B=",B
      PRINT*, "C=",C
      PRINT*, "D=",D
      END
C END OF FILE STRING.F
</pre>  <p>and wrap it using <code>f2py -c -m mystring string.f</code>.</p> <p>Python session:</p>  <pre data-language="python">&gt;&gt;&gt; import mystring
&gt;&gt;&gt; print(mystring.foo.__doc__)
foo(a,b,c,d)

Wrapper for ``foo``.

Parameters
----------
a : input string(len=5)
b : in/output rank-0 array(string(len=5),'c')
c : input string(len=-1)
d : in/output rank-0 array(string(len=-1),'c')

&gt;&gt;&gt; from numpy import array
&gt;&gt;&gt; a = array(b'123\0\0')
&gt;&gt;&gt; b = array(b'123\0\0')
&gt;&gt;&gt; c = array(b'123')
&gt;&gt;&gt; d = array(b'123')
&gt;&gt;&gt; mystring.foo(a, b, c, d)
 A=123
 B=123
 C=123
 D=123
 CHANGE A,B,C,D
 A=A23
 B=B23
 C=C23
 D=D23
&gt;&gt;&gt; a[()], b[()], c[()], d[()]
(b'123', b'B23', b'123', b'D2')
</pre>  </section> <section id="array-arguments"> <h2>Array arguments</h2> <p>In general, array arguments for F2PY generated wrapper functions accept arbitrary sequences that can be transformed to NumPy array objects. There are two notable exceptions:</p> <ul class="simple"> <li>
<code>intent(inout)</code> array arguments must always be proper-contiguous (defined below) and have a compatible <code>dtype</code>, otherwise an exception is raised.</li> <li>
<code>intent(inplace)</code> array arguments will be changed <em>in situ</em> if the argument has a different type than expected (see the <code>intent(inplace)</code> attribute for more information).</li> </ul> <p>In general, if a NumPy array is proper-contiguous and has a proper type then it is directly passed to the wrapped Fortran/C function. Otherwise, an element-wise copy of the input array is made and the copy, being proper-contiguous and with proper type, is used as the array argument.</p> <p>There are two types of proper-contiguous NumPy arrays:</p> <ul class="simple"> <li>Fortran-contiguous arrays refer to data that is stored columnwise, i.e. the indexing of data as stored in memory starts from the lowest dimension;</li> <li>C-contiguous, or simply contiguous arrays, refer to data that is stored rowwise, i.e. the indexing of data as stored in memory starts from the highest dimension.</li> </ul> <p>For one-dimensional arrays these notions coincide.</p> <p>For example, a 2x2 array <code>A</code> is Fortran-contiguous if its elements are stored in memory in the following order:</p> <pre data-language="python">A[0,0] A[1,0] A[0,1] A[1,1]
</pre> <p>and C-contiguous if the order is as follows:</p> <pre data-language="python">A[0,0] A[0,1] A[1,0] A[1,1]
</pre> <p>To test whether an array is C-contiguous, use the <code>.flags.c_contiguous</code> attribute of NumPy arrays. To test for Fortran contiguity, use the <code>.flags.f_contiguous</code> attribute.</p> <p>Usually there is no need to worry about how the arrays are stored in memory and whether the wrapped functions, being either Fortran or C functions, assume one or another storage order. F2PY automatically ensures that wrapped functions get arguments with the proper storage order; the underlying algorithm is designed to make copies of arrays only when absolutely necessary. However, when dealing with very large multidimensional input arrays with sizes close to the size of the physical memory in your computer, then care must be taken to ensure the usage of proper-contiguous and proper type arguments.</p> <p>To transform input arrays to column major storage order before passing them to Fortran routines, use the function <code>numpy.asfortranarray(&lt;array&gt;)</code>.</p> <p>Consider the following Fortran 77 code:</p>  <pre data-language="fortran">C FILE: ARRAY.F
      SUBROUTINE FOO(A,N,M)
C
C     INCREMENT THE FIRST ROW AND DECREMENT THE FIRST COLUMN OF A
C
      INTEGER N,M,I,J
      REAL*8 A(N,M)
Cf2py intent(in,out,copy) a
Cf2py integer intent(hide),depend(a) :: n=shape(a,0), m=shape(a,1)
      DO J=1,M
         A(1,J) = A(1,J) + 1D0
      ENDDO
      DO I=1,N
         A(I,1) = A(I,1) - 1D0
      ENDDO
      END
C END OF FILE ARRAY.F
</pre>  <p>and wrap it using <code>f2py -c -m arr array.f -DF2PY_REPORT_ON_ARRAY_COPY=1</code>.</p> <p>In Python:</p>  <pre data-language="python">&gt;&gt;&gt; import arr
&gt;&gt;&gt; from numpy import asfortranarray
&gt;&gt;&gt; print(arr.foo.__doc__)
a = foo(a,[overwrite_a])

Wrapper for ``foo``.

Parameters
----------
a : input rank-2 array('d') with bounds (n,m)

Other Parameters
----------------
overwrite_a : input int, optional
    Default: 0

Returns
-------
a : rank-2 array('d') with bounds (n,m)

&gt;&gt;&gt; a = arr.foo([[1, 2, 3],
...              [4, 5, 6]])
created an array from object
&gt;&gt;&gt; print(a)
[[ 1.  3.  4.]
 [ 3.  5.  6.]]
&gt;&gt;&gt; a.flags.c_contiguous
False
&gt;&gt;&gt; a.flags.f_contiguous
True
# even if a is proper-contiguous and has proper type,
# a copy is made forced by intent(copy) attribute
# to preserve its original contents
&gt;&gt;&gt; b = arr.foo(a)
copied an array: size=6, elsize=8
&gt;&gt;&gt; print(a)
[[ 1.  3.  4.]
 [ 3.  5.  6.]]
&gt;&gt;&gt; print(b)
[[ 1.  4.  5.]
 [ 2.  5.  6.]]
&gt;&gt;&gt; b = arr.foo(a, overwrite_a = 1) # a is passed directly to Fortran
...                                 # routine and its contents is discarded
... 
&gt;&gt;&gt; print(a)
[[ 1.  4.  5.]
 [ 2.  5.  6.]]
&gt;&gt;&gt; print(b)
[[ 1.  4.  5.]
 [ 2.  5.  6.]]
&gt;&gt;&gt; a is b                          # a and b are actually the same objects
True
&gt;&gt;&gt; print(arr.foo([1, 2, 3]))       # different rank arrays are allowed
created an array from object
[ 1.  1.  2.]
&gt;&gt;&gt; print(arr.foo([[[1], [2], [3]]]))
created an array from object
[[[ 1.]
  [ 1.]
  [ 2.]]]
&gt;&gt;&gt;
&gt;&gt;&gt; # Creating arrays with column major data storage order:
 ...
&gt;&gt;&gt; s = asfortranarray([[1, 2, 3], [4, 5, 6]])
&gt;&gt;&gt; s.flags.f_contiguous
True
&gt;&gt;&gt; print(s)
[[1 2 3]
 [4 5 6]]
&gt;&gt;&gt; print(arr.foo(s))
&gt;&gt;&gt; s2 = asfortranarray(s)
&gt;&gt;&gt; s2 is s    # an array with column major storage order 
               # is returned immediately
True
&gt;&gt;&gt; # Note that arr.foo returns a column major data storage order array:
 ...
&gt;&gt;&gt; s3 = ascontiguousarray(s)
&gt;&gt;&gt; s3.flags.f_contiguous
False
&gt;&gt;&gt; s3.flags.c_contiguous
True
&gt;&gt;&gt; s3 = arr.foo(s3)
copied an array: size=6, elsize=8
&gt;&gt;&gt; s3.flags.f_contiguous
True
&gt;&gt;&gt; s3.flags.c_contiguous
False
</pre>  </section> <section id="call-back-arguments"> <h2 id="id1">Call-back arguments</h2> <p>F2PY supports calling Python functions from Fortran or C codes.</p> <p>Consider the following Fortran 77 code:</p>  <pre data-language="fortran">C FILE: CALLBACK.F
      SUBROUTINE FOO(FUN,R)
      EXTERNAL FUN
      INTEGER I
      REAL*8 R, FUN
Cf2py intent(out) r
      R = 0D0
      DO I=-5,5
         R = R + FUN(I)
      ENDDO
      END
C END OF FILE CALLBACK.F
</pre>  <p>and wrap it using <code>f2py -c -m callback callback.f</code>.</p> <p>In Python:</p>  <pre data-language="python">&gt;&gt;&gt; import callback
&gt;&gt;&gt; print(callback.foo.__doc__)
r = foo(fun,[fun_extra_args])

Wrapper for ``foo``.

Parameters
----------
fun : call-back function

Other Parameters
----------------
fun_extra_args : input tuple, optional
    Default: ()

Returns
-------
r : float

Notes
-----
Call-back functions::

  def fun(i): return r
  Required arguments:
    i : input int
  Return objects:
    r : float

&gt;&gt;&gt; def f(i): return i*i
... 
&gt;&gt;&gt; print(callback.foo(f))
110.0
&gt;&gt;&gt; print(callback.foo(lambda i:1))
11.0
</pre>  <p>In the above example F2PY was able to guess accurately the signature of the call-back function. However, sometimes F2PY cannot establish the appropriate signature; in these cases the signature of the call-back function must be explicitly defined in the signature file.</p> <p>To facilitate this, signature files may contain special modules (the names of these modules contain the special <code>__user__</code> sub-string) that defines the various signatures for call-back functions. Callback arguments in routine signatures have the <code>external</code> attribute (see also the <code>intent(callback)</code> attribute). To relate a callback argument with its signature in a <code>__user__</code> module block, a <code>use</code> statement can be utilized as illustrated below. The same signature for a callback argument can be referred to in different routine signatures.</p> <p>We use the same Fortran 77 code as in the previous example but now we will pretend that F2PY was not able to guess the signatures of call-back arguments correctly. First, we create an initial signature file <code>callback2.pyf</code> using F2PY:</p> <pre data-language="python">f2py -m callback2 -h callback2.pyf callback.f
</pre> <p>Then modify it as follows</p>  <pre data-language="python">!    -*- f90 -*-
python module __user__routines 
    interface
        function fun(i) result (r)
            integer :: i
            real*8 :: r
        end function fun
    end interface
end python module __user__routines

python module callback2
    interface
        subroutine foo(f,r)
            use __user__routines, f=&gt;fun
            external f
            real*8 intent(out) :: r
        end subroutine foo
    end interface 
end python module callback2
</pre>  <p>Finally, we build the extension module using <code>f2py -c callback2.pyf callback.f</code>.</p> <p>An example Python session for this snippet would be identical to the previous example except that the argument names would differ.</p> <p>Sometimes a Fortran package may require that users provide routines that the package will use. F2PY can construct an interface to such routines so that Python functions can be called from Fortran.</p> <p>Consider the following Fortran 77 subroutine that takes an array as its input and applies a function <code>func</code> to its elements.</p>  <pre data-language="fortran">      subroutine calculate(x,n)
cf2py intent(callback) func
      external func
c     The following lines define the signature of func for F2PY:
cf2py real*8 y
cf2py y = func(y)
c
cf2py intent(in,out,copy) x
      integer n,i
      real*8 x(n), func
      do i=1,n
         x(i) = func(x(i))
      end do
      end
</pre>  <p>The Fortran code expects that the function <code>func</code> has been defined externally. In order to use a Python function for <code>func</code>, it must have an attribute <code>intent(callback)</code> and, it must be specified before the <code>external</code> statement.</p> <p>Finally, build an extension module using <code>f2py -c -m foo calculate.f</code></p> <p>In Python:</p>  <pre data-language="python">&gt;&gt;&gt; import foo
&gt;&gt;&gt; foo.calculate(range(5), lambda x: x*x)
array([  0.,   1.,   4.,   9.,  16.])
&gt;&gt;&gt; import math
&gt;&gt;&gt; foo.calculate(range(5), math.exp)
array([  1.        ,   2.71828183,   7.3890561,  20.08553692,  54.59815003])
</pre>  <p>The function is included as an argument to the python function call to the Fortran subroutine even though it was <em>not</em> in the Fortran subroutine argument list. The “external” keyword refers to the C function generated by f2py, not the python function itself. The python function is essentially being supplied to the C function.</p> <p>The callback function may also be explicitly set in the module. Then it is not necessary to pass the function in the argument list to the Fortran function. This may be desired if the Fortran function calling the python callback function is itself called by another Fortran function.</p> <p>Consider the following Fortran 77 subroutine:</p>  <pre data-language="fortran">      subroutine f1()
         print *, "in f1, calling f2 twice.."
         call f2()
         call f2()
         return
      end
      
      subroutine f2()
cf2py    intent(callback, hide) fpy
         external fpy
         print *, "in f2, calling f2py.."
         call fpy()
         return
      end
</pre>  <p>and wrap it using <code>f2py -c -m pfromf extcallback.f</code>.</p> <p>In Python:</p>  <pre data-language="python">&gt;&gt;&gt; import pfromf
&gt;&gt;&gt; pfromf.f2()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
pfromf.error: Callback fpy not defined (as an argument or module pfromf attribute).

&gt;&gt;&gt; def f(): print("python f")
... 
&gt;&gt;&gt; pfromf.fpy = f
&gt;&gt;&gt; pfromf.f2()
 in f2, calling f2py..
python f
&gt;&gt;&gt; pfromf.f1()
 in f1, calling f2 twice..
 in f2, calling f2py..
python f
 in f2, calling f2py..
python f
&gt;&gt;&gt; 
</pre>  </section> <section id="resolving-arguments-to-call-back-functions"> <h2>Resolving arguments to call-back functions</h2> <p>F2PY generated interfaces are very flexible with respect to call-back arguments. For each call-back argument an additional optional argument <code>&lt;name&gt;_extra_args</code> is introduced by F2PY. This argument can be used to pass extra arguments to user provided call-back functions.</p> <p>If a F2PY generated wrapper function expects the following call-back argument:</p> <pre data-language="python">def fun(a_1,...,a_n):
   ...
   return x_1,...,x_k
</pre> <p>but the following Python function</p> <pre data-language="python">def gun(b_1,...,b_m):
   ...
   return y_1,...,y_l
</pre> <p>is provided by a user, and in addition,</p> <pre data-language="python">fun_extra_args = (e_1,...,e_p)
</pre> <p>is used, then the following rules are applied when a Fortran or C function evaluates the call-back argument <code>gun</code>:</p> <ul class="simple"> <li>If <code>p == 0</code> then <code>gun(a_1, ..., a_q)</code> is called, here <code>q = min(m, n)</code>.</li> <li>If <code>n + p &lt;= m</code> then <code>gun(a_1, ..., a_n, e_1, ..., e_p)</code> is called.</li> <li>If <code>p &lt;= m &lt; n + p</code> then <code>gun(a_1, ..., a_q, e_1, ..., e_p)</code> is called, here <code>q=m-p</code>.</li> <li>If <code>p &gt; m</code> then <code>gun(e_1, ..., e_m)</code> is called.</li> <li>If <code>n + p</code> is less than the number of required arguments to <code>gun</code> then an exception is raised.</li> </ul> <p>If the function <code>gun</code> may return any number of objects as a tuple; then the following rules are applied:</p> <ul class="simple"> <li>If <code>k &lt; l</code>, then <code>y_{k + 1}, ..., y_l</code> are ignored.</li> <li>If <code>k &gt; l</code>, then only <code>x_1, ..., x_l</code> are set.</li> </ul> </section> <section id="common-blocks"> <h2>Common blocks</h2> <p>F2PY generates wrappers to <code>common</code> blocks defined in a routine signature block. Common blocks are visible to all Fortran codes linked to the current extension module, but not to other extension modules (this restriction is due to the way Python imports shared libraries). In Python, the F2PY wrappers to <code>common</code> blocks are <code>fortran</code> type objects that have (dynamic) attributes related to the data members of the common blocks. When accessed, these attributes return as NumPy array objects (multidimensional arrays are Fortran-contiguous) which directly link to data members in common blocks. Data members can be changed by direct assignment or by in-place changes to the corresponding array objects.</p> <p>Consider the following Fortran 77 code:</p>  <pre data-language="fortran">C FILE: COMMON.F
      SUBROUTINE FOO
      INTEGER I,X
      REAL A
      COMMON /DATA/ I,X(4),A(2,3)
      PRINT*, "I=",I
      PRINT*, "X=[",X,"]"
      PRINT*, "A=["
      PRINT*, "[",A(1,1),",",A(1,2),",",A(1,3),"]"
      PRINT*, "[",A(2,1),",",A(2,2),",",A(2,3),"]"
      PRINT*, "]"
      END
C END OF COMMON.F
</pre>  <p>and wrap it using <code>f2py -c -m common common.f</code>.</p> <p>In Python:</p>  <pre data-language="python">&gt;&gt;&gt; import common
&gt;&gt;&gt; print(common.data.__doc__)
i : 'i'-scalar
x : 'i'-array(4)
a : 'f'-array(2,3)

&gt;&gt;&gt; common.data.i = 5
&gt;&gt;&gt; common.data.x[1] = 2 
&gt;&gt;&gt; common.data.a = [[1,2,3],[4,5,6]]
&gt;&gt;&gt; common.foo()
&gt;&gt;&gt; common.foo()
 I=           5
 X=[           0           2           0           0 ]
 A=[
 [   1.00000000     ,   2.00000000     ,   3.00000000     ]
 [   4.00000000     ,   5.00000000     ,   6.00000000     ]
 ]
&gt;&gt;&gt; common.data.a[1] = 45
&gt;&gt;&gt; common.foo()
 I=           5
 X=[           0           2           0           0 ]
 A=[
 [   1.00000000     ,   2.00000000     ,   3.00000000     ]
 [   45.0000000     ,   45.0000000     ,   45.0000000     ]
 ]
&gt;&gt;&gt; common.data.a                 # a is Fortran-contiguous
array([[  1.,   2.,   3.],
       [ 45.,  45.,  45.]], dtype=float32)
&gt;&gt;&gt; common.data.a.flags.f_contiguous
True
</pre>  </section> <section id="fortran-90-module-data"> <h2>Fortran 90 module data</h2> <p>The F2PY interface to Fortran 90 module data is similar to the handling of Fortran 77 common blocks.</p> <p>Consider the following Fortran 90 code:</p>  <pre data-language="fortran">module mod
  integer i
  integer :: x(4)
  real, dimension(2,3) :: a
  real, allocatable, dimension(:,:) :: b 
contains
  subroutine foo
    integer k
    print*, "i=",i
    print*, "x=[",x,"]"
    print*, "a=["
    print*, "[",a(1,1),",",a(1,2),",",a(1,3),"]"
    print*, "[",a(2,1),",",a(2,2),",",a(2,3),"]"
    print*, "]"
    print*, "Setting a(1,2)=a(1,2)+3"
    a(1,2) = a(1,2)+3
  end subroutine foo
end module mod
</pre>  <p>and wrap it using <code>f2py -c -m moddata moddata.f90</code>.</p> <p>In Python:</p>  <pre data-language="python">&gt;&gt;&gt; import moddata
&gt;&gt;&gt; print(moddata.mod.__doc__)
i : 'i'-scalar
x : 'i'-array(4)
a : 'f'-array(2,3)
b : 'f'-array(-1,-1), not allocated
foo()

Wrapper for ``foo``.



&gt;&gt;&gt; moddata.mod.i = 5  
&gt;&gt;&gt; moddata.mod.x[:2] = [1,2]
&gt;&gt;&gt; moddata.mod.a = [[1,2,3],[4,5,6]]
&gt;&gt;&gt; moddata.mod.foo()                
 i=           5
 x=[           1           2           0           0 ]
 a=[
 [   1.000000     ,   2.000000     ,   3.000000     ]
 [   4.000000     ,   5.000000     ,   6.000000     ]
 ]
 Setting a(1,2)=a(1,2)+3
&gt;&gt;&gt; moddata.mod.a               # a is Fortran-contiguous
array([[ 1.,  5.,  3.],
       [ 4.,  5.,  6.]], dtype=float32)
&gt;&gt;&gt; moddata.mod.a.flags.f_contiguous
True
</pre>  </section> <section id="allocatable-arrays"> <h2>Allocatable arrays</h2> <p>F2PY has basic support for Fortran 90 module allocatable arrays.</p> <p>Consider the following Fortran 90 code:</p>  <pre data-language="fortran">module mod
  real, allocatable, dimension(:,:) :: b 
contains
  subroutine foo
    integer k
    if (allocated(b)) then
       print*, "b=["
       do k = 1,size(b,1)
          print*, b(k,1:size(b,2))
       enddo
       print*, "]"
    else
       print*, "b is not allocated"
    endif
  end subroutine foo
end module mod
</pre>  <p>and wrap it using <code>f2py -c -m allocarr allocarr.f90</code>.</p> <p>In Python:</p>  <pre data-language="python">&gt;&gt;&gt; import allocarr
&gt;&gt;&gt; print(allocarr.mod.__doc__)
b : 'f'-array(-1,-1), not allocated
foo()

Wrapper for ``foo``.



&gt;&gt;&gt; allocarr.mod.foo()  
 b is not allocated
&gt;&gt;&gt; allocarr.mod.b = [[1, 2, 3], [4, 5, 6]]             # allocate/initialize b
&gt;&gt;&gt; allocarr.mod.foo()
 b=[
   1.000000       2.000000       3.000000    
   4.000000       5.000000       6.000000    
 ]
&gt;&gt;&gt; allocarr.mod.b                                      # b is Fortran-contiguous
array([[ 1.,  2.,  3.],
       [ 4.,  5.,  6.]], dtype=float32)
&gt;&gt;&gt; allocarr.mod.b.flags.f_contiguous
True
&gt;&gt;&gt; allocarr.mod.b = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]  # reallocate/initialize b
&gt;&gt;&gt; allocarr.mod.foo()
 b=[
   1.000000       2.000000       3.000000    
   4.000000       5.000000       6.000000    
   7.000000       8.000000       9.000000    
 ]
&gt;&gt;&gt; allocarr.mod.b = None                               # deallocate array
&gt;&gt;&gt; allocarr.mod.foo()
 b is not allocated
</pre>  </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/f2py/python-usage.html" class="_attribution-link">https://numpy.org/doc/1.22/f2py/python-usage.html</a>
  </p>
</div>
