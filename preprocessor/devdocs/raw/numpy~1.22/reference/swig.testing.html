<h1>Testing the numpy.i Typemaps</h1> <section id="introduction"> <h2>Introduction</h2> <p>Writing tests for the <code>numpy.i</code> <a class="reference external" href="http://www.swig.org">SWIG</a> interface file is a combinatorial headache. At present, 12 different data types are supported, each with 74 different argument signatures, for a total of 888 typemaps supported “out of the box”. Each of these typemaps, in turn, might require several unit tests in order to verify expected behavior for both proper and improper inputs. Currently, this results in more than 1,000 individual unit tests executed when <code>make test</code> is run in the <code>numpy/tools/swig</code> subdirectory.</p> <p>To facilitate this many similar unit tests, some high-level programming techniques are employed, including C and <a class="reference external" href="http://www.swig.org">SWIG</a> macros, as well as Python inheritance. The purpose of this document is to describe the testing infrastructure employed to verify that the <code>numpy.i</code> typemaps are working as expected.</p> </section> <section id="testing-organization"> <h2>Testing Organization</h2> <p>There are three independent testing frameworks supported, for one-, two-, and three-dimensional arrays respectively. For one-dimensional arrays, there are two C++ files, a header and a source, named:</p> <pre data-language="python">Vector.h
Vector.cxx
</pre> <p>that contain prototypes and code for a variety of functions that have one-dimensional arrays as function arguments. The file:</p> <pre data-language="python">Vector.i
</pre> <p>is a <a class="reference external" href="http://www.swig.org">SWIG</a> interface file that defines a python module <code>Vector</code> that wraps the functions in <code>Vector.h</code> while utilizing the typemaps in <code>numpy.i</code> to correctly handle the C arrays.</p> <p>The <code>Makefile</code> calls <code>swig</code> to generate <code>Vector.py</code> and <code>Vector_wrap.cxx</code>, and also executes the <code>setup.py</code> script that compiles <code>Vector_wrap.cxx</code> and links together the extension module <code>_Vector.so</code> or <code>_Vector.dylib</code>, depending on the platform. This extension module and the proxy file <code>Vector.py</code> are both placed in a subdirectory under the <code>build</code> directory.</p> <p>The actual testing takes place with a Python script named:</p> <pre data-language="python">testVector.py
</pre> <p>that uses the standard Python library module <code>unittest</code>, which performs several tests of each function defined in <code>Vector.h</code> for each data type supported.</p> <p>Two-dimensional arrays are tested in exactly the same manner. The above description applies, but with <code>Matrix</code> substituted for <code>Vector</code>. For three-dimensional tests, substitute <code>Tensor</code> for <code>Vector</code>. For four-dimensional tests, substitute <code>SuperTensor</code> for <code>Vector</code>. For flat in-place array tests, substitute <code>Flat</code> for <code>Vector</code>. For the descriptions that follow, we will reference the <code>Vector</code> tests, but the same information applies to <code>Matrix</code>, <code>Tensor</code> and <code>SuperTensor</code> tests.</p> <p>The command <code>make test</code> will ensure that all of the test software is built and then run all three test scripts.</p> </section> <section id="testing-header-files"> <h2>Testing Header Files</h2> <p><code>Vector.h</code> is a C++ header file that defines a C macro called <code>TEST_FUNC_PROTOS</code> that takes two arguments: <code>TYPE</code>, which is a data type name such as <code>unsigned int</code>; and <code>SNAME</code>, which is a short name for the same data type with no spaces, e.g. <code>uint</code>. This macro defines several function prototypes that have the prefix <code>SNAME</code> and have at least one argument that is an array of type <code>TYPE</code>. Those functions that have return arguments return a <code>TYPE</code> value.</p> <p><code>TEST_FUNC_PROTOS</code> is then implemented for all of the data types supported by <code>numpy.i</code>:</p>  <ul class="simple"> <li><code>signed char</code></li> <li><code>unsigned char</code></li> <li><code>short</code></li> <li><code>unsigned short</code></li> <li><code>int</code></li> <li><code>unsigned int</code></li> <li><code>long</code></li> <li><code>unsigned long</code></li> <li><code>long long</code></li> <li><code>unsigned long long</code></li> <li><code>float</code></li> <li><code>double</code></li> </ul>  </section> <section id="testing-source-files"> <h2>Testing Source Files</h2> <p><code>Vector.cxx</code> is a C++ source file that implements compilable code for each of the function prototypes specified in <code>Vector.h</code>. It defines a C macro <code>TEST_FUNCS</code> that has the same arguments and works in the same way as <code>TEST_FUNC_PROTOS</code> does in <code>Vector.h</code>. <code>TEST_FUNCS</code> is implemented for each of the 12 data types as above.</p> </section> <section id="testing-swig-interface-files"> <h2>Testing SWIG Interface Files</h2> <p><code>Vector.i</code> is a <a class="reference external" href="http://www.swig.org">SWIG</a> interface file that defines python module <code>Vector</code>. It follows the conventions for using <code>numpy.i</code> as described in this chapter. It defines a <a class="reference external" href="http://www.swig.org">SWIG</a> macro <code>%apply_numpy_typemaps</code> that has a single argument <code>TYPE</code>. It uses the <a class="reference external" href="http://www.swig.org">SWIG</a> directive <code>%apply</code> to apply the provided typemaps to the argument signatures found in <code>Vector.h</code>. This macro is then implemented for all of the data types supported by <code>numpy.i</code>. It then does a <code>%include "Vector.h"</code> to wrap all of the function prototypes in <code>Vector.h</code> using the typemaps in <code>numpy.i</code>.</p> </section> <section id="testing-python-scripts"> <h2>Testing Python Scripts</h2> <p>After <code>make</code> is used to build the testing extension modules, <code>testVector.py</code> can be run to execute the tests. As with other scripts that use <code>unittest</code> to facilitate unit testing, <code>testVector.py</code> defines a class that inherits from <code>unittest.TestCase</code>:</p> <pre data-language="python">class VectorTestCase(unittest.TestCase):
</pre> <p>However, this class is not run directly. Rather, it serves as a base class to several other python classes, each one specific to a particular data type. The <code>VectorTestCase</code> class stores two strings for typing information:</p>  <dl class="simple"> <dt><strong>self.typeStr</strong></dt>
<dd>
<p>A string that matches one of the <code>SNAME</code> prefixes used in <code>Vector.h</code> and <code>Vector.cxx</code>. For example, <code>"double"</code>.</p> </dd> <dt><strong>self.typeCode</strong></dt>
<dd>
<p>A short (typically single-character) string that represents a data type in numpy and corresponds to <code>self.typeStr</code>. For example, if <code>self.typeStr</code> is <code>"double"</code>, then <code>self.typeCode</code> should be <code>"d"</code>.</p> </dd> </dl>  <p>Each test defined by the <code>VectorTestCase</code> class extracts the python function it is trying to test by accessing the <code>Vector</code> module’s dictionary:</p> <pre data-language="python">length = Vector.__dict__[self.typeStr + "Length"]
</pre> <p>In the case of double precision tests, this will return the python function <code>Vector.doubleLength</code>.</p> <p>We then define a new test case class for each supported data type with a short definition such as:</p> <pre data-language="python">class doubleTestCase(VectorTestCase):
    def __init__(self, methodName="runTest"):
        VectorTestCase.__init__(self, methodName)
        self.typeStr  = "double"
        self.typeCode = "d"
</pre> <p>Each of these 12 classes is collected into a <code>unittest.TestSuite</code>, which is then executed. Errors and failures are summed together and returned as the exit argument. Any non-zero result indicates that at least one test did not pass.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/swig.testing.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/swig.testing.html</a>
  </p>
</div>
