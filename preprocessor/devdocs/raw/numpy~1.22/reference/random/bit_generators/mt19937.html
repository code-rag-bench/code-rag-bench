<h1>Mersenne Twister (MT19937)</h1> <dl class="py class"> <dt class="sig sig-object py" id="numpy.random.MT19937"> <em class="property">class </em><span class="sig-prename descclassname">numpy.random.</span><span class="sig-name descname">MT19937</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>Container for the Mersenne Twister pseudo-random number generator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>seed</strong><span class="classifier">{None, int, array_like[ints], SeedSequence}, optional</span>
</dt>
<dd>
<p>A seed to initialize the <a class="reference internal" href="generated/numpy.random.bitgenerator#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a>. If None, then fresh, unpredictable entropy will be pulled from the OS. If an <code>int</code> or <code>array_like[ints]</code> is passed, then it will be passed to <a class="reference internal" href="generated/numpy.random.seedsequence#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> to derive the initial <a class="reference internal" href="generated/numpy.random.bitgenerator#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a> state. One may also pass in a <a class="reference internal" href="generated/numpy.random.seedsequence#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> instance.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p><code>MT19937</code> provides a capsule containing function pointers that produce doubles, and unsigned 32 and 64- bit integers <a class="reference internal" href="#r312276d80bfa-1" id="id1">[1]</a>. These are not directly consumable in Python and must be consumed by a <code>Generator</code> or similar object that supports low-level access.</p> <p>The Python stdlib module “random” also contains a Mersenne Twister pseudo-random number generator.</p> <p><strong>State and Seeding</strong></p> <p>The <code>MT19937</code> state vector consists of a 624-element array of 32-bit unsigned integers plus a single integer value between 0 and 624 that indexes the current position within the main array.</p> <p>The input seed is processed by <a class="reference internal" href="generated/numpy.random.seedsequence#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> to fill the whole state. The first element is reset such that only its most significant bit is set.</p> <p><strong>Parallel Features</strong></p> <p>The preferred way to use a BitGenerator in parallel applications is to use the <a class="reference internal" href="generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn" title="numpy.random.SeedSequence.spawn"><code>SeedSequence.spawn</code></a> method to obtain entropy values, and to use these to generate new BitGenerators:</p> <pre data-language="python">&gt;&gt;&gt; from numpy.random import Generator, MT19937, SeedSequence
&gt;&gt;&gt; sg = SeedSequence(1234)
&gt;&gt;&gt; rg = [Generator(MT19937(s)) for s in sg.spawn(10)]
</pre> <p>Another method is to use <a class="reference internal" href="generated/numpy.random.mt19937.jumped#numpy.random.MT19937.jumped" title="numpy.random.MT19937.jumped"><code>MT19937.jumped</code></a> which advances the state as-if <span class="math notranslate nohighlight">\(2^{128}\)</span> random numbers have been generated (<a class="reference internal" href="#r312276d80bfa-1" id="id2">[1]</a>, <a class="reference internal" href="#r312276d80bfa-2" id="id3">[2]</a>). This allows the original sequence to be split so that distinct segments can be used in each worker process. All generators should be chained to ensure that the segments come from the same sequence.</p> <pre data-language="python">&gt;&gt;&gt; from numpy.random import Generator, MT19937, SeedSequence
&gt;&gt;&gt; sg = SeedSequence(1234)
&gt;&gt;&gt; bit_generator = MT19937(sg)
&gt;&gt;&gt; rg = []
&gt;&gt;&gt; for _ in range(10):
...    rg.append(Generator(bit_generator))
...    # Chain the BitGenerators
...    bit_generator = bit_generator.jumped()
</pre> <p><strong>Compatibility Guarantee</strong></p> <p><code>MT19937</code> makes a guarantee that a fixed seed and will always produce the same random integer stream.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r312276d80bfa-1">
<span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>)</span>
</dt> <dd>
<p>Hiroshi Haramoto, Makoto Matsumoto, and Pierre L’Ecuyer, “A Fast Jump Ahead Algorithm for Linear Recurrences in a Polynomial Space”, Sequences and Their Applications - SETA, 290–298, 2008.</p> </dd> <dt class="label" id="r312276d80bfa-2"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt> <dd>
<p>Hiroshi Haramoto, Makoto Matsumoto, Takuji Nishimura, François Panneton, Pierre L’Ecuyer, “Efficient Jump Ahead for F2-Linear Random Number Generators”, INFORMS JOURNAL ON COMPUTING, Vol. 20, No. 3, Summer 2008, pp. 385-390.</p> </dd> </dl> <dl class="field-list simple"> <dt class="field-odd">Attributes</dt> <dd class="field-odd">
<dl class="simple"> <dt><strong>lock: threading.Lock</strong></dt>
<dd>
<p>Lock instance that is shared so that the same bit git generator can be used in multiple Generators without corrupting the state. Code that generates values from a bit generator should hold the bit generator’s lock.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <section id="state"> <h2>State</h2> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.random.mt19937.state#numpy.random.MT19937.state" title="numpy.random.MT19937.state"><code>state</code></a></p></td> <td><p>Get or set the PRNG state</p></td> </tr>  </table> </section> <section id="parallel-generation"> <h2>Parallel generation</h2> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.random.mt19937.jumped#numpy.random.MT19937.jumped" title="numpy.random.MT19937.jumped"><code>jumped</code></a>([jumps])</p></td> <td><p>Returns a new bit generator with the state jumped</p></td> </tr>  </table> </section> <section id="extending"> <h2>Extending</h2> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.random.mt19937.cffi#numpy.random.MT19937.cffi" title="numpy.random.MT19937.cffi"><code>cffi</code></a></p></td> <td><p>CFFI interface</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.random.mt19937.ctypes#numpy.random.MT19937.ctypes" title="numpy.random.MT19937.ctypes"><code>ctypes</code></a></p></td> <td><p>ctypes interface</p></td> </tr>  </table> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/random/bit_generators/mt19937.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/random/bit_generators/mt19937.html</a>
  </p>
</div>
