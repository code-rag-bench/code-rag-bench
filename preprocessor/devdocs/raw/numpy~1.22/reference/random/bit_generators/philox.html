<h1>Philox Counter-based RNG</h1> <dl class="py class"> <dt class="sig sig-object py" id="numpy.random.Philox"> <em class="property">class </em><span class="sig-prename descclassname">numpy.random.</span><span class="sig-name descname">Philox</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">counter</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">key</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>Container for the Philox (4x64) pseudo-random number generator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>seed</strong><span class="classifier">{None, int, array_like[ints], SeedSequence}, optional</span>
</dt>
<dd>
<p>A seed to initialize the <a class="reference internal" href="generated/numpy.random.bitgenerator#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a>. If None, then fresh, unpredictable entropy will be pulled from the OS. If an <code>int</code> or <code>array_like[ints]</code> is passed, then it will be passed to <a class="reference internal" href="generated/numpy.random.seedsequence#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> to derive the initial <a class="reference internal" href="generated/numpy.random.bitgenerator#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a> state. One may also pass in a <a class="reference internal" href="generated/numpy.random.seedsequence#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> instance.</p> </dd> <dt>
<strong>counter</strong><span class="classifier">{None, int, array_like}, optional</span>
</dt>
<dd>
<p>Counter to use in the Philox state. Can be either a Python int (long in 2.x) in [0, 2**256) or a 4-element uint64 array. If not provided, the RNG is initialized at 0.</p> </dd> <dt>
<strong>key</strong><span class="classifier">{None, int, array_like}, optional</span>
</dt>
<dd>
<p>Key to use in the Philox state. Unlike <code>seed</code>, the value in key is directly set. Can be either a Python int in [0, 2**128) or a 2-element uint64 array. <code>key</code> and <code>seed</code> cannot both be used.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>Philox is a 64-bit PRNG that uses a counter-based design based on weaker (and faster) versions of cryptographic functions <a class="reference internal" href="#r40f8e2ad755a-1" id="id1">[1]</a>. Instances using different values of the key produce independent sequences. Philox has a period of <span class="math notranslate nohighlight">\(2^{256} - 1\)</span> and supports arbitrary advancing and jumping the sequence in increments of <span class="math notranslate nohighlight">\(2^{128}\)</span>. These features allow multiple non-overlapping sequences to be generated.</p> <p><code>Philox</code> provides a capsule containing function pointers that produce doubles, and unsigned 32 and 64- bit integers. These are not directly consumable in Python and must be consumed by a <code>Generator</code> or similar object that supports low-level access.</p> <p><strong>State and Seeding</strong></p> <p>The <code>Philox</code> state vector consists of a 256-bit value encoded as a 4-element uint64 array and a 128-bit value encoded as a 2-element uint64 array. The former is a counter which is incremented by 1 for every 4 64-bit randoms produced. The second is a key which determined the sequence produced. Using different keys produces independent sequences.</p> <p>The input <code>seed</code> is processed by <a class="reference internal" href="generated/numpy.random.seedsequence#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> to generate the key. The counter is set to 0.</p> <p>Alternately, one can omit the <code>seed</code> parameter and set the <code>key</code> and <code>counter</code> directly.</p> <p><strong>Parallel Features</strong></p> <p>The preferred way to use a BitGenerator in parallel applications is to use the <a class="reference internal" href="generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn" title="numpy.random.SeedSequence.spawn"><code>SeedSequence.spawn</code></a> method to obtain entropy values, and to use these to generate new BitGenerators:</p> <pre data-language="python">&gt;&gt;&gt; from numpy.random import Generator, Philox, SeedSequence
&gt;&gt;&gt; sg = SeedSequence(1234)
&gt;&gt;&gt; rg = [Generator(Philox(s)) for s in sg.spawn(10)]
</pre> <p><code>Philox</code> can be used in parallel applications by calling the <code>jumped</code> method to advances the state as-if <span class="math notranslate nohighlight">\(2^{128}\)</span> random numbers have been generated. Alternatively, <code>advance</code> can be used to advance the counter for any positive step in [0, 2**256). When using <code>jumped</code>, all generators should be chained to ensure that the segments come from the same sequence.</p> <pre data-language="python">&gt;&gt;&gt; from numpy.random import Generator, Philox
&gt;&gt;&gt; bit_generator = Philox(1234)
&gt;&gt;&gt; rg = []
&gt;&gt;&gt; for _ in range(10):
...    rg.append(Generator(bit_generator))
...    bit_generator = bit_generator.jumped()
</pre> <p>Alternatively, <code>Philox</code> can be used in parallel applications by using a sequence of distinct keys where each instance uses different key.</p> <pre data-language="python">&gt;&gt;&gt; key = 2**96 + 2**33 + 2**17 + 2**9
&gt;&gt;&gt; rg = [Generator(Philox(key=key+i)) for i in range(10)]
</pre> <p><strong>Compatibility Guarantee</strong></p> <p><code>Philox</code> makes a guarantee that a fixed <code>seed</code> will always produce the same random integer stream.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r40f8e2ad755a-1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt> <dd>
<p>John K. Salmon, Mark A. Moraes, Ron O. Dror, and David E. Shaw, “Parallel Random Numbers: As Easy as 1, 2, 3,” Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis (SC11), New York, NY: ACM, 2011.</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from numpy.random import Generator, Philox
&gt;&gt;&gt; rg = Generator(Philox(1234))
&gt;&gt;&gt; rg.standard_normal()
0.123  # random
</pre> <dl class="field-list simple"> <dt class="field-odd">Attributes</dt> <dd class="field-odd">
<dl class="simple"> <dt><strong>lock: threading.Lock</strong></dt>
<dd>
<p>Lock instance that is shared so that the same bit git generator can be used in multiple Generators without corrupting the state. Code that generates values from a bit generator should hold the bit generator’s lock.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <section id="state"> <h2>State</h2> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.random.philox.state#numpy.random.Philox.state" title="numpy.random.Philox.state"><code>state</code></a></p></td> <td><p>Get or set the PRNG state</p></td> </tr>  </table> </section> <section id="parallel-generation"> <h2>Parallel generation</h2> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.random.philox.advance#numpy.random.Philox.advance" title="numpy.random.Philox.advance"><code>advance</code></a>(delta)</p></td> <td><p>Advance the underlying RNG as-if delta draws have occurred.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.random.philox.jumped#numpy.random.Philox.jumped" title="numpy.random.Philox.jumped"><code>jumped</code></a>([jumps])</p></td> <td><p>Returns a new bit generator with the state jumped</p></td> </tr>  </table> </section> <section id="extending"> <h2>Extending</h2> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.random.philox.cffi#numpy.random.Philox.cffi" title="numpy.random.Philox.cffi"><code>cffi</code></a></p></td> <td><p>CFFI interface</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.random.philox.ctypes#numpy.random.Philox.ctypes" title="numpy.random.Philox.ctypes"><code>ctypes</code></a></p></td> <td><p>ctypes interface</p></td> </tr>  </table> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/random/bit_generators/philox.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/random/bit_generators/philox.html</a>
  </p>
</div>
