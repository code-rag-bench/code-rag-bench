<h1 id="upgrading-pcg64">Upgrading PCG64 with PCG64DXSM</h1> <p>Uses of the <a class="reference internal" href="bit_generators/pcg64#numpy.random.PCG64" title="numpy.random.PCG64"><code>PCG64</code></a> <a class="reference internal" href="bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a> in a massively-parallel context have been shown to have statistical weaknesses that were not apparent at the first release in numpy 1.17. Most users will never observe this weakness and are safe to continue to use <a class="reference internal" href="bit_generators/pcg64#numpy.random.PCG64" title="numpy.random.PCG64"><code>PCG64</code></a>. We have introduced a new <a class="reference internal" href="bit_generators/pcg64dxsm#numpy.random.PCG64DXSM" title="numpy.random.PCG64DXSM"><code>PCG64DXSM</code></a> <a class="reference internal" href="bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a> that will eventually become the new default <a class="reference internal" href="bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a> implementation used by <a class="reference internal" href="generator#numpy.random.default_rng" title="numpy.random.default_rng"><code>default_rng</code></a> in future releases. <a class="reference internal" href="bit_generators/pcg64dxsm#numpy.random.PCG64DXSM" title="numpy.random.PCG64DXSM"><code>PCG64DXSM</code></a> solves the statistical weakness while preserving the performance and the features of <a class="reference internal" href="bit_generators/pcg64#numpy.random.PCG64" title="numpy.random.PCG64"><code>PCG64</code></a>.</p> <section id="does-this-affect-me"> <h2>Does this affect me?</h2> <p>If you</p>  <ol class="arabic simple"> <li>only use a single <a class="reference internal" href="generator#numpy.random.Generator" title="numpy.random.Generator"><code>Generator</code></a> instance,</li> <li>only use <a class="reference internal" href="legacy#numpy.random.RandomState" title="numpy.random.RandomState"><code>RandomState</code></a> or the functions in <a class="reference internal" href="index#module-numpy.random" title="numpy.random"><code>numpy.random</code></a>,</li> <li>only use the <a class="reference internal" href="bit_generators/generated/numpy.random.pcg64.jumped#numpy.random.PCG64.jumped" title="numpy.random.PCG64.jumped"><code>PCG64.jumped</code></a> method to generate parallel streams,</li> <li>explicitly use a <a class="reference internal" href="bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a> other than <a class="reference internal" href="bit_generators/pcg64#numpy.random.PCG64" title="numpy.random.PCG64"><code>PCG64</code></a>,</li> </ol>  <p>then this weakness does not affect you at all. Carry on.</p> <p>If you use moderate numbers of parallel streams created with <a class="reference internal" href="generator#numpy.random.default_rng" title="numpy.random.default_rng"><code>default_rng</code></a> or <a class="reference internal" href="bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn" title="numpy.random.SeedSequence.spawn"><code>SeedSequence.spawn</code></a>, in the 1000s, then the chance of observing this weakness is negligibly small. You can continue to use <a class="reference internal" href="bit_generators/pcg64#numpy.random.PCG64" title="numpy.random.PCG64"><code>PCG64</code></a> comfortably.</p> <p>If you use very large numbers of parallel streams, in the millions, and draw large amounts of numbers from each, then the chance of observing this weakness can become non-negligible, if still small. An example of such a use case would be a very large distributed reinforcement learning problem with millions of long Monte Carlo playouts each generating billions of random number draws. Such use cases should consider using <a class="reference internal" href="bit_generators/pcg64dxsm#numpy.random.PCG64DXSM" title="numpy.random.PCG64DXSM"><code>PCG64DXSM</code></a> explicitly or another modern <a class="reference internal" href="bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a> like <a class="reference internal" href="bit_generators/sfc64#numpy.random.SFC64" title="numpy.random.SFC64"><code>SFC64</code></a> or <a class="reference internal" href="bit_generators/philox#numpy.random.Philox" title="numpy.random.Philox"><code>Philox</code></a>, but it is unlikely that any old results you may have calculated are invalid. In any case, the weakness is a kind of <a class="reference external" href="https://en.wikipedia.org/wiki/Birthday_problem">Birthday Paradox</a> collision. That is, a single pair of parallel streams out of the millions, considered together, might fail a stringent set of statistical tests of randomness. The remaining millions of streams would all be perfectly fine, and the effect of the bad pair in the whole calculation is very likely to be swamped by the remaining streams in most applications.</p> </section> <section id="technical-details"> <h2 id="upgrading-pcg64-details">Technical Details</h2> <p>Like many PRNG algorithms, <a class="reference internal" href="bit_generators/pcg64#numpy.random.PCG64" title="numpy.random.PCG64"><code>PCG64</code></a> is constructed from a transition function, which advances a 128-bit state, and an output function, that mixes the 128-bit state into a 64-bit integer to be output. One of the guiding design principles of the PCG family of PRNGs is to balance the computational cost (and pseudorandomness strength) between the transition function and the output function. The transition function is a 128-bit linear congruential generator (LCG), which consists of multiplying the 128-bit state with a fixed multiplication constant and then adding a user-chosen increment, in 128-bit modular arithmetic. LCGs are well-analyzed PRNGs with known weaknesses, though 128-bit LCGs are large enough to pass stringent statistical tests on their own, with only the trivial output function. The output function of <a class="reference internal" href="bit_generators/pcg64#numpy.random.PCG64" title="numpy.random.PCG64"><code>PCG64</code></a> is intended to patch up some of those known weaknesses by doing “just enough” scrambling of the bits to assist in the statistical properties without adding too much computational cost.</p> <p>One of these known weaknesses is that advancing the state of the LCG by steps numbering a power of two (<code>bg.advance(2**N)</code>) will leave the lower <code>N</code> bits identical to the state that was just left. For a single stream drawn from sequentially, this is of little consequence. The remaining <span class="math notranslate nohighlight">\(128-N\)</span> bits provide plenty of pseudorandomness that will be mixed in for any practical <code>N</code> that can be observed in a single stream, which is why one does not need to worry about this if you only use a single stream in your application. Similarly, the <a class="reference internal" href="bit_generators/generated/numpy.random.pcg64.jumped#numpy.random.PCG64.jumped" title="numpy.random.PCG64.jumped"><code>PCG64.jumped</code></a> method uses a carefully chosen number of steps to avoid creating these collisions. However, once you start creating “randomly-initialized” parallel streams, either using OS entropy by calling <a class="reference internal" href="generator#numpy.random.default_rng" title="numpy.random.default_rng"><code>default_rng</code></a> repeatedly or using <a class="reference internal" href="bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn" title="numpy.random.SeedSequence.spawn"><code>SeedSequence.spawn</code></a>, then we need to consider how many lower bits need to “collide” in order to create a bad pair of streams, and then evaluate the probability of creating such a collision. <a class="reference external" href="https://github.com/numpy/numpy/issues/16313">Empirically</a>, it has been determined that if one shares the lower 58 bits of state and shares an increment, then the pair of streams, when interleaved, will fail <a class="reference external" href="http://pracrand.sourceforge.net/">PractRand</a> in a reasonable amount of time, after drawing a few gigabytes of data. Following the standard Birthday Paradox calculations for a collision of 58 bits, we can see that we can create <span class="math notranslate nohighlight">\(2^{29}\)</span>, or about half a billion, streams which is when the probability of such a collision becomes high. Half a billion streams is quite high, and the amount of data each stream needs to draw before the statistical correlations become apparent to even the strict <code>PractRand</code> tests is in the gigabytes. But this is on the horizon for very large applications like distributed reinforcement learning. There are reasons to expect that even in these applications a collision probably will not have a practical effect in the total result, since the statistical problem is constrained to just the colliding pair.</p> <p>Now, let us consider the case when the increment is not constrained to be the same. Our implementation of <a class="reference internal" href="bit_generators/pcg64#numpy.random.PCG64" title="numpy.random.PCG64"><code>PCG64</code></a> seeds both the state and the increment; that is, two calls to <a class="reference internal" href="generator#numpy.random.default_rng" title="numpy.random.default_rng"><code>default_rng</code></a> (almost certainly) have different states and increments. Upon our first release, we believed that having the seeded increment would provide a certain amount of extra protection, that one would have to be “close” in both the state space and increment space in order to observe correlations (<code>PractRand</code> failures) in a pair of streams. If that were true, then the “bottleneck” for collisions would be the 128-bit entropy pool size inside of <a class="reference internal" href="bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> (and 128-bit collisions are in the “preposterously unlikely” category). Unfortunately, this is not true.</p> <p>One of the known properties of an LCG is that different increments create <em>distinct</em> streams, but with a known relationship. Each LCG has an orbit that traverses all <span class="math notranslate nohighlight">\(2^{128}\)</span> different 128-bit states. Two LCGs with different increments are related in that one can “rotate” the orbit of the first LCG (advance it by a number of steps that we can compute from the two increments) such that then both LCGs will always then have the same state, up to an additive constant and maybe an inversion of the bits. If you then iterate both streams in lockstep, then the states will <em>always</em> remain related by that same additive constant (and the inversion, if present). Recall that <a class="reference internal" href="bit_generators/pcg64#numpy.random.PCG64" title="numpy.random.PCG64"><code>PCG64</code></a> is constructed from both a transition function (the LCG) and an output function. It was expected that the scrambling effect of the output function would have been strong enough to make the distinct streams practically independent (i.e. “passing the <code>PractRand</code> tests”) unless the two increments were pathologically related to each other (e.g. 1 and 3). The output function XSL-RR of the then-standard PCG algorithm that we implemented in <a class="reference internal" href="bit_generators/pcg64#numpy.random.PCG64" title="numpy.random.PCG64"><code>PCG64</code></a> turns out to be too weak to cover up for the 58-bit collision of the underlying LCG that we described above. For any given pair of increments, the size of the “colliding” space of states is the same, so for this weakness, the extra distinctness provided by the increments does not translate into extra protection from statistical correlations that <code>PractRand</code> can detect.</p> <p>Fortunately, strengthening the output function is able to correct this weakness and <em>does</em> turn the extra distinctness provided by differing increments into additional protection from these low-bit collisions. To the <a class="reference external" href="https://github.com/numpy/numpy/issues/13635#issuecomment-506088698">PCG author’s credit</a>, she had developed a stronger output function in response to related discussions during the long birth of the new <a class="reference internal" href="bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator" title="numpy.random.BitGenerator"><code>BitGenerator</code></a> system. We NumPy developers chose to be “conservative” and use the XSL-RR variant that had undergone a longer period of testing at that time. The DXSM output function adopts a “xorshift-multiply” construction used in strong integer hashes that has much better avalanche properties than the XSL-RR output function. While there are “pathological” pairs of increments that induce “bad” additive constants that relate the two streams, the vast majority of pairs induce “good” additive constants that make the merely-distinct streams of LCG states into practically-independent output streams. Indeed, now the claim we once made about <a class="reference internal" href="bit_generators/pcg64#numpy.random.PCG64" title="numpy.random.PCG64"><code>PCG64</code></a> is actually true of <a class="reference internal" href="bit_generators/pcg64dxsm#numpy.random.PCG64DXSM" title="numpy.random.PCG64DXSM"><code>PCG64DXSM</code></a>: collisions are possible, but both streams have to simultaneously be both “close” in the 128 bit state space <em>and</em> “close” in the 127-bit increment space, so that would be less likely than the negligible chance of colliding in the 128-bit internal <a class="reference internal" href="bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence" title="numpy.random.SeedSequence"><code>SeedSequence</code></a> pool. The DXSM output function is more computationally intensive than XSL-RR, but some optimizations in the LCG more than make up for the performance hit on most machines, so <a class="reference internal" href="bit_generators/pcg64dxsm#numpy.random.PCG64DXSM" title="numpy.random.PCG64DXSM"><code>PCG64DXSM</code></a> is a good, safe upgrade. There are, of course, an infinite number of stronger output functions that one could consider, but most will have a greater computational cost, and the DXSM output function has now received many CPU cycles of testing via <code>PractRand</code> at this time.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/random/upgrading-pcg64.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/random/upgrading-pcg64.html</a>
  </p>
</div>
