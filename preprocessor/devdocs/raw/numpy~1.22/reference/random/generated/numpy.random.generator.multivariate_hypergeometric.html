<h1>numpy.random.Generator.multivariate_hypergeometric</h1> <p>method</p> <dl class="py method"> <dt class="sig sig-object py" id="numpy.random.Generator.multivariate_hypergeometric"> <span class="sig-prename descclassname">random.Generator.</span><span class="sig-name descname">multivariate_hypergeometric</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">colors</span></em>, <em class="sig-param"><span class="n">nsample</span></em>, <em class="sig-param"><span class="n">size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'marginals'</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>Generate variates from a multivariate hypergeometric distribution.</p> <p>The multivariate hypergeometric distribution is a generalization of the hypergeometric distribution.</p> <p>Choose <code>nsample</code> items at random without replacement from a collection with <code>N</code> distinct types. <code>N</code> is the length of <code>colors</code>, and the values in <code>colors</code> are the number of occurrences of that type in the collection. The total number of items in the collection is <code>sum(colors)</code>. Each random variate generated by this function is a vector of length <code>N</code> holding the counts of the different types that occurred in the <code>nsample</code> items.</p> <p>The name <code>colors</code> comes from a common description of the distribution: it is the probability distribution of the number of marbles of each color selected without replacement from an urn containing marbles of different colors; <code>colors[i]</code> is the number of marbles in the urn with color <code>i</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>colors</strong><span class="classifier">sequence of integers</span>
</dt>
<dd>
<p>The number of each type of item in the collection from which a sample is drawn. The values in <code>colors</code> must be nonnegative. To avoid loss of precision in the algorithm, <code>sum(colors)</code> must be less than <code>10**9</code> when <code>method</code> is “marginals”.</p> </dd> <dt>
<strong>nsample</strong><span class="classifier">int</span>
</dt>
<dd>
<p>The number of items selected. <code>nsample</code> must not be greater than <code>sum(colors)</code>.</p> </dd> <dt>
<strong>size</strong><span class="classifier">int or tuple of ints, optional</span>
</dt>
<dd>
<p>The number of variates to generate, either an integer or a tuple holding the shape of the array of variates. If the given size is, e.g., <code>(k, m)</code>, then <code>k * m</code> variates are drawn, where one variate is a vector of length <code>len(colors)</code>, and the return value has shape <code>(k, m, len(colors))</code>. If <code>size</code> is an integer, the output has shape <code>(size, len(colors))</code>. Default is None, in which case a single variate is returned as an array with shape <code>(len(colors),)</code>.</p> </dd> <dt>
<strong>method</strong><span class="classifier">string, optional</span>
</dt>
<dd>
<p>Specify the algorithm that is used to generate the variates. Must be ‘count’ or ‘marginals’ (the default). See the Notes for a description of the methods.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>variates</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p>Array of variates drawn from the multivariate hypergeometric distribution.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="numpy.random.generator.hypergeometric#numpy.random.Generator.hypergeometric" title="numpy.random.Generator.hypergeometric"><code>hypergeometric</code></a></dt>
<dd>
<p>Draw samples from the (univariate) hypergeometric distribution.</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>The two methods do not return the same sequence of variates.</p> <p>The “count” algorithm is roughly equivalent to the following numpy code:</p> <pre data-language="python">choices = np.repeat(np.arange(len(colors)), colors)
selection = np.random.choice(choices, nsample, replace=False)
variate = np.bincount(selection, minlength=len(colors))
</pre> <p>The “count” algorithm uses a temporary array of integers with length <code>sum(colors)</code>.</p> <p>The “marginals” algorithm generates a variate by using repeated calls to the univariate hypergeometric sampler. It is roughly equivalent to:</p> <pre data-language="python">variate = np.zeros(len(colors), dtype=np.int64)
# `remaining` is the cumulative sum of `colors` from the last
# element to the first; e.g. if `colors` is [3, 1, 5], then
# `remaining` is [9, 6, 5].
remaining = np.cumsum(colors[::-1])[::-1]
for i in range(len(colors)-1):
    if nsample &lt; 1:
        break
    variate[i] = hypergeometric(colors[i], remaining[i+1],
                               nsample)
    nsample -= variate[i]
variate[-1] = nsample
</pre> <p>The default method is “marginals”. For some cases (e.g. when <code>colors</code> contains relatively small integers), the “count” method can be significantly faster than the “marginals” method. If performance of the algorithm is important, test the two methods with typical inputs to decide which works best.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.18.0.</span></p> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; colors = [16, 8, 4]
&gt;&gt;&gt; seed = 4861946401452
&gt;&gt;&gt; gen = np.random.Generator(np.random.PCG64(seed))
&gt;&gt;&gt; gen.multivariate_hypergeometric(colors, 6)
array([5, 0, 1])
&gt;&gt;&gt; gen.multivariate_hypergeometric(colors, 6, size=3)
array([[5, 0, 1],
       [2, 2, 2],
       [3, 3, 0]])
&gt;&gt;&gt; gen.multivariate_hypergeometric(colors, 6, size=(2, 2))
array([[[3, 2, 1],
        [3, 2, 1]],
       [[4, 1, 1],
        [3, 2, 1]]])
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/random/generated/numpy.random.Generator.multivariate_hypergeometric.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/random/generated/numpy.random.Generator.multivariate_hypergeometric.html</a>
  </p>
</div>
