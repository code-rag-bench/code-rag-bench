<h1 id="ufuncs">Universal functions (ufunc)</h1> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="../user/basics.ufuncs#ufuncs-basics"><span class="std std-ref">Universal functions (ufunc) basics</span></a></p> </div> <p>A universal function (or <a class="reference internal" href="../glossary#term-ufunc"><span class="xref std std-term">ufunc</span></a> for short) is a function that operates on <a class="reference internal" href="generated/numpy.ndarray#numpy.ndarray" title="numpy.ndarray"><code>ndarrays</code></a> in an element-by-element fashion, supporting <a class="reference internal" href="../user/basics.ufuncs#ufuncs-broadcasting"><span class="std std-ref">array broadcasting</span></a>, <a class="reference internal" href="../user/basics.ufuncs#ufuncs-casting"><span class="std std-ref">type casting</span></a>, and several other standard features. That is, a ufunc is a “<a class="reference internal" href="../glossary#term-vectorization"><span class="xref std std-term">vectorized</span></a>” wrapper for a function that takes a fixed number of specific inputs and produces a fixed number of specific outputs. For detailed information on universal functions, see <a class="reference internal" href="../user/basics.ufuncs#ufuncs-basics"><span class="std std-ref">Universal functions (ufunc) basics</span></a>.</p> <section id="ufunc"> <h2>ufunc</h2> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.ufunc#numpy.ufunc" title="numpy.ufunc"><code>numpy.ufunc</code></a>()</p></td> <td><p>Functions that operate element by element on whole arrays.</p></td> </tr>  </table> <section id="optional-keyword-arguments"> <h3 id="ufuncs-kwargs">Optional keyword arguments</h3> <p>All ufuncs take optional keyword arguments. Most of these represent advanced usage and will not typically be used.</p> <h4 class="rubric" id="index-0"><em>out</em></h4> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> <p>The first output can be provided as either a positional or a keyword parameter. Keyword ‘out’ arguments are incompatible with positional ones.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.10.</span></p> </div> <p>The ‘out’ keyword argument is expected to be a tuple with one entry per output (which can be None for arrays to be allocated by the ufunc). For ufuncs with a single output, passing a single array (instead of a tuple holding a single array) is also valid.</p> <p>Passing a single array in the ‘out’ keyword argument to a ufunc with multiple outputs is deprecated, and will raise a warning in numpy 1.10, and an error in a future release.</p> <p>If ‘out’ is None (the default), a uninitialized return array is created. The output array is then filled with the results of the ufunc in the places that the broadcast ‘where’ is True. If ‘where’ is the scalar True (the default), then this corresponds to the entire output being filled. Note that outputs not explicitly filled are left with their uninitialized values.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.13.</span></p> </div> <p>Operations where ufunc input and output operands have memory overlap are defined to be the same as for equivalent operations where there is no memory overlap. Operations affected make temporary copies as needed to eliminate data dependency. As detecting these cases is computationally expensive, a heuristic is used, which may in rare cases result in needless temporary copies. For operations where the data dependency is simple enough for the heuristic to analyze, temporary copies will not be made even if the arrays overlap, if it can be deduced copies are not necessary. As an example, <code>np.add(a, b, out=a)</code> will not involve copies.</p> <h4 class="rubric"><em>where</em></h4> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.7.</span></p> </div> <p>Accepts a boolean array which is broadcast together with the operands. Values of True indicate to calculate the ufunc at that position, values of False indicate to leave the value in the output alone. This argument cannot be used for generalized ufuncs as those take non-scalar input.</p> <p>Note that if an uninitialized return array is created, values of False will leave those values <strong>uninitialized</strong>.</p> <h4 class="rubric"><em>axes</em></h4> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.15.</span></p> </div> <p>A list of tuples with indices of axes a generalized ufunc should operate on. For instance, for a signature of <code>(i,j),(j,k)-&gt;(i,k)</code> appropriate for matrix multiplication, the base elements are two-dimensional matrices and these are taken to be stored in the two last axes of each argument. The corresponding axes keyword would be <code>[(-2, -1), (-2, -1), (-2, -1)]</code>. For simplicity, for generalized ufuncs that operate on 1-dimensional arrays (vectors), a single integer is accepted instead of a single-element tuple, and for generalized ufuncs for which all outputs are scalars, the output tuples can be omitted.</p> <h4 class="rubric"><em>axis</em></h4> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.15.</span></p> </div> <p>A single axis over which a generalized ufunc should operate. This is a short-cut for ufuncs that operate over a single, shared core dimension, equivalent to passing in <code>axes</code> with entries of <code>(axis,)</code> for each single-core-dimension argument and <code>()</code> for all others. For instance, for a signature <code>(i),(i)-&gt;()</code>, it is equivalent to passing in <code>axes=[(axis,), (axis,), ()]</code>.</p> <h4 class="rubric"><em>keepdims</em></h4> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.15.</span></p> </div> <p>If this is set to <code>True</code>, axes which are reduced over will be left in the result as a dimension with size one, so that the result will broadcast correctly against the inputs. This option can only be used for generalized ufuncs that operate on inputs that all have the same number of core dimensions and with outputs that have no core dimensions, i.e., with signatures like <code>(i),(i)-&gt;()</code> or <code>(m,m)-&gt;()</code>. If used, the location of the dimensions in the output can be controlled with <code>axes</code> and <code>axis</code>.</p> <h4 class="rubric"><em>casting</em></h4> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> <p>May be ‘no’, ‘equiv’, ‘safe’, ‘same_kind’, or ‘unsafe’. See <a class="reference internal" href="generated/numpy.can_cast#numpy.can_cast" title="numpy.can_cast"><code>can_cast</code></a> for explanations of the parameter values.</p> <p>Provides a policy for what kind of casting is permitted. For compatibility with previous versions of NumPy, this defaults to ‘unsafe’ for numpy &lt; 1.7. In numpy 1.7 a transition to ‘same_kind’ was begun where ufuncs produce a DeprecationWarning for calls which are allowed under the ‘unsafe’ rules, but not under the ‘same_kind’ rules. From numpy 1.10 and onwards, the default is ‘same_kind’.</p> <h4 class="rubric"><em>order</em></h4> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> <p>Specifies the calculation iteration order/memory layout of the output array. Defaults to ‘K’. ‘C’ means the output should be C-contiguous, ‘F’ means F-contiguous, ‘A’ means F-contiguous if the inputs are F-contiguous and not also not C-contiguous, C-contiguous otherwise, and ‘K’ means to match the element ordering of the inputs as closely as possible.</p> <h4 class="rubric"><em>dtype</em></h4> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> <p>Overrides the DType of the output arrays the same way as the <em>signature</em>. This should ensure a matching precision of the calculation. The exact calculation DTypes chosen may depend on the ufunc and the inputs may be cast to this DType to perform the calculation.</p> <h4 class="rubric"><em>subok</em></h4> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> <p>Defaults to true. If set to false, the output will always be a strict array, not a subtype.</p> <h4 class="rubric"><em>signature</em></h4> <p>Either a Dtype, a tuple of DTypes, or a special signature string indicating the input and output types of a ufunc.</p> <p>This argument allows the user to specify exact DTypes to be used for the calculation. Casting will be used as necessary. The actual DType of the input arrays is not considered unless <code>signature</code> is <code>None</code> for that array.</p> <p>When all DTypes are fixed, a specific loop is chosen or an error raised if no matching loop exists. If some DTypes are not specified and left <code>None</code>, the behaviour may depend on the ufunc. At this time, a list of available signatures is provided by the <strong>types</strong> attribute of the ufunc. (This list may be missing DTypes not defined by NumPy.)</p> <p>The <code>signature</code> only specifies the DType class/type. For example, it can specify that the operation should be <code>datetime64</code> or <code>float64</code> operation. It does not specify the <code>datetime64</code> time-unit or the <code>float64</code> byte-order.</p> <p>For backwards compatibility this argument can also be provided as <em>sig</em>, although the long form is preferred. Note that this should not be confused with the generalized ufunc <a class="reference internal" href="c-api/generalized-ufuncs#details-of-signature"><span class="std std-ref">signature</span></a> that is stored in the <strong>signature</strong> attribute of the of the ufunc object.</p> <h4 class="rubric"><em>extobj</em></h4> <p>A list of length 3 specifying the ufunc buffer-size, the error mode integer, and the error call-back function. Normally, these values are looked up in a thread-specific dictionary. Passing them here circumvents that look up and uses the low-level specification provided for the error mode. This may be useful, for example, as an optimization for calculations requiring many ufunc calls on small arrays in a loop.</p> </section> <section id="attributes"> <h3>Attributes</h3> <p>There are some informational attributes that universal functions possess. None of the attributes can be set.</p> <table class="table" id="index-1">   <tr>
<td><p><strong>__doc__</strong></p></td> <td><p>A docstring for each ufunc. The first part of the docstring is dynamically generated from the number of outputs, the name, and the number of inputs. The second part of the docstring is provided at creation time and stored with the ufunc.</p></td> </tr> <tr>
<td><p><strong>__name__</strong></p></td> <td><p>The name of the ufunc.</p></td> </tr>  </table> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.ufunc.nin#numpy.ufunc.nin" title="numpy.ufunc.nin"><code>ufunc.nin</code></a></p></td> <td><p>The number of inputs.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.ufunc.nout#numpy.ufunc.nout" title="numpy.ufunc.nout"><code>ufunc.nout</code></a></p></td> <td><p>The number of outputs.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.ufunc.nargs#numpy.ufunc.nargs" title="numpy.ufunc.nargs"><code>ufunc.nargs</code></a></p></td> <td><p>The number of arguments.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.ufunc.ntypes#numpy.ufunc.ntypes" title="numpy.ufunc.ntypes"><code>ufunc.ntypes</code></a></p></td> <td><p>The number of types.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.ufunc.types#numpy.ufunc.types" title="numpy.ufunc.types"><code>ufunc.types</code></a></p></td> <td><p>Returns a list with types grouped input-&gt;output.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.ufunc.identity#numpy.ufunc.identity" title="numpy.ufunc.identity"><code>ufunc.identity</code></a></p></td> <td><p>The identity value.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.ufunc.signature#numpy.ufunc.signature" title="numpy.ufunc.signature"><code>ufunc.signature</code></a></p></td> <td><p>Definition of the core elements a generalized ufunc operates on.</p></td> </tr>  </table> </section> <section id="methods"> <h3 id="ufuncs-methods">Methods</h3> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.ufunc.reduce#numpy.ufunc.reduce" title="numpy.ufunc.reduce"><code>ufunc.reduce</code></a>(array[, axis, dtype, out, ...])</p></td> <td><p>Reduces <a class="reference internal" href="generated/numpy.array#numpy.array" title="numpy.array"><code>array</code></a>'s dimension by one, by applying ufunc along one axis.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.ufunc.accumulate#numpy.ufunc.accumulate" title="numpy.ufunc.accumulate"><code>ufunc.accumulate</code></a>(array[, axis, dtype, out])</p></td> <td><p>Accumulate the result of applying the operator to all elements.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.ufunc.reduceat#numpy.ufunc.reduceat" title="numpy.ufunc.reduceat"><code>ufunc.reduceat</code></a>(array, indices[, axis, ...])</p></td> <td><p>Performs a (local) reduce with specified slices over a single axis.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.ufunc.outer#numpy.ufunc.outer" title="numpy.ufunc.outer"><code>ufunc.outer</code></a>(A, B, /, **kwargs)</p></td> <td><p>Apply the ufunc <code>op</code> to all pairs (a, b) with a in <code>A</code> and b in <code>B</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.ufunc.at#numpy.ufunc.at" title="numpy.ufunc.at"><code>ufunc.at</code></a>(a, indices[, b])</p></td> <td><p>Performs unbuffered in place operation on operand 'a' for elements specified by 'indices'.</p></td> </tr>  </table> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>A reduce-like operation on an array with a data-type that has a range “too small” to handle the result will silently wrap. One should use <a class="reference internal" href="generated/numpy.dtype#numpy.dtype" title="numpy.dtype"><code>dtype</code></a> to increase the size of the data-type over which reduction takes place.</p> </div> </section> </section> <section id="available-ufuncs"> <h2>Available ufuncs</h2> <p>There are currently more than 60 universal functions defined in <a class="reference internal" href="index#module-numpy" title="numpy"><code>numpy</code></a> on one or more types, covering a wide variety of operations. Some of these ufuncs are called automatically on arrays when the relevant infix notation is used (<em>e.g.</em>, <a class="reference internal" href="generated/numpy.add#numpy.add" title="numpy.add"><code>add(a, b)</code></a> is called internally when <code>a + b</code> is written and <em>a</em> or <em>b</em> is an <a class="reference internal" href="generated/numpy.ndarray#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a>). Nevertheless, you may still want to use the ufunc call in order to use the optional output argument(s) to place the output(s) in an object (or objects) of your choice.</p> <p>Recall that each ufunc operates element-by-element. Therefore, each scalar ufunc will be described as if acting on a set of scalar inputs to return a set of scalar outputs.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The ufunc still returns its output(s) even if you use the optional output argument(s).</p> </div> <section id="math-operations"> <h3>Math operations</h3> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.add#numpy.add" title="numpy.add"><code>add</code></a>(x1, x2, /[, out, where, casting, order, ...])</p></td> <td><p>Add arguments element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.subtract#numpy.subtract" title="numpy.subtract"><code>subtract</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Subtract arguments, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.multiply#numpy.multiply" title="numpy.multiply"><code>multiply</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Multiply arguments element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.matmul#numpy.matmul" title="numpy.matmul"><code>matmul</code></a>(x1, x2, /[, out, casting, order, ...])</p></td> <td><p>Matrix product of two arrays.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.divide#numpy.divide" title="numpy.divide"><code>divide</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Returns a true division of the inputs, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.logaddexp#numpy.logaddexp" title="numpy.logaddexp"><code>logaddexp</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Logarithm of the sum of exponentiations of the inputs.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.logaddexp2#numpy.logaddexp2" title="numpy.logaddexp2"><code>logaddexp2</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Logarithm of the sum of exponentiations of the inputs in base-2.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.true_divide#numpy.true_divide" title="numpy.true_divide"><code>true_divide</code></a>(x1, x2, /[, out, where, ...])</p></td> <td><p>Returns a true division of the inputs, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.floor_divide#numpy.floor_divide" title="numpy.floor_divide"><code>floor_divide</code></a>(x1, x2, /[, out, where, ...])</p></td> <td><p>Return the largest integer smaller or equal to the division of the inputs.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.negative#numpy.negative" title="numpy.negative"><code>negative</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Numerical negative, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.positive#numpy.positive" title="numpy.positive"><code>positive</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Numerical positive, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.power#numpy.power" title="numpy.power"><code>power</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>First array elements raised to powers from second array, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.float_power#numpy.float_power" title="numpy.float_power"><code>float_power</code></a>(x1, x2, /[, out, where, ...])</p></td> <td><p>First array elements raised to powers from second array, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.remainder#numpy.remainder" title="numpy.remainder"><code>remainder</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Returns the element-wise remainder of division.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.mod#numpy.mod" title="numpy.mod"><code>mod</code></a>(x1, x2, /[, out, where, casting, order, ...])</p></td> <td><p>Returns the element-wise remainder of division.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.fmod#numpy.fmod" title="numpy.fmod"><code>fmod</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Returns the element-wise remainder of division.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.divmod#numpy.divmod" title="numpy.divmod"><code>divmod</code></a>(x1, x2[, out1, out2], / [[, out, ...])</p></td> <td><p>Return element-wise quotient and remainder simultaneously.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.absolute#numpy.absolute" title="numpy.absolute"><code>absolute</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Calculate the absolute value element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.fabs#numpy.fabs" title="numpy.fabs"><code>fabs</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Compute the absolute values element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.rint#numpy.rint" title="numpy.rint"><code>rint</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Round elements of the array to the nearest integer.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.sign#numpy.sign" title="numpy.sign"><code>sign</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Returns an element-wise indication of the sign of a number.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.heaviside#numpy.heaviside" title="numpy.heaviside"><code>heaviside</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Compute the Heaviside step function.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.conj#numpy.conj" title="numpy.conj"><code>conj</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Return the complex conjugate, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.conjugate#numpy.conjugate" title="numpy.conjugate"><code>conjugate</code></a>(x, /[, out, where, casting, ...])</p></td> <td><p>Return the complex conjugate, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.exp#numpy.exp" title="numpy.exp"><code>exp</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Calculate the exponential of all elements in the input array.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.exp2#numpy.exp2" title="numpy.exp2"><code>exp2</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Calculate <code>2**p</code> for all <code>p</code> in the input array.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.log#numpy.log" title="numpy.log"><code>log</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Natural logarithm, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.log2#numpy.log2" title="numpy.log2"><code>log2</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Base-2 logarithm of <code>x</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.log10#numpy.log10" title="numpy.log10"><code>log10</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Return the base 10 logarithm of the input array, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.expm1#numpy.expm1" title="numpy.expm1"><code>expm1</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Calculate <code>exp(x) - 1</code> for all elements in the array.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.log1p#numpy.log1p" title="numpy.log1p"><code>log1p</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Return the natural logarithm of one plus the input array, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.sqrt#numpy.sqrt" title="numpy.sqrt"><code>sqrt</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Return the non-negative square-root of an array, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.square#numpy.square" title="numpy.square"><code>square</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Return the element-wise square of the input.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.cbrt#numpy.cbrt" title="numpy.cbrt"><code>cbrt</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Return the cube-root of an array, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.reciprocal#numpy.reciprocal" title="numpy.reciprocal"><code>reciprocal</code></a>(x, /[, out, where, casting, ...])</p></td> <td><p>Return the reciprocal of the argument, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.gcd#numpy.gcd" title="numpy.gcd"><code>gcd</code></a>(x1, x2, /[, out, where, casting, order, ...])</p></td> <td><p>Returns the greatest common divisor of <code>|x1|</code> and <code>|x2|</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.lcm#numpy.lcm" title="numpy.lcm"><code>lcm</code></a>(x1, x2, /[, out, where, casting, order, ...])</p></td> <td><p>Returns the lowest common multiple of <code>|x1|</code> and <code>|x2|</code></p></td> </tr>  </table> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>The optional output arguments can be used to help you save memory for large calculations. If your arrays are large, complicated expressions can take longer than absolutely necessary due to the creation and (later) destruction of temporary calculation spaces. For example, the expression <code>G = A * B + C</code> is equivalent to <code>T1 = A * B; G = T1 + C; del T1</code>. It will be more quickly executed as <code>G = A * B; add(G, C, G)</code> which is the same as <code>G = A * B; G += C</code>.</p> </div> </section> <section id="trigonometric-functions"> <h3>Trigonometric functions</h3> <p>All trigonometric functions use radians when an angle is called for. The ratio of degrees to radians is <span class="math notranslate nohighlight">\(180^{\circ}/\pi.\)</span></p> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.sin#numpy.sin" title="numpy.sin"><code>sin</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Trigonometric sine, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.cos#numpy.cos" title="numpy.cos"><code>cos</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Cosine element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.tan#numpy.tan" title="numpy.tan"><code>tan</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Compute tangent element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.arcsin#numpy.arcsin" title="numpy.arcsin"><code>arcsin</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Inverse sine, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.arccos#numpy.arccos" title="numpy.arccos"><code>arccos</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Trigonometric inverse cosine, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.arctan#numpy.arctan" title="numpy.arctan"><code>arctan</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Trigonometric inverse tangent, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.arctan2#numpy.arctan2" title="numpy.arctan2"><code>arctan2</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Element-wise arc tangent of <code>x1/x2</code> choosing the quadrant correctly.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.hypot#numpy.hypot" title="numpy.hypot"><code>hypot</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Given the "legs" of a right triangle, return its hypotenuse.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.sinh#numpy.sinh" title="numpy.sinh"><code>sinh</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Hyperbolic sine, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.cosh#numpy.cosh" title="numpy.cosh"><code>cosh</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Hyperbolic cosine, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.tanh#numpy.tanh" title="numpy.tanh"><code>tanh</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Compute hyperbolic tangent element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.arcsinh#numpy.arcsinh" title="numpy.arcsinh"><code>arcsinh</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Inverse hyperbolic sine element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.arccosh#numpy.arccosh" title="numpy.arccosh"><code>arccosh</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Inverse hyperbolic cosine, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.arctanh#numpy.arctanh" title="numpy.arctanh"><code>arctanh</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Inverse hyperbolic tangent element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.degrees#numpy.degrees" title="numpy.degrees"><code>degrees</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Convert angles from radians to degrees.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.radians#numpy.radians" title="numpy.radians"><code>radians</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Convert angles from degrees to radians.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.deg2rad#numpy.deg2rad" title="numpy.deg2rad"><code>deg2rad</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Convert angles from degrees to radians.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.rad2deg#numpy.rad2deg" title="numpy.rad2deg"><code>rad2deg</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Convert angles from radians to degrees.</p></td> </tr>  </table> </section> <section id="bit-twiddling-functions"> <h3>Bit-twiddling functions</h3> <p>These function all require integer arguments and they manipulate the bit-pattern of those arguments.</p> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.bitwise_and#numpy.bitwise_and" title="numpy.bitwise_and"><code>bitwise_and</code></a>(x1, x2, /[, out, where, ...])</p></td> <td><p>Compute the bit-wise AND of two arrays element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.bitwise_or#numpy.bitwise_or" title="numpy.bitwise_or"><code>bitwise_or</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Compute the bit-wise OR of two arrays element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.bitwise_xor#numpy.bitwise_xor" title="numpy.bitwise_xor"><code>bitwise_xor</code></a>(x1, x2, /[, out, where, ...])</p></td> <td><p>Compute the bit-wise XOR of two arrays element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.invert#numpy.invert" title="numpy.invert"><code>invert</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Compute bit-wise inversion, or bit-wise NOT, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.left_shift#numpy.left_shift" title="numpy.left_shift"><code>left_shift</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Shift the bits of an integer to the left.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.right_shift#numpy.right_shift" title="numpy.right_shift"><code>right_shift</code></a>(x1, x2, /[, out, where, ...])</p></td> <td><p>Shift the bits of an integer to the right.</p></td> </tr>  </table> </section> <section id="comparison-functions"> <h3>Comparison functions</h3> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.greater#numpy.greater" title="numpy.greater"><code>greater</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Return the truth value of (x1 &gt; x2) element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.greater_equal#numpy.greater_equal" title="numpy.greater_equal"><code>greater_equal</code></a>(x1, x2, /[, out, where, ...])</p></td> <td><p>Return the truth value of (x1 &gt;= x2) element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.less#numpy.less" title="numpy.less"><code>less</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Return the truth value of (x1 &lt; x2) element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.less_equal#numpy.less_equal" title="numpy.less_equal"><code>less_equal</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Return the truth value of (x1 &lt;= x2) element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.not_equal#numpy.not_equal" title="numpy.not_equal"><code>not_equal</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Return (x1 != x2) element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.equal#numpy.equal" title="numpy.equal"><code>equal</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Return (x1 == x2) element-wise.</p></td> </tr>  </table> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Do not use the Python keywords <code>and</code> and <code>or</code> to combine logical array expressions. These keywords will test the truth value of the entire array (not element-by-element as you might expect). Use the bitwise operators &amp; and | instead.</p> </div> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.logical_and#numpy.logical_and" title="numpy.logical_and"><code>logical_and</code></a>(x1, x2, /[, out, where, ...])</p></td> <td><p>Compute the truth value of x1 AND x2 element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.logical_or#numpy.logical_or" title="numpy.logical_or"><code>logical_or</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Compute the truth value of x1 OR x2 element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.logical_xor#numpy.logical_xor" title="numpy.logical_xor"><code>logical_xor</code></a>(x1, x2, /[, out, where, ...])</p></td> <td><p>Compute the truth value of x1 XOR x2, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.logical_not#numpy.logical_not" title="numpy.logical_not"><code>logical_not</code></a>(x, /[, out, where, casting, ...])</p></td> <td><p>Compute the truth value of NOT x element-wise.</p></td> </tr>  </table> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The bit-wise operators &amp; and | are the proper way to perform element-by-element array comparisons. Be sure you understand the operator precedence: <code>(a &gt; 2) &amp; (a &lt; 5)</code> is the proper syntax because <code>a &gt; 2 &amp; a &lt; 5</code> will result in an error due to the fact that <code>2 &amp; a</code> is evaluated first.</p> </div> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.maximum#numpy.maximum" title="numpy.maximum"><code>maximum</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Element-wise maximum of array elements.</p></td> </tr>  </table> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>The Python function <code>max()</code> will find the maximum over a one-dimensional array, but it will do so using a slower sequence interface. The reduce method of the maximum ufunc is much faster. Also, the <code>max()</code> method will not give answers you might expect for arrays with greater than one dimension. The reduce method of minimum also allows you to compute a total minimum over an array.</p> </div> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.minimum#numpy.minimum" title="numpy.minimum"><code>minimum</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Element-wise minimum of array elements.</p></td> </tr>  </table> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>the behavior of <code>maximum(a, b)</code> is different than that of <code>max(a, b)</code>. As a ufunc, <code>maximum(a, b)</code> performs an element-by-element comparison of <code>a</code> and <code>b</code> and chooses each element of the result according to which element in the two arrays is larger. In contrast, <code>max(a, b)</code> treats the objects <code>a</code> and <code>b</code> as a whole, looks at the (total) truth value of <code>a &gt; b</code> and uses it to return either <code>a</code> or <code>b</code> (as a whole). A similar difference exists between <code>minimum(a, b)</code> and <code>min(a, b)</code>.</p> </div> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.fmax#numpy.fmax" title="numpy.fmax"><code>fmax</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Element-wise maximum of array elements.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.fmin#numpy.fmin" title="numpy.fmin"><code>fmin</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Element-wise minimum of array elements.</p></td> </tr>  </table> </section> <section id="floating-functions"> <h3>Floating functions</h3> <p>Recall that all of these functions work element-by-element over an array, returning an array output. The description details only a single operation.</p> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.isfinite#numpy.isfinite" title="numpy.isfinite"><code>isfinite</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Test element-wise for finiteness (not infinity and not Not a Number).</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.isinf#numpy.isinf" title="numpy.isinf"><code>isinf</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Test element-wise for positive or negative infinity.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.isnan#numpy.isnan" title="numpy.isnan"><code>isnan</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Test element-wise for NaN and return result as a boolean array.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.isnat#numpy.isnat" title="numpy.isnat"><code>isnat</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Test element-wise for NaT (not a time) and return result as a boolean array.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.fabs#numpy.fabs" title="numpy.fabs"><code>fabs</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Compute the absolute values element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.signbit#numpy.signbit" title="numpy.signbit"><code>signbit</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Returns element-wise True where signbit is set (less than zero).</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.copysign#numpy.copysign" title="numpy.copysign"><code>copysign</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Change the sign of x1 to that of x2, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.nextafter#numpy.nextafter" title="numpy.nextafter"><code>nextafter</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Return the next floating-point value after x1 towards x2, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.spacing#numpy.spacing" title="numpy.spacing"><code>spacing</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Return the distance between x and the nearest adjacent number.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.modf#numpy.modf" title="numpy.modf"><code>modf</code></a>(x[, out1, out2], / [[, out, where, ...])</p></td> <td><p>Return the fractional and integral parts of an array, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.ldexp#numpy.ldexp" title="numpy.ldexp"><code>ldexp</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Returns x1 * 2**x2, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.frexp#numpy.frexp" title="numpy.frexp"><code>frexp</code></a>(x[, out1, out2], / [[, out, where, ...])</p></td> <td><p>Decompose the elements of x into mantissa and twos exponent.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.fmod#numpy.fmod" title="numpy.fmod"><code>fmod</code></a>(x1, x2, /[, out, where, casting, ...])</p></td> <td><p>Returns the element-wise remainder of division.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.floor#numpy.floor" title="numpy.floor"><code>floor</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Return the floor of the input, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.ceil#numpy.ceil" title="numpy.ceil"><code>ceil</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Return the ceiling of the input, element-wise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.trunc#numpy.trunc" title="numpy.trunc"><code>trunc</code></a>(x, /[, out, where, casting, order, ...])</p></td> <td><p>Return the truncated value of the input, element-wise.</p></td> </tr>  </table> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/ufuncs.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/ufuncs.html</a>
  </p>
</div>
