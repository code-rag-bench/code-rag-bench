<h1 id="arrays-dtypes">Data type objects (dtype)</h1> <p>A data type object (an instance of <a class="reference internal" href="generated/numpy.dtype#numpy.dtype" title="numpy.dtype"><code>numpy.dtype</code></a> class) describes how the bytes in the fixed-size block of memory corresponding to an array item should be interpreted. It describes the following aspects of the data:</p> <ol class="arabic simple"> <li>Type of the data (integer, float, Python object, etc.)</li> <li>Size of the data (how many bytes is in <em>e.g.</em> the integer)</li> <li>Byte order of the data (<a class="reference internal" href="../glossary#term-little-endian"><span class="xref std std-term">little-endian</span></a> or <a class="reference internal" href="../glossary#term-big-endian"><span class="xref std std-term">big-endian</span></a>)</li> <li>
<p>If the data type is <a class="reference internal" href="../glossary#term-structured-data-type"><span class="xref std std-term">structured data type</span></a>, an aggregate of other data types, (<em>e.g.</em>, describing an array item consisting of an integer and a float),</p> <ol class="arabic simple"> <li>what are the names of the “<a class="reference internal" href="../glossary#term-field"><span class="xref std std-term">fields</span></a>” of the structure, by which they can be <a class="reference internal" href="../user/basics.indexing#arrays-indexing-fields"><span class="std std-ref">accessed</span></a>,</li> <li>what is the data-type of each <a class="reference internal" href="../glossary#term-field"><span class="xref std std-term">field</span></a>, and</li> <li>which part of the memory block each field takes.</li> </ol> </li> <li>If the data type is a sub-array, what is its shape and data type.</li> </ol> <p id="index-0">To describe the type of scalar data, there are several <a class="reference internal" href="arrays.scalars#arrays-scalars-built-in"><span class="std std-ref">built-in scalar types</span></a> in NumPy for various precision of integers, floating-point numbers, <em>etc</em>. An item extracted from an array, <em>e.g.</em>, by indexing, will be a Python object whose type is the scalar type associated with the data type of the array.</p> <p>Note that the scalar types are not <a class="reference internal" href="generated/numpy.dtype#numpy.dtype" title="numpy.dtype"><code>dtype</code></a> objects, even though they can be used in place of one whenever a data type specification is needed in NumPy.</p> <p id="index-1">Structured data types are formed by creating a data type whose <a class="reference internal" href="../glossary#term-field"><span class="xref std std-term">field</span></a> contain other data types. Each field has a name by which it can be <a class="reference internal" href="../user/basics.indexing#arrays-indexing-fields"><span class="std std-ref">accessed</span></a>. The parent data type should be of sufficient size to contain all its fields; the parent is nearly always based on the <a class="reference internal" href="arrays.scalars#numpy.void" title="numpy.void"><code>void</code></a> type which allows an arbitrary item size. Structured data types may also contain nested structured sub-array data types in their fields.</p> <p id="index-2">Finally, a data type can describe items that are themselves arrays of items of another data type. These sub-arrays must, however, be of a fixed size.</p> <p>If an array is created using a data-type describing a sub-array, the dimensions of the sub-array are appended to the shape of the array when the array is created. Sub-arrays in a field of a structured type behave differently, see <a class="reference internal" href="../user/basics.indexing#arrays-indexing-fields"><span class="std std-ref">Field access</span></a>.</p> <p>Sub-arrays always have a C-contiguous memory layout.</p>  <h4>Example</h4> <p>A simple data type containing a 32-bit big-endian integer: (see <a class="reference internal" href="#arrays-dtypes-constructing"><span class="std std-ref">Specifying and constructing data types</span></a> for details on construction)</p> <pre data-language="python">&gt;&gt;&gt; dt = np.dtype('&gt;i4')
&gt;&gt;&gt; dt.byteorder
'&gt;'
&gt;&gt;&gt; dt.itemsize
4
&gt;&gt;&gt; dt.name
'int32'
&gt;&gt;&gt; dt.type is np.int32
True
</pre> <p>The corresponding array scalar type is <a class="reference internal" href="arrays.scalars#numpy.int32" title="numpy.int32"><code>int32</code></a>.</p>   <h4>Example</h4> <p>A structured data type containing a 16-character string (in field ‘name’) and a sub-array of two 64-bit floating-point number (in field ‘grades’):</p> <pre data-language="python">&gt;&gt;&gt; dt = np.dtype([('name', np.unicode_, 16), ('grades', np.float64, (2,))])
&gt;&gt;&gt; dt['name']
dtype('&lt;U16')
&gt;&gt;&gt; dt['grades']
dtype(('&lt;f8', (2,)))
</pre> <p>Items of an array of this data type are wrapped in an <a class="reference internal" href="arrays.scalars#arrays-scalars"><span class="std std-ref">array scalar</span></a> type that also has two fields:</p> <pre data-language="python">&gt;&gt;&gt; x = np.array([('Sarah', (8.0, 7.0)), ('John', (6.0, 7.0))], dtype=dt)
&gt;&gt;&gt; x[1]
('John', [6., 7.])
&gt;&gt;&gt; x[1]['grades']
array([6.,  7.])
&gt;&gt;&gt; type(x[1])
&lt;class 'numpy.void'&gt;
&gt;&gt;&gt; type(x[1]['grades'])
&lt;class 'numpy.ndarray'&gt;
</pre>  <section id="specifying-and-constructing-data-types"> <h2 id="arrays-dtypes-constructing">Specifying and constructing data types</h2> <p>Whenever a data-type is required in a NumPy function or method, either a <a class="reference internal" href="generated/numpy.dtype#numpy.dtype" title="numpy.dtype"><code>dtype</code></a> object or something that can be converted to one can be supplied. Such conversions are done by the <a class="reference internal" href="generated/numpy.dtype#numpy.dtype" title="numpy.dtype"><code>dtype</code></a> constructor:</p> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype#numpy.dtype" title="numpy.dtype"><code>dtype</code></a>(dtype[, align, copy])</p></td> <td><p>Create a data type object.</p></td> </tr>  </table> <p>What can be converted to a data-type object is described below:</p> <dl> <dt>
<a class="reference internal" href="generated/numpy.dtype#numpy.dtype" title="numpy.dtype"><code>dtype</code></a> object</dt>
<dd>
<p id="index-3">Used as-is.</p> </dd> <dt>None</dt>
<dd>
<p id="index-4">The default data type: <a class="reference internal" href="arrays.scalars#numpy.float_" title="numpy.float_"><code>float_</code></a>.</p> </dd> </dl> <dl id="index-5"> <dt>Array-scalar types</dt>
<dd>
<p>The 24 built-in <a class="reference internal" href="arrays.scalars#arrays-scalars-built-in"><span class="std std-ref">array scalar type objects</span></a> all convert to an associated data-type object. This is true for their sub-classes as well.</p> <p>Note that not all data-type information can be supplied with a type-object: for example, <a class="reference internal" href="arrays.scalars#numpy.flexible" title="numpy.flexible"><code>flexible</code></a> data-types have a default <em>itemsize</em> of 0, and require an explicitly given size to be useful.</p>  <h4>Example</h4> <pre data-language="python">&gt;&gt;&gt; dt = np.dtype(np.int32)      # 32-bit integer
&gt;&gt;&gt; dt = np.dtype(np.complex128) # 128-bit complex floating-point number
</pre>  </dd> <dt>Generic types</dt>
<dd>
<p>The generic hierarchical type objects convert to corresponding type objects according to the associations:</p> <table class="table">   <tr>
<td><p><a class="reference internal" href="arrays.scalars#numpy.number" title="numpy.number"><code>number</code></a>, <a class="reference internal" href="arrays.scalars#numpy.inexact" title="numpy.inexact"><code>inexact</code></a>, <a class="reference internal" href="arrays.scalars#numpy.floating" title="numpy.floating"><code>floating</code></a></p></td> <td><p><a class="reference external" href="https://docs.python.org/dev/library/functions.html#float" title="(in Python v3.11)"><code>float</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="arrays.scalars#numpy.complexfloating" title="numpy.complexfloating"><code>complexfloating</code></a></p></td> <td><p><a class="reference internal" href="arrays.scalars#numpy.cfloat" title="numpy.cfloat"><code>cfloat</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="arrays.scalars#numpy.integer" title="numpy.integer"><code>integer</code></a>, <a class="reference internal" href="arrays.scalars#numpy.signedinteger" title="numpy.signedinteger"><code>signedinteger</code></a></p></td> <td><p><a class="reference internal" href="arrays.scalars#numpy.int_" title="numpy.int_"><code>int_</code></a></p></td> </tr> <tr>
<td><p><a class="reference internal" href="arrays.scalars#numpy.unsignedinteger" title="numpy.unsignedinteger"><code>unsignedinteger</code></a></p></td> <td><p><a class="reference internal" href="arrays.scalars#numpy.uint" title="numpy.uint"><code>uint</code></a></p></td> </tr> <tr>
<td><p><code>character</code></p></td> <td><p><code>string</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="arrays.scalars#numpy.generic" title="numpy.generic"><code>generic</code></a>, <a class="reference internal" href="arrays.scalars#numpy.flexible" title="numpy.flexible"><code>flexible</code></a></p></td> <td><p><a class="reference internal" href="arrays.scalars#numpy.void" title="numpy.void"><code>void</code></a></p></td> </tr>  </table> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 1.19: </span>This conversion of generic scalar types is deprecated. This is because it can be unexpected in a context such as <code>arr.astype(dtype=np.floating)</code>, which casts an array of <code>float32</code> to an array of <code>float64</code>, even though <code>float32</code> is a subdtype of <code>np.floating</code>.</p> </div> </dd> <dt>Built-in Python types</dt>
<dd>
<p>Several python types are equivalent to a corresponding array scalar when used to generate a <a class="reference internal" href="generated/numpy.dtype#numpy.dtype" title="numpy.dtype"><code>dtype</code></a> object:</p> <table class="table">   <tr>
<td><p><a class="reference external" href="https://docs.python.org/dev/library/functions.html#int" title="(in Python v3.11)"><code>int</code></a></p></td> <td><p><a class="reference internal" href="arrays.scalars#numpy.int_" title="numpy.int_"><code>int_</code></a></p></td> </tr> <tr>
<td><p><a class="reference external" href="https://docs.python.org/dev/library/functions.html#bool" title="(in Python v3.11)"><code>bool</code></a></p></td> <td><p><a class="reference internal" href="arrays.scalars#numpy.bool_" title="numpy.bool_"><code>bool_</code></a></p></td> </tr> <tr>
<td><p><a class="reference external" href="https://docs.python.org/dev/library/functions.html#float" title="(in Python v3.11)"><code>float</code></a></p></td> <td><p><a class="reference internal" href="arrays.scalars#numpy.float_" title="numpy.float_"><code>float_</code></a></p></td> </tr> <tr>
<td><p><a class="reference external" href="https://docs.python.org/dev/library/functions.html#complex" title="(in Python v3.11)"><code>complex</code></a></p></td> <td><p><a class="reference internal" href="arrays.scalars#numpy.cfloat" title="numpy.cfloat"><code>cfloat</code></a></p></td> </tr> <tr>
<td><p><a class="reference external" href="https://docs.python.org/dev/library/stdtypes.html#bytes" title="(in Python v3.11)"><code>bytes</code></a></p></td> <td><p><a class="reference internal" href="arrays.scalars#numpy.bytes_" title="numpy.bytes_"><code>bytes_</code></a></p></td> </tr> <tr>
<td><p><a class="reference external" href="https://docs.python.org/dev/library/stdtypes.html#str" title="(in Python v3.11)"><code>str</code></a></p></td> <td><p><a class="reference internal" href="arrays.scalars#numpy.str_" title="numpy.str_"><code>str_</code></a></p></td> </tr> <tr>
<td><p><code>buffer</code></p></td> <td><p><a class="reference internal" href="arrays.scalars#numpy.void" title="numpy.void"><code>void</code></a></p></td> </tr> <tr>
<td><p>(all others)</p></td> <td><p><a class="reference internal" href="arrays.scalars#numpy.object_" title="numpy.object_"><code>object_</code></a></p></td> </tr>  </table> <p>Note that <code>str</code> refers to either null terminated bytes or unicode strings depending on the Python version. In code targeting both Python 2 and 3 <code>np.unicode_</code> should be used as a dtype for strings. See <a class="reference internal" href="#string-dtype-note"><span class="std std-ref">Note on string types</span></a>.</p>  <h4>Example</h4> <pre data-language="python">&gt;&gt;&gt; dt = np.dtype(float)   # Python-compatible floating-point number
&gt;&gt;&gt; dt = np.dtype(int)     # Python-compatible integer
&gt;&gt;&gt; dt = np.dtype(object)  # Python object
</pre>  <div class="admonition note"> <p class="admonition-title">Note</p> <p>All other types map to <code>object_</code> for convenience. Code should expect that such types may map to a specific (new) dtype in the future.</p> </div> </dd> <dt>Types with <code>.dtype</code>
</dt>
<dd>
<p>Any type object with a <code>dtype</code> attribute: The attribute will be accessed and used directly. The attribute must return something that is convertible into a dtype object.</p> </dd> </dl> <p id="index-6">Several kinds of strings can be converted. Recognized strings can be prepended with <code>'&gt;'</code> (<a class="reference internal" href="../glossary#term-big-endian"><span class="xref std std-term">big-endian</span></a>), <code>'&lt;'</code> (<a class="reference internal" href="../glossary#term-little-endian"><span class="xref std std-term">little-endian</span></a>), or <code>'='</code> (hardware-native, the default), to specify the byte order.</p> <dl> <dt>One-character strings</dt>
<dd>
<p>Each built-in data-type has a character code (the updated Numeric typecodes), that uniquely identifies it.</p>  <h4>Example</h4> <pre data-language="python">&gt;&gt;&gt; dt = np.dtype('b')  # byte, native byte order
&gt;&gt;&gt; dt = np.dtype('&gt;H') # big-endian unsigned short
&gt;&gt;&gt; dt = np.dtype('&lt;f') # little-endian single-precision float
&gt;&gt;&gt; dt = np.dtype('d')  # double-precision floating-point number
</pre>  </dd> <dt>Array-protocol type strings (see <a class="reference internal" href="arrays.interface#arrays-interface"><span class="std std-ref">The Array Interface</span></a>)</dt>
<dd>
<p>The first character specifies the kind of data and the remaining characters specify the number of bytes per item, except for Unicode, where it is interpreted as the number of characters. The item size must correspond to an existing type, or an error will be raised. The supported kinds are</p> <table class="table">   <tr>
<td><p><code>'?'</code></p></td> <td><p>boolean</p></td> </tr> <tr>
<td><p><code>'b'</code></p></td> <td><p>(signed) byte</p></td> </tr> <tr>
<td><p><code>'B'</code></p></td> <td><p>unsigned byte</p></td> </tr> <tr>
<td><p><code>'i'</code></p></td> <td><p>(signed) integer</p></td> </tr> <tr>
<td><p><code>'u'</code></p></td> <td><p>unsigned integer</p></td> </tr> <tr>
<td><p><code>'f'</code></p></td> <td><p>floating-point</p></td> </tr> <tr>
<td><p><code>'c'</code></p></td> <td><p>complex-floating point</p></td> </tr> <tr>
<td><p><code>'m'</code></p></td> <td><p>timedelta</p></td> </tr> <tr>
<td><p><code>'M'</code></p></td> <td><p>datetime</p></td> </tr> <tr>
<td><p><code>'O'</code></p></td> <td><p>(Python) objects</p></td> </tr> <tr>
<td><p><code>'S'</code>, <code>'a'</code></p></td> <td><p>zero-terminated bytes (not recommended)</p></td> </tr> <tr>
<td><p><code>'U'</code></p></td> <td><p>Unicode string</p></td> </tr> <tr>
<td><p><code>'V'</code></p></td> <td><p>raw data (<a class="reference internal" href="arrays.scalars#numpy.void" title="numpy.void"><code>void</code></a>)</p></td> </tr>  </table>  <h4>Example</h4> <pre data-language="python">&gt;&gt;&gt; dt = np.dtype('i4')   # 32-bit signed integer
&gt;&gt;&gt; dt = np.dtype('f8')   # 64-bit floating-point number
&gt;&gt;&gt; dt = np.dtype('c16')  # 128-bit complex floating-point number
&gt;&gt;&gt; dt = np.dtype('a25')  # 25-length zero-terminated bytes
&gt;&gt;&gt; dt = np.dtype('U25')  # 25-character string
</pre>  <div class="admonition-note-on-string-types admonition" id="string-dtype-note"> <p class="admonition-title">Note on string types</p> <p>For backward compatibility with Python 2 the <code>S</code> and <code>a</code> typestrings remain zero-terminated bytes and <a class="reference internal" href="arrays.scalars#numpy.string_" title="numpy.string_"><code>numpy.string_</code></a> continues to alias <a class="reference internal" href="arrays.scalars#numpy.bytes_" title="numpy.bytes_"><code>numpy.bytes_</code></a>. To use actual strings in Python 3 use <code>U</code> or <a class="reference internal" href="arrays.scalars#numpy.str_" title="numpy.str_"><code>numpy.str_</code></a>. For signed bytes that do not need zero-termination <code>b</code> or <code>i1</code> can be used.</p> </div> </dd> <dt>String with comma-separated fields</dt>
<dd>
<p>A short-hand notation for specifying the format of a structured data type is a comma-separated string of basic formats.</p> <p>A basic format in this context is an optional shape specifier followed by an array-protocol type string. Parenthesis are required on the shape if it has more than one dimension. NumPy allows a modification on the format in that any string that can uniquely identify the type can be used to specify the data-type in a field. The generated data-type fields are named <code>'f0'</code>, <code>'f1'</code>, …, <code>'f&lt;N-1&gt;'</code> where N (&gt;1) is the number of comma-separated basic formats in the string. If the optional shape specifier is provided, then the data-type for the corresponding field describes a sub-array.</p>  <h4>Example</h4> <ul class="simple"> <li>field named <code>f0</code> containing a 32-bit integer</li> <li>field named <code>f1</code> containing a 2 x 3 sub-array of 64-bit floating-point numbers</li> <li>field named <code>f2</code> containing a 32-bit floating-point number</li> </ul> <pre data-language="python">&gt;&gt;&gt; dt = np.dtype("i4, (2,3)f8, f4")
</pre> <ul class="simple"> <li>field named <code>f0</code> containing a 3-character string</li> <li>field named <code>f1</code> containing a sub-array of shape (3,) containing 64-bit unsigned integers</li> <li>field named <code>f2</code> containing a 3 x 4 sub-array containing 10-character strings</li> </ul> <pre data-language="python">&gt;&gt;&gt; dt = np.dtype("a3, 3u8, (3,4)a10")
</pre>  </dd> <dt>Type strings</dt>
<dd>
<p>Any string in <code>numpy.sctypeDict</code>.keys():</p>  <h4>Example</h4> <pre data-language="python">&gt;&gt;&gt; dt = np.dtype('uint32')   # 32-bit unsigned integer
&gt;&gt;&gt; dt = np.dtype('float64')  # 64-bit floating-point number
</pre>  </dd> </dl> <dl id="index-7"> <dt><code>(flexible_dtype, itemsize)</code></dt>
<dd>
<p>The first argument must be an object that is converted to a zero-sized flexible data-type object, the second argument is an integer providing the desired itemsize.</p>  <h4>Example</h4> <pre data-language="python">&gt;&gt;&gt; dt = np.dtype((np.void, 10))  # 10-byte wide data block
&gt;&gt;&gt; dt = np.dtype(('U', 10))   # 10-character unicode string
</pre>  </dd> <dt><code>(fixed_dtype, shape)</code></dt>
<dd>
<p id="index-8">The first argument is any object that can be converted into a fixed-size data-type object. The second argument is the desired shape of this type. If the shape parameter is 1, then the data-type object used to be equivalent to fixed dtype. This behaviour is deprecated since NumPy 1.17 and will raise an error in the future. If <em>shape</em> is a tuple, then the new dtype defines a sub-array of the given shape.</p>  <h4>Example</h4> <pre data-language="python">&gt;&gt;&gt; dt = np.dtype((np.int32, (2,2)))          # 2 x 2 integer sub-array
&gt;&gt;&gt; dt = np.dtype(('i4, (2,3)f8, f4', (2,3))) # 2 x 3 structured sub-array
</pre>  </dd> </dl> <dl id="index-9"> <dt><code>[(field_name, field_dtype, field_shape), ...]</code></dt>
<dd>
<p><em>obj</em> should be a list of fields where each field is described by a tuple of length 2 or 3. (Equivalent to the <code>descr</code> item in the <a class="reference internal" href="arrays.interface#object.__array_interface__" title="object.__array_interface__"><code>__array_interface__</code></a> attribute.)</p> <p>The first element, <em>field_name</em>, is the field name (if this is <code>''</code> then a standard field name, <code>'f#'</code>, is assigned). The field name may also be a 2-tuple of strings where the first string is either a “title” (which may be any string or unicode string) or meta-data for the field which can be any object, and the second string is the “name” which must be a valid Python identifier.</p> <p>The second element, <em>field_dtype</em>, can be anything that can be interpreted as a data-type.</p> <p>The optional third element <em>field_shape</em> contains the shape if this field represents an array of the data-type in the second element. Note that a 3-tuple with a third argument equal to 1 is equivalent to a 2-tuple.</p> <p>This style does not accept <em>align</em> in the <a class="reference internal" href="generated/numpy.dtype#numpy.dtype" title="numpy.dtype"><code>dtype</code></a> constructor as it is assumed that all of the memory is accounted for by the array interface description.</p>  <h4>Example</h4> <p>Data-type with fields <code>big</code> (big-endian 32-bit integer) and <code>little</code> (little-endian 32-bit integer):</p> <pre data-language="python">&gt;&gt;&gt; dt = np.dtype([('big', '&gt;i4'), ('little', '&lt;i4')])
</pre> <p>Data-type with fields <code>R</code>, <code>G</code>, <code>B</code>, <code>A</code>, each being an unsigned 8-bit integer:</p> <pre data-language="python">&gt;&gt;&gt; dt = np.dtype([('R','u1'), ('G','u1'), ('B','u1'), ('A','u1')])
</pre>  </dd> </dl> <dl id="index-10"> <dt><code>{'names': ..., 'formats': ..., 'offsets': ..., 'titles': ..., 'itemsize': ...}</code></dt>
<dd>
<p>This style has two required and three optional keys. The <em>names</em> and <em>formats</em> keys are required. Their respective values are equal-length lists with the field names and the field formats. The field names must be strings and the field formats can be any object accepted by <a class="reference internal" href="generated/numpy.dtype#numpy.dtype" title="numpy.dtype"><code>dtype</code></a> constructor.</p> <p>When the optional keys <em>offsets</em> and <em>titles</em> are provided, their values must each be lists of the same length as the <em>names</em> and <em>formats</em> lists. The <em>offsets</em> value is a list of byte offsets (limited to <a class="reference external" href="https://docs.python.org/dev/library/ctypes.html#ctypes.c_int" title="(in Python v3.11)"><code>ctypes.c_int</code></a>) for each field, while the <em>titles</em> value is a list of titles for each field (<code>None</code> can be used if no title is desired for that field). The <em>titles</em> can be any object, but when a <a class="reference external" href="https://docs.python.org/dev/library/stdtypes.html#str" title="(in Python v3.11)"><code>str</code></a> object will add another entry to the fields dictionary keyed by the title and referencing the same field tuple which will contain the title as an additional tuple member.</p> <p>The <em>itemsize</em> key allows the total size of the dtype to be set, and must be an integer large enough so all the fields are within the dtype. If the dtype being constructed is aligned, the <em>itemsize</em> must also be divisible by the struct alignment. Total dtype <em>itemsize</em> is limited to <a class="reference external" href="https://docs.python.org/dev/library/ctypes.html#ctypes.c_int" title="(in Python v3.11)"><code>ctypes.c_int</code></a>.</p>  <h4>Example</h4> <p>Data type with fields <code>r</code>, <code>g</code>, <code>b</code>, <code>a</code>, each being an 8-bit unsigned integer:</p> <pre data-language="python">&gt;&gt;&gt; dt = np.dtype({'names': ['r','g','b','a'],
...                'formats': [np.uint8, np.uint8, np.uint8, np.uint8]})
</pre> <p>Data type with fields <code>r</code> and <code>b</code> (with the given titles), both being 8-bit unsigned integers, the first at byte position 0 from the start of the field and the second at position 2:</p> <pre data-language="python">&gt;&gt;&gt; dt = np.dtype({'names': ['r','b'], 'formats': ['u1', 'u1'],
...                'offsets': [0, 2],
...                'titles': ['Red pixel', 'Blue pixel']})
</pre>  </dd> <dt><code>{'field1': ..., 'field2': ..., ...}</code></dt>
<dd>
<p>This usage is discouraged, because it is ambiguous with the other dict-based construction method. If you have a field called ‘names’ and a field called ‘formats’ there will be a conflict.</p> <p>This style allows passing in the <a class="reference internal" href="generated/numpy.dtype.fields#numpy.dtype.fields" title="numpy.dtype.fields"><code>fields</code></a> attribute of a data-type object.</p> <p><em>obj</em> should contain string or unicode keys that refer to <code>(data-type, offset)</code> or <code>(data-type, offset, title)</code> tuples.</p>  <h4>Example</h4> <p>Data type containing field <code>col1</code> (10-character string at byte position 0), <code>col2</code> (32-bit float at byte position 10), and <code>col3</code> (integers at byte position 14):</p> <pre data-language="python">&gt;&gt;&gt; dt = np.dtype({'col1': ('U10', 0), 'col2': (np.float32, 10),
...                'col3': (int, 14)})
</pre>  </dd> <dt><code>(base_dtype, new_dtype)</code></dt>
<dd>
<p>In NumPy 1.7 and later, this form allows <code>base_dtype</code> to be interpreted as a structured dtype. Arrays created with this dtype will have underlying dtype <code>base_dtype</code> but will have fields and flags taken from <code>new_dtype</code>. This is useful for creating custom structured dtypes, as done in <a class="reference internal" href="arrays.classes#arrays-classes-rec"><span class="std std-ref">record arrays</span></a>.</p> <p>This form also makes it possible to specify struct dtypes with overlapping fields, functioning like the ‘union’ type in C. This usage is discouraged, however, and the union mechanism is preferred.</p> <p>Both arguments must be convertible to data-type objects with the same total size.</p>  <h4>Example</h4> <p>32-bit integer, whose first two bytes are interpreted as an integer via field <code>real</code>, and the following two bytes via field <code>imag</code>.</p> <pre data-language="python">&gt;&gt;&gt; dt = np.dtype((np.int32,{'real':(np.int16, 0),'imag':(np.int16, 2)}))
</pre> <p>32-bit integer, which is interpreted as consisting of a sub-array of shape <code>(4,)</code> containing 8-bit integers:</p> <pre data-language="python">&gt;&gt;&gt; dt = np.dtype((np.int32, (np.int8, 4)))
</pre> <p>32-bit integer, containing fields <code>r</code>, <code>g</code>, <code>b</code>, <code>a</code> that interpret the 4 bytes in the integer as four unsigned integers:</p> <pre data-language="python">&gt;&gt;&gt; dt = np.dtype(('i4', [('r','u1'),('g','u1'),('b','u1'),('a','u1')]))
</pre>  </dd> </dl> </section> <section id="dtype"> <h2>dtype</h2> <p>NumPy data type descriptions are instances of the <a class="reference internal" href="generated/numpy.dtype#numpy.dtype" title="numpy.dtype"><code>dtype</code></a> class.</p> <section id="attributes"> <h3>Attributes</h3> <p>The type of the data is described by the following <a class="reference internal" href="generated/numpy.dtype#numpy.dtype" title="numpy.dtype"><code>dtype</code></a> attributes:</p> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.type#numpy.dtype.type" title="numpy.dtype.type"><code>dtype.type</code></a></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.kind#numpy.dtype.kind" title="numpy.dtype.kind"><code>dtype.kind</code></a></p></td> <td><p>A character code (one of 'biufcmMOSUV') identifying the general kind of data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.char#numpy.dtype.char" title="numpy.dtype.char"><code>dtype.char</code></a></p></td> <td><p>A unique character code for each of the 21 different built-in types.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.num#numpy.dtype.num" title="numpy.dtype.num"><code>dtype.num</code></a></p></td> <td><p>A unique number for each of the 21 different built-in types.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.str#numpy.dtype.str" title="numpy.dtype.str"><code>dtype.str</code></a></p></td> <td><p>The array-protocol typestring of this data-type object.</p></td> </tr>  </table> <p>Size of the data is in turn described by:</p> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.name#numpy.dtype.name" title="numpy.dtype.name"><code>dtype.name</code></a></p></td> <td><p>A bit-width name for this data-type.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.itemsize#numpy.dtype.itemsize" title="numpy.dtype.itemsize"><code>dtype.itemsize</code></a></p></td> <td><p>The element size of this data-type object.</p></td> </tr>  </table> <p>Endianness of this data:</p> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.byteorder#numpy.dtype.byteorder" title="numpy.dtype.byteorder"><code>dtype.byteorder</code></a></p></td> <td><p>A character indicating the byte-order of this data-type object.</p></td> </tr>  </table> <p>Information about sub-data-types in a <a class="reference internal" href="../glossary#term-structured-data-type"><span class="xref std std-term">structured data type</span></a>:</p> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.fields#numpy.dtype.fields" title="numpy.dtype.fields"><code>dtype.fields</code></a></p></td> <td><p>Dictionary of named fields defined for this data type, or <code>None</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.names#numpy.dtype.names" title="numpy.dtype.names"><code>dtype.names</code></a></p></td> <td><p>Ordered list of field names, or <code>None</code> if there are no fields.</p></td> </tr>  </table> <p>For data types that describe sub-arrays:</p> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.subdtype#numpy.dtype.subdtype" title="numpy.dtype.subdtype"><code>dtype.subdtype</code></a></p></td> <td><p>Tuple <code>(item_dtype, shape)</code> if this <a class="reference internal" href="generated/numpy.dtype#numpy.dtype" title="numpy.dtype"><code>dtype</code></a> describes a sub-array, and None otherwise.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.shape#numpy.dtype.shape" title="numpy.dtype.shape"><code>dtype.shape</code></a></p></td> <td><p>Shape tuple of the sub-array if this data type describes a sub-array, and <code>()</code> otherwise.</p></td> </tr>  </table> <p>Attributes providing additional information:</p> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.hasobject#numpy.dtype.hasobject" title="numpy.dtype.hasobject"><code>dtype.hasobject</code></a></p></td> <td><p>Boolean indicating whether this dtype contains any reference-counted objects in any fields or sub-dtypes.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.flags#numpy.dtype.flags" title="numpy.dtype.flags"><code>dtype.flags</code></a></p></td> <td><p>Bit-flags describing how this data type is to be interpreted.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.isbuiltin#numpy.dtype.isbuiltin" title="numpy.dtype.isbuiltin"><code>dtype.isbuiltin</code></a></p></td> <td><p>Integer indicating how this dtype relates to the built-in dtypes.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.isnative#numpy.dtype.isnative" title="numpy.dtype.isnative"><code>dtype.isnative</code></a></p></td> <td><p>Boolean indicating whether the byte order of this dtype is native to the platform.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.descr#numpy.dtype.descr" title="numpy.dtype.descr"><code>dtype.descr</code></a></p></td> <td><p><code>__array_interface__</code> description of the data-type.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.alignment#numpy.dtype.alignment" title="numpy.dtype.alignment"><code>dtype.alignment</code></a></p></td> <td><p>The required alignment (bytes) of this data-type according to the compiler.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.base#numpy.dtype.base" title="numpy.dtype.base"><code>dtype.base</code></a></p></td> <td><p>Returns dtype for the base element of the subarrays, regardless of their dimension or shape.</p></td> </tr>  </table> <p>Metadata attached by the user:</p> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.metadata#numpy.dtype.metadata" title="numpy.dtype.metadata"><code>dtype.metadata</code></a></p></td> <td><p>Either <code>None</code> or a readonly dictionary of metadata (mappingproxy).</p></td> </tr>  </table> </section> <section id="methods"> <h3>Methods</h3> <p>Data types have the following method for changing the byte order:</p> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.newbyteorder#numpy.dtype.newbyteorder" title="numpy.dtype.newbyteorder"><code>dtype.newbyteorder</code></a>([new_order])</p></td> <td><p>Return a new dtype with a different byte order.</p></td> </tr>  </table> <p>The following methods implement the pickle protocol:</p> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.__reduce__#numpy.dtype.__reduce__" title="numpy.dtype.__reduce__"><code>dtype.__reduce__</code></a></p></td> <td><p>Helper for pickle.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.__setstate__#numpy.dtype.__setstate__" title="numpy.dtype.__setstate__"><code>dtype.__setstate__</code></a></p></td> <td></td> </tr>  </table> <p>Utility method for typing:</p> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.__class_getitem__#numpy.dtype.__class_getitem__" title="numpy.dtype.__class_getitem__"><code>dtype.__class_getitem__</code></a>(item, /)</p></td> <td><p>Return a parametrized wrapper around the <a class="reference internal" href="generated/numpy.dtype#numpy.dtype" title="numpy.dtype"><code>dtype</code></a> type.</p></td> </tr>  </table> <p>Comparison operations:</p> <table class="longtable table autosummary">   <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.__ge__#numpy.dtype.__ge__" title="numpy.dtype.__ge__"><code>dtype.__ge__</code></a>(value, /)</p></td> <td><p>Return self&gt;=value.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.__gt__#numpy.dtype.__gt__" title="numpy.dtype.__gt__"><code>dtype.__gt__</code></a>(value, /)</p></td> <td><p>Return self&gt;value.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.__le__#numpy.dtype.__le__" title="numpy.dtype.__le__"><code>dtype.__le__</code></a>(value, /)</p></td> <td><p>Return self&lt;=value.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/numpy.dtype.__lt__#numpy.dtype.__lt__" title="numpy.dtype.__lt__"><code>dtype.__lt__</code></a>(value, /)</p></td> <td><p>Return self&lt;value.</p></td> </tr>  </table> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/arrays.dtypes.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/arrays.dtypes.html</a>
  </p>
</div>
