<h1>numpy.ma.array</h1> <dl class="py function"> <dt class="sig sig-object py" id="numpy.ma.array"> <span class="sig-prename descclassname">ma.</span><span class="sig-name descname">array</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mask</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keep_mask</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">hard_mask</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">shrink</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">subok</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">ndmin</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/numpy/numpy/blob/v1.22.0/numpy/ma/core.py#L6552-L6565"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>An array class with possibly masked values.</p> <p>Masked values of True exclude the corresponding element from any computation.</p> <p>Construction:</p> <pre data-language="python">x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,
                ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,
                shrink=True, order=None)
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>data</strong><span class="classifier">array_like</span>
</dt>
<dd>
<p>Input data.</p> </dd> <dt>
<strong>mask</strong><span class="classifier">sequence, optional</span>
</dt>
<dd>
<p>Mask. Must be convertible to an array of booleans with the same shape as <code>data</code>. True indicates a masked (i.e. invalid) data.</p> </dd> <dt>
<strong>dtype</strong><span class="classifier">dtype, optional</span>
</dt>
<dd>
<p>Data type of the output. If <a class="reference internal" href="numpy.dtype#numpy.dtype" title="numpy.dtype"><code>dtype</code></a> is None, the type of the data argument (<code>data.dtype</code>) is used. If <a class="reference internal" href="numpy.dtype#numpy.dtype" title="numpy.dtype"><code>dtype</code></a> is not None and different from <code>data.dtype</code>, a copy is performed.</p> </dd> <dt>
<strong>copy</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>Whether to copy the input data (True), or to use a reference instead. Default is False.</p> </dd> <dt>
<strong>subok</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>Whether to return a subclass of <a class="reference internal" href="../maskedarray.baseclass#numpy.ma.MaskedArray" title="numpy.ma.MaskedArray"><code>MaskedArray</code></a> if possible (True) or a plain <a class="reference internal" href="../maskedarray.baseclass#numpy.ma.MaskedArray" title="numpy.ma.MaskedArray"><code>MaskedArray</code></a>. Default is True.</p> </dd> <dt>
<strong>ndmin</strong><span class="classifier">int, optional</span>
</dt>
<dd>
<p>Minimum number of dimensions. Default is 0.</p> </dd> <dt>
<strong>fill_value</strong><span class="classifier">scalar, optional</span>
</dt>
<dd>
<p>Value used to fill in the masked values when necessary. If None, a default based on the data-type is used.</p> </dd> <dt>
<strong>keep_mask</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>Whether to combine <code>mask</code> with the mask of the input data, if any (True), or to use only <code>mask</code> for the output (False). Default is True.</p> </dd> <dt>
<strong>hard_mask</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>Whether to use a hard mask or not. With a hard mask, masked values cannot be unmasked. Default is False.</p> </dd> <dt>
<strong>shrink</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>Whether to force compression of an empty mask. Default is True.</p> </dd> <dt>
<strong>order</strong><span class="classifier">{‘C’, ‘F’, ‘A’}, optional</span>
</dt>
<dd>
<p>Specify the order of the array. If order is ‘C’, then the array will be in C-contiguous order (last-index varies the fastest). If order is ‘F’, then the returned array will be in Fortran-contiguous order (first-index varies the fastest). If order is ‘A’ (default), then the returned array may be in any order (either C-, Fortran-contiguous, or even discontiguous), unless a copy is required, in which case it will be C-contiguous.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <p>The <code>mask</code> can be initialized with an array of boolean values with the same shape as <code>data</code>.</p> <pre data-language="python">&gt;&gt;&gt; data = np.arange(6).reshape((2, 3))
&gt;&gt;&gt; np.ma.MaskedArray(data, mask=[[False, True, False],
...                               [False, False, True]])
masked_array(
  data=[[0, --, 2],
        [3, 4, --]],
  mask=[[False,  True, False],
        [False, False,  True]],
  fill_value=999999)
</pre> <p>Alternatively, the <code>mask</code> can be initialized to homogeneous boolean array with the same shape as <code>data</code> by passing in a scalar boolean value:</p> <pre data-language="python">&gt;&gt;&gt; np.ma.MaskedArray(data, mask=False)
masked_array(
  data=[[0, 1, 2],
        [3, 4, 5]],
  mask=[[False, False, False],
        [False, False, False]],
  fill_value=999999)
</pre> <pre data-language="python">&gt;&gt;&gt; np.ma.MaskedArray(data, mask=True)
masked_array(
  data=[[--, --, --],
        [--, --, --]],
  mask=[[ True,  True,  True],
        [ True,  True,  True]],
  fill_value=999999,
  dtype=int64)
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The recommended practice for initializing <code>mask</code> with a scalar boolean value is to use <code>True</code>/<code>False</code> rather than <code>np.True_</code>/<code>np.False_</code>. The reason is <a class="reference internal" href="../maskedarray.baseclass#numpy.ma.nomask" title="numpy.ma.nomask"><code>nomask</code></a> is represented internally as <code>np.False_</code>.</p> <pre data-language="python">&gt;&gt;&gt; np.False_ is np.ma.nomask
True
</pre> </div> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/generated/numpy.ma.array.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/generated/numpy.ma.array.html</a>
  </p>
</div>
