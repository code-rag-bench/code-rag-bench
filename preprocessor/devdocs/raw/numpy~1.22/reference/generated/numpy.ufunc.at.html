<h1>numpy.ufunc.at</h1> <p>method</p> <dl class="py method"> <dt class="sig sig-object py" id="numpy.ufunc.at"> <span class="sig-prename descclassname">ufunc.</span><span class="sig-name descname">at</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">indices</span></em>, <em class="sig-param"><span class="n">b</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">/</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>Performs unbuffered in place operation on operand ‘a’ for elements specified by ‘indices’. For addition ufunc, this method is equivalent to <code>a[indices] += b</code>, except that results are accumulated for elements that are indexed more than once. For example, <code>a[[0,0]] += 1</code> will only increment the first element once because of buffering, whereas <code>add.at(a, [0,0], 1)</code> will increment the first element twice.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.8.0.</span></p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>a</strong><span class="classifier">array_like</span>
</dt>
<dd>
<p>The array to perform in place operation on.</p> </dd> <dt>
<strong>indices</strong><span class="classifier">array_like or tuple</span>
</dt>
<dd>
<p>Array like index object or slice object for indexing into first operand. If first operand has multiple dimensions, indices can be a tuple of array like index objects or slice objects.</p> </dd> <dt>
<strong>b</strong><span class="classifier">array_like</span>
</dt>
<dd>
<p>Second operand for ufuncs requiring two operands. Operand must be broadcastable over first operand after indexing or slicing.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <p>Set items 0 and 1 to their negative values:</p> <pre data-language="python">&gt;&gt;&gt; a = np.array([1, 2, 3, 4])
&gt;&gt;&gt; np.negative.at(a, [0, 1])
&gt;&gt;&gt; a
array([-1, -2,  3,  4])
</pre> <p>Increment items 0 and 1, and increment item 2 twice:</p> <pre data-language="python">&gt;&gt;&gt; a = np.array([1, 2, 3, 4])
&gt;&gt;&gt; np.add.at(a, [0, 1, 2, 2], 1)
&gt;&gt;&gt; a
array([2, 3, 5, 4])
</pre> <p>Add items 0 and 1 in first array to second array, and store results in first array:</p> <pre data-language="python">&gt;&gt;&gt; a = np.array([1, 2, 3, 4])
&gt;&gt;&gt; b = np.array([1, 2])
&gt;&gt;&gt; np.add.at(a, [0, 1], b)
&gt;&gt;&gt; a
array([2, 4, 3, 4])
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/generated/numpy.ufunc.at.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/generated/numpy.ufunc.at.html</a>
  </p>
</div>
