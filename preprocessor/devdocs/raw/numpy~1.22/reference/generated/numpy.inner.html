<h1>numpy.inner</h1> <dl class="py function"> <dt class="sig sig-object py" id="numpy.inner"> <span class="sig-prename descclassname">numpy.</span><span class="sig-name descname">inner</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="o">/</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>Inner product of two arrays.</p> <p>Ordinary inner product of vectors for 1-D arrays (without complex conjugation), in higher dimensions a sum product over the last axes.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>a, b</strong><span class="classifier">array_like</span>
</dt>
<dd>
<p>If <code>a</code> and <code>b</code> are nonscalar, their last dimensions must match.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>out</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p>If <code>a</code> and <code>b</code> are both scalars or both 1-D arrays then a scalar is returned; otherwise an array is returned. <code>out.shape = (*a.shape[:-1], *b.shape[:-1])</code></p> </dd> </dl> </dd> <dt class="field-odd">Raises</dt> <dd class="field-odd">
<dl class="simple"> <dt>ValueError</dt>
<dd>
<p>If both <code>a</code> and <code>b</code> are nonscalar and their last dimensions have different sizes.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="numpy.tensordot#numpy.tensordot" title="numpy.tensordot"><code>tensordot</code></a></dt>
<dd>
<p>Sum products over arbitrary axes.</p> </dd> <dt><a class="reference internal" href="numpy.dot#numpy.dot" title="numpy.dot"><code>dot</code></a></dt>
<dd>
<p>Generalised matrix product, using second last dimension of <code>b</code>.</p> </dd> <dt><a class="reference internal" href="numpy.einsum#numpy.einsum" title="numpy.einsum"><code>einsum</code></a></dt>
<dd>
<p>Einstein summation convention.</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>For vectors (1-D arrays) it computes the ordinary inner-product:</p> <pre data-language="python">np.inner(a, b) = sum(a[:]*b[:])
</pre> <p>More generally, if <code>ndim(a) = r &gt; 0</code> and <code>ndim(b) = s &gt; 0</code>:</p> <pre data-language="python">np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))
</pre> <p>or explicitly:</p> <pre data-language="python">np.inner(a, b)[i0,...,ir-2,j0,...,js-2]
     = sum(a[i0,...,ir-2,:]*b[j0,...,js-2,:])
</pre> <p>In addition <code>a</code> or <code>b</code> may be scalars, in which case:</p> <pre data-language="python">np.inner(a,b) = a*b
</pre> <h4 class="rubric">Examples</h4> <p>Ordinary inner product for vectors:</p> <pre data-language="python">&gt;&gt;&gt; a = np.array([1,2,3])
&gt;&gt;&gt; b = np.array([0,1,0])
&gt;&gt;&gt; np.inner(a, b)
2
</pre> <p>Some multidimensional examples:</p> <pre data-language="python">&gt;&gt;&gt; a = np.arange(24).reshape((2,3,4))
&gt;&gt;&gt; b = np.arange(4)
&gt;&gt;&gt; c = np.inner(a, b)
&gt;&gt;&gt; c.shape
(2, 3)
&gt;&gt;&gt; c
array([[ 14,  38,  62],
       [ 86, 110, 134]])
</pre> <pre data-language="python">&gt;&gt;&gt; a = np.arange(2).reshape((1,1,2))
&gt;&gt;&gt; b = np.arange(6).reshape((3,2))
&gt;&gt;&gt; c = np.inner(a, b)
&gt;&gt;&gt; c.shape
(1, 1, 3)
&gt;&gt;&gt; c
array([[[1, 3, 5]]])
</pre> <p>An example where <code>b</code> is a scalar:</p> <pre data-language="python">&gt;&gt;&gt; np.inner(np.eye(2), 7)
array([[7., 0.],
       [0., 7.]])
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/generated/numpy.inner.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/generated/numpy.inner.html</a>
  </p>
</div>
