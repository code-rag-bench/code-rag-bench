<h1>numpy.dot</h1> <dl class="py function"> <dt class="sig sig-object py" id="numpy.dot"> <span class="sig-prename descclassname">numpy.</span><span class="sig-name descname">dot</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>Dot product of two arrays. Specifically,</p> <ul> <li>If both <code>a</code> and <code>b</code> are 1-D arrays, it is inner product of vectors (without complex conjugation).</li> <li>If both <code>a</code> and <code>b</code> are 2-D arrays, it is matrix multiplication, but using <a class="reference internal" href="numpy.matmul#numpy.matmul" title="numpy.matmul"><code>matmul</code></a> or <code>a @ b</code> is preferred.</li> <li>If either <code>a</code> or <code>b</code> is 0-D (scalar), it is equivalent to <a class="reference internal" href="numpy.multiply#numpy.multiply" title="numpy.multiply"><code>multiply</code></a> and using <code>numpy.multiply(a, b)</code> or <code>a * b</code> is preferred.</li> <li>If <code>a</code> is an N-D array and <code>b</code> is a 1-D array, it is a sum product over the last axis of <code>a</code> and <code>b</code>.</li> <li>
<p>If <code>a</code> is an N-D array and <code>b</code> is an M-D array (where <code>M&gt;=2</code>), it is a sum product over the last axis of <code>a</code> and the second-to-last axis of <code>b</code>:</p> <pre data-language="python">dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])
</pre> </li> </ul> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>a</strong><span class="classifier">array_like</span>
</dt>
<dd>
<p>First argument.</p> </dd> <dt>
<strong>b</strong><span class="classifier">array_like</span>
</dt>
<dd>
<p>Second argument.</p> </dd> <dt>
<strong>out</strong><span class="classifier">ndarray, optional</span>
</dt>
<dd>
<p>Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for <code>dot(a,b)</code>. This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>output</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p>Returns the dot product of <code>a</code> and <code>b</code>. If <code>a</code> and <code>b</code> are both scalars or both 1-D arrays then a scalar is returned; otherwise an array is returned. If <code>out</code> is given, then it is returned.</p> </dd> </dl> </dd> <dt class="field-odd">Raises</dt> <dd class="field-odd">
<dl class="simple"> <dt>ValueError</dt>
<dd>
<p>If the last dimension of <code>a</code> is not the same size as the second-to-last dimension of <code>b</code>.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="numpy.vdot#numpy.vdot" title="numpy.vdot"><code>vdot</code></a></dt>
<dd>
<p>Complex-conjugating dot product.</p> </dd> <dt><a class="reference internal" href="numpy.tensordot#numpy.tensordot" title="numpy.tensordot"><code>tensordot</code></a></dt>
<dd>
<p>Sum products over arbitrary axes.</p> </dd> <dt><a class="reference internal" href="numpy.einsum#numpy.einsum" title="numpy.einsum"><code>einsum</code></a></dt>
<dd>
<p>Einstein summation convention.</p> </dd> <dt><a class="reference internal" href="numpy.matmul#numpy.matmul" title="numpy.matmul"><code>matmul</code></a></dt>
<dd>
<p>‘@’ operator as method with out parameter.</p> </dd> <dt><a class="reference internal" href="numpy.linalg.multi_dot#numpy.linalg.multi_dot" title="numpy.linalg.multi_dot"><code>linalg.multi_dot</code></a></dt>
<dd>
<p>Chained dot product.</p> </dd> </dl> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; np.dot(3, 4)
12
</pre> <p>Neither argument is complex-conjugated:</p> <pre data-language="python">&gt;&gt;&gt; np.dot([2j, 3j], [2j, 3j])
(-13+0j)
</pre> <p>For 2-D arrays it is the matrix product:</p> <pre data-language="python">&gt;&gt;&gt; a = [[1, 0], [0, 1]]
&gt;&gt;&gt; b = [[4, 1], [2, 2]]
&gt;&gt;&gt; np.dot(a, b)
array([[4, 1],
       [2, 2]])
</pre> <pre data-language="python">&gt;&gt;&gt; a = np.arange(3*4*5*6).reshape((3,4,5,6))
&gt;&gt;&gt; b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))
&gt;&gt;&gt; np.dot(a, b)[2,3,2,1,2,2]
499128
&gt;&gt;&gt; sum(a[2,3,2,:] * b[1,2,:,2])
499128
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/generated/numpy.dot.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/generated/numpy.dot.html</a>
  </p>
</div>
