<h1>numpy.nested_iters</h1> <dl class="py function"> <dt class="sig sig-object py" id="numpy.nested_iters"> <span class="sig-prename descclassname">numpy.</span><span class="sig-name descname">nested_iters</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">op</span></em>, <em class="sig-param"><span class="n">axes</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">op_flags</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">op_dtypes</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">'K'</span></em>, <em class="sig-param"><span class="n">casting</span><span class="o">=</span><span class="default_value">'safe'</span></em>, <em class="sig-param"><span class="n">buffersize</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>Create nditers for use in nested loops</p> <p>Create a tuple of <a class="reference internal" href="numpy.nditer#numpy.nditer" title="numpy.nditer"><code>nditer</code></a> objects which iterate in nested loops over different axes of the op argument. The first iterator is used in the outermost loop, the last in the innermost loop. Advancing one will change the subsequent iterators to point at its new element.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>op</strong><span class="classifier">ndarray or sequence of array_like</span>
</dt>
<dd>
<p>The array(s) to iterate over.</p> </dd> <dt>
<strong>axes</strong><span class="classifier">list of list of int</span>
</dt>
<dd>
<p>Each item is used as an “op_axes” argument to an nditer</p> </dd> <dt><strong>flags, op_flags, op_dtypes, order, casting, buffersize (optional)</strong></dt>
<dd>
<p>See <a class="reference internal" href="numpy.nditer#numpy.nditer" title="numpy.nditer"><code>nditer</code></a> parameters of the same name</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>iters</strong><span class="classifier">tuple of nditer</span>
</dt>
<dd>
<p>An nditer for each item in <code>axes</code>, outermost first</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="numpy.nditer#numpy.nditer" title="numpy.nditer"><code>nditer</code></a></dt>
 </dl> </div> <h4 class="rubric">Examples</h4> <p>Basic usage. Note how y is the “flattened” version of [a[:, 0, :], a[:, 1, 0], a[:, 2, :]] since we specified the first iter’s axes as [1]</p> <pre data-language="python">&gt;&gt;&gt; a = np.arange(12).reshape(2, 3, 2)
&gt;&gt;&gt; i, j = np.nested_iters(a, [[1], [0, 2]], flags=["multi_index"])
&gt;&gt;&gt; for x in i:
...      print(i.multi_index)
...      for y in j:
...          print('', j.multi_index, y)
(0,)
 (0, 0) 0
 (0, 1) 1
 (1, 0) 6
 (1, 1) 7
(1,)
 (0, 0) 2
 (0, 1) 3
 (1, 0) 8
 (1, 1) 9
(2,)
 (0, 0) 4
 (0, 1) 5
 (1, 0) 10
 (1, 1) 11
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/generated/numpy.nested_iters.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/generated/numpy.nested_iters.html</a>
  </p>
</div>
