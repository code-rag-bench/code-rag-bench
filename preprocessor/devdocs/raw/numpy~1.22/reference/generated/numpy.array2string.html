<h1>numpy.array2string</h1> <dl class="py function"> <dt class="sig sig-object py" id="numpy.array2string"> <span class="sig-prename descclassname">numpy.</span><span class="sig-name descname">array2string</span><span class="sig-paren">(</span><em class="sig-param">a</em>, <em class="sig-param">max_line_width=None</em>, <em class="sig-param">precision=None</em>, <em class="sig-param">suppress_small=None</em>, <em class="sig-param">separator=' '</em>, <em class="sig-param">prefix=''</em>, <em class="sig-param">style=&lt;no value&gt;</em>, <em class="sig-param">formatter=None</em>, <em class="sig-param">threshold=None</em>, <em class="sig-param">edgeitems=None</em>, <em class="sig-param">sign=None</em>, <em class="sig-param">floatmode=None</em>, <em class="sig-param">suffix=''</em>, <em class="sig-param">*</em>, <em class="sig-param">legacy=None</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/numpy/numpy/blob/v1.22.0/numpy/core/arrayprint.py#L561-L736"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a string representation of an array.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>a</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p>Input array.</p> </dd> <dt>
<strong>max_line_width</strong><span class="classifier">int, optional</span>
</dt>
<dd>
<p>Inserts newlines if text is longer than <code>max_line_width</code>. Defaults to <code>numpy.get_printoptions()['linewidth']</code>.</p> </dd> <dt>
<strong>precision</strong><span class="classifier">int or None, optional</span>
</dt>
<dd>
<p>Floating point precision. Defaults to <code>numpy.get_printoptions()['precision']</code>.</p> </dd> <dt>
<strong>suppress_small</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>Represent numbers “very close” to zero as zero; default is False. Very close is defined by precision: if the precision is 8, e.g., numbers smaller (in absolute value) than 5e-9 are represented as zero. Defaults to <code>numpy.get_printoptions()['suppress']</code>.</p> </dd> <dt>
<strong>separator</strong><span class="classifier">str, optional</span>
</dt>
<dd>
<p>Inserted between elements.</p> </dd> <dt>
<strong>prefix</strong><span class="classifier">str, optional</span>
</dt>
 <dt>
<strong>suffix</strong><span class="classifier">str, optional</span>
</dt>
<dd>
<p>The length of the prefix and suffix strings are used to respectively align and wrap the output. An array is typically printed as:</p> <pre data-language="python">prefix + array2string(a) + suffix
</pre> <p>The output is left-padded by the length of the prefix string, and wrapping is forced at the column <code>max_line_width - len(suffix)</code>. It should be noted that the content of prefix and suffix strings are not included in the output.</p> </dd> <dt>
<strong>style</strong><span class="classifier">_NoValue, optional</span>
</dt>
<dd>
<p>Has no effect, do not use.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 1.14.0.</span></p> </div> </dd> <dt>
<strong>formatter</strong><span class="classifier">dict of callables, optional</span>
</dt>
<dd>
<p>If not None, the keys should indicate the type(s) that the respective formatting function applies to. Callables should return a string. Types that are not specified (by their corresponding keys) are handled by the default formatters. Individual types for which a formatter can be set are:</p> <ul class="simple"> <li>‘bool’</li> <li>‘int’</li> <li>‘timedelta’ : a <a class="reference internal" href="../arrays.scalars#numpy.timedelta64" title="numpy.timedelta64"><code>numpy.timedelta64</code></a>
</li> <li>‘datetime’ : a <a class="reference internal" href="../arrays.scalars#numpy.datetime64" title="numpy.datetime64"><code>numpy.datetime64</code></a>
</li> <li>‘float’</li> <li>‘longfloat’ : 128-bit floats</li> <li>‘complexfloat’</li> <li>‘longcomplexfloat’ : composed of two 128-bit floats</li> <li>‘void’ : type <a class="reference internal" href="../arrays.scalars#numpy.void" title="numpy.void"><code>numpy.void</code></a>
</li> <li>‘numpystr’ : types <a class="reference internal" href="../arrays.scalars#numpy.string_" title="numpy.string_"><code>numpy.string_</code></a> and <a class="reference internal" href="../arrays.scalars#numpy.unicode_" title="numpy.unicode_"><code>numpy.unicode_</code></a>
</li> </ul> <p>Other keys that can be used to set a group of types at once are:</p> <ul class="simple"> <li>‘all’ : sets all types</li> <li>‘int_kind’ : sets ‘int’</li> <li>‘float_kind’ : sets ‘float’ and ‘longfloat’</li> <li>‘complex_kind’ : sets ‘complexfloat’ and ‘longcomplexfloat’</li> <li>‘str_kind’ : sets ‘numpystr’</li> </ul> </dd> <dt>
<strong>threshold</strong><span class="classifier">int, optional</span>
</dt>
<dd>
<p>Total number of array elements which trigger summarization rather than full repr. Defaults to <code>numpy.get_printoptions()['threshold']</code>.</p> </dd> <dt>
<strong>edgeitems</strong><span class="classifier">int, optional</span>
</dt>
<dd>
<p>Number of array items in summary at beginning and end of each dimension. Defaults to <code>numpy.get_printoptions()['edgeitems']</code>.</p> </dd> <dt>
<strong>sign</strong><span class="classifier">string, either ‘-’, ‘+’, or ‘ ‘, optional</span>
</dt>
<dd>
<p>Controls printing of the sign of floating-point types. If ‘+’, always print the sign of positive values. If ‘ ‘, always prints a space (whitespace character) in the sign position of positive values. If ‘-’, omit the sign character of positive values. Defaults to <code>numpy.get_printoptions()['sign']</code>.</p> </dd> <dt>
<strong>floatmode</strong><span class="classifier">str, optional</span>
</dt>
<dd>
<p>Controls the interpretation of the <code>precision</code> option for floating-point types. Defaults to <code>numpy.get_printoptions()['floatmode']</code>. Can take the following values:</p> <ul class="simple"> <li>‘fixed’: Always print exactly <code>precision</code> fractional digits, even if this would print more or fewer digits than necessary to specify the value uniquely.</li> <li>‘unique’: Print the minimum number of fractional digits necessary to represent each value uniquely. Different elements may have a different number of digits. The value of the <code>precision</code> option is ignored.</li> <li>‘maxprec’: Print at most <code>precision</code> fractional digits, but if an element can be uniquely represented with fewer digits only print it with that many.</li> <li>‘maxprec_equal’: Print at most <code>precision</code> fractional digits, but if every element in the array can be uniquely represented with an equal number of fewer digits, use that many digits for all elements.</li> </ul> </dd> <dt>
<strong>legacy</strong><span class="classifier">string or <code>False</code>, optional</span>
</dt>
<dd>
<p>If set to the string <code>‘1.13’</code> enables 1.13 legacy printing mode. This approximates numpy 1.13 print output by including a space in the sign position of floats and different behavior for 0d arrays. If set to <code>False</code>, disables legacy mode. Unrecognized strings will be ignored with a warning for forward compatibility.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.14.0.</span></p> </div> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>array_str</strong><span class="classifier">str</span>
</dt>
<dd>
<p>String representation of the array.</p> </dd> </dl> </dd> <dt class="field-odd">Raises</dt> <dd class="field-odd">
<dl class="simple"> <dt>TypeError</dt>
<dd>
<p>if a callable in <code>formatter</code> does not return a string.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<a class="reference internal" href="numpy.array_str#numpy.array_str" title="numpy.array_str"><code>array_str</code></a>, <a class="reference internal" href="numpy.array_repr#numpy.array_repr" title="numpy.array_repr"><code>array_repr</code></a>, <a class="reference internal" href="numpy.set_printoptions#numpy.set_printoptions" title="numpy.set_printoptions"><code>set_printoptions</code></a>, <a class="reference internal" href="numpy.get_printoptions#numpy.get_printoptions" title="numpy.get_printoptions"><code>get_printoptions</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>If a formatter is specified for a certain type, the <code>precision</code> keyword is ignored for that type.</p> <p>This is a very flexible function; <a class="reference internal" href="numpy.array_repr#numpy.array_repr" title="numpy.array_repr"><code>array_repr</code></a> and <a class="reference internal" href="numpy.array_str#numpy.array_str" title="numpy.array_str"><code>array_str</code></a> are using <a class="reference internal" href="#numpy.array2string" title="numpy.array2string"><code>array2string</code></a> internally so keywords with the same name should work identically in all three functions.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; x = np.array([1e-16,1,2,3])
&gt;&gt;&gt; np.array2string(x, precision=2, separator=',',
...                       suppress_small=True)
'[0.,1.,2.,3.]'
</pre> <pre data-language="python">&gt;&gt;&gt; x  = np.arange(3.)
&gt;&gt;&gt; np.array2string(x, formatter={'float_kind':lambda x: "%.2f" % x})
'[0.00 1.00 2.00]'
</pre> <pre data-language="python">&gt;&gt;&gt; x  = np.arange(3)
&gt;&gt;&gt; np.array2string(x, formatter={'int':lambda x: hex(x)})
'[0x0 0x1 0x2]'
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/generated/numpy.array2string.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/generated/numpy.array2string.html</a>
  </p>
</div>
