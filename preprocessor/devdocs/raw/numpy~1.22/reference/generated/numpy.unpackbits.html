<h1>numpy.unpackbits</h1> <dl class="py function"> <dt class="sig sig-object py" id="numpy.unpackbits"> <span class="sig-prename descclassname">numpy.</span><span class="sig-name descname">unpackbits</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="o">/</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">count</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">bitorder</span><span class="o">=</span><span class="default_value">'big'</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>Unpacks elements of a uint8 array into a binary-valued output array.</p> <p>Each element of <code>a</code> represents a bit-field that should be unpacked into a binary-valued output array. The shape of the output array is either 1-D (if <code>axis</code> is <code>None</code>) or the same shape as the input array with unpacking done along the axis specified.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>a</strong><span class="classifier">ndarray, uint8 type</span>
</dt>
<dd>
<p>Input array.</p> </dd> <dt>
<strong>axis</strong><span class="classifier">int, optional</span>
</dt>
<dd>
<p>The dimension over which bit-unpacking is done. <code>None</code> implies unpacking the flattened array.</p> </dd> <dt>
<strong>count</strong><span class="classifier">int or None, optional</span>
</dt>
<dd>
<p>The number of elements to unpack along <code>axis</code>, provided as a way of undoing the effect of packing a size that is not a multiple of eight. A non-negative number means to only unpack <code>count</code> bits. A negative number means to trim off that many bits from the end. <code>None</code> means to unpack the entire array (the default). Counts larger than the available number of bits will add zero padding to the output. Negative counts must not exceed the available number of bits.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.17.0.</span></p> </div> </dd> <dt>
<strong>bitorder</strong><span class="classifier">{‘big’, ‘little’}, optional</span>
</dt>
<dd>
<p>The order of the returned bits. ‘big’ will mimic bin(val), <code>3 = 0b00000011 =&gt; [0, 0, 0, 0, 0, 0, 1, 1]</code>, ‘little’ will reverse the order to <code>[1, 1, 0, 0, 0, 0, 0, 0]</code>. Defaults to ‘big’.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.17.0.</span></p> </div> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>unpacked</strong><span class="classifier">ndarray, uint8 type</span>
</dt>
<dd>
<p>The elements are binary-valued (0 or 1).</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="numpy.packbits#numpy.packbits" title="numpy.packbits"><code>packbits</code></a></dt>
<dd>
<p>Packs the elements of a binary-valued array into bits in a uint8 array.</p> </dd> </dl> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; a = np.array([[2], [7], [23]], dtype=np.uint8)
&gt;&gt;&gt; a
array([[ 2],
       [ 7],
       [23]], dtype=uint8)
&gt;&gt;&gt; b = np.unpackbits(a, axis=1)
&gt;&gt;&gt; b
array([[0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 1, 1, 1],
       [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)
&gt;&gt;&gt; c = np.unpackbits(a, axis=1, count=-3)
&gt;&gt;&gt; c
array([[0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0]], dtype=uint8)
</pre> <pre data-language="python">&gt;&gt;&gt; p = np.packbits(b, axis=0)
&gt;&gt;&gt; np.unpackbits(p, axis=0)
array([[0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 1, 1, 1],
       [0, 0, 0, 1, 0, 1, 1, 1],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
&gt;&gt;&gt; np.array_equal(b, np.unpackbits(p, axis=0, count=b.shape[0]))
True
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/generated/numpy.unpackbits.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/generated/numpy.unpackbits.html</a>
  </p>
</div>
