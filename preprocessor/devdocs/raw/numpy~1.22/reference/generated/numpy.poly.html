<h1>numpy.poly</h1> <dl class="py function"> <dt class="sig sig-object py" id="numpy.poly"> <span class="sig-prename descclassname">numpy.</span><span class="sig-name descname">poly</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">seq_of_zeros</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/numpy/numpy/blob/v1.22.0/numpy/lib/polynomial.py#L44-L164"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find the coefficients of a polynomial with the given sequence of roots.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This forms part of the old polynomial API. Since version 1.4, the new polynomial API defined in <a class="reference internal" href="../routines.polynomials.package#module-numpy.polynomial" title="numpy.polynomial"><code>numpy.polynomial</code></a> is preferred. A summary of the differences can be found in the <a class="reference internal" href="../routines.polynomials"><span class="doc">transition guide</span></a>.</p> </div> <p>Returns the coefficients of the polynomial whose leading coefficient is one for the given sequence of zeros (multiple roots must be included in the sequence as many times as their multiplicity; see Examples). A square matrix (or array, which will be treated as a matrix) can also be given, in which case the coefficients of the characteristic polynomial of the matrix are returned.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>seq_of_zeros</strong><span class="classifier">array_like, shape (N,) or (N, N)</span>
</dt>
<dd>
<p>A sequence of polynomial roots, or a square array or matrix object.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<strong>c</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p>1D array of polynomial coefficients from highest to lowest degree:</p> <p><code>c[0] * x**(N) + c[1] * x**(N-1) + ... + c[N-1] * x + c[N]</code> where c[0] always equals 1.</p> </dd> </dl> </dd> <dt class="field-odd">Raises</dt> <dd class="field-odd">
<dl class="simple"> <dt>ValueError</dt>
<dd>
<p>If input is the wrong shape (the input must be a 1-D or square 2-D array).</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="numpy.polyval#numpy.polyval" title="numpy.polyval"><code>polyval</code></a></dt>
<dd>
<p>Compute polynomial values.</p> </dd> <dt><a class="reference internal" href="numpy.roots#numpy.roots" title="numpy.roots"><code>roots</code></a></dt>
<dd>
<p>Return the roots of a polynomial.</p> </dd> <dt><a class="reference internal" href="numpy.polyfit#numpy.polyfit" title="numpy.polyfit"><code>polyfit</code></a></dt>
<dd>
<p>Least squares polynomial fit.</p> </dd> <dt><a class="reference internal" href="numpy.poly1d#numpy.poly1d" title="numpy.poly1d"><code>poly1d</code></a></dt>
<dd>
<p>A one-dimensional polynomial class.</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>Specifying the roots of a polynomial still leaves one degree of freedom, typically represented by an undetermined leading coefficient. <a class="reference internal" href="#r6c2ffae921d1-1" id="id1">[1]</a> In the case of this function, that coefficient - the first one in the returned array - is always taken as one. (If for some reason you have one other point, the only automatic way presently to leverage that information is to use <code>polyfit</code>.)</p> <p>The characteristic polynomial, <span class="math notranslate nohighlight">\(p_a(t)\)</span>, of an <code>n</code>-by-<code>n</code> matrix <strong>A</strong> is given by</p>  <p><span class="math notranslate nohighlight">\(p_a(t) = \mathrm{det}(t\, \mathbf{I} - \mathbf{A})\)</span>,</p>  <p>where <strong>I</strong> is the <code>n</code>-by-<code>n</code> identity matrix. <a class="reference internal" href="#r6c2ffae921d1-2" id="id2">[2]</a></p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r6c2ffae921d1-1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt> <dd>
<p>M. Sullivan and M. Sullivan, III, “Algebra and Trignometry, Enhanced With Graphing Utilities,” Prentice-Hall, pg. 318, 1996.</p> </dd> <dt class="label" id="r6c2ffae921d1-2"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt> <dd>
<p>G. Strang, “Linear Algebra and Its Applications, 2nd Edition,” Academic Press, pg. 182, 1980.</p> </dd> </dl> <h4 class="rubric">Examples</h4> <p>Given a sequence of a polynomial’s zeros:</p> <pre data-language="python">&gt;&gt;&gt; np.poly((0, 0, 0)) # Multiple root example
array([1., 0., 0., 0.])
</pre> <p>The line above represents z**3 + 0*z**2 + 0*z + 0.</p> <pre data-language="python">&gt;&gt;&gt; np.poly((-1./2, 0, 1./2))
array([ 1.  ,  0.  , -0.25,  0.  ])
</pre> <p>The line above represents z**3 - z/4</p> <pre data-language="python">&gt;&gt;&gt; np.poly((np.random.random(1)[0], 0, np.random.random(1)[0]))
array([ 1.        , -0.77086955,  0.08618131,  0.        ]) # random
</pre> <p>Given a square array object:</p> <pre data-language="python">&gt;&gt;&gt; P = np.array([[0, 1./3], [-1./2, 0]])
&gt;&gt;&gt; np.poly(P)
array([1.        , 0.        , 0.16666667])
</pre> <p>Note how in all cases the leading coefficient is always 1.</p> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/generated/numpy.poly.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/generated/numpy.poly.html</a>
  </p>
</div>
