<h1>numpy.finfo</h1> <dl class="py class"> <dt class="sig sig-object py" id="numpy.finfo"> <em class="property">class </em><span class="sig-prename descclassname">numpy.</span><span class="sig-name descname">finfo</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">dtype</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/numpy/numpy/blob/v1.22.0/numpy/__init__.py"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Machine limits for floating point types.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>dtype</strong><span class="classifier">float, dtype, or instance</span>
</dt>
<dd>
<p>Kind of floating point data-type about which to get information.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="numpy.machar#numpy.MachAr" title="numpy.MachAr"><code>MachAr</code></a></dt>
<dd>
<p>The implementation of the tests that produce this information.</p> </dd> <dt><a class="reference internal" href="numpy.iinfo#numpy.iinfo" title="numpy.iinfo"><code>iinfo</code></a></dt>
<dd>
<p>The equivalent for integer data types.</p> </dd> <dt><a class="reference internal" href="numpy.spacing#numpy.spacing" title="numpy.spacing"><code>spacing</code></a></dt>
<dd>
<p>The distance between a value and the nearest adjacent number</p> </dd> <dt><a class="reference internal" href="numpy.nextafter#numpy.nextafter" title="numpy.nextafter"><code>nextafter</code></a></dt>
<dd>
<p>The next floating point value after x1 towards x2</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>For developers of NumPy: do not instantiate this at the module level. The initial calculation of these parameters is expensive and negatively impacts import times. These objects are cached, so calling <code>finfo()</code> repeatedly inside your functions is not a problem.</p> <p>Note that <code>smallest_normal</code> is not actually the smallest positive representable value in a NumPy floating point type. As in the IEEE-754 standard <a class="reference internal" href="#r2ee89c7f792a-1" id="id1">[1]</a>, NumPy floating point types make use of subnormal numbers to fill the gap between 0 and <code>smallest_normal</code>. However, subnormal numbers may have significantly reduced precision <a class="reference internal" href="#r2ee89c7f792a-2" id="id2">[2]</a>.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r2ee89c7f792a-1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt> <dd>
<p>IEEE Standard for Floating-Point Arithmetic, IEEE Std 754-2008, pp.1-70, 2008, <a class="reference external" href="http://www.doi.org/10.1109/IEEESTD.2008.4610935">http://www.doi.org/10.1109/IEEESTD.2008.4610935</a></p> </dd> <dt class="label" id="r2ee89c7f792a-2"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt> <dd>
<p>Wikipedia, “Denormal Numbers”, <a class="reference external" href="https://en.wikipedia.org/wiki/Denormal_number">https://en.wikipedia.org/wiki/Denormal_number</a></p> </dd> </dl> <dl class="field-list simple"> <dt class="field-odd">Attributes</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>bits</strong><span class="classifier">int</span>
</dt>
<dd>
<p>The number of bits occupied by the type.</p> </dd> <dt>
<strong>eps</strong><span class="classifier">float</span>
</dt>
<dd>
<p>The difference between 1.0 and the next smallest representable float larger than 1.0. For example, for 64-bit binary floats in the IEEE-754 standard, <code>eps = 2**-52</code>, approximately 2.22e-16.</p> </dd> <dt>
<strong>epsneg</strong><span class="classifier">float</span>
</dt>
<dd>
<p>The difference between 1.0 and the next smallest representable float less than 1.0. For example, for 64-bit binary floats in the IEEE-754 standard, <code>epsneg = 2**-53</code>, approximately 1.11e-16.</p> </dd> <dt>
<strong>iexp</strong><span class="classifier">int</span>
</dt>
<dd>
<p>The number of bits in the exponent portion of the floating point representation.</p> </dd> <dt>
<a class="reference internal" href="numpy.finfo.machar#numpy.finfo.machar" title="numpy.finfo.machar"><code>machar</code></a><span class="classifier">MachAr</span>
</dt>
<dd>
<p>The object which calculated these parameters and holds more detailed information.</p> </dd> <dt>
<strong>machep</strong><span class="classifier">int</span>
</dt>
<dd>
<p>The exponent that yields <code>eps</code>.</p> </dd> <dt>
<strong>max</strong><span class="classifier">floating point number of the appropriate type</span>
</dt>
<dd>
<p>The largest representable number.</p> </dd> <dt>
<strong>maxexp</strong><span class="classifier">int</span>
</dt>
<dd>
<p>The smallest positive power of the base (2) that causes overflow.</p> </dd> <dt>
<strong>min</strong><span class="classifier">floating point number of the appropriate type</span>
</dt>
<dd>
<p>The smallest representable number, typically <code>-max</code>.</p> </dd> <dt>
<strong>minexp</strong><span class="classifier">int</span>
</dt>
<dd>
<p>The most negative power of the base (2) consistent with there being no leading 0’s in the mantissa.</p> </dd> <dt>
<strong>negep</strong><span class="classifier">int</span>
</dt>
<dd>
<p>The exponent that yields <code>epsneg</code>.</p> </dd> <dt>
<strong>nexp</strong><span class="classifier">int</span>
</dt>
<dd>
<p>The number of bits in the exponent including its sign and bias.</p> </dd> <dt>
<strong>nmant</strong><span class="classifier">int</span>
</dt>
<dd>
<p>The number of bits in the mantissa.</p> </dd> <dt>
<strong>precision</strong><span class="classifier">int</span>
</dt>
<dd>
<p>The approximate number of decimal digits to which this kind of float is precise.</p> </dd> <dt>
<strong>resolution</strong><span class="classifier">floating point number of the appropriate type</span>
</dt>
<dd>
<p>The approximate decimal resolution of this type, i.e., <code>10**-precision</code>.</p> </dd> <dt>
<a class="reference internal" href="numpy.finfo.tiny#numpy.finfo.tiny" title="numpy.finfo.tiny"><code>tiny</code></a><span class="classifier">float</span>
</dt>
<dd>
<p>Return the value for tiny, alias of smallest_normal.</p> </dd> <dt>
<a class="reference internal" href="numpy.finfo.smallest_normal#numpy.finfo.smallest_normal" title="numpy.finfo.smallest_normal"><code>smallest_normal</code></a><span class="classifier">float</span>
</dt>
<dd>
<p>Return the value for the smallest normal.</p> </dd> <dt>
<strong>smallest_subnormal</strong><span class="classifier">float</span>
</dt>
<dd>
<p>The smallest positive floating point number with 0 as leading bit in the mantissa following IEEE-754.</p> </dd> </dl> </dd> </dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/generated/numpy.finfo.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/generated/numpy.finfo.html</a>
  </p>
</div>
