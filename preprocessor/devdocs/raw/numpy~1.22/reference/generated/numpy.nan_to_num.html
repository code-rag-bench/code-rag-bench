<h1>numpy.nan_to_num</h1> <dl class="py function"> <dt class="sig sig-object py" id="numpy.nan_to_num"> <span class="sig-prename descclassname">numpy.</span><span class="sig-name descname">nan_to_num</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">nan</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">posinf</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">neginf</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/numpy/numpy/blob/v1.22.0/numpy/lib/type_check.py#L404-L521"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Replace NaN with zero and infinity with large finite numbers (default behaviour) or with the numbers defined by the user using the <a class="reference internal" href="../constants#numpy.nan" title="numpy.nan"><code>nan</code></a>, <code>posinf</code> and/or <code>neginf</code> keywords.</p> <p>If <code>x</code> is inexact, NaN is replaced by zero or by the user defined value in <a class="reference internal" href="../constants#numpy.nan" title="numpy.nan"><code>nan</code></a> keyword, infinity is replaced by the largest finite floating point values representable by <code>x.dtype</code> or by the user defined value in <code>posinf</code> keyword and -infinity is replaced by the most negative finite floating point values representable by <code>x.dtype</code> or by the user defined value in <code>neginf</code> keyword.</p> <p>For complex dtypes, the above is applied to each of the real and imaginary components of <code>x</code> separately.</p> <p>If <code>x</code> is not inexact, then no replacements are made.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>x</strong><span class="classifier">scalar or array_like</span>
</dt>
<dd>
<p>Input data.</p> </dd> <dt>
<strong>copy</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>Whether to create a copy of <code>x</code> (True) or to replace values in-place (False). The in-place operation only occurs if casting to an array does not require a copy. Default is True.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.13.</span></p> </div> </dd> <dt>
<strong>nan</strong><span class="classifier">int, float, optional</span>
</dt>
<dd>
<p>Value to be used to fill NaN values. If no value is passed then NaN values will be replaced with 0.0.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.17.</span></p> </div> </dd> <dt>
<strong>posinf</strong><span class="classifier">int, float, optional</span>
</dt>
<dd>
<p>Value to be used to fill positive infinity values. If no value is passed then positive infinity values will be replaced with a very large number.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.17.</span></p> </div> </dd> <dt>
<strong>neginf</strong><span class="classifier">int, float, optional</span>
</dt>
<dd>
<p>Value to be used to fill negative infinity values. If no value is passed then negative infinity values will be replaced with a very small (or negative) number.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.17.</span></p> </div> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>out</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p><code>x</code>, with the non-finite values replaced. If <a class="reference internal" href="numpy.copy#numpy.copy" title="numpy.copy"><code>copy</code></a> is False, this may be <code>x</code> itself.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="numpy.isinf#numpy.isinf" title="numpy.isinf"><code>isinf</code></a></dt>
<dd>
<p>Shows which elements are positive or negative infinity.</p> </dd> <dt><a class="reference internal" href="numpy.isneginf#numpy.isneginf" title="numpy.isneginf"><code>isneginf</code></a></dt>
<dd>
<p>Shows which elements are negative infinity.</p> </dd> <dt><a class="reference internal" href="numpy.isposinf#numpy.isposinf" title="numpy.isposinf"><code>isposinf</code></a></dt>
<dd>
<p>Shows which elements are positive infinity.</p> </dd> <dt><a class="reference internal" href="numpy.isnan#numpy.isnan" title="numpy.isnan"><code>isnan</code></a></dt>
<dd>
<p>Shows which elements are Not a Number (NaN).</p> </dd> <dt><a class="reference internal" href="numpy.isfinite#numpy.isfinite" title="numpy.isfinite"><code>isfinite</code></a></dt>
<dd>
<p>Shows which elements are finite (not NaN, not infinity)</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; np.nan_to_num(np.inf)
1.7976931348623157e+308
&gt;&gt;&gt; np.nan_to_num(-np.inf)
-1.7976931348623157e+308
&gt;&gt;&gt; np.nan_to_num(np.nan)
0.0
&gt;&gt;&gt; x = np.array([np.inf, -np.inf, np.nan, -128, 128])
&gt;&gt;&gt; np.nan_to_num(x)
array([ 1.79769313e+308, -1.79769313e+308,  0.00000000e+000, # may vary
       -1.28000000e+002,  1.28000000e+002])
&gt;&gt;&gt; np.nan_to_num(x, nan=-9999, posinf=33333333, neginf=33333333)
array([ 3.3333333e+07,  3.3333333e+07, -9.9990000e+03, 
       -1.2800000e+02,  1.2800000e+02])
&gt;&gt;&gt; y = np.array([complex(np.inf, np.nan), np.nan, complex(np.nan, np.inf)])
array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000, # may vary
     -1.28000000e+002,   1.28000000e+002])
&gt;&gt;&gt; np.nan_to_num(y)
array([  1.79769313e+308 +0.00000000e+000j, # may vary
         0.00000000e+000 +0.00000000e+000j,
         0.00000000e+000 +1.79769313e+308j])
&gt;&gt;&gt; np.nan_to_num(y, nan=111111, posinf=222222)
array([222222.+111111.j, 111111.     +0.j, 111111.+222222.j])
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/generated/numpy.nan_to_num.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/generated/numpy.nan_to_num.html</a>
  </p>
</div>
