<h1>UFunc API</h1> <section id="constants"> <h2 id="index-0">Constants</h2> <dl> <dt><code>UFUNC_ERR_{HANDLER}</code></dt>
<dd>
<dl class="c macro"> <dt class="sig sig-object c" id="c.UFUNC_ERR_IGNORE"> <span class="sig-name descname"><span class="n">UFUNC_ERR_IGNORE</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.UFUNC_ERR_WARN"> <span class="sig-name descname"><span class="n">UFUNC_ERR_WARN</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.UFUNC_ERR_RAISE"> <span class="sig-name descname"><span class="n">UFUNC_ERR_RAISE</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.UFUNC_ERR_CALL"> <span class="sig-name descname"><span class="n">UFUNC_ERR_CALL</span></span><br>
</dt> 
</dl> </dd> <dt><code>UFUNC_{THING}_{ERR}</code></dt>
<dd>
<dl class="c macro"> <dt class="sig sig-object c" id="c.UFUNC_MASK_DIVIDEBYZERO"> <span class="sig-name descname"><span class="n">UFUNC_MASK_DIVIDEBYZERO</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.UFUNC_MASK_OVERFLOW"> <span class="sig-name descname"><span class="n">UFUNC_MASK_OVERFLOW</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.UFUNC_MASK_UNDERFLOW"> <span class="sig-name descname"><span class="n">UFUNC_MASK_UNDERFLOW</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.UFUNC_MASK_INVALID"> <span class="sig-name descname"><span class="n">UFUNC_MASK_INVALID</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.UFUNC_SHIFT_DIVIDEBYZERO"> <span class="sig-name descname"><span class="n">UFUNC_SHIFT_DIVIDEBYZERO</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.UFUNC_SHIFT_OVERFLOW"> <span class="sig-name descname"><span class="n">UFUNC_SHIFT_OVERFLOW</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.UFUNC_SHIFT_UNDERFLOW"> <span class="sig-name descname"><span class="n">UFUNC_SHIFT_UNDERFLOW</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.UFUNC_SHIFT_INVALID"> <span class="sig-name descname"><span class="n">UFUNC_SHIFT_INVALID</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.UFUNC_FPE_DIVIDEBYZERO"> <span class="sig-name descname"><span class="n">UFUNC_FPE_DIVIDEBYZERO</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.UFUNC_FPE_OVERFLOW"> <span class="sig-name descname"><span class="n">UFUNC_FPE_OVERFLOW</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.UFUNC_FPE_UNDERFLOW"> <span class="sig-name descname"><span class="n">UFUNC_FPE_UNDERFLOW</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.UFUNC_FPE_INVALID"> <span class="sig-name descname"><span class="n">UFUNC_FPE_INVALID</span></span><br>
</dt> 
</dl> </dd> <dt><code>PyUFunc_{VALUE}</code></dt>
<dd>
<dl class="c macro"> <dt class="sig sig-object c" id="c.PyUFunc_One"> <span class="sig-name descname"><span class="n">PyUFunc_One</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyUFunc_Zero"> <span class="sig-name descname"><span class="n">PyUFunc_Zero</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyUFunc_MinusOne"> <span class="sig-name descname"><span class="n">PyUFunc_MinusOne</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyUFunc_ReorderableNone"> <span class="sig-name descname"><span class="n">PyUFunc_ReorderableNone</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyUFunc_None"> <span class="sig-name descname"><span class="n">PyUFunc_None</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.PyUFunc_IdentityValue"> <span class="sig-name descname"><span class="n">PyUFunc_IdentityValue</span></span><br>
</dt> 
</dl> </dd> </dl> </section> <section id="macros"> <h2>Macros</h2> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_LOOP_BEGIN_THREADS"> <span class="sig-name descname"><span class="n">NPY_LOOP_BEGIN_THREADS</span></span><br>
</dt> <dd>
<p>Used in universal function code to only release the Python GIL if loop-&gt;obj is not true (<em>i.e.</em> this is not an OBJECT array loop). Requires use of <a class="reference internal" href="array#c.NPY_BEGIN_THREADS_DEF" title="NPY_BEGIN_THREADS_DEF"><code>NPY_BEGIN_THREADS_DEF</code></a> in variable declaration area.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_LOOP_END_THREADS"> <span class="sig-name descname"><span class="n">NPY_LOOP_END_THREADS</span></span><br>
</dt> <dd>
<p>Used in universal function code to re-acquire the Python GIL if it was released (because loop-&gt;obj was not true).</p> </dd>
</dl> </section> <section id="types"> <h2>Types</h2> <dl class="c type"> <dt class="sig sig-object c" id="c.PyUFuncGenericFunction"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyUFuncGenericFunction</span></span><br>
</dt> <dd>
<p>pointers to functions that actually implement the underlying (element-by-element) function <span class="math notranslate nohighlight">\(N\)</span> times with the following signature:</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFuncGenericFunction.loopfunc"> <span class="kt">void</span><span class="sig-name descname"><span class="n">loopfunc</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">data</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p><em>args</em></p>  <p>An array of pointers to the actual data for the input and output arrays. The input arguments are given first followed by the output arguments.</p>  <p><em>dimensions</em></p>  <p>A pointer to the size of the dimension over which this function is looping.</p>  <p><em>steps</em></p>  <p>A pointer to the number of bytes to jump to get to the next element in this dimension for each of the input and output arguments.</p>  <p><em>data</em></p>  <p>Arbitrary data (extra arguments, function names, <em>etc.</em> ) that can be stored with the ufunc and will be passed in when it is called.</p>  <p>This is an example of a func specialized for addition of doubles returning doubles.</p> <pre data-language="c">static void
double_add(char **args,
           npy_intp const *dimensions,
           npy_intp const *steps,
           void *extra)
{
    npy_intp i;
    npy_intp is1 = steps[0], is2 = steps[1];
    npy_intp os = steps[2], n = dimensions[0];
    char *i1 = args[0], *i2 = args[1], *op = args[2];
    for (i = 0; i &lt; n; i++) {
        *((double *)op) = *((double *)i1) +
                          *((double *)i2);
        i1 += is1;
        i2 += is2;
        op += os;
     }
}
</pre> </dd>
</dl> </dd>
</dl> </section> <section id="functions"> <h2>Functions</h2> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_FromFuncAndData"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.11)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyUFunc_FromFuncAndData</span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyUFuncGenericFunction" title="PyUFuncGenericFunction"><span class="n">PyUFuncGenericFunction</span></a><span class="p">*</span><span class="n">func</span>, <span class="kt">void</span><span class="p">*</span><span class="p">*</span><span class="n">data</span>, <span class="kt">char</span><span class="p">*</span><span class="n">types</span>, <span class="kt">int</span><span class="n">ntypes</span>, <span class="kt">int</span><span class="n">nin</span>, <span class="kt">int</span><span class="n">nout</span>, <span class="kt">int</span><span class="n">identity</span>, <span class="kt">char</span><span class="p">*</span><span class="n">name</span>, <span class="kt">char</span><span class="p">*</span><span class="n">doc</span>, <span class="kt">int</span><span class="n">unused</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Create a new broadcasting universal function from required variables. Each ufunc builds around the notion of an element-by-element operation. Each ufunc object contains pointers to 1-d loops implementing the basic functionality for each supported type.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <em>func</em>, <em>data</em>, <em>types</em>, <em>name</em>, and <em>doc</em> arguments are not copied by <a class="reference internal" href="#c.PyUFunc_FromFuncAndData" title="PyUFunc_FromFuncAndData"><code>PyUFunc_FromFuncAndData</code></a>. The caller must ensure that the memory used by these arrays is not freed as long as the ufunc object is alive.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>func</strong> – Must to an array of length <em>ntypes</em> containing <a class="reference internal" href="#c.PyUFuncGenericFunction" title="PyUFuncGenericFunction"><code>PyUFuncGenericFunction</code></a> items.</li> <li>
<strong>data</strong> – Should be <code>NULL</code> or a pointer to an array of size <em>ntypes</em> . This array may contain arbitrary extra-data to be passed to the corresponding loop function in the func array.</li> <li>
<p><strong>types</strong> – </p>
<p>Length <code>(nin + nout) * ntypes</code> array of <code>char</code> encoding the <a class="reference internal" href="../generated/numpy.dtype.num#numpy.dtype.num" title="numpy.dtype.num"><code>numpy.dtype.num</code></a> (built-in only) that the corresponding function in the <code>func</code> array accepts. For instance, for a comparison ufunc with three <code>ntypes</code>, two <code>nin</code> and one <code>nout</code>, where the first function accepts <a class="reference internal" href="../arrays.scalars#numpy.int32" title="numpy.int32"><code>numpy.int32</code></a> and the the second <a class="reference internal" href="../arrays.scalars#numpy.int64" title="numpy.int64"><code>numpy.int64</code></a>, with both returning <a class="reference internal" href="../arrays.scalars#numpy.bool_" title="numpy.bool_"><code>numpy.bool_</code></a>, <code>types</code> would be <code>(char[]) {5, 5, 0, 7, 7, 0}</code> since <code>NPY_INT32</code> is 5, <code>NPY_INT64</code> is 7, and <code>NPY_BOOL</code> is 0.</p> <p>The bit-width names can also be used (e.g. <a class="reference internal" href="dtype#c.NPY_INT32" title="NPY_INT32"><code>NPY_INT32</code></a>, <a class="reference internal" href="dtype#c.NPY_COMPLEX128" title="NPY_COMPLEX128"><code>NPY_COMPLEX128</code></a> ) if desired.</p> <p><a class="reference internal" href="../../user/basics.ufuncs#ufuncs-casting"><span class="std std-ref">Type casting rules</span></a> will be used at runtime to find the first <code>func</code> callable by the input/output provided.</p> </li> <li>
<strong>ntypes</strong> – How many different data-type-specific functions the ufunc has implemented.</li> <li>
<strong>nin</strong> – The number of inputs to this operation.</li> <li>
<strong>nout</strong> – The number of outputs</li> <li>
<strong>identity</strong> – Either <a class="reference internal" href="#c.PyUFunc_One" title="PyUFunc_One"><code>PyUFunc_One</code></a>, <a class="reference internal" href="#c.PyUFunc_Zero" title="PyUFunc_Zero"><code>PyUFunc_Zero</code></a>, <a class="reference internal" href="#c.PyUFunc_MinusOne" title="PyUFunc_MinusOne"><code>PyUFunc_MinusOne</code></a>, or <a class="reference internal" href="#c.PyUFunc_None" title="PyUFunc_None"><code>PyUFunc_None</code></a>. This specifies what should be returned when an empty array is passed to the reduce method of the ufunc. The special value <a class="reference internal" href="#c.PyUFunc_IdentityValue" title="PyUFunc_IdentityValue"><code>PyUFunc_IdentityValue</code></a> may only be used with the <a class="reference internal" href="#c.PyUFunc_FromFuncAndDataAndSignatureAndIdentity" title="PyUFunc_FromFuncAndDataAndSignatureAndIdentity"><code>PyUFunc_FromFuncAndDataAndSignatureAndIdentity</code></a> method, to allow an arbitrary python object to be used as the identity.</li> <li>
<strong>name</strong> – The name for the ufunc as a <code>NULL</code> terminated string. Specifying a name of ‘add’ or ‘multiply’ enables a special behavior for integer-typed reductions when no dtype is given. If the input type is an integer (or boolean) data type smaller than the size of the <a class="reference internal" href="../arrays.scalars#numpy.int_" title="numpy.int_"><code>numpy.int_</code></a> data type, it will be internally upcast to the <a class="reference internal" href="../arrays.scalars#numpy.int_" title="numpy.int_"><code>numpy.int_</code></a> (or <a class="reference internal" href="../arrays.scalars#numpy.uint" title="numpy.uint"><code>numpy.uint</code></a>) data type.</li> <li>
<strong>doc</strong> – Allows passing in a documentation string to be stored with the ufunc. The documentation string should not contain the name of the function or the calling signature as that will be dynamically determined from the object and available when accessing the <strong>__doc__</strong> attribute of the ufunc.</li> <li>
<strong>unused</strong> – Unused and present for backwards compatibility of the C-API.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_FromFuncAndDataAndSignature"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.11)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyUFunc_FromFuncAndDataAndSignature</span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyUFuncGenericFunction" title="PyUFuncGenericFunction"><span class="n">PyUFuncGenericFunction</span></a><span class="p">*</span><span class="n">func</span>, <span class="kt">void</span><span class="p">*</span><span class="p">*</span><span class="n">data</span>, <span class="kt">char</span><span class="p">*</span><span class="n">types</span>, <span class="kt">int</span><span class="n">ntypes</span>, <span class="kt">int</span><span class="n">nin</span>, <span class="kt">int</span><span class="n">nout</span>, <span class="kt">int</span><span class="n">identity</span>, <span class="kt">char</span><span class="p">*</span><span class="n">name</span>, <span class="kt">char</span><span class="p">*</span><span class="n">doc</span>, <span class="kt">int</span><span class="n">unused</span>, <span class="kt">char</span><span class="p">*</span><span class="n">signature</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This function is very similar to PyUFunc_FromFuncAndData above, but has an extra <em>signature</em> argument, to define a <a class="reference internal" href="generalized-ufuncs#c-api-generalized-ufuncs"><span class="std std-ref">generalized universal functions</span></a>. Similarly to how ufuncs are built around an element-by-element operation, gufuncs are around subarray-by-subarray operations, the <a class="reference internal" href="generalized-ufuncs#details-of-signature"><span class="std std-ref">signature</span></a> defining the subarrays to operate on.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>signature</strong> – The signature for the new gufunc. Setting it to NULL is equivalent to calling PyUFunc_FromFuncAndData. A copy of the string is made, so the passed in buffer can be freed.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_FromFuncAndDataAndSignatureAndIdentity"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.11)"><span class="n">PyObject</span></a><span class="p">*</span><span class="sig-name descname"><span class="n">PyUFunc_FromFuncAndDataAndSignatureAndIdentity</span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyUFuncGenericFunction" title="PyUFuncGenericFunction"><span class="n">PyUFuncGenericFunction</span></a><span class="p">*</span><span class="n">func</span>, <span class="kt">void</span><span class="p">*</span><span class="p">*</span><span class="n">data</span>, <span class="kt">char</span><span class="p">*</span><span class="n">types</span>, <span class="kt">int</span><span class="n">ntypes</span>, <span class="kt">int</span><span class="n">nin</span>, <span class="kt">int</span><span class="n">nout</span>, <span class="kt">int</span><span class="n">identity</span>, <span class="kt">char</span><span class="p">*</span><span class="n">name</span>, <span class="kt">char</span><span class="p">*</span><span class="n">doc</span>, <span class="kt">int</span><span class="n">unused</span>, <span class="kt">char</span><span class="p">*</span><span class="n">signature</span>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.11)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">identity_value</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This function is very similar to <code>PyUFunc_FromFuncAndDataAndSignature</code> above, but has an extra <em>identity_value</em> argument, to define an arbitrary identity for the ufunc when <code>identity</code> is passed as <code>PyUFunc_IdentityValue</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>identity_value</strong> – The identity for the new gufunc. Must be passed as <code>NULL</code> unless the <code>identity</code> argument is <code>PyUFunc_IdentityValue</code>. Setting it to NULL is equivalent to calling PyUFunc_FromFuncAndDataAndSignature.</li> </ul> </dd> </dl> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_RegisterLoopForType"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyUFunc_RegisterLoopForType</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures#c.PyUFuncObject" title="PyUFuncObject"><span class="n">PyUFuncObject</span></a><span class="p">*</span><span class="n">ufunc</span>, <span class="kt">int</span><span class="n">usertype</span>, <a class="reference internal" href="#c.PyUFuncGenericFunction" title="PyUFuncGenericFunction"><span class="n">PyUFuncGenericFunction</span></a><span class="n">function</span>, <span class="kt">int</span><span class="p">*</span><span class="n">arg_types</span>, <span class="kt">void</span><span class="p">*</span><span class="n">data</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This function allows the user to register a 1-d loop with an already- created ufunc to be used whenever the ufunc is called with any of its input arguments as the user-defined data-type. This is needed in order to make ufuncs work with built-in data-types. The data-type must have been previously registered with the numpy system. The loop is passed in as <em>function</em>. This loop can take arbitrary data which should be passed in as <em>data</em>. The data-types the loop requires are passed in as <em>arg_types</em> which must be a pointer to memory at least as large as ufunc-&gt;nargs.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_RegisterLoopForDescr"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyUFunc_RegisterLoopForDescr</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures#c.PyUFuncObject" title="PyUFuncObject"><span class="n">PyUFuncObject</span></a><span class="p">*</span><span class="n">ufunc</span>, <a class="reference internal" href="types-and-structures#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="n">userdtype</span>, <a class="reference internal" href="#c.PyUFuncGenericFunction" title="PyUFuncGenericFunction"><span class="n">PyUFuncGenericFunction</span></a><span class="n">function</span>, <a class="reference internal" href="types-and-structures#c.PyArray_Descr" title="PyArray_Descr"><span class="n">PyArray_Descr</span></a><span class="p">*</span><span class="p">*</span><span class="n">arg_dtypes</span>, <span class="kt">void</span><span class="p">*</span><span class="n">data</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This function behaves like PyUFunc_RegisterLoopForType above, except that it allows the user to register a 1-d loop using PyArray_Descr objects instead of dtype type num values. This allows a 1-d loop to be registered for structured array data-dtypes and custom data-types instead of scalar data-types.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_ReplaceLoopBySignature"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyUFunc_ReplaceLoopBySignature</span></span><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures#c.PyUFuncObject" title="PyUFuncObject"><span class="n">PyUFuncObject</span></a><span class="p">*</span><span class="n">ufunc</span>, <a class="reference internal" href="#c.PyUFuncGenericFunction" title="PyUFuncGenericFunction"><span class="n">PyUFuncGenericFunction</span></a><span class="n">newfunc</span>, <span class="kt">int</span><span class="p">*</span><span class="n">signature</span>, <a class="reference internal" href="#c.PyUFuncGenericFunction" title="PyUFuncGenericFunction"><span class="n">PyUFuncGenericFunction</span></a><span class="p">*</span><span class="n">oldfunc</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Replace a 1-d loop matching the given <em>signature</em> in the already-created <em>ufunc</em> with the new 1-d loop newfunc. Return the old 1-d loop function in <em>oldfunc</em>. Return 0 on success and -1 on failure. This function works only with built-in types (use <a class="reference internal" href="#c.PyUFunc_RegisterLoopForType" title="PyUFunc_RegisterLoopForType"><code>PyUFunc_RegisterLoopForType</code></a> for user-defined types). A signature is an array of data-type numbers indicating the inputs followed by the outputs assumed by the 1-d loop.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_checkfperr"> <span class="kt">int</span><span class="sig-name descname"><span class="n">PyUFunc_checkfperr</span></span><span class="sig-paren">(</span><span class="kt">int</span><span class="n">errmask</span>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.11)"><span class="n">PyObject</span></a><span class="p">*</span><span class="n">errobj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>A simple interface to the IEEE error-flag checking support. The <em>errmask</em> argument is a mask of <code>UFUNC_MASK_{ERR}</code> bitmasks indicating which errors to check for (and how to check for them). The <em>errobj</em> must be a Python tuple with two elements: a string containing the name which will be used in any communication of error and either a callable Python object (call-back function) or <a class="reference external" href="https://docs.python.org/dev/c-api/none.html#c.Py_None" title="(in Python v3.11)"><code>Py_None</code></a>. The callable object will only be used if <a class="reference internal" href="#c.UFUNC_ERR_CALL" title="UFUNC_ERR_CALL"><code>UFUNC_ERR_CALL</code></a> is set as the desired error checking method. This routine manages the GIL and is safe to call even after releasing the GIL. If an error in the IEEE-compatible hardware is determined a -1 is returned, otherwise a 0 is returned.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_clearfperr"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_clearfperr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Clear the IEEE error flags.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_GetPyValues"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_GetPyValues</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="n">name</span>, <span class="kt">int</span><span class="p">*</span><span class="n">bufsize</span>, <span class="kt">int</span><span class="p">*</span><span class="n">errmask</span>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.11)"><span class="n">PyObject</span></a><span class="p">*</span><span class="p">*</span><span class="n">errobj</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Get the Python values used for ufunc processing from the thread-local storage area unless the defaults have been set in which case the name lookup is bypassed. The name is placed as a string in the first element of <em>*errobj</em>. The second element is the looked-up function to call on error callback. The value of the looked-up buffer-size to use is passed into <em>bufsize</em>, and the value of the error mask is placed into <em>errmask</em>.</p> </dd>
</dl> </section> <section id="generic-functions"> <h2>Generic functions</h2> <p>At the core of every ufunc is a collection of type-specific functions that defines the basic functionality for each of the supported types. These functions must evaluate the underlying function <span class="math notranslate nohighlight">\(N\geq1\)</span> times. Extra-data may be passed in that may be used during the calculation. This feature allows some general functions to be used as these basic looping functions. The general function has all the code needed to point variables to the right place and set up a function call. The general function assumes that the actual function to call is passed in as the extra data and calls it with the correct values. All of these functions are suitable for placing directly in the array of functions stored in the functions member of the PyUFuncObject structure.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_f_f_As_d_d"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_f_f_As_d_d</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_d_d"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_d_d</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_f_f"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_f_f</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_g_g"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_g_g</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_F_F_As_D_D"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_F_F_As_D_D</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_F_F"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_F_F</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_D_D"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_D_D</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_G_G"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_G_G</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_e_e"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_e_e</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_e_e_As_f_f"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_e_e_As_f_f</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_e_e_As_d_d"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_e_e_As_d_d</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Type specific, core 1-d functions for ufuncs where each calculation is obtained by calling a function taking one input argument and returning one output. This function is passed in <code>func</code>. The letters correspond to dtypechar’s of the supported data types ( <code>e</code> - half, <code>f</code> - float, <code>d</code> - double, <code>g</code> - long double, <code>F</code> - cfloat, <code>D</code> - cdouble, <code>G</code> - clongdouble). The argument <em>func</em> must support the same signature. The _As_X_X variants assume ndarray’s of one data type but cast the values to use an underlying function that takes a different data type. Thus, <a class="reference internal" href="#c.PyUFunc_f_f_As_d_d" title="PyUFunc_f_f_As_d_d"><code>PyUFunc_f_f_As_d_d</code></a> uses ndarrays of data type <a class="reference internal" href="dtype#c.NPY_FLOAT" title="NPY_FLOAT"><code>NPY_FLOAT</code></a> but calls out to a C-function that takes double and returns double.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_ff_f_As_dd_d"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_ff_f_As_dd_d</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_ff_f"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_ff_f</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_dd_d"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_dd_d</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_gg_g"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_gg_g</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_FF_F_As_DD_D"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_FF_F_As_DD_D</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_DD_D"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_DD_D</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_FF_F"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_FF_F</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_GG_G"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_GG_G</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_ee_e"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_ee_e</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_ee_e_As_ff_f"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_ee_e_As_ff_f</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_ee_e_As_dd_d"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_ee_e_As_dd_d</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Type specific, core 1-d functions for ufuncs where each calculation is obtained by calling a function taking two input arguments and returning one output. The underlying function to call is passed in as <em>func</em>. The letters correspond to dtypechar’s of the specific data type supported by the general-purpose function. The argument <code>func</code> must support the corresponding signature. The <code>_As_XX_X</code> variants assume ndarrays of one data type but cast the values at each iteration of the loop to use the underlying function that takes a different data type.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_O_O"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_O_O</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> 
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_OO_O"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_OO_O</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>One-input, one-output, and two-input, one-output core 1-d functions for the <a class="reference internal" href="dtype#c.NPY_OBJECT" title="NPY_OBJECT"><code>NPY_OBJECT</code></a> data type. These functions handle reference count issues and return early on error. The actual function to call is <em>func</em> and it must accept calls with the signature <code>(PyObject*)
(PyObject*)</code> for <a class="reference internal" href="#c.PyUFunc_O_O" title="PyUFunc_O_O"><code>PyUFunc_O_O</code></a> or <code>(PyObject*)(PyObject *,
PyObject *)</code> for <a class="reference internal" href="#c.PyUFunc_OO_O" title="PyUFunc_OO_O"><code>PyUFunc_OO_O</code></a>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_O_O_method"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_O_O_method</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This general purpose 1-d core function assumes that <em>func</em> is a string representing a method of the input object. For each iteration of the loop, the Python object is extracted from the array and its <em>func</em> method is called returning the result to the output array.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_OO_O_method"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_OO_O_method</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This general purpose 1-d core function assumes that <em>func</em> is a string representing a method of the input object that takes one argument. The first argument in <em>args</em> is the method whose function is called, the second argument in <em>args</em> is the argument passed to the function. The output of the function is stored in the third entry of <em>args</em>.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.PyUFunc_On_Om"> <span class="kt">void</span><span class="sig-name descname"><span class="n">PyUFunc_On_Om</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="p">*</span><span class="n">args</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">dimensions</span>, <a class="reference internal" href="dtype#c.npy_intp" title="npy_intp"><span class="n">npy_intp</span></a><span class="k">const</span><span class="p">*</span><span class="n">steps</span>, <span class="kt">void</span><span class="p">*</span><span class="n">func</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This is the 1-d core function used by the dynamic ufuncs created by umath.frompyfunc(function, nin, nout). In this case <em>func</em> is a pointer to a <a class="reference internal" href="#c.PyUFunc_On_Om.PyUFunc_PyFuncData" title="PyUFunc_PyFuncData"><code>PyUFunc_PyFuncData</code></a> structure which has definition</p> <dl class="c type"> <dt class="sig sig-object c" id="c.PyUFunc_On_Om.PyUFunc_PyFuncData"> <span class="k">type</span><span class="sig-name descname"><span class="n">PyUFunc_PyFuncData</span></span><br>
</dt> <dd>
<pre data-language="c">typedef struct {
    int nin;
    int nout;
    PyObject *callable;
} PyUFunc_PyFuncData;
</pre> </dd>
</dl> <p>At each iteration of the loop, the <em>nin</em> input objects are extracted from their object arrays and placed into an argument tuple, the Python <em>callable</em> is called with the input arguments, and the nout outputs are placed into their object arrays.</p> </dd>
</dl> </section> <section id="importing-the-api"> <h2>Importing the API</h2> <dl class="c macro"> <dt class="sig sig-object c" id="c.PY_UFUNC_UNIQUE_SYMBOL"> <span class="sig-name descname"><span class="n">PY_UFUNC_UNIQUE_SYMBOL</span></span><br>
</dt> 
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NO_IMPORT_UFUNC"> <span class="sig-name descname"><span class="n">NO_IMPORT_UFUNC</span></span><br>
</dt> 
</dl> <dl class="c function" id="index-1"> <dt class="sig sig-object c" id="c.import_ufunc"> <span class="kt">void</span><span class="sig-name descname"><span class="n">import_ufunc</span></span><span class="sig-paren">(</span><span class="kt">void</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>These are the constants and functions for accessing the ufunc C-API from extension modules in precisely the same way as the array C-API can be accessed. The <code>import_ufunc</code> () function must always be called (in the initialization subroutine of the extension module). If your extension module is in one file then that is all that is required. The other two constants are useful if your extension module makes use of multiple files. In that case, define <a class="reference internal" href="#c.PY_UFUNC_UNIQUE_SYMBOL" title="PY_UFUNC_UNIQUE_SYMBOL"><code>PY_UFUNC_UNIQUE_SYMBOL</code></a> to something unique to your code and then in source files that do not contain the module initialization function but still need access to the UFUNC API, define <a class="reference internal" href="#c.PY_UFUNC_UNIQUE_SYMBOL" title="PY_UFUNC_UNIQUE_SYMBOL"><code>PY_UFUNC_UNIQUE_SYMBOL</code></a> to the same name used previously and also define <a class="reference internal" href="#c.NO_IMPORT_UFUNC" title="NO_IMPORT_UFUNC"><code>NO_IMPORT_UFUNC</code></a>.</p> <p>The C-API is actually an array of function pointers. This array is created (and pointed to by a global variable) by import_ufunc. The global variable is either statically defined or allowed to be seen by other files depending on the state of <a class="reference internal" href="#c.PY_UFUNC_UNIQUE_SYMBOL" title="PY_UFUNC_UNIQUE_SYMBOL"><code>PY_UFUNC_UNIQUE_SYMBOL</code></a> and <a class="reference internal" href="#c.NO_IMPORT_UFUNC" title="NO_IMPORT_UFUNC"><code>NO_IMPORT_UFUNC</code></a>.</p> </dd>
</dl> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/c-api/ufunc.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/c-api/ufunc.html</a>
  </p>
</div>
