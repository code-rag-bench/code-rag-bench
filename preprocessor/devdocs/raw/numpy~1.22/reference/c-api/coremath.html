<h1>NumPy core libraries</h1> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.3.0.</span></p> </div> <p>Starting from numpy 1.3.0, we are working on separating the pure C, “computational” code from the python dependent code. The goal is twofolds: making the code cleaner, and enabling code reuse by other extensions outside numpy (scipy, etc…).</p> <section id="numpy-core-math-library"> <h2>NumPy core math library</h2> <p>The numpy core math library (‘npymath’) is a first step in this direction. This library contains most math-related C99 functionality, which can be used on platforms where C99 is not well supported. The core math functions have the same API as the C99 ones, except for the npy_* prefix.</p> <p>The available functions are defined in &lt;numpy/npy_math.h&gt; - please refer to this header when in doubt.</p> <section id="floating-point-classification"> <h3>Floating point classification</h3> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_NAN"> <span class="sig-name descname"><span class="n">NPY_NAN</span></span><br>
</dt> <dd>
<p>This macro is defined to a NaN (Not a Number), and is guaranteed to have the signbit unset (‘positive’ NaN). The corresponding single and extension precision macro are available with the suffix F and L.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_INFINITY"> <span class="sig-name descname"><span class="n">NPY_INFINITY</span></span><br>
</dt> <dd>
<p>This macro is defined to a positive inf. The corresponding single and extension precision macro are available with the suffix F and L.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_PZERO"> <span class="sig-name descname"><span class="n">NPY_PZERO</span></span><br>
</dt> <dd>
<p>This macro is defined to positive zero. The corresponding single and extension precision macro are available with the suffix F and L.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_NZERO"> <span class="sig-name descname"><span class="n">NPY_NZERO</span></span><br>
</dt> <dd>
<p>This macro is defined to negative zero (that is with the sign bit set). The corresponding single and extension precision macro are available with the suffix F and L.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.npy_isnan"> <span class="sig-name descname"><span class="n">npy_isnan</span></span><span class="sig-paren">(</span><span class="n">x</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This is a macro, and is equivalent to C99 isnan: works for single, double and extended precision, and return a non 0 value if x is a NaN.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.npy_isfinite"> <span class="sig-name descname"><span class="n">npy_isfinite</span></span><span class="sig-paren">(</span><span class="n">x</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This is a macro, and is equivalent to C99 isfinite: works for single, double and extended precision, and return a non 0 value if x is neither a NaN nor an infinity.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.npy_isinf"> <span class="sig-name descname"><span class="n">npy_isinf</span></span><span class="sig-paren">(</span><span class="n">x</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This is a macro, and is equivalent to C99 isinf: works for single, double and extended precision, and return a non 0 value if x is infinite (positive and negative).</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.npy_signbit"> <span class="sig-name descname"><span class="n">npy_signbit</span></span><span class="sig-paren">(</span><span class="n">x</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This is a macro, and is equivalent to C99 signbit: works for single, double and extended precision, and return a non 0 value if x has the signbit set (that is the number is negative).</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.npy_copysign"> <span class="sig-name descname"><span class="n">npy_copysign</span></span><span class="sig-paren">(</span><span class="n">x</span>, <span class="n">y</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This is a function equivalent to C99 copysign: return x with the same sign as y. Works for any value, including inf and nan. Single and extended precisions are available with suffix f and l.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.4.0.</span></p> </div> </dd>
</dl> </section> <section id="useful-math-constants"> <h3>Useful math constants</h3> <p>The following math constants are available in <code>npy_math.h</code>. Single and extended precision are also available by adding the <code>f</code> and <code>l</code> suffixes respectively.</p> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_E"> <span class="sig-name descname"><span class="n">NPY_E</span></span><br>
</dt> <dd>
<p>Base of natural logarithm (<span class="math notranslate nohighlight">\(e\)</span>)</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_LOG2E"> <span class="sig-name descname"><span class="n">NPY_LOG2E</span></span><br>
</dt> <dd>
<p>Logarithm to base 2 of the Euler constant (<span class="math notranslate nohighlight">\(\frac{\ln(e)}{\ln(2)}\)</span>)</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_LOG10E"> <span class="sig-name descname"><span class="n">NPY_LOG10E</span></span><br>
</dt> <dd>
<p>Logarithm to base 10 of the Euler constant (<span class="math notranslate nohighlight">\(\frac{\ln(e)}{\ln(10)}\)</span>)</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_LOGE2"> <span class="sig-name descname"><span class="n">NPY_LOGE2</span></span><br>
</dt> <dd>
<p>Natural logarithm of 2 (<span class="math notranslate nohighlight">\(\ln(2)\)</span>)</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_LOGE10"> <span class="sig-name descname"><span class="n">NPY_LOGE10</span></span><br>
</dt> <dd>
<p>Natural logarithm of 10 (<span class="math notranslate nohighlight">\(\ln(10)\)</span>)</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_PI"> <span class="sig-name descname"><span class="n">NPY_PI</span></span><br>
</dt> <dd>
<p>Pi (<span class="math notranslate nohighlight">\(\pi\)</span>)</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_PI_2"> <span class="sig-name descname"><span class="n">NPY_PI_2</span></span><br>
</dt> <dd>
<p>Pi divided by 2 (<span class="math notranslate nohighlight">\(\frac{\pi}{2}\)</span>)</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_PI_4"> <span class="sig-name descname"><span class="n">NPY_PI_4</span></span><br>
</dt> <dd>
<p>Pi divided by 4 (<span class="math notranslate nohighlight">\(\frac{\pi}{4}\)</span>)</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_1_PI"> <span class="sig-name descname"><span class="n">NPY_1_PI</span></span><br>
</dt> <dd>
<p>Reciprocal of pi (<span class="math notranslate nohighlight">\(\frac{1}{\pi}\)</span>)</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_2_PI"> <span class="sig-name descname"><span class="n">NPY_2_PI</span></span><br>
</dt> <dd>
<p>Two times the reciprocal of pi (<span class="math notranslate nohighlight">\(\frac{2}{\pi}\)</span>)</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_EULER"> <span class="sig-name descname"><span class="n">NPY_EULER</span></span><br>
</dt> <dd>
<dl class="simple"> <dt>The Euler constant</dt>
<dd>
<p><span class="math notranslate nohighlight">\(\lim_{n\rightarrow\infty}({\sum_{k=1}^n{\frac{1}{k}}-\ln n})\)</span></p> </dd> </dl> </dd>
</dl> </section> <section id="low-level-floating-point-manipulation"> <h3>Low-level floating point manipulation</h3> <p>Those can be useful for precise floating point comparison.</p> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_nextafter"> <span class="kt">double</span><span class="sig-name descname"><span class="n">npy_nextafter</span></span><span class="sig-paren">(</span><span class="kt">double</span><span class="n">x</span>, <span class="kt">double</span><span class="n">y</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This is a function equivalent to C99 nextafter: return next representable floating point value from x in the direction of y. Single and extended precisions are available with suffix f and l.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.4.0.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_spacing"> <span class="kt">double</span><span class="sig-name descname"><span class="n">npy_spacing</span></span><span class="sig-paren">(</span><span class="kt">double</span><span class="n">x</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This is a function equivalent to Fortran intrinsic. Return distance between x and next representable floating point value from x, e.g. spacing(1) == eps. spacing of nan and +/- inf return nan. Single and extended precisions are available with suffix f and l.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.4.0.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_set_floatstatus_divbyzero"> <span class="kt">void</span><span class="sig-name descname"><span class="n">npy_set_floatstatus_divbyzero</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Set the divide by zero floating point exception</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.0.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_set_floatstatus_overflow"> <span class="kt">void</span><span class="sig-name descname"><span class="n">npy_set_floatstatus_overflow</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Set the overflow floating point exception</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.0.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_set_floatstatus_underflow"> <span class="kt">void</span><span class="sig-name descname"><span class="n">npy_set_floatstatus_underflow</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Set the underflow floating point exception</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.0.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_set_floatstatus_invalid"> <span class="kt">void</span><span class="sig-name descname"><span class="n">npy_set_floatstatus_invalid</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Set the invalid floating point exception</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.0.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_get_floatstatus"> <span class="kt">int</span><span class="sig-name descname"><span class="n">npy_get_floatstatus</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Get floating point status. Returns a bitmask with following possible flags:</p> <ul class="simple"> <li>NPY_FPE_DIVIDEBYZERO</li> <li>NPY_FPE_OVERFLOW</li> <li>NPY_FPE_UNDERFLOW</li> <li>NPY_FPE_INVALID</li> </ul> <p>Note that <a class="reference internal" href="#c.npy_get_floatstatus_barrier" title="npy_get_floatstatus_barrier"><code>npy_get_floatstatus_barrier</code></a> is preferable as it prevents aggressive compiler optimizations reordering the call relative to the code setting the status, which could lead to incorrect results.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.9.0.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_get_floatstatus_barrier"> <span class="kt">int</span><span class="sig-name descname"><span class="n">npy_get_floatstatus_barrier</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Get floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reordering this function call relative to the code setting the status, which could lead to incorrect results.</p> <p>Returns a bitmask with following possible flags:</p> <ul class="simple"> <li>NPY_FPE_DIVIDEBYZERO</li> <li>NPY_FPE_OVERFLOW</li> <li>NPY_FPE_UNDERFLOW</li> <li>NPY_FPE_INVALID</li> </ul> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.15.0.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_clear_floatstatus"> <span class="kt">int</span><span class="sig-name descname"><span class="n">npy_clear_floatstatus</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Clears the floating point status. Returns the previous status mask.</p> <p>Note that <a class="reference internal" href="#c.npy_clear_floatstatus_barrier" title="npy_clear_floatstatus_barrier"><code>npy_clear_floatstatus_barrier</code></a> is preferable as it prevents aggressive compiler optimizations reordering the call relative to the code setting the status, which could lead to incorrect results.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.9.0.</span></p> </div> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_clear_floatstatus_barrier"> <span class="kt">int</span><span class="sig-name descname"><span class="n">npy_clear_floatstatus_barrier</span></span><span class="sig-paren">(</span><span class="kt">char</span><span class="p">*</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Clears the floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reordering this function call. Returns the previous status mask.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.15.0.</span></p> </div> </dd>
</dl> </section> <section id="complex-functions"> <h3>Complex functions</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.4.0.</span></p> </div> <p>C99-like complex functions have been added. Those can be used if you wish to implement portable C extensions. Since we still support platforms without C99 complex type, you need to restrict to C90-compatible syntax, e.g.:</p> <pre data-language="c">/* a = 1 + 2i \*/
npy_complex a = npy_cpack(1, 2);
npy_complex b;

b = npy_log(a);
</pre> </section> <section id="linking-against-the-core-math-library-in-an-extension"> <h3>Linking against the core math library in an extension</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.4.0.</span></p> </div> <p>To use the core math library in your own extension, you need to add the npymath compile and link options to your extension in your setup.py:</p>  <pre data-language="python">&gt;&gt;&gt; from numpy.distutils.misc_util import get_info
&gt;&gt;&gt; info = get_info('npymath')
&gt;&gt;&gt; _ = config.add_extension('foo', sources=['foo.c'], extra_info=info)
</pre>  <p>In other words, the usage of info is exactly the same as when using blas_info and co.</p> </section> <section id="half-precision-functions"> <h3>Half-precision functions</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.0.</span></p> </div> <p>The header file &lt;numpy/halffloat.h&gt; provides functions to work with IEEE 754-2008 16-bit floating point values. While this format is not typically used for numerical computations, it is useful for storing values which require floating point but do not need much precision. It can also be used as an educational tool to understand the nature of floating point round-off error.</p> <p>Like for other types, NumPy includes a typedef npy_half for the 16 bit float. Unlike for most of the other types, you cannot use this as a normal type in C, since it is a typedef for npy_uint16. For example, 1.0 looks like 0x3c00 to C, and if you do an equality comparison between the different signed zeros, you will get -0.0 != 0.0 (0x8000 != 0x0000), which is incorrect.</p> <p>For these reasons, NumPy provides an API to work with npy_half values accessible by including &lt;numpy/halffloat.h&gt; and linking to ‘npymath’. For functions that are not provided directly, such as the arithmetic operations, the preferred method is to convert to float or double and back again, as in the following example.</p> <pre data-language="c">npy_half sum(int n, npy_half *array) {
    float ret = 0;
    while(n--) {
        ret += npy_half_to_float(*array++);
    }
    return npy_float_to_half(ret);
}
</pre> <p>External Links:</p> <ul class="simple"> <li><a class="reference external" href="https://ieeexplore.ieee.org/document/4610935/">754-2008 IEEE Standard for Floating-Point Arithmetic</a></li> <li>
<a class="reference external" href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format">Half-precision Float Wikipedia Article</a>.</li> <li><a class="reference external" href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_half_float_pixel.txt">OpenGL Half Float Pixel Support</a></li> <li>
<a class="reference external" href="https://www.openexr.com/about.html">The OpenEXR image format</a>.</li> </ul> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_HALF_ZERO"> <span class="sig-name descname"><span class="n">NPY_HALF_ZERO</span></span><br>
</dt> <dd>
<p>This macro is defined to positive zero.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_HALF_PZERO"> <span class="sig-name descname"><span class="n">NPY_HALF_PZERO</span></span><br>
</dt> <dd>
<p>This macro is defined to positive zero.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_HALF_NZERO"> <span class="sig-name descname"><span class="n">NPY_HALF_NZERO</span></span><br>
</dt> <dd>
<p>This macro is defined to negative zero.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_HALF_ONE"> <span class="sig-name descname"><span class="n">NPY_HALF_ONE</span></span><br>
</dt> <dd>
<p>This macro is defined to 1.0.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_HALF_NEGONE"> <span class="sig-name descname"><span class="n">NPY_HALF_NEGONE</span></span><br>
</dt> <dd>
<p>This macro is defined to -1.0.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_HALF_PINF"> <span class="sig-name descname"><span class="n">NPY_HALF_PINF</span></span><br>
</dt> <dd>
<p>This macro is defined to +inf.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_HALF_NINF"> <span class="sig-name descname"><span class="n">NPY_HALF_NINF</span></span><br>
</dt> <dd>
<p>This macro is defined to -inf.</p> </dd>
</dl> <dl class="c macro"> <dt class="sig sig-object c" id="c.NPY_HALF_NAN"> <span class="sig-name descname"><span class="n">NPY_HALF_NAN</span></span><br>
</dt> <dd>
<p>This macro is defined to a NaN value, guaranteed to have its sign bit unset.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_half_to_float"> <span class="kt">float</span><span class="sig-name descname"><span class="n">npy_half_to_float</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Converts a half-precision float to a single-precision float.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_half_to_double"> <span class="kt">double</span><span class="sig-name descname"><span class="n">npy_half_to_double</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Converts a half-precision float to a double-precision float.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_float_to_half"> <a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="sig-name descname"><span class="n">npy_float_to_half</span></span><span class="sig-paren">(</span><span class="kt">float</span><span class="n">f</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Converts a single-precision float to a half-precision float. The value is rounded to the nearest representable half, with ties going to the nearest even. If the value is too small or too big, the system’s floating point underflow or overflow bit will be set.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_double_to_half"> <a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="sig-name descname"><span class="n">npy_double_to_half</span></span><span class="sig-paren">(</span><span class="kt">double</span><span class="n">d</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Converts a double-precision float to a half-precision float. The value is rounded to the nearest representable half, with ties going to the nearest even. If the value is too small or too big, the system’s floating point underflow or overflow bit will be set.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_half_eq"> <span class="kt">int</span><span class="sig-name descname"><span class="n">npy_half_eq</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h1</span>, <a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h2</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Compares two half-precision floats (h1 == h2).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_half_ne"> <span class="kt">int</span><span class="sig-name descname"><span class="n">npy_half_ne</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h1</span>, <a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h2</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Compares two half-precision floats (h1 != h2).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_half_le"> <span class="kt">int</span><span class="sig-name descname"><span class="n">npy_half_le</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h1</span>, <a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h2</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Compares two half-precision floats (h1 &lt;= h2).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_half_lt"> <span class="kt">int</span><span class="sig-name descname"><span class="n">npy_half_lt</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h1</span>, <a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h2</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Compares two half-precision floats (h1 &lt; h2).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_half_ge"> <span class="kt">int</span><span class="sig-name descname"><span class="n">npy_half_ge</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h1</span>, <a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h2</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Compares two half-precision floats (h1 &gt;= h2).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_half_gt"> <span class="kt">int</span><span class="sig-name descname"><span class="n">npy_half_gt</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h1</span>, <a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h2</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Compares two half-precision floats (h1 &gt; h2).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_half_eq_nonan"> <span class="kt">int</span><span class="sig-name descname"><span class="n">npy_half_eq_nonan</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h1</span>, <a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h2</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Compares two half-precision floats that are known to not be NaN (h1 == h2). If a value is NaN, the result is undefined.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_half_lt_nonan"> <span class="kt">int</span><span class="sig-name descname"><span class="n">npy_half_lt_nonan</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h1</span>, <a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h2</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Compares two half-precision floats that are known to not be NaN (h1 &lt; h2). If a value is NaN, the result is undefined.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_half_le_nonan"> <span class="kt">int</span><span class="sig-name descname"><span class="n">npy_half_le_nonan</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h1</span>, <a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h2</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Compares two half-precision floats that are known to not be NaN (h1 &lt;= h2). If a value is NaN, the result is undefined.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_half_iszero"> <span class="kt">int</span><span class="sig-name descname"><span class="n">npy_half_iszero</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Tests whether the half-precision float has a value equal to zero. This may be slightly faster than calling npy_half_eq(h, NPY_ZERO).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_half_isnan"> <span class="kt">int</span><span class="sig-name descname"><span class="n">npy_half_isnan</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Tests whether the half-precision float is a NaN.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_half_isinf"> <span class="kt">int</span><span class="sig-name descname"><span class="n">npy_half_isinf</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Tests whether the half-precision float is plus or minus Inf.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_half_isfinite"> <span class="kt">int</span><span class="sig-name descname"><span class="n">npy_half_isfinite</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Tests whether the half-precision float is finite (not NaN or Inf).</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_half_signbit"> <span class="kt">int</span><span class="sig-name descname"><span class="n">npy_half_signbit</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Returns 1 is h is negative, 0 otherwise.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_half_copysign"> <a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="sig-name descname"><span class="n">npy_half_copysign</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">x</span>, <a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">y</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Returns the value of x with the sign bit copied from y. Works for any value, including Inf and NaN.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_half_spacing"> <a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="sig-name descname"><span class="n">npy_half_spacing</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">h</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This is the same for half-precision float as npy_spacing and npy_spacingf described in the low-level floating point section.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_half_nextafter"> <a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="sig-name descname"><span class="n">npy_half_nextafter</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">x</span>, <a class="reference internal" href="dtype#c.npy_half" title="npy_half"><span class="n">npy_half</span></a><span class="n">y</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>This is the same for half-precision float as npy_nextafter and npy_nextafterf described in the low-level floating point section.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_floatbits_to_halfbits"> <a class="reference internal" href="dtype#c.npy_uint16" title="npy_uint16"><span class="n">npy_uint16</span></a><span class="sig-name descname"><span class="n">npy_floatbits_to_halfbits</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_uint32" title="npy_uint32"><span class="n">npy_uint32</span></a><span class="n">f</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Low-level function which converts a 32-bit single-precision float, stored as a uint32, into a 16-bit half-precision float.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_doublebits_to_halfbits"> <a class="reference internal" href="dtype#c.npy_uint16" title="npy_uint16"><span class="n">npy_uint16</span></a><span class="sig-name descname"><span class="n">npy_doublebits_to_halfbits</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_uint64" title="npy_uint64"><span class="n">npy_uint64</span></a><span class="n">d</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Low-level function which converts a 64-bit double-precision float, stored as a uint64, into a 16-bit half-precision float.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_halfbits_to_floatbits"> <a class="reference internal" href="dtype#c.npy_uint32" title="npy_uint32"><span class="n">npy_uint32</span></a><span class="sig-name descname"><span class="n">npy_halfbits_to_floatbits</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_uint16" title="npy_uint16"><span class="n">npy_uint16</span></a><span class="n">h</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Low-level function which converts a 16-bit half-precision float into a 32-bit single-precision float, stored as a uint32.</p> </dd>
</dl> <dl class="c function"> <dt class="sig sig-object c" id="c.npy_halfbits_to_doublebits"> <a class="reference internal" href="dtype#c.npy_uint64" title="npy_uint64"><span class="n">npy_uint64</span></a><span class="sig-name descname"><span class="n">npy_halfbits_to_doublebits</span></span><span class="sig-paren">(</span><a class="reference internal" href="dtype#c.npy_uint16" title="npy_uint16"><span class="n">npy_uint16</span></a><span class="n">h</span><span class="sig-paren">)</span><br>
</dt> <dd>
<p>Low-level function which converts a 16-bit half-precision float into a 64-bit double-precision float, stored as a uint64.</p> </dd>
</dl> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/c-api/coremath.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/c-api/coremath.html</a>
  </p>
</div>
