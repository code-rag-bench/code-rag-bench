<h1 id="routines-polynomial">Polynomials</h1> <p>Polynomials in NumPy can be <em>created</em>, <em>manipulated</em>, and even <em>fitted</em> using the <a class="reference internal" href="routines.polynomials.classes"><span class="doc">convenience classes</span></a> of the <a class="reference internal" href="routines.polynomials.package#module-numpy.polynomial" title="numpy.polynomial"><code>numpy.polynomial</code></a> package, introduced in NumPy 1.4.</p> <p>Prior to NumPy 1.4, <a class="reference internal" href="generated/numpy.poly1d#numpy.poly1d" title="numpy.poly1d"><code>numpy.poly1d</code></a> was the class of choice and it is still available in order to maintain backward compatibility. However, the newer <a class="reference internal" href="routines.polynomials.package#module-numpy.polynomial" title="numpy.polynomial"><code>polynomial package</code></a> is more complete and its <code>convenience classes</code> provide a more consistent, better-behaved interface for working with polynomial expressions. Therefore <a class="reference internal" href="routines.polynomials.package#module-numpy.polynomial" title="numpy.polynomial"><code>numpy.polynomial</code></a> is recommended for new coding.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><strong>Terminology</strong></p> <p>The term <em>polynomial module</em> refers to the old API defined in <code>numpy.lib.polynomial</code>, which includes the <a class="reference internal" href="generated/numpy.poly1d#numpy.poly1d" title="numpy.poly1d"><code>numpy.poly1d</code></a> class and the polynomial functions prefixed with <em>poly</em> accessible from the <a class="reference internal" href="index#module-numpy" title="numpy"><code>numpy</code></a> namespace (e.g. <a class="reference internal" href="generated/numpy.polyadd#numpy.polyadd" title="numpy.polyadd"><code>numpy.polyadd</code></a>, <a class="reference internal" href="generated/numpy.polyval#numpy.polyval" title="numpy.polyval"><code>numpy.polyval</code></a>, <a class="reference internal" href="generated/numpy.polyfit#numpy.polyfit" title="numpy.polyfit"><code>numpy.polyfit</code></a>, etc.).</p> <p>The term <em>polynomial package</em> refers to the new API defined in <a class="reference internal" href="routines.polynomials.package#module-numpy.polynomial" title="numpy.polynomial"><code>numpy.polynomial</code></a>, which includes the convenience classes for the different kinds of polynomials (<code>numpy.polynomial.Polynomial</code>, <code>numpy.polynomial.Chebyshev</code>, etc.).</p> </div> <section id="transitioning-from-numpy-poly1d-to-numpy-polynomial"> <h2>Transitioning from numpy.poly1d to numpy.polynomial</h2> <p>As noted above, the <a class="reference internal" href="generated/numpy.poly1d#numpy.poly1d" title="numpy.poly1d"><code>poly1d class</code></a> and associated functions defined in <code>numpy.lib.polynomial</code>, such as <a class="reference internal" href="generated/numpy.polyfit#numpy.polyfit" title="numpy.polyfit"><code>numpy.polyfit</code></a> and <a class="reference internal" href="generated/numpy.poly#numpy.poly" title="numpy.poly"><code>numpy.poly</code></a>, are considered legacy and should <strong>not</strong> be used in new code. Since NumPy version 1.4, the <a class="reference internal" href="routines.polynomials.package#module-numpy.polynomial" title="numpy.polynomial"><code>numpy.polynomial</code></a> package is preferred for working with polynomials.</p> <section id="quick-reference"> <h3>Quick Reference</h3> <p>The following table highlights some of the main differences between the legacy polynomial module and the polynomial package for common tasks. The <a class="reference internal" href="generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial" title="numpy.polynomial.polynomial.Polynomial"><code>Polynomial</code></a> class is imported for brevity:</p> <pre data-language="python">from numpy.polynomial import Polynomial
</pre> <table class="table">   <tr>
<td><p><strong>How to…</strong></p></td> <td><p>Legacy (<a class="reference internal" href="generated/numpy.poly1d#numpy.poly1d" title="numpy.poly1d"><code>numpy.poly1d</code></a>)</p></td> <td><p><a class="reference internal" href="routines.polynomials.package#module-numpy.polynomial" title="numpy.polynomial"><code>numpy.polynomial</code></a></p></td> </tr> <tr>
<td><p>Create a polynomial object from coefficients <a class="footnote-reference brackets" href="#id2" id="id1">1</a></p></td> <td><p><code>p = np.poly1d([1, 2, 3])</code></p></td> <td><p><code>p = Polynomial([3, 2, 1])</code></p></td> </tr> <tr>
<td><p>Create a polynomial object from roots</p></td> <td><p><code>r = np.poly([-1, 1])</code> <code>p = np.poly1d(r)</code></p></td> <td><p><code>p = Polynomial.fromroots([-1, 1])</code></p></td> </tr> <tr>
<td><p>Fit a polynomial of degree <code>deg</code> to data</p></td> <td><p><code>np.polyfit(x, y, deg)</code></p></td> <td><p><code>Polynomial.fit(x, y, deg)</code></p></td> </tr>  </table> <dl class="footnote brackets"> <dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt> <dd>
<p>Note the reversed ordering of the coefficients</p> </dd> </dl> </section> <section id="transition-guide"> <h3>Transition Guide</h3> <p>There are significant differences between <code>numpy.lib.polynomial</code> and <a class="reference internal" href="routines.polynomials.package#module-numpy.polynomial" title="numpy.polynomial"><code>numpy.polynomial</code></a>. The most significant difference is the ordering of the coefficients for the polynomial expressions. The various routines in <a class="reference internal" href="routines.polynomials.package#module-numpy.polynomial" title="numpy.polynomial"><code>numpy.polynomial</code></a> all deal with series whose coefficients go from degree zero upward, which is the <em>reverse order</em> of the poly1d convention. The easy way to remember this is that indices correspond to degree, i.e., <code>coef[i]</code> is the coefficient of the term of degree <em>i</em>.</p> <p>Though the difference in convention may be confusing, it is straightforward to convert from the legacy polynomial API to the new. For example, the following demonstrates how you would convert a <a class="reference internal" href="generated/numpy.poly1d#numpy.poly1d" title="numpy.poly1d"><code>numpy.poly1d</code></a> instance representing the expression <span class="math notranslate nohighlight">\(x^{2} + 2x + 3\)</span> to a <a class="reference internal" href="generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial" title="numpy.polynomial.polynomial.Polynomial"><code>Polynomial</code></a> instance representing the same expression:</p> <pre data-language="python">&gt;&gt;&gt; p1d = np.poly1d([1, 2, 3])
&gt;&gt;&gt; p = np.polynomial.Polynomial(p1d.coef[::-1])
</pre> <p>In addition to the <code>coef</code> attribute, polynomials from the polynomial package also have <code>domain</code> and <code>window</code> attributes. These attributes are most relevant when fitting polynomials to data, though it should be noted that polynomials with different <code>domain</code> and <code>window</code> attributes are not considered equal, and can’t be mixed in arithmetic:</p> <pre data-language="python">&gt;&gt;&gt; p1 = np.polynomial.Polynomial([1, 2, 3])
&gt;&gt;&gt; p1
Polynomial([1., 2., 3.], domain=[-1,  1], window=[-1,  1])
&gt;&gt;&gt; p2 = np.polynomial.Polynomial([1, 2, 3], domain=[-2, 2])
&gt;&gt;&gt; p1 == p2
False
&gt;&gt;&gt; p1 + p2
Traceback (most recent call last):
    ...
TypeError: Domains differ
</pre> <p>See the documentation for the <a class="reference external" href="https://numpy.org/doc/1.22/reference/routines.polynomials.classes">convenience classes</a> for further details on the <code>domain</code> and <code>window</code> attributes.</p> <p>Another major difference between the legacy polynomial module and the polynomial package is polynomial fitting. In the old module, fitting was done via the <a class="reference internal" href="generated/numpy.polyfit#numpy.polyfit" title="numpy.polyfit"><code>polyfit</code></a> function. In the polynomial package, the <a class="reference internal" href="generated/numpy.polynomial.polynomial.polynomial.fit#numpy.polynomial.polynomial.Polynomial.fit" title="numpy.polynomial.polynomial.Polynomial.fit"><code>fit</code></a> class method is preferred. For example, consider a simple linear fit to the following data:</p> <pre data-language="python">In [1]: rng = np.random.default_rng()

In [2]: x = np.arange(10)

In [3]: y = np.arange(10) + rng.standard_normal(10)
</pre> <p>With the legacy polynomial module, a linear fit (i.e. polynomial of degree 1) could be applied to these data with <a class="reference internal" href="generated/numpy.polyfit#numpy.polyfit" title="numpy.polyfit"><code>polyfit</code></a>:</p> <pre data-language="python">In [4]: np.polyfit(x, y, deg=1)
Out[4]: array([0.89865114, 0.25736425])
</pre> <p>With the new polynomial API, the <a class="reference internal" href="generated/numpy.polynomial.polynomial.polynomial.fit#numpy.polynomial.polynomial.Polynomial.fit" title="numpy.polynomial.polynomial.Polynomial.fit"><code>fit</code></a> class method is preferred:</p> <pre data-language="python">In [5]: p_fitted = np.polynomial.Polynomial.fit(x, y, deg=1)

In [6]: p_fitted
Out[6]: Polynomial([4.30129436, 4.04393012], domain=[0., 9.], window=[-1.,  1.])
</pre> <p>Note that the coefficients are given <em>in the scaled domain</em> defined by the linear mapping between the <code>window</code> and <code>domain</code>. <a class="reference internal" href="generated/numpy.polynomial.polynomial.polynomial.convert#numpy.polynomial.polynomial.Polynomial.convert" title="numpy.polynomial.polynomial.Polynomial.convert"><code>convert</code></a> can be used to get the coefficients in the unscaled data domain.</p> <pre data-language="python">In [7]: p_fitted.convert()
Out[7]: Polynomial([0.25736425, 0.89865114], domain=[-1.,  1.], window=[-1.,  1.])
</pre> </section> </section> <section id="documentation-for-the-polynomial-package"> <h2>Documentation for the polynomial Package</h2> <p>In addition to standard power series polynomials, the polynomial package provides several additional kinds of polynomials including Chebyshev, Hermite (two subtypes), Laguerre, and Legendre polynomials. Each of these has an associated <code>convenience class</code> available from the <a class="reference internal" href="routines.polynomials.package#module-numpy.polynomial" title="numpy.polynomial"><code>numpy.polynomial</code></a> namespace that provides a consistent interface for working with polynomials regardless of their type.</p>  <ul> <li class="toctree-l1"><a class="reference internal" href="routines.polynomials.classes">Using the Convenience Classes</a></li> </ul>  <p>Documentation pertaining to specific functions defined for each kind of polynomial individually can be found in the corresponding module documentation:</p>  <ul> <li class="toctree-l1"><a class="reference internal" href="routines.polynomials.polynomial">Power Series (<code>numpy.polynomial.polynomial</code>)</a></li> <li class="toctree-l1"><a class="reference internal" href="routines.polynomials.chebyshev">Chebyshev Series (<code>numpy.polynomial.chebyshev</code>)</a></li> <li class="toctree-l1"><a class="reference internal" href="routines.polynomials.hermite">Hermite Series, “Physicists” (<code>numpy.polynomial.hermite</code>)</a></li> <li class="toctree-l1"><a class="reference internal" href="routines.polynomials.hermite_e">HermiteE Series, “Probabilists” (<code>numpy.polynomial.hermite_e</code>)</a></li> <li class="toctree-l1"><a class="reference internal" href="routines.polynomials.laguerre">Laguerre Series (<code>numpy.polynomial.laguerre</code>)</a></li> <li class="toctree-l1"><a class="reference internal" href="routines.polynomials.legendre">Legendre Series (<code>numpy.polynomial.legendre</code>)</a></li> <li class="toctree-l1"><a class="reference internal" href="routines.polynomials.polyutils">Polyutils</a></li> </ul>  </section> <section id="documentation-for-legacy-polynomials"> <h2>Documentation for Legacy Polynomials</h2>  <ul> <li class="toctree-l1">
<a class="reference internal" href="routines.polynomials.poly1d">Poly1d</a><ul> <li class="toctree-l2"><a class="reference internal" href="routines.polynomials.poly1d#basics">Basics</a></li> <li class="toctree-l2"><a class="reference internal" href="routines.polynomials.poly1d#fitting">Fitting</a></li> <li class="toctree-l2"><a class="reference internal" href="routines.polynomials.poly1d#calculus">Calculus</a></li> <li class="toctree-l2"><a class="reference internal" href="routines.polynomials.poly1d#arithmetic">Arithmetic</a></li> <li class="toctree-l2"><a class="reference internal" href="routines.polynomials.poly1d#warnings">Warnings</a></li> </ul> </li> </ul>  </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/routines.polynomials.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/routines.polynomials.html</a>
  </p>
</div>
