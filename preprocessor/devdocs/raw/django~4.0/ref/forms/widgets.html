<h1 id="widgets">Widgets</h1> <p id="s-module-django.forms.widgets">A widget is Django’s representation of an HTML input element. The widget handles the rendering of the HTML, and the extraction of data from a GET/POST dictionary that corresponds to the widget.</p> <p>The HTML generated by the built-in widgets uses HTML5 syntax, targeting <code>&lt;!DOCTYPE html&gt;</code>. For example, it uses boolean attributes such as <code>checked</code> rather than the XHTML style of <code>checked='checked'</code>.</p> <div class="admonition tip"> <p class="first admonition-title">Tip</p> <p class="last">Widgets should not be confused with the <a class="reference internal" href="fields"><span class="doc">form fields</span></a>. Form fields deal with the logic of input validation and are used directly in templates. Widgets deal with rendering of HTML form input elements on the web page and extraction of raw submitted data. However, widgets do need to be <a class="reference internal" href="#widget-to-field"><span class="std std-ref">assigned</span></a> to form fields.</p> </div>  <h2 id="widget-to-field">Specifying widgets</h2> <p id="s-specifying-widgets">Whenever you specify a field on a form, Django will use a default widget that is appropriate to the type of data that is to be displayed. To find which widget is used on which field, see the documentation about <a class="reference internal" href="fields#built-in-fields"><span class="std std-ref">Built-in Field classes</span></a>.</p> <p>However, if you want to use a different widget for a field, you can use the <a class="reference internal" href="fields#django.forms.Field.widget" title="django.forms.Field.widget"><code>widget</code></a> argument on the field definition. For example:</p> <pre data-language="python">from django import forms

class CommentForm(forms.Form):
    name = forms.CharField()
    url = forms.URLField()
    comment = forms.CharField(widget=forms.Textarea)
</pre> <p>This would specify a form with a comment that uses a larger <a class="reference internal" href="#django.forms.Textarea" title="django.forms.Textarea"><code>Textarea</code></a> widget, rather than the default <a class="reference internal" href="#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a> widget.</p>   <h2 id="setting-arguments-for-widgets">Setting arguments for widgets</h2> <p id="s-setting-arguments-for-widgets">Many widgets have optional extra arguments; they can be set when defining the widget on the field. In the following example, the <a class="reference internal" href="#django.forms.SelectDateWidget.years" title="django.forms.SelectDateWidget.years"><code>years</code></a> attribute is set for a <a class="reference internal" href="#django.forms.SelectDateWidget" title="django.forms.SelectDateWidget"><code>SelectDateWidget</code></a>:</p> <pre data-language="python">from django import forms

BIRTH_YEAR_CHOICES = ['1980', '1981', '1982']
FAVORITE_COLORS_CHOICES = [
    ('blue', 'Blue'),
    ('green', 'Green'),
    ('black', 'Black'),
]

class SimpleForm(forms.Form):
    birth_year = forms.DateField(widget=forms.SelectDateWidget(years=BIRTH_YEAR_CHOICES))
    favorite_colors = forms.MultipleChoiceField(
        required=False,
        widget=forms.CheckboxSelectMultiple,
        choices=FAVORITE_COLORS_CHOICES,
    )
</pre> <p>See the <a class="reference internal" href="#built-in-widgets"><span class="std std-ref">Built-in widgets</span></a> for more information about which widgets are available and which arguments they accept.</p>   <h2 id="widgets-inheriting-from-the-select-widget">Widgets inheriting from the <code>Select</code> widget</h2> <p id="s-widgets-inheriting-from-the-select-widget">Widgets inheriting from the <a class="reference internal" href="#django.forms.Select" title="django.forms.Select"><code>Select</code></a> widget deal with choices. They present the user with a list of options to choose from. The different widgets present this choice differently; the <a class="reference internal" href="#django.forms.Select" title="django.forms.Select"><code>Select</code></a> widget itself uses a <code>&lt;select&gt;</code> HTML list representation, while <a class="reference internal" href="#django.forms.RadioSelect" title="django.forms.RadioSelect"><code>RadioSelect</code></a> uses radio buttons.</p> <p><a class="reference internal" href="#django.forms.Select" title="django.forms.Select"><code>Select</code></a> widgets are used by default on <a class="reference internal" href="fields#django.forms.ChoiceField" title="django.forms.ChoiceField"><code>ChoiceField</code></a> fields. The choices displayed on the widget are inherited from the <a class="reference internal" href="fields#django.forms.ChoiceField" title="django.forms.ChoiceField"><code>ChoiceField</code></a> and changing <a class="reference internal" href="fields#django.forms.ChoiceField.choices" title="django.forms.ChoiceField.choices"><code>ChoiceField.choices</code></a> will update <a class="reference internal" href="#django.forms.Select.choices" title="django.forms.Select.choices"><code>Select.choices</code></a>. For example:</p> <pre data-language="python">&gt;&gt;&gt; from django import forms
&gt;&gt;&gt; CHOICES = [('1', 'First'), ('2', 'Second')]
&gt;&gt;&gt; choice_field = forms.ChoiceField(widget=forms.RadioSelect, choices=CHOICES)
&gt;&gt;&gt; choice_field.choices
[('1', 'First'), ('2', 'Second')]
&gt;&gt;&gt; choice_field.widget.choices
[('1', 'First'), ('2', 'Second')]
&gt;&gt;&gt; choice_field.widget.choices = []
&gt;&gt;&gt; choice_field.choices = [('1', 'First and only')]
&gt;&gt;&gt; choice_field.widget.choices
[('1', 'First and only')]
</pre> <p>Widgets which offer a <a class="reference internal" href="#django.forms.Select.choices" title="django.forms.Select.choices"><code>choices</code></a> attribute can however be used with fields which are not based on choice – such as a <a class="reference internal" href="fields#django.forms.CharField" title="django.forms.CharField"><code>CharField</code></a> – but it is recommended to use a <a class="reference internal" href="fields#django.forms.ChoiceField" title="django.forms.ChoiceField"><code>ChoiceField</code></a>-based field when the choices are inherent to the model and not just the representational widget.</p>   <h2 id="customizing-widget-instances">Customizing widget instances</h2> <p id="s-customizing-widget-instances">When Django renders a widget as HTML, it only renders very minimal markup - Django doesn’t add class names, or any other widget-specific attributes. This means, for example, that all <a class="reference internal" href="#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a> widgets will appear the same on your web pages.</p> <p>There are two ways to customize widgets: <a class="reference internal" href="#styling-widget-instances"><span class="std std-ref">per widget instance</span></a> and <a class="reference internal" href="#styling-widget-classes"><span class="std std-ref">per widget class</span></a>.</p>  <h3 id="id1">Styling widget instances</h3> <p id="s-styling-widget-instances">If you want to make one widget instance look different from another, you will need to specify additional attributes at the time when the widget object is instantiated and assigned to a form field (and perhaps add some rules to your CSS files).</p> <p>For example, take the following form:</p> <pre data-language="python">from django import forms

class CommentForm(forms.Form):
    name = forms.CharField()
    url = forms.URLField()
    comment = forms.CharField()
</pre> <p>This form will include three default <a class="reference internal" href="#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a> widgets, with default rendering – no CSS class, no extra attributes. This means that the input boxes provided for each widget will be rendered exactly the same:</p> <pre data-language="python">&gt;&gt;&gt; f = CommentForm(auto_id=False)
&gt;&gt;&gt; f.as_table()
&lt;tr&gt;&lt;th&gt;Name:&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="name" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Url:&lt;/th&gt;&lt;td&gt;&lt;input type="url" name="url" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Comment:&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="comment" required&gt;&lt;/td&gt;&lt;/tr&gt;
</pre> <p>On a real web page, you probably don’t want every widget to look the same. You might want a larger input element for the comment, and you might want the ‘name’ widget to have some special CSS class. It is also possible to specify the ‘type’ attribute to take advantage of the new HTML5 input types. To do this, you use the <a class="reference internal" href="#django.forms.Widget.attrs" title="django.forms.Widget.attrs"><code>Widget.attrs</code></a> argument when creating the widget:</p> <pre data-language="python">class CommentForm(forms.Form):
    name = forms.CharField(widget=forms.TextInput(attrs={'class': 'special'}))
    url = forms.URLField()
    comment = forms.CharField(widget=forms.TextInput(attrs={'size': '40'}))
</pre> <p>You can also modify a widget in the form definition:</p> <pre data-language="python">class CommentForm(forms.Form):
    name = forms.CharField()
    url = forms.URLField()
    comment = forms.CharField()

    name.widget.attrs.update({'class': 'special'})
    comment.widget.attrs.update(size='40')
</pre> <p>Or if the field isn’t declared directly on the form (such as model form fields), you can use the <a class="reference internal" href="api#django.forms.Form.fields" title="django.forms.Form.fields"><code>Form.fields</code></a> attribute:</p> <pre data-language="python">class CommentForm(forms.ModelForm):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields['name'].widget.attrs.update({'class': 'special'})
        self.fields['comment'].widget.attrs.update(size='40')
</pre> <p>Django will then include the extra attributes in the rendered output:</p> <pre data-language="python">&gt;&gt;&gt; f = CommentForm(auto_id=False)
&gt;&gt;&gt; f.as_table()
&lt;tr&gt;&lt;th&gt;Name:&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="name" class="special" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Url:&lt;/th&gt;&lt;td&gt;&lt;input type="url" name="url" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Comment:&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="comment" size="40" required&gt;&lt;/td&gt;&lt;/tr&gt;
</pre> <p>You can also set the HTML <code>id</code> using <a class="reference internal" href="#django.forms.Widget.attrs" title="django.forms.Widget.attrs"><code>attrs</code></a>. See <a class="reference internal" href="api#django.forms.BoundField.id_for_label" title="django.forms.BoundField.id_for_label"><code>BoundField.id_for_label</code></a> for an example.</p>   <h3 id="id2">Styling widget classes</h3> <p id="s-styling-widget-classes">With widgets, it is possible to add assets (<code>css</code> and <code>javascript</code>) and more deeply customize their appearance and behavior.</p> <p>In a nutshell, you will need to subclass the widget and either <a class="reference internal" href="../../topics/forms/media#assets-as-a-static-definition"><span class="std std-ref">define a “Media” inner class</span></a> or <a class="reference internal" href="../../topics/forms/media#dynamic-property"><span class="std std-ref">create a “media” property</span></a>.</p> <p>These methods involve somewhat advanced Python programming and are described in detail in the <a class="reference internal" href="../../topics/forms/media"><span class="doc">Form Assets</span></a> topic guide.</p>    <h2 id="id3">Base widget classes</h2> <p id="s-base-widget-classes">Base widget classes <a class="reference internal" href="#django.forms.Widget" title="django.forms.Widget"><code>Widget</code></a> and <a class="reference internal" href="#django.forms.MultiWidget" title="django.forms.MultiWidget"><code>MultiWidget</code></a> are subclassed by all the <a class="reference internal" href="#built-in-widgets"><span class="std std-ref">built-in widgets</span></a> and may serve as a foundation for custom widgets.</p>  <h3 id="widget"><code>Widget</code></h3> <dl class="class" id="s-widget"> <dt id="django.forms.Widget">
<code>class Widget(attrs=None)</code> </dt> <dd>
<p>This abstract class cannot be rendered, but provides the basic attribute <a class="reference internal" href="#django.forms.Widget.attrs" title="django.forms.Widget.attrs"><code>attrs</code></a>. You may also implement or override the <a class="reference internal" href="#django.forms.Widget.render" title="django.forms.Widget.render"><code>render()</code></a> method on custom widgets.</p> <dl class="attribute"> <dt id="django.forms.Widget.attrs">
<code>attrs</code> </dt> <dd>
<p>A dictionary containing HTML attributes to be set on the rendered widget.</p> <pre data-language="pycon">&gt;&gt;&gt; from django import forms
&gt;&gt;&gt; name = forms.TextInput(attrs={'size': 10, 'title': 'Your name'})
&gt;&gt;&gt; name.render('name', 'A name')
'&lt;input title="Your name" type="text" name="name" value="A name" size="10"&gt;'
</pre> <p>If you assign a value of <code>True</code> or <code>False</code> to an attribute, it will be rendered as an HTML5 boolean attribute:</p> <pre data-language="python">&gt;&gt;&gt; name = forms.TextInput(attrs={'required': True})
&gt;&gt;&gt; name.render('name', 'A name')
'&lt;input name="name" type="text" value="A name" required&gt;'
&gt;&gt;&gt;
&gt;&gt;&gt; name = forms.TextInput(attrs={'required': False})
&gt;&gt;&gt; name.render('name', 'A name')
'&lt;input name="name" type="text" value="A name"&gt;'
</pre> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.Widget.supports_microseconds">
<code>supports_microseconds</code> </dt> <dd>
<p>An attribute that defaults to <code>True</code>. If set to <code>False</code>, the microseconds part of <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime" title="(in Python v3.10)"><code>datetime</code></a> and <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.time" title="(in Python v3.10)"><code>time</code></a> values will be set to <code>0</code>.</p> </dd>
</dl> <dl class="method"> <dt id="django.forms.Widget.format_value">
<code>format_value(value)</code> </dt> <dd>
<p>Cleans and returns a value for use in the widget template. <code>value</code> isn’t guaranteed to be valid input, therefore subclass implementations should program defensively.</p> </dd>
</dl> <dl class="method"> <dt id="django.forms.Widget.get_context">
<code>get_context(name, value, attrs)</code> </dt> <dd>
<p>Returns a dictionary of values to use when rendering the widget template. By default, the dictionary contains a single key, <code>'widget'</code>, which is a dictionary representation of the widget containing the following keys:</p> <ul class="simple"> <li>
<code>'name'</code>: The name of the field from the <code>name</code> argument.</li> <li>
<code>'is_hidden'</code>: A boolean indicating whether or not this widget is hidden.</li> <li>
<code>'required'</code>: A boolean indicating whether or not the field for this widget is required.</li> <li>
<code>'value'</code>: The value as returned by <a class="reference internal" href="#django.forms.Widget.format_value" title="django.forms.Widget.format_value"><code>format_value()</code></a>.</li> <li>
<code>'attrs'</code>: HTML attributes to be set on the rendered widget. The combination of the <a class="reference internal" href="#django.forms.Widget.attrs" title="django.forms.Widget.attrs"><code>attrs</code></a> attribute and the <code>attrs</code> argument.</li> <li>
<code>'template_name'</code>: The value of <code>self.template_name</code>.</li> </ul> <p><code>Widget</code> subclasses can provide custom context values by overriding this method.</p> </dd>
</dl> <dl class="method"> <dt id="django.forms.Widget.id_for_label">
<code>id_for_label(id_)</code> </dt> <dd>
<p>Returns the HTML ID attribute of this widget for use by a <code>&lt;label&gt;</code>, given the ID of the field. Returns <code>None</code> if an ID isn’t available.</p> <p>This hook is necessary because some widgets have multiple HTML elements and, thus, multiple IDs. In that case, this method should return an ID value that corresponds to the first ID in the widget’s tags.</p> </dd>
</dl> <dl class="method"> <dt id="django.forms.Widget.render">
<code>render(name, value, attrs=None, renderer=None)</code> </dt> <dd>
<p>Renders a widget to HTML using the given renderer. If <code>renderer</code> is <code>None</code>, the renderer from the <a class="reference internal" href="../settings#std:setting-FORM_RENDERER"><code>FORM_RENDERER</code></a> setting is used.</p> </dd>
</dl> <dl class="method"> <dt id="django.forms.Widget.value_from_datadict">
<code>value_from_datadict(data, files, name)</code> </dt> <dd>
<p>Given a dictionary of data and this widget’s name, returns the value of this widget. <code>files</code> may contain data coming from <a class="reference internal" href="../request-response#django.http.HttpRequest.FILES" title="django.http.HttpRequest.FILES"><code>request.FILES</code></a>. Returns <code>None</code> if a value wasn’t provided. Note also that <code>value_from_datadict</code> may be called more than once during handling of form data, so if you customize it and add expensive processing, you should implement some caching mechanism yourself.</p> </dd>
</dl> <dl class="method"> <dt id="django.forms.Widget.value_omitted_from_data">
<code>value_omitted_from_data(data, files, name)</code> </dt> <dd>
<p>Given <code>data</code> and <code>files</code> dictionaries and this widget’s name, returns whether or not there’s data or files for the widget.</p> <p>The method’s result affects whether or not a field in a model form <a class="reference internal" href="../../topics/forms/modelforms#topics-modelform-save"><span class="std std-ref">falls back to its default</span></a>.</p> <p>Special cases are <a class="reference internal" href="#django.forms.CheckboxInput" title="django.forms.CheckboxInput"><code>CheckboxInput</code></a>, <a class="reference internal" href="#django.forms.CheckboxSelectMultiple" title="django.forms.CheckboxSelectMultiple"><code>CheckboxSelectMultiple</code></a>, and <a class="reference internal" href="#django.forms.SelectMultiple" title="django.forms.SelectMultiple"><code>SelectMultiple</code></a>, which always return <code>False</code> because an unchecked checkbox and unselected <code>&lt;select multiple&gt;</code> don’t appear in the data of an HTML form submission, so it’s unknown whether or not the user submitted a value.</p> </dd>
</dl> <dl class="method"> <dt id="django.forms.Widget.use_required_attribute">
<code>use_required_attribute(initial)</code> </dt> <dd>
<p>Given a form field’s <code>initial</code> value, returns whether or not the widget can be rendered with the <code>required</code> HTML attribute. Forms use this method along with <a class="reference internal" href="fields#django.forms.Field.required" title="django.forms.Field.required"><code>Field.required</code></a> and <a class="reference internal" href="api#django.forms.Form.use_required_attribute" title="django.forms.Form.use_required_attribute"><code>Form.use_required_attribute</code></a> to determine whether or not to display the <code>required</code> attribute for each field.</p> <p>By default, returns <code>False</code> for hidden widgets and <code>True</code> otherwise. Special cases are <a class="reference internal" href="#django.forms.FileInput" title="django.forms.FileInput"><code>FileInput</code></a> and <a class="reference internal" href="#django.forms.ClearableFileInput" title="django.forms.ClearableFileInput"><code>ClearableFileInput</code></a>, which return <code>False</code> when <code>initial</code> is set, and <a class="reference internal" href="#django.forms.CheckboxSelectMultiple" title="django.forms.CheckboxSelectMultiple"><code>CheckboxSelectMultiple</code></a>, which always returns <code>False</code> because browser validation would require all checkboxes to be checked instead of at least one.</p> <p>Override this method in custom widgets that aren’t compatible with browser validation. For example, a WSYSIWG text editor widget backed by a hidden <code>textarea</code> element may want to always return <code>False</code> to avoid browser validation on the hidden field.</p> </dd>
</dl> </dd>
</dl>   <h3 id="multiwidget"><code>MultiWidget</code></h3> <dl class="class" id="s-multiwidget"> <dt id="django.forms.MultiWidget">
<code>class MultiWidget(widgets, attrs=None)</code> </dt> <dd>
<p>A widget that is composed of multiple widgets. <a class="reference internal" href="#django.forms.MultiWidget" title="django.forms.MultiWidget"><code>MultiWidget</code></a> works hand in hand with the <a class="reference internal" href="fields#django.forms.MultiValueField" title="django.forms.MultiValueField"><code>MultiValueField</code></a>.</p> <p><a class="reference internal" href="#django.forms.MultiWidget" title="django.forms.MultiWidget"><code>MultiWidget</code></a> has one required argument:</p> <dl class="attribute"> <dt id="django.forms.MultiWidget.widgets">
<code>widgets</code> </dt> <dd>
<p>An iterable containing the widgets needed. For example:</p> <pre data-language="python">&gt;&gt;&gt; from django.forms import MultiWidget, TextInput
&gt;&gt;&gt; widget = MultiWidget(widgets=[TextInput, TextInput])
&gt;&gt;&gt; widget.render('name', ['john', 'paul'])
'&lt;input type="text" name="name_0" value="john"&gt;&lt;input type="text" name="name_1" value="paul"&gt;'
</pre> <p>You may provide a dictionary in order to specify custom suffixes for the <code>name</code> attribute on each subwidget. In this case, for each <code>(key, widget)</code> pair, the key will be appended to the <code>name</code> of the widget in order to generate the attribute value. You may provide the empty string (<code>''</code>) for a single key, in order to suppress the suffix for one widget. For example:</p> <pre data-language="python">&gt;&gt;&gt; widget = MultiWidget(widgets={'': TextInput, 'last': TextInput})
&gt;&gt;&gt; widget.render('name', ['john', 'paul'])
'&lt;input type="text" name="name" value="john"&gt;&lt;input type="text" name="name_last" value="paul"&gt;'
</pre> </dd>
</dl> <p>And one required method:</p> <dl class="method"> <dt id="django.forms.MultiWidget.decompress">
<code>decompress(value)</code> </dt> <dd>
<p>This method takes a single “compressed” value from the field and returns a list of “decompressed” values. The input value can be assumed valid, but not necessarily non-empty.</p> <p>This method <strong>must be implemented</strong> by the subclass, and since the value may be empty, the implementation must be defensive.</p> <p>The rationale behind “decompression” is that it is necessary to “split” the combined value of the form field into the values for each widget.</p> <p>An example of this is how <a class="reference internal" href="#django.forms.SplitDateTimeWidget" title="django.forms.SplitDateTimeWidget"><code>SplitDateTimeWidget</code></a> turns a <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime" title="(in Python v3.10)"><code>datetime</code></a> value into a list with date and time split into two separate values:</p> <pre data-language="python">from django.forms import MultiWidget

class SplitDateTimeWidget(MultiWidget):

    # ...

    def decompress(self, value):
        if value:
            return [value.date(), value.time()]
        return [None, None]
</pre> <div class="admonition tip"> <p class="first admonition-title">Tip</p> <p class="last">Note that <a class="reference internal" href="fields#django.forms.MultiValueField" title="django.forms.MultiValueField"><code>MultiValueField</code></a> has a complementary method <a class="reference internal" href="fields#django.forms.MultiValueField.compress" title="django.forms.MultiValueField.compress"><code>compress()</code></a> with the opposite responsibility - to combine cleaned values of all member fields into one.</p> </div> </dd>
</dl> <p>It provides some custom context:</p> <dl class="method"> <dt id="django.forms.MultiWidget.get_context">
<code>get_context(name, value, attrs)</code> </dt> <dd>
<p>In addition to the <code>'widget'</code> key described in <a class="reference internal" href="#django.forms.Widget.get_context" title="django.forms.Widget.get_context"><code>Widget.get_context()</code></a>, <code>MultiWidget</code> adds a <code>widget['subwidgets']</code> key.</p> <p>These can be looped over in the widget template:</p> <pre data-language="markup">{% for subwidget in widget.subwidgets %}
    {% include subwidget.template_name with widget=subwidget %}
{% endfor %}
</pre> </dd>
</dl> <p>Here’s an example widget which subclasses <a class="reference internal" href="#django.forms.MultiWidget" title="django.forms.MultiWidget"><code>MultiWidget</code></a> to display a date with the day, month, and year in different select boxes. This widget is intended to be used with a <a class="reference internal" href="fields#django.forms.DateField" title="django.forms.DateField"><code>DateField</code></a> rather than a <a class="reference internal" href="fields#django.forms.MultiValueField" title="django.forms.MultiValueField"><code>MultiValueField</code></a>, thus we have implemented <a class="reference internal" href="#django.forms.Widget.value_from_datadict" title="django.forms.Widget.value_from_datadict"><code>value_from_datadict()</code></a>:</p> <pre data-language="python">from datetime import date
from django import forms

class DateSelectorWidget(forms.MultiWidget):
    def __init__(self, attrs=None):
        days = [(day, day) for day in range(1, 32)]
        months = [(month, month) for month in range(1, 13)]
        years = [(year, year) for year in [2018, 2019, 2020]]
        widgets = [
            forms.Select(attrs=attrs, choices=days),
            forms.Select(attrs=attrs, choices=months),
            forms.Select(attrs=attrs, choices=years),
        ]
        super().__init__(widgets, attrs)

    def decompress(self, value):
        if isinstance(value, date):
            return [value.day, value.month, value.year]
        elif isinstance(value, str):
            year, month, day = value.split('-')
            return [day, month, year]
        return [None, None, None]

    def value_from_datadict(self, data, files, name):
        day, month, year = super().value_from_datadict(data, files, name)
        # DateField expects a single string that it can parse into a date.
        return '{}-{}-{}'.format(year, month, day)
</pre> <p>The constructor creates several <a class="reference internal" href="#django.forms.Select" title="django.forms.Select"><code>Select</code></a> widgets in a list. The <code>super()</code> method uses this list to set up the widget.</p> <p>The required method <a class="reference internal" href="#django.forms.MultiWidget.decompress" title="django.forms.MultiWidget.decompress"><code>decompress()</code></a> breaks up a <code>datetime.date</code> value into the day, month, and year values corresponding to each widget. If an invalid date was selected, such as the non-existent 30th February, the <a class="reference internal" href="fields#django.forms.DateField" title="django.forms.DateField"><code>DateField</code></a> passes this method a string instead, so that needs parsing. The final <code>return</code> handles when <code>value</code> is <code>None</code>, meaning we don’t have any defaults for our subwidgets.</p> <p>The default implementation of <a class="reference internal" href="#django.forms.Widget.value_from_datadict" title="django.forms.Widget.value_from_datadict"><code>value_from_datadict()</code></a> returns a list of values corresponding to each <code>Widget</code>. This is appropriate when using a <code>MultiWidget</code> with a <a class="reference internal" href="fields#django.forms.MultiValueField" title="django.forms.MultiValueField"><code>MultiValueField</code></a>. But since we want to use this widget with a <a class="reference internal" href="fields#django.forms.DateField" title="django.forms.DateField"><code>DateField</code></a>, which takes a single value, we have overridden this method. The implementation here combines the data from the subwidgets into a string in the format that <a class="reference internal" href="fields#django.forms.DateField" title="django.forms.DateField"><code>DateField</code></a> expects.</p> </dd>
</dl>    <h2 id="id4">Built-in widgets</h2> <p id="s-built-in-widgets">Django provides a representation of all the basic HTML widgets, plus some commonly used groups of widgets in the <code>django.forms.widgets</code> module, including <a class="reference internal" href="#text-widgets"><span class="std std-ref">the input of text</span></a>, <a class="reference internal" href="#selector-widgets"><span class="std std-ref">various checkboxes and selectors</span></a>, <a class="reference internal" href="#file-upload-widgets"><span class="std std-ref">uploading files</span></a>, and <a class="reference internal" href="#composite-widgets"><span class="std std-ref">handling of multi-valued input</span></a>.</p>  <h3 id="text-widgets">Widgets handling input of text</h3> <p id="s-widgets-handling-input-of-text">These widgets make use of the HTML elements <code>input</code> and <code>textarea</code>.</p>  <h4 id="textinput"><code>TextInput</code></h4> <dl class="class" id="s-textinput"> <dt id="django.forms.TextInput">
<code>class TextInput</code> </dt> <dd>
<ul class="simple"> <li>
<code>input_type</code>: <code>'text'</code>
</li> <li>
<code>template_name</code>: <code>'django/forms/widgets/text.html'</code>
</li> <li>Renders as: <code>&lt;input type="text" ...&gt;</code>
</li> </ul> </dd>
</dl>   <h4 id="numberinput"><code>NumberInput</code></h4> <dl class="class" id="s-numberinput"> <dt id="django.forms.NumberInput">
<code>class NumberInput</code> </dt> <dd>
<ul class="simple"> <li>
<code>input_type</code>: <code>'number'</code>
</li> <li>
<code>template_name</code>: <code>'django/forms/widgets/number.html'</code>
</li> <li>Renders as: <code>&lt;input type="number" ...&gt;</code>
</li> </ul> <p>Beware that not all browsers support entering localized numbers in <code>number</code> input types. Django itself avoids using them for fields having their <a class="reference internal" href="fields#django.forms.Field.localize" title="django.forms.Field.localize"><code>localize</code></a> property set to <code>True</code>.</p> </dd>
</dl>   <h4 id="emailinput"><code>EmailInput</code></h4> <dl class="class" id="s-emailinput"> <dt id="django.forms.EmailInput">
<code>class EmailInput</code> </dt> <dd>
<ul class="simple"> <li>
<code>input_type</code>: <code>'email'</code>
</li> <li>
<code>template_name</code>: <code>'django/forms/widgets/email.html'</code>
</li> <li>Renders as: <code>&lt;input type="email" ...&gt;</code>
</li> </ul> </dd>
</dl>   <h4 id="urlinput"><code>URLInput</code></h4> <dl class="class" id="s-urlinput"> <dt id="django.forms.URLInput">
<code>class URLInput</code> </dt> <dd>
<ul class="simple"> <li>
<code>input_type</code>: <code>'url'</code>
</li> <li>
<code>template_name</code>: <code>'django/forms/widgets/url.html'</code>
</li> <li>Renders as: <code>&lt;input type="url" ...&gt;</code>
</li> </ul> </dd>
</dl>   <h4 id="passwordinput"><code>PasswordInput</code></h4> <dl class="class" id="s-passwordinput"> <dt id="django.forms.PasswordInput">
<code>class PasswordInput</code> </dt> <dd>
<ul class="simple"> <li>
<code>input_type</code>: <code>'password'</code>
</li> <li>
<code>template_name</code>: <code>'django/forms/widgets/password.html'</code>
</li> <li>Renders as: <code>&lt;input type="password" ...&gt;</code>
</li> </ul> <p>Takes one optional argument:</p> <dl class="attribute"> <dt id="django.forms.PasswordInput.render_value">
<code>render_value</code> </dt> <dd>
<p>Determines whether the widget will have a value filled in when the form is re-displayed after a validation error (default is <code>False</code>).</p> </dd>
</dl> </dd>
</dl>   <h4 id="hiddeninput"><code>HiddenInput</code></h4> <dl class="class" id="s-hiddeninput"> <dt id="django.forms.HiddenInput">
<code>class HiddenInput</code> </dt> <dd>
<ul class="simple"> <li>
<code>input_type</code>: <code>'hidden'</code>
</li> <li>
<code>template_name</code>: <code>'django/forms/widgets/hidden.html'</code>
</li> <li>Renders as: <code>&lt;input type="hidden" ...&gt;</code>
</li> </ul> <p>Note that there also is a <a class="reference internal" href="#django.forms.MultipleHiddenInput" title="django.forms.MultipleHiddenInput"><code>MultipleHiddenInput</code></a> widget that encapsulates a set of hidden input elements.</p> </dd>
</dl>   <h4 id="dateinput"><code>DateInput</code></h4> <dl class="class" id="s-dateinput"> <dt id="django.forms.DateInput">
<code>class DateInput</code> </dt> <dd>
<ul class="simple"> <li>
<code>input_type</code>: <code>'text'</code>
</li> <li>
<code>template_name</code>: <code>'django/forms/widgets/date.html'</code>
</li> <li>Renders as: <code>&lt;input type="text" ...&gt;</code>
</li> </ul> <p>Takes same arguments as <a class="reference internal" href="#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a>, with one more optional argument:</p> <dl class="attribute"> <dt id="django.forms.DateInput.format">
<code>format</code> </dt> <dd>
<p>The format in which this field’s initial value will be displayed.</p> </dd>
</dl> <p>If no <code>format</code> argument is provided, the default format is the first format found in <a class="reference internal" href="../settings#std:setting-DATE_INPUT_FORMATS"><code>DATE_INPUT_FORMATS</code></a> and respects <a class="reference internal" href="../../topics/i18n/formatting"><span class="doc">Format localization</span></a>.</p> </dd>
</dl>   <h4 id="datetimeinput"><code>DateTimeInput</code></h4> <dl class="class" id="s-datetimeinput"> <dt id="django.forms.DateTimeInput">
<code>class DateTimeInput</code> </dt> <dd>
<ul class="simple"> <li>
<code>input_type</code>: <code>'text'</code>
</li> <li>
<code>template_name</code>: <code>'django/forms/widgets/datetime.html'</code>
</li> <li>Renders as: <code>&lt;input type="text" ...&gt;</code>
</li> </ul> <p>Takes same arguments as <a class="reference internal" href="#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a>, with one more optional argument:</p> <dl class="attribute"> <dt id="django.forms.DateTimeInput.format">
<code>format</code> </dt> <dd>
<p>The format in which this field’s initial value will be displayed.</p> </dd>
</dl> <p>If no <code>format</code> argument is provided, the default format is the first format found in <a class="reference internal" href="../settings#std:setting-DATETIME_INPUT_FORMATS"><code>DATETIME_INPUT_FORMATS</code></a> and respects <a class="reference internal" href="../../topics/i18n/formatting"><span class="doc">Format localization</span></a>.</p> <p>By default, the microseconds part of the time value is always set to <code>0</code>. If microseconds are required, use a subclass with the <a class="reference internal" href="#django.forms.Widget.supports_microseconds" title="django.forms.Widget.supports_microseconds"><code>supports_microseconds</code></a> attribute set to <code>True</code>.</p> </dd>
</dl>   <h4 id="timeinput"><code>TimeInput</code></h4> <dl class="class" id="s-timeinput"> <dt id="django.forms.TimeInput">
<code>class TimeInput</code> </dt> <dd>
<ul class="simple"> <li>
<code>input_type</code>: <code>'text'</code>
</li> <li>
<code>template_name</code>: <code>'django/forms/widgets/time.html'</code>
</li> <li>Renders as: <code>&lt;input type="text" ...&gt;</code>
</li> </ul> <p>Takes same arguments as <a class="reference internal" href="#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a>, with one more optional argument:</p> <dl class="attribute"> <dt id="django.forms.TimeInput.format">
<code>format</code> </dt> <dd>
<p>The format in which this field’s initial value will be displayed.</p> </dd>
</dl> <p>If no <code>format</code> argument is provided, the default format is the first format found in <a class="reference internal" href="../settings#std:setting-TIME_INPUT_FORMATS"><code>TIME_INPUT_FORMATS</code></a> and respects <a class="reference internal" href="../../topics/i18n/formatting"><span class="doc">Format localization</span></a>.</p> <p>For the treatment of microseconds, see <a class="reference internal" href="#django.forms.DateTimeInput" title="django.forms.DateTimeInput"><code>DateTimeInput</code></a>.</p> </dd>
</dl>   <h4 id="textarea"><code>Textarea</code></h4> <dl class="class" id="s-textarea"> <dt id="django.forms.Textarea">
<code>class Textarea</code> </dt> <dd>
<ul class="simple"> <li>
<code>template_name</code>: <code>'django/forms/widgets/textarea.html'</code>
</li> <li>Renders as: <code>&lt;textarea&gt;...&lt;/textarea&gt;</code>
</li> </ul> </dd>
</dl>    <h3 id="selector-widgets">Selector and checkbox widgets</h3> <p id="s-selector-and-checkbox-widgets">These widgets make use of the HTML elements <code>&lt;select&gt;</code>, <code>&lt;input type="checkbox"&gt;</code>, and <code>&lt;input type="radio"&gt;</code>.</p> <p>Widgets that render multiple choices have an <code>option_template_name</code> attribute that specifies the template used to render each choice. For example, for the <a class="reference internal" href="#django.forms.Select" title="django.forms.Select"><code>Select</code></a> widget, <code>select_option.html</code> renders the <code>&lt;option&gt;</code> for a <code>&lt;select&gt;</code>.</p>  <h4 id="checkboxinput"><code>CheckboxInput</code></h4> <dl class="class" id="s-checkboxinput"> <dt id="django.forms.CheckboxInput">
<code>class CheckboxInput</code> </dt> <dd>
<ul class="simple"> <li>
<code>input_type</code>: <code>'checkbox'</code>
</li> <li>
<code>template_name</code>: <code>'django/forms/widgets/checkbox.html'</code>
</li> <li>Renders as: <code>&lt;input type="checkbox" ...&gt;</code>
</li> </ul> <p>Takes one optional argument:</p> <dl class="attribute"> <dt id="django.forms.CheckboxInput.check_test">
<code>check_test</code> </dt> <dd>
<p>A callable that takes the value of the <code>CheckboxInput</code> and returns <code>True</code> if the checkbox should be checked for that value.</p> </dd>
</dl> </dd>
</dl>   <h4 id="select"><code>Select</code></h4> <dl class="class" id="s-select"> <dt id="django.forms.Select">
<code>class Select</code> </dt> <dd>
<ul class="simple"> <li>
<code>template_name</code>: <code>'django/forms/widgets/select.html'</code>
</li> <li>
<code>option_template_name</code>: <code>'django/forms/widgets/select_option.html'</code>
</li> <li>Renders as: <code>&lt;select&gt;&lt;option ...&gt;...&lt;/select&gt;</code>
</li> </ul> <dl class="attribute"> <dt id="django.forms.Select.choices">
<code>choices</code> </dt> <dd>
<p>This attribute is optional when the form field does not have a <code>choices</code> attribute. If it does, it will override anything you set here when the attribute is updated on the <a class="reference internal" href="fields#django.forms.Field" title="django.forms.Field"><code>Field</code></a>.</p> </dd>
</dl> </dd>
</dl>   <h4 id="nullbooleanselect"><code>NullBooleanSelect</code></h4> <dl class="class" id="s-nullbooleanselect"> <dt id="django.forms.NullBooleanSelect">
<code>class NullBooleanSelect</code> </dt> <dd>
<ul class="simple"> <li>
<code>template_name</code>: <code>'django/forms/widgets/select.html'</code>
</li> <li>
<code>option_template_name</code>: <code>'django/forms/widgets/select_option.html'</code>
</li> </ul> <p>Select widget with options ‘Unknown’, ‘Yes’ and ‘No’</p> </dd>
</dl>   <h4 id="selectmultiple"><code>SelectMultiple</code></h4> <dl class="class" id="s-selectmultiple"> <dt id="django.forms.SelectMultiple">
<code>class SelectMultiple</code> </dt> <dd>
<ul class="simple"> <li>
<code>template_name</code>: <code>'django/forms/widgets/select.html'</code>
</li> <li>
<code>option_template_name</code>: <code>'django/forms/widgets/select_option.html'</code>
</li> </ul> <p>Similar to <a class="reference internal" href="#django.forms.Select" title="django.forms.Select"><code>Select</code></a>, but allows multiple selection: <code>&lt;select multiple&gt;...&lt;/select&gt;</code></p> </dd>
</dl>   <h4 id="radioselect"><code>RadioSelect</code></h4> <dl class="class" id="s-radioselect"> <dt id="django.forms.RadioSelect">
<code>class RadioSelect</code> </dt> <dd>
<ul class="simple"> <li>
<code>template_name</code>: <code>'django/forms/widgets/radio.html'</code>
</li> <li>
<code>option_template_name</code>: <code>'django/forms/widgets/radio_option.html'</code>
</li> </ul> <p>Similar to <a class="reference internal" href="#django.forms.Select" title="django.forms.Select"><code>Select</code></a>, but rendered as a list of radio buttons within <code>&lt;div&gt;</code> tags:</p> <pre data-language="html">&lt;div&gt;
  &lt;div&gt;&lt;input type="radio" name="..."&gt;&lt;/div&gt;
  ...
&lt;/div&gt;
</pre> <div class="versionchanged"> <span class="title">Changed in Django 4.0:</span> <p>So they are announced more concisely by screen readers, radio buttons were changed to render in <code>&lt;div&gt;</code> tags.</p> </div> <p>For more granular control over the generated markup, you can loop over the radio buttons in the template. Assuming a form <code>myform</code> with a field <code>beatles</code> that uses a <code>RadioSelect</code> as its widget:</p> <pre data-language="markup">&lt;fieldset&gt;
    &lt;legend&gt;{{ myform.beatles.label }}&lt;/legend&gt;
    {% for radio in myform.beatles %}
    &lt;div class="myradio"&gt;
        {{ radio }}
    &lt;/div&gt;
    {% endfor %}
&lt;/fieldset&gt;
</pre> <p>This would generate the following HTML:</p> <pre data-language="html">&lt;fieldset&gt;
    &lt;legend&gt;Radio buttons&lt;/legend&gt;
    &lt;div class="myradio"&gt;
        &lt;label for="id_beatles_0"&gt;&lt;input id="id_beatles_0" name="beatles" type="radio" value="john" required&gt; John&lt;/label&gt;
    &lt;/div&gt;
    &lt;div class="myradio"&gt;
        &lt;label for="id_beatles_1"&gt;&lt;input id="id_beatles_1" name="beatles" type="radio" value="paul" required&gt; Paul&lt;/label&gt;
    &lt;/div&gt;
    &lt;div class="myradio"&gt;
        &lt;label for="id_beatles_2"&gt;&lt;input id="id_beatles_2" name="beatles" type="radio" value="george" required&gt; George&lt;/label&gt;
    &lt;/div&gt;
    &lt;div class="myradio"&gt;
        &lt;label for="id_beatles_3"&gt;&lt;input id="id_beatles_3" name="beatles" type="radio" value="ringo" required&gt; Ringo&lt;/label&gt;
    &lt;/div&gt;
&lt;/fieldset&gt;
</pre> <p>That included the <code>&lt;label&gt;</code> tags. To get more granular, you can use each radio button’s <code>tag</code>, <code>choice_label</code> and <code>id_for_label</code> attributes. For example, this template…</p> <pre data-language="markup">&lt;fieldset&gt;
    &lt;legend&gt;{{ myform.beatles.label }}&lt;/legend&gt;
    {% for radio in myform.beatles %}
    &lt;label for="{{ radio.id_for_label }}"&gt;
        {{ radio.choice_label }}
        &lt;span class="radio"&gt;{{ radio.tag }}&lt;/span&gt;
    &lt;/label&gt;
    {% endfor %}
&lt;/fieldset&gt;
</pre> <p>…will result in the following HTML:</p> <pre data-language="html">&lt;fieldset&gt;
    &lt;legend&gt;Radio buttons&lt;/legend&gt;
    &lt;label for="id_beatles_0"&gt;
        John
        &lt;span class="radio"&gt;&lt;input id="id_beatles_0" name="beatles" type="radio" value="john" required&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;label for="id_beatles_1"&gt;
        Paul
        &lt;span class="radio"&gt;&lt;input id="id_beatles_1" name="beatles" type="radio" value="paul" required&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;label for="id_beatles_2"&gt;
        George
        &lt;span class="radio"&gt;&lt;input id="id_beatles_2" name="beatles" type="radio" value="george" required&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;label for="id_beatles_3"&gt;
        Ringo
        &lt;span class="radio"&gt;&lt;input id="id_beatles_3" name="beatles" type="radio" value="ringo" required&gt;&lt;/span&gt;
    &lt;/label&gt;
&lt;/fieldset&gt;
</pre> <p>If you decide not to loop over the radio buttons – e.g., if your template includes <code>{{ myform.beatles }}</code> – they’ll be output in a <code>&lt;div&gt;</code> with <code>&lt;div&gt;</code> tags, as above.</p> <p>The outer <code>&lt;div&gt;</code> container receives the <code>id</code> attribute of the widget, if defined, or <a class="reference internal" href="api#django.forms.BoundField.auto_id" title="django.forms.BoundField.auto_id"><code>BoundField.auto_id</code></a> otherwise.</p> <p>When looping over the radio buttons, the <code>label</code> and <code>input</code> tags include <code>for</code> and <code>id</code> attributes, respectively. Each radio button has an <code>id_for_label</code> attribute to output the element’s ID.</p> </dd>
</dl>   <h4 id="checkboxselectmultiple"><code>CheckboxSelectMultiple</code></h4> <dl class="class" id="s-checkboxselectmultiple"> <dt id="django.forms.CheckboxSelectMultiple">
<code>class CheckboxSelectMultiple</code> </dt> <dd>
<ul class="simple"> <li>
<code>template_name</code>: <code>'django/forms/widgets/checkbox_select.html'</code>
</li> <li>
<code>option_template_name</code>: <code>'django/forms/widgets/checkbox_option.html'</code>
</li> </ul> <p>Similar to <a class="reference internal" href="#django.forms.SelectMultiple" title="django.forms.SelectMultiple"><code>SelectMultiple</code></a>, but rendered as a list of checkboxes:</p> <pre data-language="html">&lt;div&gt;
  &lt;div&gt;&lt;input type="checkbox" name="..." &gt;&lt;/div&gt;
  ...
&lt;/div&gt;
</pre> <p>The outer <code>&lt;div&gt;</code> container receives the <code>id</code> attribute of the widget, if defined, or <a class="reference internal" href="api#django.forms.BoundField.auto_id" title="django.forms.BoundField.auto_id"><code>BoundField.auto_id</code></a> otherwise.</p> <div class="versionchanged"> <span class="title">Changed in Django 4.0:</span> <p>So they are announced more concisely by screen readers, checkboxes were changed to render in <code>&lt;div&gt;</code> tags.</p> </div> </dd>
</dl> <p>Like <a class="reference internal" href="#django.forms.RadioSelect" title="django.forms.RadioSelect"><code>RadioSelect</code></a>, you can loop over the individual checkboxes for the widget’s choices. Unlike <a class="reference internal" href="#django.forms.RadioSelect" title="django.forms.RadioSelect"><code>RadioSelect</code></a>, the checkboxes won’t include the <code>required</code> HTML attribute if the field is required because browser validation would require all checkboxes to be checked instead of at least one.</p> <p>When looping over the checkboxes, the <code>label</code> and <code>input</code> tags include <code>for</code> and <code>id</code> attributes, respectively. Each checkbox has an <code>id_for_label</code> attribute to output the element’s ID.</p>    <h3 id="id5">File upload widgets</h3>  <h4 id="fileinput"><code>FileInput</code></h4> <dl class="class" id="s-file-upload-widgets"> <dt id="django.forms.FileInput">
<code>class FileInput</code> </dt> <dd>
<ul class="simple"> <li>
<code>template_name</code>: <code>'django/forms/widgets/file.html'</code>
</li> <li>Renders as: <code>&lt;input type="file" ...&gt;</code>
</li> </ul> </dd>
</dl>   <h4 id="clearablefileinput"><code>ClearableFileInput</code></h4> <dl class="class" id="s-clearablefileinput"> <dt id="django.forms.ClearableFileInput">
<code>class ClearableFileInput</code> </dt> <dd>
<ul class="simple"> <li>
<code>template_name</code>: <code>'django/forms/widgets/clearable_file_input.html'</code>
</li> <li>Renders as: <code>&lt;input type="file" ...&gt;</code> with an additional checkbox input to clear the field’s value, if the field is not required and has initial data.</li> </ul> </dd>
</dl>    <h3 id="id6">Composite widgets</h3>  <h4 id="multiplehiddeninput"><code>MultipleHiddenInput</code></h4> <dl class="class" id="s-composite-widgets"> <dt id="django.forms.MultipleHiddenInput">
<code>class MultipleHiddenInput</code> </dt> <dd>
<ul class="simple"> <li>
<code>template_name</code>: <code>'django/forms/widgets/multiple_hidden.html'</code>
</li> <li>Renders as: multiple <code>&lt;input type="hidden" ...&gt;</code> tags</li> </ul> <p>A widget that handles multiple hidden widgets for fields that have a list of values.</p> </dd>
</dl>   <h4 id="splitdatetimewidget"><code>SplitDateTimeWidget</code></h4> <dl class="class" id="s-splitdatetimewidget"> <dt id="django.forms.SplitDateTimeWidget">
<code>class SplitDateTimeWidget</code> </dt> <dd>
<ul class="simple"> <li>
<code>template_name</code>: <code>'django/forms/widgets/splitdatetime.html'</code>
</li> </ul> <p>Wrapper (using <a class="reference internal" href="#django.forms.MultiWidget" title="django.forms.MultiWidget"><code>MultiWidget</code></a>) around two widgets: <a class="reference internal" href="#django.forms.DateInput" title="django.forms.DateInput"><code>DateInput</code></a> for the date, and <a class="reference internal" href="#django.forms.TimeInput" title="django.forms.TimeInput"><code>TimeInput</code></a> for the time. Must be used with <a class="reference internal" href="fields#django.forms.SplitDateTimeField" title="django.forms.SplitDateTimeField"><code>SplitDateTimeField</code></a> rather than <a class="reference internal" href="fields#django.forms.DateTimeField" title="django.forms.DateTimeField"><code>DateTimeField</code></a>.</p> <p><code>SplitDateTimeWidget</code> has several optional arguments:</p> <dl class="attribute"> <dt id="django.forms.SplitDateTimeWidget.date_format">
<code>date_format</code> </dt> <dd>
<p>Similar to <a class="reference internal" href="#django.forms.DateInput.format" title="django.forms.DateInput.format"><code>DateInput.format</code></a></p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.SplitDateTimeWidget.time_format">
<code>time_format</code> </dt> <dd>
<p>Similar to <a class="reference internal" href="#django.forms.TimeInput.format" title="django.forms.TimeInput.format"><code>TimeInput.format</code></a></p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.SplitDateTimeWidget.date_attrs">
<code>date_attrs</code> </dt> 
</dl> <dl class="attribute"> <dt id="django.forms.SplitDateTimeWidget.time_attrs">
<code>time_attrs</code> </dt> <dd>
<p>Similar to <a class="reference internal" href="#django.forms.Widget.attrs" title="django.forms.Widget.attrs"><code>Widget.attrs</code></a>. A dictionary containing HTML attributes to be set on the rendered <a class="reference internal" href="#django.forms.DateInput" title="django.forms.DateInput"><code>DateInput</code></a> and <a class="reference internal" href="#django.forms.TimeInput" title="django.forms.TimeInput"><code>TimeInput</code></a> widgets, respectively. If these attributes aren’t set, <a class="reference internal" href="#django.forms.Widget.attrs" title="django.forms.Widget.attrs"><code>Widget.attrs</code></a> is used instead.</p> </dd>
</dl> </dd>
</dl>   <h4 id="splithiddendatetimewidget"><code>SplitHiddenDateTimeWidget</code></h4> <dl class="class" id="s-splithiddendatetimewidget"> <dt id="django.forms.SplitHiddenDateTimeWidget">
<code>class SplitHiddenDateTimeWidget</code> </dt> <dd>
<ul class="simple"> <li>
<code>template_name</code>: <code>'django/forms/widgets/splithiddendatetime.html'</code>
</li> </ul> <p>Similar to <a class="reference internal" href="#django.forms.SplitDateTimeWidget" title="django.forms.SplitDateTimeWidget"><code>SplitDateTimeWidget</code></a>, but uses <a class="reference internal" href="#django.forms.HiddenInput" title="django.forms.HiddenInput"><code>HiddenInput</code></a> for both date and time.</p> </dd>
</dl>   <h4 id="selectdatewidget"><code>SelectDateWidget</code></h4> <dl class="class" id="s-selectdatewidget"> <dt id="django.forms.SelectDateWidget">
<code>class SelectDateWidget</code> </dt> <dd>
<ul class="simple"> <li>
<code>template_name</code>: <code>'django/forms/widgets/select_date.html'</code>
</li> </ul> <p>Wrapper around three <a class="reference internal" href="#django.forms.Select" title="django.forms.Select"><code>Select</code></a> widgets: one each for month, day, and year.</p> <p>Takes several optional arguments:</p> <dl class="attribute"> <dt id="django.forms.SelectDateWidget.years">
<code>years</code> </dt> <dd>
<p>An optional list/tuple of years to use in the “year” select box. The default is a list containing the current year and the next 9 years.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.SelectDateWidget.months">
<code>months</code> </dt> <dd>
<p>An optional dict of months to use in the “months” select box.</p> <p>The keys of the dict correspond to the month number (1-indexed) and the values are the displayed months:</p> <pre data-language="python">MONTHS = {
    1:_('jan'), 2:_('feb'), 3:_('mar'), 4:_('apr'),
    5:_('may'), 6:_('jun'), 7:_('jul'), 8:_('aug'),
    9:_('sep'), 10:_('oct'), 11:_('nov'), 12:_('dec')
}
</pre> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.SelectDateWidget.empty_label">
<code>empty_label</code> </dt> <dd>
<p>If the <a class="reference internal" href="fields#django.forms.DateField" title="django.forms.DateField"><code>DateField</code></a> is not required, <a class="reference internal" href="#django.forms.SelectDateWidget" title="django.forms.SelectDateWidget"><code>SelectDateWidget</code></a> will have an empty choice at the top of the list (which is <code>---</code> by default). You can change the text of this label with the <code>empty_label</code> attribute. <code>empty_label</code> can be a <code>string</code>, <code>list</code>, or <code>tuple</code>. When a string is used, all select boxes will each have an empty choice with this label. If <code>empty_label</code> is a <code>list</code> or <code>tuple</code> of 3 string elements, the select boxes will have their own custom label. The labels should be in this order <code>('year_label', 'month_label', 'day_label')</code>.</p> <pre data-language="python"># A custom empty label with string
field1 = forms.DateField(widget=SelectDateWidget(empty_label="Nothing"))

# A custom empty label with tuple
field1 = forms.DateField(
    widget=SelectDateWidget(
        empty_label=("Choose Year", "Choose Month", "Choose Day"),
    ),
)
</pre> </dd>
</dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/4.0/ref/forms/widgets/" class="_attribution-link">https://docs.djangoproject.com/en/4.0/ref/forms/widgets/</a>
  </p>
</div>
