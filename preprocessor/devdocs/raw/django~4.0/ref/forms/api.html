<h1 id="the-forms-api">The Forms API</h1> <div class="admonition-about-this-document admonition" id="s-module-django.forms"> <p class="first admonition-title">About this document</p> <p class="last">This document covers the gritty details of Django’s forms API. You should read the <a class="reference internal" href="../../topics/forms/index"><span class="doc">introduction to working with forms</span></a> first.</p> </div>  <h2 id="ref-forms-api-bound-unbound">Bound and unbound forms</h2> <p id="s-bound-and-unbound-forms">A <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance is either <strong>bound</strong> to a set of data, or <strong>unbound</strong>.</p> <ul class="simple"> <li>If it’s <strong>bound</strong> to a set of data, it’s capable of validating that data and rendering the form as HTML with the data displayed in the HTML.</li> <li>If it’s <strong>unbound</strong>, it cannot do validation (because there’s no data to validate!), but it can still render the blank form as HTML.</li> </ul> <dl class="class"> <dt id="django.forms.Form">
<code>class Form</code> </dt> 
</dl> <p>To create an unbound <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance, instantiate the class:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm()
</pre> <p>To bind data to a form, pass the data as a dictionary as the first parameter to your <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> class constructor:</p> <pre data-language="python">&gt;&gt;&gt; data = {'subject': 'hello',
...         'message': 'Hi there',
...         'sender': 'foo@example.com',
...         'cc_myself': True}
&gt;&gt;&gt; f = ContactForm(data)
</pre> <p>In this dictionary, the keys are the field names, which correspond to the attributes in your <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> class. The values are the data you’re trying to validate. These will usually be strings, but there’s no requirement that they be strings; the type of data you pass depends on the <a class="reference internal" href="fields#django.forms.Field" title="django.forms.Field"><code>Field</code></a>, as we’ll see in a moment.</p> <dl class="attribute"> <dt id="django.forms.Form.is_bound">
<code>Form.is_bound</code> </dt> 
</dl> <p>If you need to distinguish between bound and unbound form instances at runtime, check the value of the form’s <a class="reference internal" href="#django.forms.Form.is_bound" title="django.forms.Form.is_bound"><code>is_bound</code></a> attribute:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm()
&gt;&gt;&gt; f.is_bound
False
&gt;&gt;&gt; f = ContactForm({'subject': 'hello'})
&gt;&gt;&gt; f.is_bound
True
</pre> <p>Note that passing an empty dictionary creates a <em>bound</em> form with empty data:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm({})
&gt;&gt;&gt; f.is_bound
True
</pre> <p>If you have a bound <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance and want to change the data somehow, or if you want to bind an unbound <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance to some data, create another <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance. There is no way to change data in a <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance. Once a <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance has been created, you should consider its data immutable, whether it has data or not.</p>   <h2 id="using-forms-to-validate-data">Using forms to validate data</h2> <dl class="method" id="s-using-forms-to-validate-data"> <dt id="django.forms.Form.clean">
<code>Form.clean()</code> </dt> 
</dl> <p>Implement a <code>clean()</code> method on your <code>Form</code> when you must add custom validation for fields that are interdependent. See <a class="reference internal" href="validation#validating-fields-with-clean"><span class="std std-ref">Cleaning and validating fields that depend on each other</span></a> for example usage.</p> <dl class="method"> <dt id="django.forms.Form.is_valid">
<code>Form.is_valid()</code> </dt> 
</dl> <p>The primary task of a <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> object is to validate data. With a bound <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance, call the <a class="reference internal" href="#django.forms.Form.is_valid" title="django.forms.Form.is_valid"><code>is_valid()</code></a> method to run validation and return a boolean designating whether the data was valid:</p> <pre data-language="python">&gt;&gt;&gt; data = {'subject': 'hello',
...         'message': 'Hi there',
...         'sender': 'foo@example.com',
...         'cc_myself': True}
&gt;&gt;&gt; f = ContactForm(data)
&gt;&gt;&gt; f.is_valid()
True
</pre> <p>Let’s try with some invalid data. In this case, <code>subject</code> is blank (an error, because all fields are required by default) and <code>sender</code> is not a valid email address:</p> <pre data-language="python">&gt;&gt;&gt; data = {'subject': '',
...         'message': 'Hi there',
...         'sender': 'invalid email address',
...         'cc_myself': True}
&gt;&gt;&gt; f = ContactForm(data)
&gt;&gt;&gt; f.is_valid()
False
</pre> <dl class="attribute"> <dt id="django.forms.Form.errors">
<code>Form.errors</code> </dt> 
</dl> <p>Access the <a class="reference internal" href="#django.forms.Form.errors" title="django.forms.Form.errors"><code>errors</code></a> attribute to get a dictionary of error messages:</p> <pre data-language="python">&gt;&gt;&gt; f.errors
{'sender': ['Enter a valid email address.'], 'subject': ['This field is required.']}
</pre> <p>In this dictionary, the keys are the field names, and the values are lists of strings representing the error messages. The error messages are stored in lists because a field can have multiple error messages.</p> <p>You can access <a class="reference internal" href="#django.forms.Form.errors" title="django.forms.Form.errors"><code>errors</code></a> without having to call <a class="reference internal" href="#django.forms.Form.is_valid" title="django.forms.Form.is_valid"><code>is_valid()</code></a> first. The form’s data will be validated the first time either you call <a class="reference internal" href="#django.forms.Form.is_valid" title="django.forms.Form.is_valid"><code>is_valid()</code></a> or access <a class="reference internal" href="#django.forms.Form.errors" title="django.forms.Form.errors"><code>errors</code></a>.</p> <p>The validation routines will only get called once, regardless of how many times you access <a class="reference internal" href="#django.forms.Form.errors" title="django.forms.Form.errors"><code>errors</code></a> or call <a class="reference internal" href="#django.forms.Form.is_valid" title="django.forms.Form.is_valid"><code>is_valid()</code></a>. This means that if validation has side effects, those side effects will only be triggered once.</p> <dl class="method"> <dt id="django.forms.Form.errors.as_data">
<code>Form.errors.as_data()</code> </dt> 
</dl> <p>Returns a <code>dict</code> that maps fields to their original <code>ValidationError</code> instances.</p> <pre data-language="python">&gt;&gt;&gt; f.errors.as_data()
{'sender': [ValidationError(['Enter a valid email address.'])],
'subject': [ValidationError(['This field is required.'])]}
</pre> <p>Use this method anytime you need to identify an error by its <code>code</code>. This enables things like rewriting the error’s message or writing custom logic in a view when a given error is present. It can also be used to serialize the errors in a custom format (e.g. XML); for instance, <a class="reference internal" href="#django.forms.Form.errors.as_json" title="django.forms.Form.errors.as_json"><code>as_json()</code></a> relies on <code>as_data()</code>.</p> <p>The need for the <code>as_data()</code> method is due to backwards compatibility. Previously <code>ValidationError</code> instances were lost as soon as their <strong>rendered</strong> error messages were added to the <code>Form.errors</code> dictionary. Ideally <code>Form.errors</code> would have stored <code>ValidationError</code> instances and methods with an <code>as_</code> prefix could render them, but it had to be done the other way around in order not to break code that expects rendered error messages in <code>Form.errors</code>.</p> <dl class="method"> <dt id="django.forms.Form.errors.as_json">
<code>Form.errors.as_json(escape_html=False)</code> </dt> 
</dl> <p>Returns the errors serialized as JSON.</p> <pre data-language="python">&gt;&gt;&gt; f.errors.as_json()
{"sender": [{"message": "Enter a valid email address.", "code": "invalid"}],
"subject": [{"message": "This field is required.", "code": "required"}]}
</pre> <p>By default, <code>as_json()</code> does not escape its output. If you are using it for something like AJAX requests to a form view where the client interprets the response and inserts errors into the page, you’ll want to be sure to escape the results on the client-side to avoid the possibility of a cross-site scripting attack. You can do this in JavaScript with <code>element.textContent = errorText</code> or with jQuery’s <code>$(el).text(errorText)</code> (rather than its <code>.html()</code> function).</p> <p>If for some reason you don’t want to use client-side escaping, you can also set <code>escape_html=True</code> and error messages will be escaped so you can use them directly in HTML.</p> <dl class="method"> <dt id="django.forms.Form.errors.get_json_data">
<code>Form.errors.get_json_data(escape_html=False)</code> </dt> 
</dl> <p>Returns the errors as a dictionary suitable for serializing to JSON. <a class="reference internal" href="#django.forms.Form.errors.as_json" title="django.forms.Form.errors.as_json"><code>Form.errors.as_json()</code></a> returns serialized JSON, while this returns the error data before it’s serialized.</p> <p>The <code>escape_html</code> parameter behaves as described in <a class="reference internal" href="#django.forms.Form.errors.as_json" title="django.forms.Form.errors.as_json"><code>Form.errors.as_json()</code></a>.</p> <dl class="method"> <dt id="django.forms.Form.add_error">
<code>Form.add_error(field, error)</code> </dt> 
</dl> <p>This method allows adding errors to specific fields from within the <code>Form.clean()</code> method, or from outside the form altogether; for instance from a view.</p> <p>The <code>field</code> argument is the name of the field to which the errors should be added. If its value is <code>None</code> the error will be treated as a non-field error as returned by <a class="reference internal" href="#django.forms.Form.non_field_errors" title="django.forms.Form.non_field_errors"><code>Form.non_field_errors()</code></a>.</p> <p>The <code>error</code> argument can be a string, or preferably an instance of <code>ValidationError</code>. See <a class="reference internal" href="validation#raising-validation-error"><span class="std std-ref">Raising ValidationError</span></a> for best practices when defining form errors.</p> <p>Note that <code>Form.add_error()</code> automatically removes the relevant field from <code>cleaned_data</code>.</p> <dl class="method"> <dt id="django.forms.Form.has_error">
<code>Form.has_error(field, code=None)</code> </dt> 
</dl> <p>This method returns a boolean designating whether a field has an error with a specific error <code>code</code>. If <code>code</code> is <code>None</code>, it will return <code>True</code> if the field contains any errors at all.</p> <p>To check for non-field errors use <a class="reference internal" href="../exceptions#django.core.exceptions.NON_FIELD_ERRORS" title="django.core.exceptions.NON_FIELD_ERRORS"><code>NON_FIELD_ERRORS</code></a> as the <code>field</code> parameter.</p> <dl class="method"> <dt id="django.forms.Form.non_field_errors">
<code>Form.non_field_errors()</code> </dt> 
</dl> <p>This method returns the list of errors from <a class="reference internal" href="#django.forms.Form.errors" title="django.forms.Form.errors"><code>Form.errors</code></a> that aren’t associated with a particular field. This includes <code>ValidationError</code>s that are raised in <a class="reference internal" href="#django.forms.Form.clean" title="django.forms.Form.clean"><code>Form.clean()</code></a> and errors added using <a class="reference internal" href="#django.forms.Form.add_error" title="django.forms.Form.add_error"><code>Form.add_error(None,
"...")</code></a>.</p>  <h3 id="behavior-of-unbound-forms">Behavior of unbound forms</h3> <p id="s-behavior-of-unbound-forms">It’s meaningless to validate a form with no data, but, for the record, here’s what happens with unbound forms:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm()
&gt;&gt;&gt; f.is_valid()
False
&gt;&gt;&gt; f.errors
{}
</pre>    <h2 id="ref-forms-initial-form-values">Initial form values</h2> <dl class="attribute" id="s-initial-form-values"> <dt id="django.forms.Form.initial">
<code>Form.initial</code> </dt> 
</dl> <p>Use <a class="reference internal" href="#django.forms.Form.initial" title="django.forms.Form.initial"><code>initial</code></a> to declare the initial value of form fields at runtime. For example, you might want to fill in a <code>username</code> field with the username of the current session.</p> <p>To accomplish this, use the <a class="reference internal" href="#django.forms.Form.initial" title="django.forms.Form.initial"><code>initial</code></a> argument to a <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a>. This argument, if given, should be a dictionary mapping field names to initial values. Only include the fields for which you’re specifying an initial value; it’s not necessary to include every field in your form. For example:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm(initial={'subject': 'Hi there!'})
</pre> <p>These values are only displayed for unbound forms, and they’re not used as fallback values if a particular value isn’t provided.</p> <p>If a <a class="reference internal" href="fields#django.forms.Field" title="django.forms.Field"><code>Field</code></a> defines <a class="reference internal" href="fields#django.forms.Field.initial" title="django.forms.Field.initial"><code>initial</code></a> <em>and</em> you include <a class="reference internal" href="#django.forms.Form.initial" title="django.forms.Form.initial"><code>initial</code></a> when instantiating the <code>Form</code>, then the latter <code>initial</code> will have precedence. In this example, <code>initial</code> is provided both at the field level and at the form instance level, and the latter gets precedence:</p> <pre data-language="python">&gt;&gt;&gt; from django import forms
&gt;&gt;&gt; class CommentForm(forms.Form):
...     name = forms.CharField(initial='class')
...     url = forms.URLField()
...     comment = forms.CharField()
&gt;&gt;&gt; f = CommentForm(initial={'name': 'instance'}, auto_id=False)
&gt;&gt;&gt; print(f)
&lt;tr&gt;&lt;th&gt;Name:&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="name" value="instance" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Url:&lt;/th&gt;&lt;td&gt;&lt;input type="url" name="url" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Comment:&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="comment" required&gt;&lt;/td&gt;&lt;/tr&gt;
</pre> <dl class="method"> <dt id="django.forms.Form.get_initial_for_field">
<code>Form.get_initial_for_field(field, field_name)</code> </dt> 
</dl> <p>Returns the initial data for a form field. It retrieves the data from <a class="reference internal" href="#django.forms.Form.initial" title="django.forms.Form.initial"><code>Form.initial</code></a> if present, otherwise trying <a class="reference internal" href="fields#django.forms.Field.initial" title="django.forms.Field.initial"><code>Field.initial</code></a>. Callable values are evaluated.</p> <p>It is recommended to use <a class="reference internal" href="#django.forms.BoundField.initial" title="django.forms.BoundField.initial"><code>BoundField.initial</code></a> over <a class="reference internal" href="#django.forms.Form.get_initial_for_field" title="django.forms.Form.get_initial_for_field"><code>get_initial_for_field()</code></a> because <code>BoundField.initial</code> has a simpler interface. Also, unlike <a class="reference internal" href="#django.forms.Form.get_initial_for_field" title="django.forms.Form.get_initial_for_field"><code>get_initial_for_field()</code></a>, <a class="reference internal" href="#django.forms.BoundField.initial" title="django.forms.BoundField.initial"><code>BoundField.initial</code></a> caches its values. This is useful especially when dealing with callables whose return values can change (e.g. <code>datetime.now</code> or <code>uuid.uuid4</code>):</p> <pre data-language="python">&gt;&gt;&gt; import uuid
&gt;&gt;&gt; class UUIDCommentForm(CommentForm):
...     identifier = forms.UUIDField(initial=uuid.uuid4)
&gt;&gt;&gt; f = UUIDCommentForm()
&gt;&gt;&gt; f.get_initial_for_field(f.fields['identifier'], 'identifier')
UUID('972ca9e4-7bfe-4f5b-af7d-07b3aa306334')
&gt;&gt;&gt; f.get_initial_for_field(f.fields['identifier'], 'identifier')
UUID('1b411fab-844e-4dec-bd4f-e9b0495f04d0')
&gt;&gt;&gt; # Using BoundField.initial, for comparison
&gt;&gt;&gt; f['identifier'].initial
UUID('28a09c59-5f00-4ed9-9179-a3b074fa9c30')
&gt;&gt;&gt; f['identifier'].initial
UUID('28a09c59-5f00-4ed9-9179-a3b074fa9c30')
</pre>   <h2 id="checking-which-form-data-has-changed">Checking which form data has changed</h2> <dl class="method" id="s-checking-which-form-data-has-changed"> <dt id="django.forms.Form.has_changed">
<code>Form.has_changed()</code> </dt> 
</dl> <p>Use the <code>has_changed()</code> method on your <code>Form</code> when you need to check if the form data has been changed from the initial data.</p> <pre data-language="python">&gt;&gt;&gt; data = {'subject': 'hello',
...         'message': 'Hi there',
...         'sender': 'foo@example.com',
...         'cc_myself': True}
&gt;&gt;&gt; f = ContactForm(data, initial=data)
&gt;&gt;&gt; f.has_changed()
False
</pre> <p>When the form is submitted, we reconstruct it and provide the original data so that the comparison can be done:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm(request.POST, initial=data)
&gt;&gt;&gt; f.has_changed()
</pre> <p><code>has_changed()</code> will be <code>True</code> if the data from <code>request.POST</code> differs from what was provided in <a class="reference internal" href="#django.forms.Form.initial" title="django.forms.Form.initial"><code>initial</code></a> or <code>False</code> otherwise. The result is computed by calling <a class="reference internal" href="fields#django.forms.Field.has_changed" title="django.forms.Field.has_changed"><code>Field.has_changed()</code></a> for each field in the form.</p> <dl class="attribute"> <dt id="django.forms.Form.changed_data">
<code>Form.changed_data</code> </dt> 
</dl> <p>The <code>changed_data</code> attribute returns a list of the names of the fields whose values in the form’s bound data (usually <code>request.POST</code>) differ from what was provided in <a class="reference internal" href="#django.forms.Form.initial" title="django.forms.Form.initial"><code>initial</code></a>. It returns an empty list if no data differs.</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm(request.POST, initial=data)
&gt;&gt;&gt; if f.has_changed():
...     print("The following fields changed: %s" % ", ".join(f.changed_data))
&gt;&gt;&gt; f.changed_data
['subject', 'message']
</pre>   <h2 id="accessing-the-fields-from-the-form">Accessing the fields from the form</h2> <dl class="attribute" id="s-accessing-the-fields-from-the-form"> <dt id="django.forms.Form.fields">
<code>Form.fields</code> </dt> 
</dl> <p>You can access the fields of <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance from its <code>fields</code> attribute:</p> <pre data-language="python">&gt;&gt;&gt; for row in f.fields.values(): print(row)
...
&lt;django.forms.fields.CharField object at 0x7ffaac632510&gt;
&lt;django.forms.fields.URLField object at 0x7ffaac632f90&gt;
&lt;django.forms.fields.CharField object at 0x7ffaac3aa050&gt;
&gt;&gt;&gt; f.fields['name']
&lt;django.forms.fields.CharField object at 0x7ffaac6324d0&gt;
</pre> <p>You can alter the field of <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance to change the way it is presented in the form:</p> <pre data-language="python">&gt;&gt;&gt; f.as_table().split('\n')[0]
'&lt;tr&gt;&lt;th&gt;Name:&lt;/th&gt;&lt;td&gt;&lt;input name="name" type="text" value="instance" required&gt;&lt;/td&gt;&lt;/tr&gt;'
&gt;&gt;&gt; f.fields['name'].label = "Username"
&gt;&gt;&gt; f.as_table().split('\n')[0]
'&lt;tr&gt;&lt;th&gt;Username:&lt;/th&gt;&lt;td&gt;&lt;input name="name" type="text" value="instance" required&gt;&lt;/td&gt;&lt;/tr&gt;'
</pre> <p>Beware not to alter the <code>base_fields</code> attribute because this modification will influence all subsequent <code>ContactForm</code> instances within the same Python process:</p> <pre data-language="python">&gt;&gt;&gt; f.base_fields['name'].label = "Username"
&gt;&gt;&gt; another_f = CommentForm(auto_id=False)
&gt;&gt;&gt; another_f.as_table().split('\n')[0]
'&lt;tr&gt;&lt;th&gt;Username:&lt;/th&gt;&lt;td&gt;&lt;input name="name" type="text" value="class" required&gt;&lt;/td&gt;&lt;/tr&gt;'
</pre>   <h2 id="accessing-clean-data">Accessing “clean” data</h2> <dl class="attribute" id="s-accessing-clean-data"> <dt id="django.forms.Form.cleaned_data">
<code>Form.cleaned_data</code> </dt> 
</dl> <p>Each field in a <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> class is responsible not only for validating data, but also for “cleaning” it – normalizing it to a consistent format. This is a nice feature, because it allows data for a particular field to be input in a variety of ways, always resulting in consistent output.</p> <p>For example, <a class="reference internal" href="fields#django.forms.DateField" title="django.forms.DateField"><code>DateField</code></a> normalizes input into a Python <code>datetime.date</code> object. Regardless of whether you pass it a string in the format <code>'1994-07-15'</code>, a <code>datetime.date</code> object, or a number of other formats, <code>DateField</code> will always normalize it to a <code>datetime.date</code> object as long as it’s valid.</p> <p>Once you’ve created a <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance with a set of data and validated it, you can access the clean data via its <code>cleaned_data</code> attribute:</p> <pre data-language="python">&gt;&gt;&gt; data = {'subject': 'hello',
...         'message': 'Hi there',
...         'sender': 'foo@example.com',
...         'cc_myself': True}
&gt;&gt;&gt; f = ContactForm(data)
&gt;&gt;&gt; f.is_valid()
True
&gt;&gt;&gt; f.cleaned_data
{'cc_myself': True, 'message': 'Hi there', 'sender': 'foo@example.com', 'subject': 'hello'}
</pre> <p>Note that any text-based field – such as <code>CharField</code> or <code>EmailField</code> – always cleans the input into a string. We’ll cover the encoding implications later in this document.</p> <p>If your data does <em>not</em> validate, the <code>cleaned_data</code> dictionary contains only the valid fields:</p> <pre data-language="python">&gt;&gt;&gt; data = {'subject': '',
...         'message': 'Hi there',
...         'sender': 'invalid email address',
...         'cc_myself': True}
&gt;&gt;&gt; f = ContactForm(data)
&gt;&gt;&gt; f.is_valid()
False
&gt;&gt;&gt; f.cleaned_data
{'cc_myself': True, 'message': 'Hi there'}
</pre> <p><code>cleaned_data</code> will always <em>only</em> contain a key for fields defined in the <code>Form</code>, even if you pass extra data when you define the <code>Form</code>. In this example, we pass a bunch of extra fields to the <code>ContactForm</code> constructor, but <code>cleaned_data</code> contains only the form’s fields:</p> <pre data-language="python">&gt;&gt;&gt; data = {'subject': 'hello',
...         'message': 'Hi there',
...         'sender': 'foo@example.com',
...         'cc_myself': True,
...         'extra_field_1': 'foo',
...         'extra_field_2': 'bar',
...         'extra_field_3': 'baz'}
&gt;&gt;&gt; f = ContactForm(data)
&gt;&gt;&gt; f.is_valid()
True
&gt;&gt;&gt; f.cleaned_data # Doesn't contain extra_field_1, etc.
{'cc_myself': True, 'message': 'Hi there', 'sender': 'foo@example.com', 'subject': 'hello'}
</pre> <p>When the <code>Form</code> is valid, <code>cleaned_data</code> will include a key and value for <em>all</em> its fields, even if the data didn’t include a value for some optional fields. In this example, the data dictionary doesn’t include a value for the <code>nick_name</code> field, but <code>cleaned_data</code> includes it, with an empty value:</p> <pre data-language="python">&gt;&gt;&gt; from django import forms
&gt;&gt;&gt; class OptionalPersonForm(forms.Form):
...     first_name = forms.CharField()
...     last_name = forms.CharField()
...     nick_name = forms.CharField(required=False)
&gt;&gt;&gt; data = {'first_name': 'John', 'last_name': 'Lennon'}
&gt;&gt;&gt; f = OptionalPersonForm(data)
&gt;&gt;&gt; f.is_valid()
True
&gt;&gt;&gt; f.cleaned_data
{'nick_name': '', 'first_name': 'John', 'last_name': 'Lennon'}
</pre> <p>In this above example, the <code>cleaned_data</code> value for <code>nick_name</code> is set to an empty string, because <code>nick_name</code> is <code>CharField</code>, and <code>CharField</code>s treat empty values as an empty string. Each field type knows what its “blank” value is – e.g., for <code>DateField</code>, it’s <code>None</code> instead of the empty string. For full details on each field’s behavior in this case, see the “Empty value” note for each field in the “Built-in <code>Field</code> classes” section below.</p> <p>You can write code to perform validation for particular form fields (based on their name) or for the form as a whole (considering combinations of various fields). More information about this is in <a class="reference internal" href="validation"><span class="doc">Form and field validation</span></a>.</p>   <h2 id="ref-forms-api-outputting-html">Outputting forms as HTML</h2> <p id="s-outputting-forms-as-html">The second task of a <code>Form</code> object is to render itself as HTML. To do so, <code>print</code> it:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm()
&gt;&gt;&gt; print(f)
&lt;tr&gt;&lt;th&gt;&lt;label for="id_subject"&gt;Subject:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input id="id_subject" type="text" name="subject" maxlength="100" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;&lt;label for="id_message"&gt;Message:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="message" id="id_message" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;&lt;label for="id_sender"&gt;Sender:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="email" name="sender" id="id_sender" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;&lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="checkbox" name="cc_myself" id="id_cc_myself"&gt;&lt;/td&gt;&lt;/tr&gt;
</pre> <p>If the form is bound to data, the HTML output will include that data appropriately. For example, if a field is represented by an <code>&lt;input type="text"&gt;</code>, the data will be in the <code>value</code> attribute. If a field is represented by an <code>&lt;input type="checkbox"&gt;</code>, then that HTML will include <code>checked</code> if appropriate:</p> <pre data-language="python">&gt;&gt;&gt; data = {'subject': 'hello',
...         'message': 'Hi there',
...         'sender': 'foo@example.com',
...         'cc_myself': True}
&gt;&gt;&gt; f = ContactForm(data)
&gt;&gt;&gt; print(f)
&lt;tr&gt;&lt;th&gt;&lt;label for="id_subject"&gt;Subject:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input id="id_subject" type="text" name="subject" maxlength="100" value="hello" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;&lt;label for="id_message"&gt;Message:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="message" id="id_message" value="Hi there" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;&lt;label for="id_sender"&gt;Sender:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="email" name="sender" id="id_sender" value="foo@example.com" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;&lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="checkbox" name="cc_myself" id="id_cc_myself" checked&gt;&lt;/td&gt;&lt;/tr&gt;
</pre> <p>This default output is a two-column HTML table, with a <code>&lt;tr&gt;</code> for each field. Notice the following:</p> <ul class="simple"> <li>For flexibility, the output does <em>not</em> include the <code>&lt;table&gt;</code> and <code>&lt;/table&gt;</code> tags, nor does it include the <code>&lt;form&gt;</code> and <code>&lt;/form&gt;</code> tags or an <code>&lt;input type="submit"&gt;</code> tag. It’s your job to do that.</li> <li>Each field type has a default HTML representation. <code>CharField</code> is represented by an <code>&lt;input type="text"&gt;</code> and <code>EmailField</code> by an <code>&lt;input type="email"&gt;</code>. <code>BooleanField(null=False)</code> is represented by an <code>&lt;input type="checkbox"&gt;</code>. Note these are merely sensible defaults; you can specify which HTML to use for a given field by using widgets, which we’ll explain shortly.</li> <li>The HTML <code>name</code> for each tag is taken directly from its attribute name in the <code>ContactForm</code> class.</li> <li>The text label for each field – e.g. <code>'Subject:'</code>, <code>'Message:'</code> and <code>'Cc myself:'</code> is generated from the field name by converting all underscores to spaces and upper-casing the first letter. Again, note these are merely sensible defaults; you can also specify labels manually.</li> <li>Each text label is surrounded in an HTML <code>&lt;label&gt;</code> tag, which points to the appropriate form field via its <code>id</code>. Its <code>id</code>, in turn, is generated by prepending <code>'id_'</code> to the field name. The <code>id</code> attributes and <code>&lt;label&gt;</code> tags are included in the output by default, to follow best practices, but you can change that behavior.</li> <li>The output uses HTML5 syntax, targeting <code>&lt;!DOCTYPE html&gt;</code>. For example, it uses boolean attributes such as <code>checked</code> rather than the XHTML style of <code>checked='checked'</code>.</li> </ul> <p>Although <code>&lt;table&gt;</code> output is the default output style when you <code>print</code> a form, other output styles are available. Each style is available as a method on a form object, and each rendering method returns a string.</p>  <h3 id="template-name"><code>template_name</code></h3> <div class="versionadded" id="s-template-name"> <span class="title">New in Django 4.0.</span> </div> <dl class="attribute"> <dt id="django.forms.Form.template_name">
<code>Form.template_name</code> </dt> 
</dl> <p>The name of a template that is going to be rendered if the form is cast into a string, e.g. via <code>print(form)</code> or in a template via <code>{{ form }}</code>. By default this template is <code>'django/forms/default.html'</code>, which is a proxy for <code>'django/forms/table.html'</code>. The template can be changed per form by overriding the <code>template_name</code> attribute or more generally by overriding the default template, see also <a class="reference internal" href="renderers#overriding-built-in-form-templates"><span class="std std-ref">Overriding built-in form templates</span></a>.</p>   <h3 id="template-name-label"><code>template_name_label</code></h3> <div class="versionadded" id="s-template-name-label"> <span class="title">New in Django 4.0.</span> </div> <dl class="attribute"> <dt id="django.forms.Form.template_name_label">
<code>Form.template_name_label</code> </dt> 
</dl> <p>The template used to render a field’s <code>&lt;label&gt;</code>, used when calling <a class="reference internal" href="#django.forms.BoundField.label_tag" title="django.forms.BoundField.label_tag"><code>BoundField.label_tag()</code></a>. Can be changed per form by overriding this attribute or more generally by overriding the default template, see also <a class="reference internal" href="renderers#overriding-built-in-form-templates"><span class="std std-ref">Overriding built-in form templates</span></a>.</p>   <h3 id="as-p"><code>as_p()</code></h3> <dl class="method" id="s-as-p"> <dt id="django.forms.Form.as_p">
<code>Form.as_p()</code> </dt> 
</dl> <p><code>as_p()</code> renders the form using the template assigned to the forms <code>template_name_p</code> attribute, by default this template is <code>'django/forms/p.html'</code>. This template renders the form as a series of <code>&lt;p&gt;</code> tags, with each <code>&lt;p&gt;</code> containing one field:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm()
&gt;&gt;&gt; f.as_p()
'&lt;p&gt;&lt;label for="id_subject"&gt;Subject:&lt;/label&gt; &lt;input id="id_subject" type="text" name="subject" maxlength="100" required&gt;&lt;/p&gt;\n&lt;p&gt;&lt;label for="id_message"&gt;Message:&lt;/label&gt; &lt;input type="text" name="message" id="id_message" required&gt;&lt;/p&gt;\n&lt;p&gt;&lt;label for="id_sender"&gt;Sender:&lt;/label&gt; &lt;input type="text" name="sender" id="id_sender" required&gt;&lt;/p&gt;\n&lt;p&gt;&lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt; &lt;input type="checkbox" name="cc_myself" id="id_cc_myself"&gt;&lt;/p&gt;'
&gt;&gt;&gt; print(f.as_p())
&lt;p&gt;&lt;label for="id_subject"&gt;Subject:&lt;/label&gt; &lt;input id="id_subject" type="text" name="subject" maxlength="100" required&gt;&lt;/p&gt;
&lt;p&gt;&lt;label for="id_message"&gt;Message:&lt;/label&gt; &lt;input type="text" name="message" id="id_message" required&gt;&lt;/p&gt;
&lt;p&gt;&lt;label for="id_sender"&gt;Sender:&lt;/label&gt; &lt;input type="email" name="sender" id="id_sender" required&gt;&lt;/p&gt;
&lt;p&gt;&lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt; &lt;input type="checkbox" name="cc_myself" id="id_cc_myself"&gt;&lt;/p&gt;
</pre>   <h3 id="as-ul"><code>as_ul()</code></h3> <dl class="method" id="s-as-ul"> <dt id="django.forms.Form.as_ul">
<code>Form.as_ul()</code> </dt> 
</dl> <p><code>as_ul()</code> renders the form using the template assigned to the forms <code>template_name_ul</code> attribute, by default this template is <code>'django/forms/ul.html'</code>. This template renders the form as a series of <code>&lt;li&gt;</code> tags, with each <code>&lt;li&gt;</code> containing one field. It does <em>not</em> include the <code>&lt;ul&gt;</code> or <code>&lt;/ul&gt;</code>, so that you can specify any HTML attributes on the <code>&lt;ul&gt;</code> for flexibility:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm()
&gt;&gt;&gt; f.as_ul()
'&lt;li&gt;&lt;label for="id_subject"&gt;Subject:&lt;/label&gt; &lt;input id="id_subject" type="text" name="subject" maxlength="100" required&gt;&lt;/li&gt;\n&lt;li&gt;&lt;label for="id_message"&gt;Message:&lt;/label&gt; &lt;input type="text" name="message" id="id_message" required&gt;&lt;/li&gt;\n&lt;li&gt;&lt;label for="id_sender"&gt;Sender:&lt;/label&gt; &lt;input type="email" name="sender" id="id_sender" required&gt;&lt;/li&gt;\n&lt;li&gt;&lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt; &lt;input type="checkbox" name="cc_myself" id="id_cc_myself"&gt;&lt;/li&gt;'
&gt;&gt;&gt; print(f.as_ul())
&lt;li&gt;&lt;label for="id_subject"&gt;Subject:&lt;/label&gt; &lt;input id="id_subject" type="text" name="subject" maxlength="100" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="id_message"&gt;Message:&lt;/label&gt; &lt;input type="text" name="message" id="id_message" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="id_sender"&gt;Sender:&lt;/label&gt; &lt;input type="email" name="sender" id="id_sender" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt; &lt;input type="checkbox" name="cc_myself" id="id_cc_myself"&gt;&lt;/li&gt;
</pre>   <h3 id="as-table"><code>as_table()</code></h3> <dl class="method" id="s-as-table"> <dt id="django.forms.Form.as_table">
<code>Form.as_table()</code> </dt> 
</dl> <p>Finally, <code>as_table()</code> renders the form using the template assigned to the forms <code>template_name_table</code> attribute, by default this template is <code>'django/forms/table.html'</code>. This template outputs the form as an HTML <code>&lt;table&gt;</code>:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm()
&gt;&gt;&gt; f.as_table()
'&lt;tr&gt;&lt;th&gt;&lt;label for="id_subject"&gt;Subject:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input id="id_subject" type="text" name="subject" maxlength="100" required&gt;&lt;/td&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;th&gt;&lt;label for="id_message"&gt;Message:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="message" id="id_message" required&gt;&lt;/td&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;th&gt;&lt;label for="id_sender"&gt;Sender:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="email" name="sender" id="id_sender" required&gt;&lt;/td&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;th&gt;&lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="checkbox" name="cc_myself" id="id_cc_myself"&gt;&lt;/td&gt;&lt;/tr&gt;'
&gt;&gt;&gt; print(f)
&lt;tr&gt;&lt;th&gt;&lt;label for="id_subject"&gt;Subject:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input id="id_subject" type="text" name="subject" maxlength="100" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;&lt;label for="id_message"&gt;Message:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="message" id="id_message" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;&lt;label for="id_sender"&gt;Sender:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="email" name="sender" id="id_sender" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;&lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="checkbox" name="cc_myself" id="id_cc_myself"&gt;&lt;/td&gt;&lt;/tr&gt;
</pre>   <h3 id="get-context"><code>get_context()</code></h3> <div class="versionadded" id="s-get-context"> <span class="title">New in Django 4.0.</span> </div> <dl class="method"> <dt id="django.forms.Form.get_context">
<code>Form.get_context()</code> </dt> 
</dl> <p>Return context for form rendering in a template.</p> <p>The available context is:</p> <ul class="simple"> <li>
<code>form</code>: The bound form.</li> <li>
<code>fields</code>: All bound fields, except the hidden fields.</li> <li>
<code>hidden_fields</code>: All hidden bound fields.</li> <li>
<code>errors</code>: All non field related or hidden field related form errors.</li> </ul>   <h3 id="render"><code>render()</code></h3> <div class="versionadded" id="s-render"> <span class="title">New in Django 4.0.</span> </div> <dl class="method"> <dt id="django.forms.Form.render">
<code>Form.render(template_name=None, context=None, renderer=None)</code> </dt> 
</dl> <p>The render method is called by <code>__str__</code> as well as the <a class="reference internal" href="#django.forms.Form.as_table" title="django.forms.Form.as_table"><code>Form.as_table()</code></a>, <a class="reference internal" href="#django.forms.Form.as_p" title="django.forms.Form.as_p"><code>Form.as_p()</code></a>, and <a class="reference internal" href="#django.forms.Form.as_ul" title="django.forms.Form.as_ul"><code>Form.as_ul()</code></a> methods. All arguments are optional and default to:</p> <ul class="simple"> <li>
<code>template_name</code>: <a class="reference internal" href="#django.forms.Form.template_name" title="django.forms.Form.template_name"><code>Form.template_name</code></a>
</li> <li>
<code>context</code>: Value returned by <a class="reference internal" href="#django.forms.Form.get_context" title="django.forms.Form.get_context"><code>Form.get_context()</code></a>
</li> <li>
<code>renderer</code>: Value returned by <a class="reference internal" href="#django.forms.Form.default_renderer" title="django.forms.Form.default_renderer"><code>Form.default_renderer</code></a>
</li> </ul>   <h3 id="ref-forms-api-styling-form-rows">Styling required or erroneous form rows</h3> <dl class="attribute" id="s-styling-required-or-erroneous-form-rows"> <dt id="django.forms.Form.error_css_class">
<code>Form.error_css_class</code> </dt> 
</dl> <dl class="attribute"> <dt id="django.forms.Form.required_css_class">
<code>Form.required_css_class</code> </dt> 
</dl> <p>It’s pretty common to style form rows and fields that are required or have errors. For example, you might want to present required form rows in bold and highlight errors in red.</p> <p>The <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> class has a couple of hooks you can use to add <code>class</code> attributes to required rows or to rows with errors: set the <a class="reference internal" href="#django.forms.Form.error_css_class" title="django.forms.Form.error_css_class"><code>Form.error_css_class</code></a> and/or <a class="reference internal" href="#django.forms.Form.required_css_class" title="django.forms.Form.required_css_class"><code>Form.required_css_class</code></a> attributes:</p> <pre data-language="python">from django import forms

class ContactForm(forms.Form):
    error_css_class = 'error'
    required_css_class = 'required'

    # ... and the rest of your fields here
</pre> <p>Once you’ve done that, rows will be given <code>"error"</code> and/or <code>"required"</code> classes, as needed. The HTML will look something like:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm(data)
&gt;&gt;&gt; print(f.as_table())
&lt;tr class="required"&gt;&lt;th&gt;&lt;label class="required" for="id_subject"&gt;Subject:&lt;/label&gt;    ...
&lt;tr class="required"&gt;&lt;th&gt;&lt;label class="required" for="id_message"&gt;Message:&lt;/label&gt;    ...
&lt;tr class="required error"&gt;&lt;th&gt;&lt;label class="required" for="id_sender"&gt;Sender:&lt;/label&gt;      ...
&lt;tr&gt;&lt;th&gt;&lt;label for="id_cc_myself"&gt;Cc myself:&lt;label&gt; ...
&gt;&gt;&gt; f['subject'].label_tag()
&lt;label class="required" for="id_subject"&gt;Subject:&lt;/label&gt;
&gt;&gt;&gt; f['subject'].label_tag(attrs={'class': 'foo'})
&lt;label for="id_subject" class="foo required"&gt;Subject:&lt;/label&gt;
</pre>   <h3 id="ref-forms-api-configuring-label">Configuring form elements’ HTML <code>id</code> attributes and <code>&lt;label&gt;</code> tags</h3> <dl class="attribute" id="s-configuring-form-elements-html-id-attributes-and-label-tags"> <dt id="django.forms.Form.auto_id">
<code>Form.auto_id</code> </dt> 
</dl> <p>By default, the form rendering methods include:</p> <ul class="simple"> <li>HTML <code>id</code> attributes on the form elements.</li> <li>The corresponding <code>&lt;label&gt;</code> tags around the labels. An HTML <code>&lt;label&gt;</code> tag designates which label text is associated with which form element. This small enhancement makes forms more usable and more accessible to assistive devices. It’s always a good idea to use <code>&lt;label&gt;</code> tags.</li> </ul> <p>The <code>id</code> attribute values are generated by prepending <code>id_</code> to the form field names. This behavior is configurable, though, if you want to change the <code>id</code> convention or remove HTML <code>id</code> attributes and <code>&lt;label&gt;</code> tags entirely.</p> <p>Use the <code>auto_id</code> argument to the <code>Form</code> constructor to control the <code>id</code> and label behavior. This argument must be <code>True</code>, <code>False</code> or a string.</p> <p>If <code>auto_id</code> is <code>False</code>, then the form output will not include <code>&lt;label&gt;</code> tags nor <code>id</code> attributes:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm(auto_id=False)
&gt;&gt;&gt; print(f.as_table())
&lt;tr&gt;&lt;th&gt;Subject:&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="subject" maxlength="100" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Message:&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="message" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Sender:&lt;/th&gt;&lt;td&gt;&lt;input type="email" name="sender" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Cc myself:&lt;/th&gt;&lt;td&gt;&lt;input type="checkbox" name="cc_myself"&gt;&lt;/td&gt;&lt;/tr&gt;
&gt;&gt;&gt; print(f.as_ul())
&lt;li&gt;Subject: &lt;input type="text" name="subject" maxlength="100" required&gt;&lt;/li&gt;
&lt;li&gt;Message: &lt;input type="text" name="message" required&gt;&lt;/li&gt;
&lt;li&gt;Sender: &lt;input type="email" name="sender" required&gt;&lt;/li&gt;
&lt;li&gt;Cc myself: &lt;input type="checkbox" name="cc_myself"&gt;&lt;/li&gt;
&gt;&gt;&gt; print(f.as_p())
&lt;p&gt;Subject: &lt;input type="text" name="subject" maxlength="100" required&gt;&lt;/p&gt;
&lt;p&gt;Message: &lt;input type="text" name="message" required&gt;&lt;/p&gt;
&lt;p&gt;Sender: &lt;input type="email" name="sender" required&gt;&lt;/p&gt;
&lt;p&gt;Cc myself: &lt;input type="checkbox" name="cc_myself"&gt;&lt;/p&gt;
</pre> <p>If <code>auto_id</code> is set to <code>True</code>, then the form output <em>will</em> include <code>&lt;label&gt;</code> tags and will use the field name as its <code>id</code> for each form field:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm(auto_id=True)
&gt;&gt;&gt; print(f.as_table())
&lt;tr&gt;&lt;th&gt;&lt;label for="subject"&gt;Subject:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input id="subject" type="text" name="subject" maxlength="100" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;&lt;label for="message"&gt;Message:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="message" id="message" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;&lt;label for="sender"&gt;Sender:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="email" name="sender" id="sender" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;&lt;label for="cc_myself"&gt;Cc myself:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="checkbox" name="cc_myself" id="cc_myself"&gt;&lt;/td&gt;&lt;/tr&gt;
&gt;&gt;&gt; print(f.as_ul())
&lt;li&gt;&lt;label for="subject"&gt;Subject:&lt;/label&gt; &lt;input id="subject" type="text" name="subject" maxlength="100" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="message"&gt;Message:&lt;/label&gt; &lt;input type="text" name="message" id="message" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="sender"&gt;Sender:&lt;/label&gt; &lt;input type="email" name="sender" id="sender" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="cc_myself"&gt;Cc myself:&lt;/label&gt; &lt;input type="checkbox" name="cc_myself" id="cc_myself"&gt;&lt;/li&gt;
&gt;&gt;&gt; print(f.as_p())
&lt;p&gt;&lt;label for="subject"&gt;Subject:&lt;/label&gt; &lt;input id="subject" type="text" name="subject" maxlength="100" required&gt;&lt;/p&gt;
&lt;p&gt;&lt;label for="message"&gt;Message:&lt;/label&gt; &lt;input type="text" name="message" id="message" required&gt;&lt;/p&gt;
&lt;p&gt;&lt;label for="sender"&gt;Sender:&lt;/label&gt; &lt;input type="email" name="sender" id="sender" required&gt;&lt;/p&gt;
&lt;p&gt;&lt;label for="cc_myself"&gt;Cc myself:&lt;/label&gt; &lt;input type="checkbox" name="cc_myself" id="cc_myself"&gt;&lt;/p&gt;
</pre> <p>If <code>auto_id</code> is set to a string containing the format character <code>'%s'</code>, then the form output will include <code>&lt;label&gt;</code> tags, and will generate <code>id</code> attributes based on the format string. For example, for a format string <code>'field_%s'</code>, a field named <code>subject</code> will get the <code>id</code> value <code>'field_subject'</code>. Continuing our example:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm(auto_id='id_for_%s')
&gt;&gt;&gt; print(f.as_table())
&lt;tr&gt;&lt;th&gt;&lt;label for="id_for_subject"&gt;Subject:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input id="id_for_subject" type="text" name="subject" maxlength="100" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;&lt;label for="id_for_message"&gt;Message:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="message" id="id_for_message" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;&lt;label for="id_for_sender"&gt;Sender:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="email" name="sender" id="id_for_sender" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;&lt;label for="id_for_cc_myself"&gt;Cc myself:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="checkbox" name="cc_myself" id="id_for_cc_myself"&gt;&lt;/td&gt;&lt;/tr&gt;
&gt;&gt;&gt; print(f.as_ul())
&lt;li&gt;&lt;label for="id_for_subject"&gt;Subject:&lt;/label&gt; &lt;input id="id_for_subject" type="text" name="subject" maxlength="100" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="id_for_message"&gt;Message:&lt;/label&gt; &lt;input type="text" name="message" id="id_for_message" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="id_for_sender"&gt;Sender:&lt;/label&gt; &lt;input type="email" name="sender" id="id_for_sender" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="id_for_cc_myself"&gt;Cc myself:&lt;/label&gt; &lt;input type="checkbox" name="cc_myself" id="id_for_cc_myself"&gt;&lt;/li&gt;
&gt;&gt;&gt; print(f.as_p())
&lt;p&gt;&lt;label for="id_for_subject"&gt;Subject:&lt;/label&gt; &lt;input id="id_for_subject" type="text" name="subject" maxlength="100" required&gt;&lt;/p&gt;
&lt;p&gt;&lt;label for="id_for_message"&gt;Message:&lt;/label&gt; &lt;input type="text" name="message" id="id_for_message" required&gt;&lt;/p&gt;
&lt;p&gt;&lt;label for="id_for_sender"&gt;Sender:&lt;/label&gt; &lt;input type="email" name="sender" id="id_for_sender" required&gt;&lt;/p&gt;
&lt;p&gt;&lt;label for="id_for_cc_myself"&gt;Cc myself:&lt;/label&gt; &lt;input type="checkbox" name="cc_myself" id="id_for_cc_myself"&gt;&lt;/p&gt;
</pre> <p>If <code>auto_id</code> is set to any other true value – such as a string that doesn’t include <code>%s</code> – then the library will act as if <code>auto_id</code> is <code>True</code>.</p> <p>By default, <code>auto_id</code> is set to the string <code>'id_%s'</code>.</p> <dl class="attribute"> <dt id="django.forms.Form.label_suffix">
<code>Form.label_suffix</code> </dt> 
</dl> <p>A translatable string (defaults to a colon (<code>:</code>) in English) that will be appended after any label name when a form is rendered.</p> <p>It’s possible to customize that character, or omit it entirely, using the <code>label_suffix</code> parameter:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm(auto_id='id_for_%s', label_suffix='')
&gt;&gt;&gt; print(f.as_ul())
&lt;li&gt;&lt;label for="id_for_subject"&gt;Subject&lt;/label&gt; &lt;input id="id_for_subject" type="text" name="subject" maxlength="100" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="id_for_message"&gt;Message&lt;/label&gt; &lt;input type="text" name="message" id="id_for_message" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="id_for_sender"&gt;Sender&lt;/label&gt; &lt;input type="email" name="sender" id="id_for_sender" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="id_for_cc_myself"&gt;Cc myself&lt;/label&gt; &lt;input type="checkbox" name="cc_myself" id="id_for_cc_myself"&gt;&lt;/li&gt;
&gt;&gt;&gt; f = ContactForm(auto_id='id_for_%s', label_suffix=' -&gt;')
&gt;&gt;&gt; print(f.as_ul())
&lt;li&gt;&lt;label for="id_for_subject"&gt;Subject -&gt;&lt;/label&gt; &lt;input id="id_for_subject" type="text" name="subject" maxlength="100" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="id_for_message"&gt;Message -&gt;&lt;/label&gt; &lt;input type="text" name="message" id="id_for_message" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="id_for_sender"&gt;Sender -&gt;&lt;/label&gt; &lt;input type="email" name="sender" id="id_for_sender" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="id_for_cc_myself"&gt;Cc myself -&gt;&lt;/label&gt; &lt;input type="checkbox" name="cc_myself" id="id_for_cc_myself"&gt;&lt;/li&gt;
</pre> <p>Note that the label suffix is added only if the last character of the label isn’t a punctuation character (in English, those are <code>.</code>, <code>!</code>, <code>?</code> or <code>:</code>).</p> <p>Fields can also define their own <a class="reference internal" href="fields#django.forms.Field.label_suffix" title="django.forms.Field.label_suffix"><code>label_suffix</code></a>. This will take precedence over <a class="reference internal" href="#django.forms.Form.label_suffix" title="django.forms.Form.label_suffix"><code>Form.label_suffix</code></a>. The suffix can also be overridden at runtime using the <code>label_suffix</code> parameter to <a class="reference internal" href="#django.forms.BoundField.label_tag" title="django.forms.BoundField.label_tag"><code>label_tag()</code></a>.</p> <dl class="attribute"> <dt id="django.forms.Form.use_required_attribute">
<code>Form.use_required_attribute</code> </dt> 
</dl> <p>When set to <code>True</code> (the default), required form fields will have the <code>required</code> HTML attribute.</p> <p><a class="reference internal" href="../../topics/forms/formsets"><span class="doc">Formsets</span></a> instantiate forms with <code>use_required_attribute=False</code> to avoid incorrect browser validation when adding and deleting forms from a formset.</p>   <h3 id="configuring-the-rendering-of-a-form-s-widgets">Configuring the rendering of a form’s widgets</h3> <dl class="attribute" id="s-configuring-the-rendering-of-a-form-s-widgets"> <dt id="django.forms.Form.default_renderer">
<code>Form.default_renderer</code> </dt> 
</dl> <p>Specifies the <a class="reference internal" href="renderers"><span class="doc">renderer</span></a> to use for the form. Defaults to <code>None</code> which means to use the default renderer specified by the <a class="reference internal" href="../settings#std:setting-FORM_RENDERER"><code>FORM_RENDERER</code></a> setting.</p> <p>You can set this as a class attribute when declaring your form or use the <code>renderer</code> argument to <code>Form.__init__()</code>. For example:</p> <pre data-language="python">from django import forms

class MyForm(forms.Form):
    default_renderer = MyRenderer()
</pre> <p>or:</p> <pre data-language="python">form = MyForm(renderer=MyRenderer())
</pre>   <h3 id="notes-on-field-ordering">Notes on field ordering</h3> <p id="s-notes-on-field-ordering">In the <code>as_p()</code>, <code>as_ul()</code> and <code>as_table()</code> shortcuts, the fields are displayed in the order in which you define them in your form class. For example, in the <code>ContactForm</code> example, the fields are defined in the order <code>subject</code>, <code>message</code>, <code>sender</code>, <code>cc_myself</code>. To reorder the HTML output, change the order in which those fields are listed in the class.</p> <p>There are several other ways to customize the order:</p> <dl class="attribute"> <dt id="django.forms.Form.field_order">
<code>Form.field_order</code> </dt> 
</dl> <p>By default <code>Form.field_order=None</code>, which retains the order in which you define the fields in your form class. If <code>field_order</code> is a list of field names, the fields are ordered as specified by the list and remaining fields are appended according to the default order. Unknown field names in the list are ignored. This makes it possible to disable a field in a subclass by setting it to <code>None</code> without having to redefine ordering.</p> <p>You can also use the <code>Form.field_order</code> argument to a <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> to override the field order. If a <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> defines <a class="reference internal" href="#django.forms.Form.field_order" title="django.forms.Form.field_order"><code>field_order</code></a> <em>and</em> you include <code>field_order</code> when instantiating the <code>Form</code>, then the latter <code>field_order</code> will have precedence.</p> <dl class="method"> <dt id="django.forms.Form.order_fields">
<code>Form.order_fields(field_order)</code> </dt> 
</dl> <p>You may rearrange the fields any time using <code>order_fields()</code> with a list of field names as in <a class="reference internal" href="#django.forms.Form.field_order" title="django.forms.Form.field_order"><code>field_order</code></a>.</p>   <h3 id="how-errors-are-displayed">How errors are displayed</h3> <p id="s-how-errors-are-displayed">If you render a bound <code>Form</code> object, the act of rendering will automatically run the form’s validation if it hasn’t already happened, and the HTML output will include the validation errors as a <code>&lt;ul class="errorlist"&gt;</code> near the field. The particular positioning of the error messages depends on the output method you’re using:</p> <pre data-language="python">&gt;&gt;&gt; data = {'subject': '',
...         'message': 'Hi there',
...         'sender': 'invalid email address',
...         'cc_myself': True}
&gt;&gt;&gt; f = ContactForm(data, auto_id=False)
&gt;&gt;&gt; print(f.as_table())
&lt;tr&gt;&lt;th&gt;Subject:&lt;/th&gt;&lt;td&gt;&lt;ul class="errorlist"&gt;&lt;li&gt;This field is required.&lt;/li&gt;&lt;/ul&gt;&lt;input type="text" name="subject" maxlength="100" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Message:&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="message" value="Hi there" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Sender:&lt;/th&gt;&lt;td&gt;&lt;ul class="errorlist"&gt;&lt;li&gt;Enter a valid email address.&lt;/li&gt;&lt;/ul&gt;&lt;input type="email" name="sender" value="invalid email address" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Cc myself:&lt;/th&gt;&lt;td&gt;&lt;input checked type="checkbox" name="cc_myself"&gt;&lt;/td&gt;&lt;/tr&gt;
&gt;&gt;&gt; print(f.as_ul())
&lt;li&gt;&lt;ul class="errorlist"&gt;&lt;li&gt;This field is required.&lt;/li&gt;&lt;/ul&gt;Subject: &lt;input type="text" name="subject" maxlength="100" required&gt;&lt;/li&gt;
&lt;li&gt;Message: &lt;input type="text" name="message" value="Hi there" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;ul class="errorlist"&gt;&lt;li&gt;Enter a valid email address.&lt;/li&gt;&lt;/ul&gt;Sender: &lt;input type="email" name="sender" value="invalid email address" required&gt;&lt;/li&gt;
&lt;li&gt;Cc myself: &lt;input checked type="checkbox" name="cc_myself"&gt;&lt;/li&gt;
&gt;&gt;&gt; print(f.as_p())
&lt;p&gt;&lt;ul class="errorlist"&gt;&lt;li&gt;This field is required.&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;
&lt;p&gt;Subject: &lt;input type="text" name="subject" maxlength="100" required&gt;&lt;/p&gt;
&lt;p&gt;Message: &lt;input type="text" name="message" value="Hi there" required&gt;&lt;/p&gt;
&lt;p&gt;&lt;ul class="errorlist"&gt;&lt;li&gt;Enter a valid email address.&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;
&lt;p&gt;Sender: &lt;input type="email" name="sender" value="invalid email address" required&gt;&lt;/p&gt;
&lt;p&gt;Cc myself: &lt;input checked type="checkbox" name="cc_myself"&gt;&lt;/p&gt;
</pre>   <h3 id="ref-forms-error-list-format">Customizing the error list format</h3> <dl class="class" id="s-customizing-the-error-list-format"> <dt id="django.forms.ErrorList">
<code>class ErrorList(initlist=None, error_class=None, renderer=None)</code> </dt> <dd>
<p>By default, forms use <code>django.forms.utils.ErrorList</code> to format validation errors. <code>ErrorList</code> is a list like object where <code>initlist</code> is the list of errors. In addition this class has the following attributes and methods.</p> <dl class="attribute"> <dt id="django.forms.ErrorList.error_class">
<code>error_class</code> </dt> <dd>
<p>The CSS classes to be used when rendering the error list. Any provided classes are added to the default <code>errorlist</code> class.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.ErrorList.renderer">
<code>renderer</code> </dt> <dd>
<div class="versionadded"> <span class="title">New in Django 4.0.</span> </div> <p>Specifies the <a class="reference internal" href="renderers"><span class="doc">renderer</span></a> to use for <code>ErrorList</code>. Defaults to <code>None</code> which means to use the default renderer specified by the <a class="reference internal" href="../settings#std:setting-FORM_RENDERER"><code>FORM_RENDERER</code></a> setting.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.ErrorList.template_name">
<code>template_name</code> </dt> <dd>
<div class="versionadded"> <span class="title">New in Django 4.0.</span> </div> <p>The name of the template used when calling <code>__str__</code> or <a class="reference internal" href="#django.forms.ErrorList.render" title="django.forms.ErrorList.render"><code>render()</code></a>. By default this is <code>'django/forms/errors/list/default.html'</code> which is a proxy for the <code>'ul.html'</code> template.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.ErrorList.template_name_text">
<code>template_name_text</code> </dt> <dd>
<div class="versionadded"> <span class="title">New in Django 4.0.</span> </div> <p>The name of the template used when calling <a class="reference internal" href="#django.forms.ErrorList.as_text" title="django.forms.ErrorList.as_text"><code>as_text()</code></a>. By default this is <code>'django/forms/errors/list/text.html'</code>. This template renders the errors as a list of bullet points.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.ErrorList.template_name_ul">
<code>template_name_ul</code> </dt> <dd>
<div class="versionadded"> <span class="title">New in Django 4.0.</span> </div> <p>The name of the template used when calling <a class="reference internal" href="#django.forms.ErrorList.as_ul" title="django.forms.ErrorList.as_ul"><code>as_ul()</code></a>. By default this is <code>'django/forms/errors/list/ul.html'</code>. This template renders the errors in <code>&lt;li&gt;</code> tags with a wrapping <code>&lt;ul&gt;</code> with the CSS classes as defined by <a class="reference internal" href="#django.forms.ErrorList.error_class" title="django.forms.ErrorList.error_class"><code>error_class</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="django.forms.ErrorList.get_context">
<code>get_context()</code> </dt> <dd>
<div class="versionadded"> <span class="title">New in Django 4.0.</span> </div> <p>Return context for rendering of errors in a template.</p> <p>The available context is:</p> <ul class="simple"> <li>
<code>errors</code> : A list of the errors.</li> <li>
<code>error_class</code> : A string of CSS classes.</li> </ul> </dd>
</dl> <dl class="method"> <dt id="django.forms.ErrorList.render">
<code>render(template_name=None, context=None, renderer=None)</code> </dt> <dd>
<div class="versionadded"> <span class="title">New in Django 4.0.</span> </div> <p>The render method is called by <code>__str__</code> as well as by the <a class="reference internal" href="#django.forms.ErrorList.as_ul" title="django.forms.ErrorList.as_ul"><code>as_ul()</code></a> method.</p> <p>All arguments are optional and will default to:</p> <ul class="simple"> <li>
<code>template_name</code>: Value returned by <a class="reference internal" href="#django.forms.ErrorList.template_name" title="django.forms.ErrorList.template_name"><code>template_name</code></a>
</li> <li>
<code>context</code>: Value returned by <a class="reference internal" href="#django.forms.ErrorList.get_context" title="django.forms.ErrorList.get_context"><code>get_context()</code></a>
</li> <li>
<code>renderer</code>: Value returned by <a class="reference internal" href="#django.forms.ErrorList.renderer" title="django.forms.ErrorList.renderer"><code>renderer</code></a>
</li> </ul> </dd>
</dl> <dl class="method"> <dt id="django.forms.ErrorList.as_text">
<code>as_text()</code> </dt> <dd>
<p>Renders the error list using the template defined by <a class="reference internal" href="#django.forms.ErrorList.template_name_text" title="django.forms.ErrorList.template_name_text"><code>template_name_text</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="django.forms.ErrorList.as_ul">
<code>as_ul()</code> </dt> <dd>
<p>Renders the error list using the template defined by <a class="reference internal" href="#django.forms.ErrorList.template_name_ul" title="django.forms.ErrorList.template_name_ul"><code>template_name_ul</code></a>.</p> </dd>
</dl> <p>If you’d like to customize the rendering of errors this can be achieved by overriding the <a class="reference internal" href="#django.forms.ErrorList.template_name" title="django.forms.ErrorList.template_name"><code>template_name</code></a> attribute or more generally by overriding the default template, see also <a class="reference internal" href="renderers#overriding-built-in-form-templates"><span class="std std-ref">Overriding built-in form templates</span></a>.</p> </dd>
</dl> <div class="versionchanged"> <span class="title">Changed in Django 4.0:</span> <p>Rendering of <a class="reference internal" href="#django.forms.ErrorList" title="django.forms.ErrorList"><code>ErrorList</code></a> was moved to the template engine.</p> </div> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 4.0: </span>The ability to return a <code>str</code> when calling the <code>__str__</code> method is deprecated. Use the template engine instead which returns a <code>SafeString</code>.</p> </div>    <h2 id="more-granular-output">More granular output</h2> <p id="s-more-granular-output">The <code>as_p()</code>, <code>as_ul()</code>, and <code>as_table()</code> methods are shortcuts – they’re not the only way a form object can be displayed.</p> <dl class="class"> <dt id="django.forms.BoundField">
<code>class BoundField</code> </dt> <dd>
<p>Used to display HTML or access attributes for a single field of a <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance.</p> <p>The <code>__str__()</code> method of this object displays the HTML for this field.</p> </dd>
</dl> <p>To retrieve a single <code>BoundField</code>, use dictionary lookup syntax on your form using the field’s name as the key:</p> <pre data-language="python">&gt;&gt;&gt; form = ContactForm()
&gt;&gt;&gt; print(form['subject'])
&lt;input id="id_subject" type="text" name="subject" maxlength="100" required&gt;
</pre> <p>To retrieve all <code>BoundField</code> objects, iterate the form:</p> <pre data-language="python">&gt;&gt;&gt; form = ContactForm()
&gt;&gt;&gt; for boundfield in form: print(boundfield)
&lt;input id="id_subject" type="text" name="subject" maxlength="100" required&gt;
&lt;input type="text" name="message" id="id_message" required&gt;
&lt;input type="email" name="sender" id="id_sender" required&gt;
&lt;input type="checkbox" name="cc_myself" id="id_cc_myself"&gt;
</pre> <p>The field-specific output honors the form object’s <code>auto_id</code> setting:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm(auto_id=False)
&gt;&gt;&gt; print(f['message'])
&lt;input type="text" name="message" required&gt;
&gt;&gt;&gt; f = ContactForm(auto_id='id_%s')
&gt;&gt;&gt; print(f['message'])
&lt;input type="text" name="message" id="id_message" required&gt;
</pre>  <h3 id="attributes-of-boundfield">Attributes of <code>BoundField</code>
</h3> <dl class="attribute" id="s-attributes-of-boundfield"> <dt id="django.forms.BoundField.auto_id">
<code>BoundField.auto_id</code> </dt> <dd>
<p>The HTML ID attribute for this <code>BoundField</code>. Returns an empty string if <a class="reference internal" href="#django.forms.Form.auto_id" title="django.forms.Form.auto_id"><code>Form.auto_id</code></a> is <code>False</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.BoundField.data">
<code>BoundField.data</code> </dt> <dd>
<p>This property returns the data for this <a class="reference internal" href="#django.forms.BoundField" title="django.forms.BoundField"><code>BoundField</code></a> extracted by the widget’s <a class="reference internal" href="widgets#django.forms.Widget.value_from_datadict" title="django.forms.Widget.value_from_datadict"><code>value_from_datadict()</code></a> method, or <code>None</code> if it wasn’t given:</p> <pre data-language="python">&gt;&gt;&gt; unbound_form = ContactForm()
&gt;&gt;&gt; print(unbound_form['subject'].data)
None
&gt;&gt;&gt; bound_form = ContactForm(data={'subject': 'My Subject'})
&gt;&gt;&gt; print(bound_form['subject'].data)
My Subject
</pre> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.BoundField.errors">
<code>BoundField.errors</code> </dt> <dd>
<p>A <a class="reference internal" href="#ref-forms-error-list-format"><span class="std std-ref">list-like object</span></a> that is displayed as an HTML <code>&lt;ul class="errorlist"&gt;</code> when printed:</p> <pre data-language="python">&gt;&gt;&gt; data = {'subject': 'hi', 'message': '', 'sender': '', 'cc_myself': ''}
&gt;&gt;&gt; f = ContactForm(data, auto_id=False)
&gt;&gt;&gt; print(f['message'])
&lt;input type="text" name="message" required&gt;
&gt;&gt;&gt; f['message'].errors
['This field is required.']
&gt;&gt;&gt; print(f['message'].errors)
&lt;ul class="errorlist"&gt;&lt;li&gt;This field is required.&lt;/li&gt;&lt;/ul&gt;
&gt;&gt;&gt; f['subject'].errors
[]
&gt;&gt;&gt; print(f['subject'].errors)

&gt;&gt;&gt; str(f['subject'].errors)
''
</pre> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.BoundField.field">
<code>BoundField.field</code> </dt> <dd>
<p>The form <a class="reference internal" href="fields#django.forms.Field" title="django.forms.Field"><code>Field</code></a> instance from the form class that this <a class="reference internal" href="#django.forms.BoundField" title="django.forms.BoundField"><code>BoundField</code></a> wraps.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.BoundField.form">
<code>BoundField.form</code> </dt> <dd>
<p>The <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance this <a class="reference internal" href="#django.forms.BoundField" title="django.forms.BoundField"><code>BoundField</code></a> is bound to.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.BoundField.help_text">
<code>BoundField.help_text</code> </dt> <dd>
<p>The <a class="reference internal" href="fields#django.forms.Field.help_text" title="django.forms.Field.help_text"><code>help_text</code></a> of the field.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.BoundField.html_name">
<code>BoundField.html_name</code> </dt> <dd>
<p>The name that will be used in the widget’s HTML <code>name</code> attribute. It takes the form <a class="reference internal" href="#django.forms.Form.prefix" title="django.forms.Form.prefix"><code>prefix</code></a> into account.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.BoundField.id_for_label">
<code>BoundField.id_for_label</code> </dt> <dd>
<p>Use this property to render the ID of this field. For example, if you are manually constructing a <code>&lt;label&gt;</code> in your template (despite the fact that <a class="reference internal" href="#django.forms.BoundField.label_tag" title="django.forms.BoundField.label_tag"><code>label_tag()</code></a> will do this for you):</p> <pre data-language="markup">&lt;label for="{{ form.my_field.id_for_label }}"&gt;...&lt;/label&gt;{{ my_field }}
</pre> <p>By default, this will be the field’s name prefixed by <code>id_</code> (“<code>id_my_field</code>” for the example above). You may modify the ID by setting <a class="reference internal" href="widgets#django.forms.Widget.attrs" title="django.forms.Widget.attrs"><code>attrs</code></a> on the field’s widget. For example, declaring a field like this:</p> <pre data-language="python">my_field = forms.CharField(widget=forms.TextInput(attrs={'id': 'myFIELD'}))
</pre> <p>and using the template above, would render something like:</p> <pre data-language="html">&lt;label for="myFIELD"&gt;...&lt;/label&gt;&lt;input id="myFIELD" type="text" name="my_field" required&gt;
</pre> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.BoundField.initial">
<code>BoundField.initial</code> </dt> <dd>
<p>Use <a class="reference internal" href="#django.forms.BoundField.initial" title="django.forms.BoundField.initial"><code>BoundField.initial</code></a> to retrieve initial data for a form field. It retrieves the data from <a class="reference internal" href="#django.forms.Form.initial" title="django.forms.Form.initial"><code>Form.initial</code></a> if present, otherwise trying <a class="reference internal" href="fields#django.forms.Field.initial" title="django.forms.Field.initial"><code>Field.initial</code></a>. Callable values are evaluated. See <a class="reference internal" href="#ref-forms-initial-form-values"><span class="std std-ref">Initial form values</span></a> for more examples.</p> <p><a class="reference internal" href="#django.forms.BoundField.initial" title="django.forms.BoundField.initial"><code>BoundField.initial</code></a> caches its return value, which is useful especially when dealing with callables whose return values can change (e.g. <code>datetime.now</code> or <code>uuid.uuid4</code>):</p> <pre data-language="python">&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; class DatedCommentForm(CommentForm):
...     created = forms.DateTimeField(initial=datetime.now)
&gt;&gt;&gt; f = DatedCommentForm()
&gt;&gt;&gt; f['created'].initial
datetime.datetime(2021, 7, 27, 9, 5, 54)
&gt;&gt;&gt; f['created'].initial
datetime.datetime(2021, 7, 27, 9, 5, 54)
</pre> <p>Using <a class="reference internal" href="#django.forms.BoundField.initial" title="django.forms.BoundField.initial"><code>BoundField.initial</code></a> is recommended over <a class="reference internal" href="#django.forms.Form.get_initial_for_field" title="django.forms.Form.get_initial_for_field"><code>get_initial_for_field()</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.BoundField.is_hidden">
<code>BoundField.is_hidden</code> </dt> <dd>
<p>Returns <code>True</code> if this <a class="reference internal" href="#django.forms.BoundField" title="django.forms.BoundField"><code>BoundField</code></a>’s widget is hidden.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.BoundField.label">
<code>BoundField.label</code> </dt> <dd>
<p>The <a class="reference internal" href="fields#django.forms.Field.label" title="django.forms.Field.label"><code>label</code></a> of the field. This is used in <a class="reference internal" href="#django.forms.BoundField.label_tag" title="django.forms.BoundField.label_tag"><code>label_tag()</code></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.BoundField.name">
<code>BoundField.name</code> </dt> <dd>
<p>The name of this field in the form:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm()
&gt;&gt;&gt; print(f['subject'].name)
subject
&gt;&gt;&gt; print(f['message'].name)
message
</pre> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.BoundField.widget_type">
<code>BoundField.widget_type</code> </dt> <dd>
<p>Returns the lowercased class name of the wrapped field’s widget, with any trailing <code>input</code> or <code>widget</code> removed. This may be used when building forms where the layout is dependent upon the widget type. For example:</p> <pre data-language="python">{% for field in form %}
    {% if field.widget_type == 'checkbox' %}
        # render one way
    {% else %}
        # render another way
    {% endif %}
{% endfor %}
</pre> </dd>
</dl>   <h3 id="methods-of-boundfield">Methods of <code>BoundField</code>
</h3> <dl class="method" id="s-methods-of-boundfield"> <dt id="django.forms.BoundField.as_hidden">
<code>BoundField.as_hidden(attrs=None, **kwargs)</code> </dt> <dd>
<p>Returns a string of HTML for representing this as an <code>&lt;input type="hidden"&gt;</code>.</p> <p><code>**kwargs</code> are passed to <a class="reference internal" href="#django.forms.BoundField.as_widget" title="django.forms.BoundField.as_widget"><code>as_widget()</code></a>.</p> <p>This method is primarily used internally. You should use a widget instead.</p> </dd>
</dl> <dl class="method"> <dt id="django.forms.BoundField.as_widget">
<code>BoundField.as_widget(widget=None, attrs=None, only_initial=False)</code> </dt> <dd>
<p>Renders the field by rendering the passed widget, adding any HTML attributes passed as <code>attrs</code>. If no widget is specified, then the field’s default widget will be used.</p> <p><code>only_initial</code> is used by Django internals and should not be set explicitly.</p> </dd>
</dl> <dl class="method"> <dt id="django.forms.BoundField.css_classes">
<code>BoundField.css_classes(extra_classes=None)</code> </dt> <dd>
<p>When you use Django’s rendering shortcuts, CSS classes are used to indicate required form fields or fields that contain errors. If you’re manually rendering a form, you can access these CSS classes using the <code>css_classes</code> method:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm(data={'message': ''})
&gt;&gt;&gt; f['message'].css_classes()
'required'
</pre> <p>If you want to provide some additional classes in addition to the error and required classes that may be required, you can provide those classes as an argument:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm(data={'message': ''})
&gt;&gt;&gt; f['message'].css_classes('foo bar')
'foo bar required'
</pre> </dd>
</dl> <dl class="method"> <dt id="django.forms.BoundField.label_tag">
<code>BoundField.label_tag(contents=None, attrs=None, label_suffix=None)</code> </dt> <dd>
<p>Renders a label tag for the form field using the template specified by <a class="reference internal" href="#django.forms.Form.template_name_label" title="django.forms.Form.template_name_label"><code>Form.template_name_label</code></a>.</p> <p>The available context is:</p> <ul class="simple"> <li>
<code>field</code>: This instance of the <a class="reference internal" href="#django.forms.BoundField" title="django.forms.BoundField"><code>BoundField</code></a>.</li> <li>
<code>contents</code>: By default a concatenated string of <a class="reference internal" href="#django.forms.BoundField.label" title="django.forms.BoundField.label"><code>BoundField.label</code></a> and <a class="reference internal" href="#django.forms.Form.label_suffix" title="django.forms.Form.label_suffix"><code>Form.label_suffix</code></a> (or <a class="reference internal" href="fields#django.forms.Field.label_suffix" title="django.forms.Field.label_suffix"><code>Field.label_suffix</code></a>, if set). This can be overridden by the <code>contents</code> and <code>label_suffix</code> arguments.</li> <li>
<code>attrs</code>: A <code>dict</code> containing <code>for</code>, <a class="reference internal" href="#django.forms.Form.required_css_class" title="django.forms.Form.required_css_class"><code>Form.required_css_class</code></a>, and <code>id</code>. <code>id</code> is generated by the field’s widget <code>attrs</code> or <a class="reference internal" href="#django.forms.BoundField.auto_id" title="django.forms.BoundField.auto_id"><code>BoundField.auto_id</code></a>. Additional attributes can be provided by the <code>attrs</code> argument.</li> <li>
<code>use_tag</code>: A boolean which is <code>True</code> if the label has an <code>id</code>. If <code>False</code> the default template omits the <code>&lt;label&gt;</code> tag.</li> </ul> <div class="admonition tip"> <p class="first admonition-title">Tip</p> <p class="last">In your template <code>field</code> is the instance of the <code>BoundField</code>. Therefore <code>field.field</code> accesses <a class="reference internal" href="#django.forms.BoundField.field" title="django.forms.BoundField.field"><code>BoundField.field</code></a> being the field you declare, e.g. <code>forms.CharField</code>.</p> </div> <p>To separately render the label tag of a form field, you can call its <code>label_tag()</code> method:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactForm(data={'message': ''})
&gt;&gt;&gt; print(f['message'].label_tag())
&lt;label for="id_message"&gt;Message:&lt;/label&gt;
</pre> <p>If you’d like to customize the rendering this can be achieved by overriding the <a class="reference internal" href="#django.forms.Form.template_name_label" title="django.forms.Form.template_name_label"><code>Form.template_name_label</code></a> attribute or more generally by overriding the default template, see also <a class="reference internal" href="renderers#overriding-built-in-form-templates"><span class="std std-ref">Overriding built-in form templates</span></a>.</p> <div class="versionchanged"> <span class="title">Changed in Django 4.0:</span> <p>The label is now rendered using the template engine.</p> </div> </dd>
</dl> <dl class="method"> <dt id="django.forms.BoundField.value">
<code>BoundField.value()</code> </dt> <dd>
<p>Use this method to render the raw value of this field as it would be rendered by a <code>Widget</code>:</p> <pre data-language="python">&gt;&gt;&gt; initial = {'subject': 'welcome'}
&gt;&gt;&gt; unbound_form = ContactForm(initial=initial)
&gt;&gt;&gt; bound_form = ContactForm(data={'subject': 'hi'}, initial=initial)
&gt;&gt;&gt; print(unbound_form['subject'].value())
welcome
&gt;&gt;&gt; print(bound_form['subject'].value())
hi
</pre> </dd>
</dl>    <h2 id="customizing-boundfield">Customizing <code>BoundField</code>
</h2> <p id="s-customizing-boundfield">If you need to access some additional information about a form field in a template and using a subclass of <a class="reference internal" href="fields#django.forms.Field" title="django.forms.Field"><code>Field</code></a> isn’t sufficient, consider also customizing <a class="reference internal" href="#django.forms.BoundField" title="django.forms.BoundField"><code>BoundField</code></a>.</p> <p>A custom form field can override <code>get_bound_field()</code>:</p> <dl class="method"> <dt id="django.forms.Field.get_bound_field">
<code>Field.get_bound_field(form, field_name)</code> </dt> <dd>
<p>Takes an instance of <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> and the name of the field. The return value will be used when accessing the field in a template. Most likely it will be an instance of a subclass of <a class="reference internal" href="#django.forms.BoundField" title="django.forms.BoundField"><code>BoundField</code></a>.</p> </dd>
</dl> <p>If you have a <code>GPSCoordinatesField</code>, for example, and want to be able to access additional information about the coordinates in a template, this could be implemented as follows:</p> <pre data-language="python">class GPSCoordinatesBoundField(BoundField):
    @property
    def country(self):
        """
        Return the country the coordinates lie in or None if it can't be
        determined.
        """
        value = self.value()
        if value:
            return get_country_from_coordinates(value)
        else:
            return None

class GPSCoordinatesField(Field):
    def get_bound_field(self, form, field_name):
        return GPSCoordinatesBoundField(form, self, field_name)
</pre> <p>Now you can access the country in a template with <code>{{ form.coordinates.country }}</code>.</p>   <h2 id="binding-uploaded-files">Binding uploaded files to a form</h2> <p id="s-binding-uploaded-files-to-a-form">Dealing with forms that have <code>FileField</code> and <code>ImageField</code> fields is a little more complicated than a normal form.</p> <p>Firstly, in order to upload files, you’ll need to make sure that your <code>&lt;form&gt;</code> element correctly defines the <code>enctype</code> as <code>"multipart/form-data"</code>:</p> <pre data-language="python">&lt;form enctype="multipart/form-data" method="post" action="/foo/"&gt;
</pre> <p>Secondly, when you use the form, you need to bind the file data. File data is handled separately to normal form data, so when your form contains a <code>FileField</code> and <code>ImageField</code>, you will need to specify a second argument when you bind your form. So if we extend our ContactForm to include an <code>ImageField</code> called <code>mugshot</code>, we need to bind the file data containing the mugshot image:</p> <pre data-language="python"># Bound form with an image field
&gt;&gt;&gt; from django.core.files.uploadedfile import SimpleUploadedFile
&gt;&gt;&gt; data = {'subject': 'hello',
...         'message': 'Hi there',
...         'sender': 'foo@example.com',
...         'cc_myself': True}
&gt;&gt;&gt; file_data = {'mugshot': SimpleUploadedFile('face.jpg', &lt;file data&gt;)}
&gt;&gt;&gt; f = ContactFormWithMugshot(data, file_data)
</pre> <p>In practice, you will usually specify <code>request.FILES</code> as the source of file data (just like you use <code>request.POST</code> as the source of form data):</p> <pre data-language="python"># Bound form with an image field, data from the request
&gt;&gt;&gt; f = ContactFormWithMugshot(request.POST, request.FILES)
</pre> <p>Constructing an unbound form is the same as always – omit both form data <em>and</em> file data:</p> <pre data-language="python"># Unbound form with an image field
&gt;&gt;&gt; f = ContactFormWithMugshot()
</pre>  <h3 id="testing-for-multipart-forms">Testing for multipart forms</h3> <dl class="method" id="s-testing-for-multipart-forms"> <dt id="django.forms.Form.is_multipart">
<code>Form.is_multipart()</code> </dt> 
</dl> <p>If you’re writing reusable views or templates, you may not know ahead of time whether your form is a multipart form or not. The <code>is_multipart()</code> method tells you whether the form requires multipart encoding for submission:</p> <pre data-language="python">&gt;&gt;&gt; f = ContactFormWithMugshot()
&gt;&gt;&gt; f.is_multipart()
True
</pre> <p>Here’s an example of how you might use this in a template:</p> <pre data-language="python">{% if form.is_multipart %}
    &lt;form enctype="multipart/form-data" method="post" action="/foo/"&gt;
{% else %}
    &lt;form method="post" action="/foo/"&gt;
{% endif %}
{{ form }}
&lt;/form&gt;
</pre>    <h2 id="subclassing-forms">Subclassing forms</h2> <p id="s-subclassing-forms">If you have multiple <code>Form</code> classes that share fields, you can use subclassing to remove redundancy.</p> <p>When you subclass a custom <code>Form</code> class, the resulting subclass will include all fields of the parent class(es), followed by the fields you define in the subclass.</p> <p>In this example, <code>ContactFormWithPriority</code> contains all the fields from <code>ContactForm</code>, plus an additional field, <code>priority</code>. The <code>ContactForm</code> fields are ordered first:</p> <pre data-language="python">&gt;&gt;&gt; class ContactFormWithPriority(ContactForm):
...     priority = forms.CharField()
&gt;&gt;&gt; f = ContactFormWithPriority(auto_id=False)
&gt;&gt;&gt; print(f.as_ul())
&lt;li&gt;Subject: &lt;input type="text" name="subject" maxlength="100" required&gt;&lt;/li&gt;
&lt;li&gt;Message: &lt;input type="text" name="message" required&gt;&lt;/li&gt;
&lt;li&gt;Sender: &lt;input type="email" name="sender" required&gt;&lt;/li&gt;
&lt;li&gt;Cc myself: &lt;input type="checkbox" name="cc_myself"&gt;&lt;/li&gt;
&lt;li&gt;Priority: &lt;input type="text" name="priority" required&gt;&lt;/li&gt;
</pre> <p>It’s possible to subclass multiple forms, treating forms as mixins. In this example, <code>BeatleForm</code> subclasses both <code>PersonForm</code> and <code>InstrumentForm</code> (in that order), and its field list includes the fields from the parent classes:</p> <pre data-language="python">&gt;&gt;&gt; from django import forms
&gt;&gt;&gt; class PersonForm(forms.Form):
...     first_name = forms.CharField()
...     last_name = forms.CharField()
&gt;&gt;&gt; class InstrumentForm(forms.Form):
...     instrument = forms.CharField()
&gt;&gt;&gt; class BeatleForm(InstrumentForm, PersonForm):
...     haircut_type = forms.CharField()
&gt;&gt;&gt; b = BeatleForm(auto_id=False)
&gt;&gt;&gt; print(b.as_ul())
&lt;li&gt;First name: &lt;input type="text" name="first_name" required&gt;&lt;/li&gt;
&lt;li&gt;Last name: &lt;input type="text" name="last_name" required&gt;&lt;/li&gt;
&lt;li&gt;Instrument: &lt;input type="text" name="instrument" required&gt;&lt;/li&gt;
&lt;li&gt;Haircut type: &lt;input type="text" name="haircut_type" required&gt;&lt;/li&gt;
</pre> <p>It’s possible to declaratively remove a <code>Field</code> inherited from a parent class by setting the name of the field to <code>None</code> on the subclass. For example:</p> <pre data-language="python">&gt;&gt;&gt; from django import forms

&gt;&gt;&gt; class ParentForm(forms.Form):
...     name = forms.CharField()
...     age = forms.IntegerField()

&gt;&gt;&gt; class ChildForm(ParentForm):
...     name = None

&gt;&gt;&gt; list(ChildForm().fields)
['age']
</pre>   <h2 id="form-prefix">Prefixes for forms</h2> <dl class="attribute" id="s-prefixes-for-forms"> <dt id="django.forms.Form.prefix">
<code>Form.prefix</code> </dt> 
</dl> <p>You can put several Django forms inside one <code>&lt;form&gt;</code> tag. To give each <code>Form</code> its own namespace, use the <code>prefix</code> keyword argument:</p> <pre data-language="python">&gt;&gt;&gt; mother = PersonForm(prefix="mother")
&gt;&gt;&gt; father = PersonForm(prefix="father")
&gt;&gt;&gt; print(mother.as_ul())
&lt;li&gt;&lt;label for="id_mother-first_name"&gt;First name:&lt;/label&gt; &lt;input type="text" name="mother-first_name" id="id_mother-first_name" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="id_mother-last_name"&gt;Last name:&lt;/label&gt; &lt;input type="text" name="mother-last_name" id="id_mother-last_name" required&gt;&lt;/li&gt;
&gt;&gt;&gt; print(father.as_ul())
&lt;li&gt;&lt;label for="id_father-first_name"&gt;First name:&lt;/label&gt; &lt;input type="text" name="father-first_name" id="id_father-first_name" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="id_father-last_name"&gt;Last name:&lt;/label&gt; &lt;input type="text" name="father-last_name" id="id_father-last_name" required&gt;&lt;/li&gt;
</pre> <p>The prefix can also be specified on the form class:</p> <pre data-language="python">&gt;&gt;&gt; class PersonForm(forms.Form):
...     ...
...     prefix = 'person'
</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/4.0/ref/forms/api/" class="_attribution-link">https://docs.djangoproject.com/en/4.0/ref/forms/api/</a>
  </p>
</div>
