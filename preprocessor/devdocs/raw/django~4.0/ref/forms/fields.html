<h1 id="form-fields">Form fields</h1> <dl class="class" id="s-module-django.forms.fields"> <dt id="django.forms.Field">
<code>class Field(**kwargs)</code> </dt> 
</dl> <p>When you create a <code>Form</code> class, the most important part is defining the fields of the form. Each field has custom validation logic, along with a few other hooks.</p> <dl class="method"> <dt id="django.forms.Field.clean">
<code>Field.clean(value)</code> </dt> 
</dl> <p>Although the primary way you’ll use <code>Field</code> classes is in <code>Form</code> classes, you can also instantiate them and use them directly to get a better idea of how they work. Each <code>Field</code> instance has a <code>clean()</code> method, which takes a single argument and either raises a <code>django.core.exceptions.ValidationError</code> exception or returns the clean value:</p> <pre data-language="python">&gt;&gt;&gt; from django import forms
&gt;&gt;&gt; f = forms.EmailField()
&gt;&gt;&gt; f.clean('foo@example.com')
'foo@example.com'
&gt;&gt;&gt; f.clean('invalid email address')
Traceback (most recent call last):
...
ValidationError: ['Enter a valid email address.']
</pre>  <h2 id="id1">Core field arguments</h2> <p id="s-core-field-arguments">Each <code>Field</code> class constructor takes at least these arguments. Some <code>Field</code> classes take additional, field-specific arguments, but the following should <em>always</em> be accepted:</p>  <h3 id="required"><code>required</code></h3> <dl class="attribute" id="s-required"> <dt id="django.forms.Field.required">
<code>Field.required</code> </dt> 
</dl> <p>By default, each <code>Field</code> class assumes the value is required, so if you pass an empty value – either <code>None</code> or the empty string (<code>""</code>) – then <code>clean()</code> will raise a <code>ValidationError</code> exception:</p> <pre data-language="python">&gt;&gt;&gt; from django import forms
&gt;&gt;&gt; f = forms.CharField()
&gt;&gt;&gt; f.clean('foo')
'foo'
&gt;&gt;&gt; f.clean('')
Traceback (most recent call last):
...
ValidationError: ['This field is required.']
&gt;&gt;&gt; f.clean(None)
Traceback (most recent call last):
...
ValidationError: ['This field is required.']
&gt;&gt;&gt; f.clean(' ')
' '
&gt;&gt;&gt; f.clean(0)
'0'
&gt;&gt;&gt; f.clean(True)
'True'
&gt;&gt;&gt; f.clean(False)
'False'
</pre> <p>To specify that a field is <em>not</em> required, pass <code>required=False</code> to the <code>Field</code> constructor:</p> <pre data-language="python">&gt;&gt;&gt; f = forms.CharField(required=False)
&gt;&gt;&gt; f.clean('foo')
'foo'
&gt;&gt;&gt; f.clean('')
''
&gt;&gt;&gt; f.clean(None)
''
&gt;&gt;&gt; f.clean(0)
'0'
&gt;&gt;&gt; f.clean(True)
'True'
&gt;&gt;&gt; f.clean(False)
'False'
</pre> <p>If a <code>Field</code> has <code>required=False</code> and you pass <code>clean()</code> an empty value, then <code>clean()</code> will return a <em>normalized</em> empty value rather than raising <code>ValidationError</code>. For <code>CharField</code>, this will return <a class="reference internal" href="#django.forms.CharField.empty_value" title="django.forms.CharField.empty_value"><code>empty_value</code></a> which defaults to an empty string. For other <code>Field</code> classes, it might be <code>None</code>. (This varies from field to field.)</p> <p>Widgets of required form fields have the <code>required</code> HTML attribute. Set the <a class="reference internal" href="api#django.forms.Form.use_required_attribute" title="django.forms.Form.use_required_attribute"><code>Form.use_required_attribute</code></a> attribute to <code>False</code> to disable it. The <code>required</code> attribute isn’t included on forms of formsets because the browser validation may not be correct when adding and deleting formsets.</p>   <h3 id="label"><code>label</code></h3> <dl class="attribute" id="s-label"> <dt id="django.forms.Field.label">
<code>Field.label</code> </dt> 
</dl> <p>The <code>label</code> argument lets you specify the “human-friendly” label for this field. This is used when the <code>Field</code> is displayed in a <code>Form</code>.</p> <p>As explained in “Outputting forms as HTML” above, the default label for a <code>Field</code> is generated from the field name by converting all underscores to spaces and upper-casing the first letter. Specify <code>label</code> if that default behavior doesn’t result in an adequate label.</p> <p>Here’s a full example <code>Form</code> that implements <code>label</code> for two of its fields. We’ve specified <code>auto_id=False</code> to simplify the output:</p> <pre data-language="python">&gt;&gt;&gt; from django import forms
&gt;&gt;&gt; class CommentForm(forms.Form):
...     name = forms.CharField(label='Your name')
...     url = forms.URLField(label='Your website', required=False)
...     comment = forms.CharField()
&gt;&gt;&gt; f = CommentForm(auto_id=False)
&gt;&gt;&gt; print(f)
&lt;tr&gt;&lt;th&gt;Your name:&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="name" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Your website:&lt;/th&gt;&lt;td&gt;&lt;input type="url" name="url"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Comment:&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="comment" required&gt;&lt;/td&gt;&lt;/tr&gt;
</pre>   <h3 id="label-suffix"><code>label_suffix</code></h3> <dl class="attribute" id="s-label-suffix"> <dt id="django.forms.Field.label_suffix">
<code>Field.label_suffix</code> </dt> 
</dl> <p>The <code>label_suffix</code> argument lets you override the form’s <a class="reference internal" href="api#django.forms.Form.label_suffix" title="django.forms.Form.label_suffix"><code>label_suffix</code></a> on a per-field basis:</p> <pre data-language="python">&gt;&gt;&gt; class ContactForm(forms.Form):
...     age = forms.IntegerField()
...     nationality = forms.CharField()
...     captcha_answer = forms.IntegerField(label='2 + 2', label_suffix=' =')
&gt;&gt;&gt; f = ContactForm(label_suffix='?')
&gt;&gt;&gt; print(f.as_p())
&lt;p&gt;&lt;label for="id_age"&gt;Age?&lt;/label&gt; &lt;input id="id_age" name="age" type="number" required&gt;&lt;/p&gt;
&lt;p&gt;&lt;label for="id_nationality"&gt;Nationality?&lt;/label&gt; &lt;input id="id_nationality" name="nationality" type="text" required&gt;&lt;/p&gt;
&lt;p&gt;&lt;label for="id_captcha_answer"&gt;2 + 2 =&lt;/label&gt; &lt;input id="id_captcha_answer" name="captcha_answer" type="number" required&gt;&lt;/p&gt;
</pre>   <h3 id="initial"><code>initial</code></h3> <dl class="attribute" id="s-initial"> <dt id="django.forms.Field.initial">
<code>Field.initial</code> </dt> 
</dl> <p>The <code>initial</code> argument lets you specify the initial value to use when rendering this <code>Field</code> in an unbound <code>Form</code>.</p> <p>To specify dynamic initial data, see the <a class="reference internal" href="api#django.forms.Form.initial" title="django.forms.Form.initial"><code>Form.initial</code></a> parameter.</p> <p>The use-case for this is when you want to display an “empty” form in which a field is initialized to a particular value. For example:</p> <pre data-language="python">&gt;&gt;&gt; from django import forms
&gt;&gt;&gt; class CommentForm(forms.Form):
...     name = forms.CharField(initial='Your name')
...     url = forms.URLField(initial='http://')
...     comment = forms.CharField()
&gt;&gt;&gt; f = CommentForm(auto_id=False)
&gt;&gt;&gt; print(f)
&lt;tr&gt;&lt;th&gt;Name:&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="name" value="Your name" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Url:&lt;/th&gt;&lt;td&gt;&lt;input type="url" name="url" value="http://" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Comment:&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="comment" required&gt;&lt;/td&gt;&lt;/tr&gt;
</pre> <p>You may be thinking, why not just pass a dictionary of the initial values as data when displaying the form? Well, if you do that, you’ll trigger validation, and the HTML output will include any validation errors:</p> <pre data-language="python">&gt;&gt;&gt; class CommentForm(forms.Form):
...     name = forms.CharField()
...     url = forms.URLField()
...     comment = forms.CharField()
&gt;&gt;&gt; default_data = {'name': 'Your name', 'url': 'http://'}
&gt;&gt;&gt; f = CommentForm(default_data, auto_id=False)
&gt;&gt;&gt; print(f)
&lt;tr&gt;&lt;th&gt;Name:&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="name" value="Your name" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Url:&lt;/th&gt;&lt;td&gt;&lt;ul class="errorlist"&gt;&lt;li&gt;Enter a valid URL.&lt;/li&gt;&lt;/ul&gt;&lt;input type="url" name="url" value="http://" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Comment:&lt;/th&gt;&lt;td&gt;&lt;ul class="errorlist"&gt;&lt;li&gt;This field is required.&lt;/li&gt;&lt;/ul&gt;&lt;input type="text" name="comment" required&gt;&lt;/td&gt;&lt;/tr&gt;
</pre> <p>This is why <code>initial</code> values are only displayed for unbound forms. For bound forms, the HTML output will use the bound data.</p> <p>Also note that <code>initial</code> values are <em>not</em> used as “fallback” data in validation if a particular field’s value is not given. <code>initial</code> values are <em>only</em> intended for initial form display:</p> <pre data-language="python">&gt;&gt;&gt; class CommentForm(forms.Form):
...     name = forms.CharField(initial='Your name')
...     url = forms.URLField(initial='http://')
...     comment = forms.CharField()
&gt;&gt;&gt; data = {'name': '', 'url': '', 'comment': 'Foo'}
&gt;&gt;&gt; f = CommentForm(data)
&gt;&gt;&gt; f.is_valid()
False
# The form does *not* fall back to using the initial values.
&gt;&gt;&gt; f.errors
{'url': ['This field is required.'], 'name': ['This field is required.']}
</pre> <p>Instead of a constant, you can also pass any callable:</p> <pre data-language="python">&gt;&gt;&gt; import datetime
&gt;&gt;&gt; class DateForm(forms.Form):
...     day = forms.DateField(initial=datetime.date.today)
&gt;&gt;&gt; print(DateForm())
&lt;tr&gt;&lt;th&gt;Day:&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="day" value="12/23/2008" required&gt;&lt;td&gt;&lt;/tr&gt;
</pre> <p>The callable will be evaluated only when the unbound form is displayed, not when it is defined.</p>   <h3 id="widget"><code>widget</code></h3> <dl class="attribute" id="s-widget"> <dt id="django.forms.Field.widget">
<code>Field.widget</code> </dt> 
</dl> <p>The <code>widget</code> argument lets you specify a <code>Widget</code> class to use when rendering this <code>Field</code>. See <a class="reference internal" href="widgets"><span class="doc">Widgets</span></a> for more information.</p>   <h3 id="help-text"><code>help_text</code></h3> <dl class="attribute" id="s-help-text"> <dt id="django.forms.Field.help_text">
<code>Field.help_text</code> </dt> 
</dl> <p>The <code>help_text</code> argument lets you specify descriptive text for this <code>Field</code>. If you provide <code>help_text</code>, it will be displayed next to the <code>Field</code> when the <code>Field</code> is rendered by one of the convenience <code>Form</code> methods (e.g., <code>as_ul()</code>).</p> <p>Like the model field’s <a class="reference internal" href="../models/fields#django.db.models.Field.help_text" title="django.db.models.Field.help_text"><code>help_text</code></a>, this value isn’t HTML-escaped in automatically-generated forms.</p> <p>Here’s a full example <code>Form</code> that implements <code>help_text</code> for two of its fields. We’ve specified <code>auto_id=False</code> to simplify the output:</p> <pre data-language="python">&gt;&gt;&gt; from django import forms
&gt;&gt;&gt; class HelpTextContactForm(forms.Form):
...     subject = forms.CharField(max_length=100, help_text='100 characters max.')
...     message = forms.CharField()
...     sender = forms.EmailField(help_text='A valid email address, please.')
...     cc_myself = forms.BooleanField(required=False)
&gt;&gt;&gt; f = HelpTextContactForm(auto_id=False)
&gt;&gt;&gt; print(f.as_table())
&lt;tr&gt;&lt;th&gt;Subject:&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="subject" maxlength="100" required&gt;&lt;br&gt;&lt;span class="helptext"&gt;100 characters max.&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Message:&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="message" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Sender:&lt;/th&gt;&lt;td&gt;&lt;input type="email" name="sender" required&gt;&lt;br&gt;A valid email address, please.&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;Cc myself:&lt;/th&gt;&lt;td&gt;&lt;input type="checkbox" name="cc_myself"&gt;&lt;/td&gt;&lt;/tr&gt;
&gt;&gt;&gt; print(f.as_ul()))
&lt;li&gt;Subject: &lt;input type="text" name="subject" maxlength="100" required&gt; &lt;span class="helptext"&gt;100 characters max.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Message: &lt;input type="text" name="message" required&gt;&lt;/li&gt;
&lt;li&gt;Sender: &lt;input type="email" name="sender" required&gt; A valid email address, please.&lt;/li&gt;
&lt;li&gt;Cc myself: &lt;input type="checkbox" name="cc_myself"&gt;&lt;/li&gt;
&gt;&gt;&gt; print(f.as_p())
&lt;p&gt;Subject: &lt;input type="text" name="subject" maxlength="100" required&gt; &lt;span class="helptext"&gt;100 characters max.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Message: &lt;input type="text" name="message" required&gt;&lt;/p&gt;
&lt;p&gt;Sender: &lt;input type="email" name="sender" required&gt; A valid email address, please.&lt;/p&gt;
&lt;p&gt;Cc myself: &lt;input type="checkbox" name="cc_myself"&gt;&lt;/p&gt;
</pre>   <h3 id="error-messages"><code>error_messages</code></h3> <dl class="attribute" id="s-error-messages"> <dt id="django.forms.Field.error_messages">
<code>Field.error_messages</code> </dt> 
</dl> <p>The <code>error_messages</code> argument lets you override the default messages that the field will raise. Pass in a dictionary with keys matching the error messages you want to override. For example, here is the default error message:</p> <pre data-language="python">&gt;&gt;&gt; from django import forms
&gt;&gt;&gt; generic = forms.CharField()
&gt;&gt;&gt; generic.clean('')
Traceback (most recent call last):
  ...
ValidationError: ['This field is required.']
</pre> <p>And here is a custom error message:</p> <pre data-language="python">&gt;&gt;&gt; name = forms.CharField(error_messages={'required': 'Please enter your name'})
&gt;&gt;&gt; name.clean('')
Traceback (most recent call last):
  ...
ValidationError: ['Please enter your name']
</pre> <p>In the <a class="reference internal" href="#built-in-field-classes">built-in Field classes</a> section below, each <code>Field</code> defines the error message keys it uses.</p>   <h3 id="validators"><code>validators</code></h3> <dl class="attribute" id="s-validators"> <dt id="django.forms.Field.validators">
<code>Field.validators</code> </dt> 
</dl> <p>The <code>validators</code> argument lets you provide a list of validation functions for this field.</p> <p>See the <a class="reference internal" href="../validators"><span class="doc">validators documentation</span></a> for more information.</p>   <h3 id="localize"><code>localize</code></h3> <dl class="attribute" id="s-localize"> <dt id="django.forms.Field.localize">
<code>Field.localize</code> </dt> 
</dl> <p>The <code>localize</code> argument enables the localization of form data input, as well as the rendered output.</p> <p>See the <a class="reference internal" href="../../topics/i18n/formatting"><span class="doc">format localization</span></a> documentation for more information.</p>   <h3 id="disabled"><code>disabled</code></h3> <dl class="attribute" id="s-disabled"> <dt id="django.forms.Field.disabled">
<code>Field.disabled</code> </dt> 
</dl> <p>The <code>disabled</code> boolean argument, when set to <code>True</code>, disables a form field using the <code>disabled</code> HTML attribute so that it won’t be editable by users. Even if a user tampers with the field’s value submitted to the server, it will be ignored in favor of the value from the form’s initial data.</p>    <h2 id="checking-if-the-field-data-has-changed">Checking if the field data has changed</h2>  <h3 id="has-changed"><code>has_changed()</code></h3> <dl class="method" id="s-checking-if-the-field-data-has-changed"> <dt id="django.forms.Field.has_changed">
<code>Field.has_changed()</code> </dt> 
</dl> <p>The <code>has_changed()</code> method is used to determine if the field value has changed from the initial value. Returns <code>True</code> or <code>False</code>.</p> <p>See the <a class="reference internal" href="api#django.forms.Form.has_changed" title="django.forms.Form.has_changed"><code>Form.has_changed()</code></a> documentation for more information.</p>    <h2 id="built-in-fields">Built-in <code>Field</code> classes</h2> <p id="s-built-in-field-classes">Naturally, the <code>forms</code> library comes with a set of <code>Field</code> classes that represent common validation needs. This section documents each built-in field.</p> <p>For each field, we describe the default widget used if you don’t specify <code>widget</code>. We also specify the value returned when you provide an empty value (see the section on <code>required</code> above to understand what that means).</p>  <h3 id="booleanfield"><code>BooleanField</code></h3> <dl class="class" id="s-booleanfield"> <dt id="django.forms.BooleanField">
<code>class BooleanField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.CheckboxInput" title="django.forms.CheckboxInput"><code>CheckboxInput</code></a>
</li> <li>Empty value: <code>False</code>
</li> <li>Normalizes to: A Python <code>True</code> or <code>False</code> value.</li> <li>Validates that the value is <code>True</code> (e.g. the check box is checked) if the field has <code>required=True</code>.</li> <li>Error message keys: <code>required</code>
</li> </ul> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Since all <code>Field</code> subclasses have <code>required=True</code> by default, the validation condition here is important. If you want to include a boolean in your form that can be either <code>True</code> or <code>False</code> (e.g. a checked or unchecked checkbox), you must remember to pass in <code>required=False</code> when creating the <code>BooleanField</code>.</p> </div> </dd>
</dl>   <h3 id="charfield"><code>CharField</code></h3> <dl class="class" id="s-charfield"> <dt id="django.forms.CharField">
<code>class CharField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a>
</li> <li>Empty value: Whatever you’ve given as <a class="reference internal" href="#django.forms.CharField.empty_value" title="django.forms.CharField.empty_value"><code>empty_value</code></a>.</li> <li>Normalizes to: A string.</li> <li>Uses <a class="reference internal" href="../validators#django.core.validators.MaxLengthValidator" title="django.core.validators.MaxLengthValidator"><code>MaxLengthValidator</code></a> and <a class="reference internal" href="../validators#django.core.validators.MinLengthValidator" title="django.core.validators.MinLengthValidator"><code>MinLengthValidator</code></a> if <code>max_length</code> and <code>min_length</code> are provided. Otherwise, all inputs are valid.</li> <li>Error message keys: <code>required</code>, <code>max_length</code>, <code>min_length</code>
</li> </ul> <p>Has four optional arguments for validation:</p> <dl class="attribute"> <dt id="django.forms.CharField.max_length">
<code>max_length</code> </dt> 
</dl> <dl class="attribute"> <dt id="django.forms.CharField.min_length">
<code>min_length</code> </dt> <dd>
<p>If provided, these arguments ensure that the string is at most or at least the given length.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.CharField.strip">
<code>strip</code> </dt> <dd>
<p>If <code>True</code> (default), the value will be stripped of leading and trailing whitespace.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.CharField.empty_value">
<code>empty_value</code> </dt> <dd>
<p>The value to use to represent “empty”. Defaults to an empty string.</p> </dd>
</dl> </dd>
</dl>   <h3 id="choicefield"><code>ChoiceField</code></h3> <dl class="class" id="s-choicefield"> <dt id="django.forms.ChoiceField">
<code>class ChoiceField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.Select" title="django.forms.Select"><code>Select</code></a>
</li> <li>Empty value: <code>''</code> (an empty string)</li> <li>Normalizes to: A string.</li> <li>Validates that the given value exists in the list of choices.</li> <li>Error message keys: <code>required</code>, <code>invalid_choice</code>
</li> </ul> <p>The <code>invalid_choice</code> error message may contain <code>%(value)s</code>, which will be replaced with the selected choice.</p> <p>Takes one extra argument:</p> <dl class="attribute"> <dt id="django.forms.ChoiceField.choices">
<code>choices</code> </dt> <dd>
<p>Either an <a class="reference external" href="https://docs.python.org/3/glossary.html#term-iterable" title="(in Python v3.10)"><span class="xref std std-term">iterable</span></a> of 2-tuples to use as choices for this field, <a class="reference internal" href="../models/fields#field-choices-enum-types"><span class="std std-ref">enumeration</span></a> choices, or a callable that returns such an iterable. This argument accepts the same formats as the <code>choices</code> argument to a model field. See the <a class="reference internal" href="../models/fields#field-choices"><span class="std std-ref">model field reference documentation on choices</span></a> for more details. If the argument is a callable, it is evaluated each time the field’s form is initialized, in addition to during rendering. Defaults to an empty list.</p> </dd>
</dl> </dd>
</dl>   <h3 id="datefield"><code>DateField</code></h3> <dl class="class" id="s-datefield"> <dt id="django.forms.DateField">
<code>class DateField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.DateInput" title="django.forms.DateInput"><code>DateInput</code></a>
</li> <li>Empty value: <code>None</code>
</li> <li>Normalizes to: A Python <code>datetime.date</code> object.</li> <li>Validates that the given value is either a <code>datetime.date</code>, <code>datetime.datetime</code> or string formatted in a particular date format.</li> <li>Error message keys: <code>required</code>, <code>invalid</code>
</li> </ul> <p>Takes one optional argument:</p> <dl class="attribute"> <dt id="django.forms.DateField.input_formats">
<code>input_formats</code> </dt> <dd>
<p>A list of formats used to attempt to convert a string to a valid <code>datetime.date</code> object.</p> </dd>
</dl> <p>If no <code>input_formats</code> argument is provided, the default input formats are taken from <a class="reference internal" href="../settings#std:setting-DATE_INPUT_FORMATS"><code>DATE_INPUT_FORMATS</code></a> if <a class="reference internal" href="../settings#std:setting-USE_L10N"><code>USE_L10N</code></a> is <code>False</code>, or from the active locale format <code>DATE_INPUT_FORMATS</code> key if localization is enabled. See also <a class="reference internal" href="../../topics/i18n/formatting"><span class="doc">format localization</span></a>.</p> </dd>
</dl>   <h3 id="datetimefield"><code>DateTimeField</code></h3> <dl class="class" id="s-datetimefield"> <dt id="django.forms.DateTimeField">
<code>class DateTimeField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.DateTimeInput" title="django.forms.DateTimeInput"><code>DateTimeInput</code></a>
</li> <li>Empty value: <code>None</code>
</li> <li>Normalizes to: A Python <code>datetime.datetime</code> object.</li> <li>Validates that the given value is either a <code>datetime.datetime</code>, <code>datetime.date</code> or string formatted in a particular datetime format.</li> <li>Error message keys: <code>required</code>, <code>invalid</code>
</li> </ul> <p>Takes one optional argument:</p> <dl class="attribute"> <dt id="django.forms.DateTimeField.input_formats">
<code>input_formats</code> </dt> <dd>
<p>A list of formats used to attempt to convert a string to a valid <code>datetime.datetime</code> object, in addition to ISO 8601 formats.</p> </dd>
</dl> <p>The field always accepts strings in ISO 8601 formatted dates or similar recognized by <a class="reference internal" href="../utils#django.utils.dateparse.parse_datetime" title="django.utils.dateparse.parse_datetime"><code>parse_datetime()</code></a>. Some examples are:</p> <pre data-language="python">* '2006-10-25 14:30:59'
* '2006-10-25T14:30:59'
* '2006-10-25 14:30'
* '2006-10-25T14:30'
* '2006-10-25T14:30Z'
* '2006-10-25T14:30+02:00'
* '2006-10-25'
</pre> <p>If no <code>input_formats</code> argument is provided, the default input formats are taken from <a class="reference internal" href="../settings#std:setting-DATETIME_INPUT_FORMATS"><code>DATETIME_INPUT_FORMATS</code></a> and <a class="reference internal" href="../settings#std:setting-DATE_INPUT_FORMATS"><code>DATE_INPUT_FORMATS</code></a> if <a class="reference internal" href="../settings#std:setting-USE_L10N"><code>USE_L10N</code></a> is <code>False</code>, or from the active locale format <code>DATETIME_INPUT_FORMATS</code> and <code>DATE_INPUT_FORMATS</code> keys if localization is enabled. See also <a class="reference internal" href="../../topics/i18n/formatting"><span class="doc">format localization</span></a>.</p> </dd>
</dl>   <h3 id="decimalfield"><code>DecimalField</code></h3> <dl class="class" id="s-decimalfield"> <dt id="django.forms.DecimalField">
<code>class DecimalField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.NumberInput" title="django.forms.NumberInput"><code>NumberInput</code></a> when <a class="reference internal" href="#django.forms.Field.localize" title="django.forms.Field.localize"><code>Field.localize</code></a> is <code>False</code>, else <a class="reference internal" href="widgets#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a>.</li> <li>Empty value: <code>None</code>
</li> <li>Normalizes to: A Python <code>decimal</code>.</li> <li>Validates that the given value is a decimal. Uses <a class="reference internal" href="../validators#django.core.validators.MaxValueValidator" title="django.core.validators.MaxValueValidator"><code>MaxValueValidator</code></a> and <a class="reference internal" href="../validators#django.core.validators.MinValueValidator" title="django.core.validators.MinValueValidator"><code>MinValueValidator</code></a> if <code>max_value</code> and <code>min_value</code> are provided. Leading and trailing whitespace is ignored.</li> <li>Error message keys: <code>required</code>, <code>invalid</code>, <code>max_value</code>, <code>min_value</code>, <code>max_digits</code>, <code>max_decimal_places</code>, <code>max_whole_digits</code>
</li> </ul> <p>The <code>max_value</code> and <code>min_value</code> error messages may contain <code>%(limit_value)s</code>, which will be substituted by the appropriate limit. Similarly, the <code>max_digits</code>, <code>max_decimal_places</code> and <code>max_whole_digits</code> error messages may contain <code>%(max)s</code>.</p> <p>Takes four optional arguments:</p> <dl class="attribute"> <dt id="django.forms.DecimalField.max_value">
<code>max_value</code> </dt> 
</dl> <dl class="attribute"> <dt id="django.forms.DecimalField.min_value">
<code>min_value</code> </dt> <dd>
<p>These control the range of values permitted in the field, and should be given as <code>decimal.Decimal</code> values.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.DecimalField.max_digits">
<code>max_digits</code> </dt> <dd>
<p>The maximum number of digits (those before the decimal point plus those after the decimal point, with leading zeros stripped) permitted in the value.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.DecimalField.decimal_places">
<code>decimal_places</code> </dt> <dd>
<p>The maximum number of decimal places permitted.</p> </dd>
</dl> </dd>
</dl>   <h3 id="durationfield"><code>DurationField</code></h3> <dl class="class" id="s-durationfield"> <dt id="django.forms.DurationField">
<code>class DurationField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a>
</li> <li>Empty value: <code>None</code>
</li> <li>Normalizes to: A Python <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.timedelta" title="(in Python v3.10)"><code>timedelta</code></a>.</li> <li>Validates that the given value is a string which can be converted into a <code>timedelta</code>. The value must be between <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.timedelta.min" title="(in Python v3.10)"><code>datetime.timedelta.min</code></a> and <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.timedelta.max" title="(in Python v3.10)"><code>datetime.timedelta.max</code></a>.</li> <li>Error message keys: <code>required</code>, <code>invalid</code>, <code>overflow</code>.</li> </ul> <p>Accepts any format understood by <a class="reference internal" href="../utils#django.utils.dateparse.parse_duration" title="django.utils.dateparse.parse_duration"><code>parse_duration()</code></a>.</p> </dd>
</dl>   <h3 id="emailfield"><code>EmailField</code></h3> <dl class="class" id="s-emailfield"> <dt id="django.forms.EmailField">
<code>class EmailField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.EmailInput" title="django.forms.EmailInput"><code>EmailInput</code></a>
</li> <li>Empty value: Whatever you’ve given as <code>empty_value</code>.</li> <li>Normalizes to: A string.</li> <li>Uses <a class="reference internal" href="../validators#django.core.validators.EmailValidator" title="django.core.validators.EmailValidator"><code>EmailValidator</code></a> to validate that the given value is a valid email address, using a moderately complex regular expression.</li> <li>Error message keys: <code>required</code>, <code>invalid</code>
</li> </ul> <p>Has three optional arguments <code>max_length</code>, <code>min_length</code>, and <code>empty_value</code> which work just as they do for <a class="reference internal" href="#django.forms.CharField" title="django.forms.CharField"><code>CharField</code></a>.</p> </dd>
</dl>   <h3 id="filefield"><code>FileField</code></h3> <dl class="class" id="s-filefield"> <dt id="django.forms.FileField">
<code>class FileField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.ClearableFileInput" title="django.forms.ClearableFileInput"><code>ClearableFileInput</code></a>
</li> <li>Empty value: <code>None</code>
</li> <li>Normalizes to: An <code>UploadedFile</code> object that wraps the file content and file name into a single object.</li> <li>Can validate that non-empty file data has been bound to the form.</li> <li>Error message keys: <code>required</code>, <code>invalid</code>, <code>missing</code>, <code>empty</code>, <code>max_length</code>
</li> </ul> <p>Has two optional arguments for validation, <code>max_length</code> and <code>allow_empty_file</code>. If provided, these ensure that the file name is at most the given length, and that validation will succeed even if the file content is empty.</p> <p>To learn more about the <code>UploadedFile</code> object, see the <a class="reference internal" href="../../topics/http/file-uploads"><span class="doc">file uploads documentation</span></a>.</p> <p>When you use a <code>FileField</code> in a form, you must also remember to <a class="reference internal" href="api#binding-uploaded-files"><span class="std std-ref">bind the file data to the form</span></a>.</p> <p>The <code>max_length</code> error refers to the length of the filename. In the error message for that key, <code>%(max)d</code> will be replaced with the maximum filename length and <code>%(length)d</code> will be replaced with the current filename length.</p> </dd>
</dl>   <h3 id="filepathfield"><code>FilePathField</code></h3> <dl class="class" id="s-filepathfield"> <dt id="django.forms.FilePathField">
<code>class FilePathField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.Select" title="django.forms.Select"><code>Select</code></a>
</li> <li>Empty value: <code>''</code> (an empty string)</li> <li>Normalizes to: A string.</li> <li>Validates that the selected choice exists in the list of choices.</li> <li>Error message keys: <code>required</code>, <code>invalid_choice</code>
</li> </ul> <p>The field allows choosing from files inside a certain directory. It takes five extra arguments; only <code>path</code> is required:</p> <dl class="attribute"> <dt id="django.forms.FilePathField.path">
<code>path</code> </dt> <dd>
<p>The absolute path to the directory whose contents you want listed. This directory must exist.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.FilePathField.recursive">
<code>recursive</code> </dt> <dd>
<p>If <code>False</code> (the default) only the direct contents of <code>path</code> will be offered as choices. If <code>True</code>, the directory will be descended into recursively and all descendants will be listed as choices.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.FilePathField.match">
<code>match</code> </dt> <dd>
<p>A regular expression pattern; only files with names matching this expression will be allowed as choices.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.FilePathField.allow_files">
<code>allow_files</code> </dt> <dd>
<p>Optional. Either <code>True</code> or <code>False</code>. Default is <code>True</code>. Specifies whether files in the specified location should be included. Either this or <a class="reference internal" href="#django.forms.FilePathField.allow_folders" title="django.forms.FilePathField.allow_folders"><code>allow_folders</code></a> must be <code>True</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.FilePathField.allow_folders">
<code>allow_folders</code> </dt> <dd>
<p>Optional. Either <code>True</code> or <code>False</code>. Default is <code>False</code>. Specifies whether folders in the specified location should be included. Either this or <a class="reference internal" href="#django.forms.FilePathField.allow_files" title="django.forms.FilePathField.allow_files"><code>allow_files</code></a> must be <code>True</code>.</p> </dd>
</dl> </dd>
</dl>   <h3 id="floatfield"><code>FloatField</code></h3> <dl class="class" id="s-floatfield"> <dt id="django.forms.FloatField">
<code>class FloatField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.NumberInput" title="django.forms.NumberInput"><code>NumberInput</code></a> when <a class="reference internal" href="#django.forms.Field.localize" title="django.forms.Field.localize"><code>Field.localize</code></a> is <code>False</code>, else <a class="reference internal" href="widgets#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a>.</li> <li>Empty value: <code>None</code>
</li> <li>Normalizes to: A Python float.</li> <li>Validates that the given value is a float. Uses <a class="reference internal" href="../validators#django.core.validators.MaxValueValidator" title="django.core.validators.MaxValueValidator"><code>MaxValueValidator</code></a> and <a class="reference internal" href="../validators#django.core.validators.MinValueValidator" title="django.core.validators.MinValueValidator"><code>MinValueValidator</code></a> if <code>max_value</code> and <code>min_value</code> are provided. Leading and trailing whitespace is allowed, as in Python’s <code>float()</code> function.</li> <li>Error message keys: <code>required</code>, <code>invalid</code>, <code>max_value</code>, <code>min_value</code>
</li> </ul> <p>Takes two optional arguments for validation, <code>max_value</code> and <code>min_value</code>. These control the range of values permitted in the field.</p> </dd>
</dl>   <h3 id="genericipaddressfield"><code>GenericIPAddressField</code></h3> <dl class="class" id="s-genericipaddressfield"> <dt id="django.forms.GenericIPAddressField">
<code>class GenericIPAddressField(**kwargs)</code> </dt> <dd>
<p>A field containing either an IPv4 or an IPv6 address.</p> <ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a>
</li> <li>Empty value: <code>''</code> (an empty string)</li> <li>Normalizes to: A string. IPv6 addresses are normalized as described below.</li> <li>Validates that the given value is a valid IP address.</li> <li>Error message keys: <code>required</code>, <code>invalid</code>
</li> </ul> <p>The IPv6 address normalization follows <a class="rfc reference external" href="https://tools.ietf.org/html/rfc4291.html#section-2.2" id="index-0"><strong>RFC 4291#section-2.2</strong></a> section 2.2, including using the IPv4 format suggested in paragraph 3 of that section, like <code>::ffff:192.0.2.0</code>. For example, <code>2001:0::0:01</code> would be normalized to <code>2001::1</code>, and <code>::ffff:0a0a:0a0a</code> to <code>::ffff:10.10.10.10</code>. All characters are converted to lowercase.</p> <p>Takes two optional arguments:</p> <dl class="attribute"> <dt id="django.forms.GenericIPAddressField.protocol">
<code>protocol</code> </dt> <dd>
<p>Limits valid inputs to the specified protocol. Accepted values are <code>both</code> (default), <code>IPv4</code> or <code>IPv6</code>. Matching is case insensitive.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.GenericIPAddressField.unpack_ipv4">
<code>unpack_ipv4</code> </dt> <dd>
<p>Unpacks IPv4 mapped addresses like <code>::ffff:192.0.2.1</code>. If this option is enabled that address would be unpacked to <code>192.0.2.1</code>. Default is disabled. Can only be used when <code>protocol</code> is set to <code>'both'</code>.</p> </dd>
</dl> </dd>
</dl>   <h3 id="imagefield"><code>ImageField</code></h3> <dl class="class" id="s-imagefield"> <dt id="django.forms.ImageField">
<code>class ImageField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.ClearableFileInput" title="django.forms.ClearableFileInput"><code>ClearableFileInput</code></a>
</li> <li>Empty value: <code>None</code>
</li> <li>Normalizes to: An <code>UploadedFile</code> object that wraps the file content and file name into a single object.</li> <li>Validates that file data has been bound to the form. Also uses <a class="reference internal" href="../validators#django.core.validators.FileExtensionValidator" title="django.core.validators.FileExtensionValidator"><code>FileExtensionValidator</code></a> to validate that the file extension is supported by Pillow.</li> <li>Error message keys: <code>required</code>, <code>invalid</code>, <code>missing</code>, <code>empty</code>, <code>invalid_image</code>
</li> </ul> <p>Using an <code>ImageField</code> requires that <a class="reference external" href="https://pillow.readthedocs.io/en/latest/">Pillow</a> is installed with support for the image formats you use. If you encounter a <code>corrupt image</code> error when you upload an image, it usually means that Pillow doesn’t understand its format. To fix this, install the appropriate library and reinstall Pillow.</p> <p>When you use an <code>ImageField</code> on a form, you must also remember to <a class="reference internal" href="api#binding-uploaded-files"><span class="std std-ref">bind the file data to the form</span></a>.</p> <p>After the field has been cleaned and validated, the <code>UploadedFile</code> object will have an additional <code>image</code> attribute containing the Pillow <a class="reference external" href="https://pillow.readthedocs.io/en/latest/reference/Image.html">Image</a> instance used to check if the file was a valid image. Pillow closes the underlying file descriptor after verifying an image, so while non-image data attributes, such as <code>format</code>, <code>height</code>, and <code>width</code>, are available, methods that access the underlying image data, such as <code>getdata()</code> or <code>getpixel()</code>, cannot be used without reopening the file. For example:</p> <pre data-language="python">&gt;&gt;&gt; from PIL import Image
&gt;&gt;&gt; from django import forms
&gt;&gt;&gt; from django.core.files.uploadedfile import SimpleUploadedFile
&gt;&gt;&gt; class ImageForm(forms.Form):
...     img = forms.ImageField()
&gt;&gt;&gt; file_data = {'img': SimpleUploadedFile('test.png', &lt;file data&gt;)}
&gt;&gt;&gt; form = ImageForm({}, file_data)
# Pillow closes the underlying file descriptor.
&gt;&gt;&gt; form.is_valid()
True
&gt;&gt;&gt; image_field = form.cleaned_data['img']
&gt;&gt;&gt; image_field.image
&lt;PIL.PngImagePlugin.PngImageFile image mode=RGBA size=191x287 at 0x7F5985045C18&gt;
&gt;&gt;&gt; image_field.image.width
191
&gt;&gt;&gt; image_field.image.height
287
&gt;&gt;&gt; image_field.image.format
'PNG'
&gt;&gt;&gt; image_field.image.getdata()
# Raises AttributeError: 'NoneType' object has no attribute 'seek'.
&gt;&gt;&gt; image = Image.open(image_field)
&gt;&gt;&gt; image.getdata()
&lt;ImagingCore object at 0x7f5984f874b0&gt;
</pre> <p>Additionally, <code>UploadedFile.content_type</code> will be updated with the image’s content type if Pillow can determine it, otherwise it will be set to <code>None</code>.</p> </dd>
</dl>   <h3 id="integerfield"><code>IntegerField</code></h3> <dl class="class" id="s-integerfield"> <dt id="django.forms.IntegerField">
<code>class IntegerField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.NumberInput" title="django.forms.NumberInput"><code>NumberInput</code></a> when <a class="reference internal" href="#django.forms.Field.localize" title="django.forms.Field.localize"><code>Field.localize</code></a> is <code>False</code>, else <a class="reference internal" href="widgets#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a>.</li> <li>Empty value: <code>None</code>
</li> <li>Normalizes to: A Python integer.</li> <li>Validates that the given value is an integer. Uses <a class="reference internal" href="../validators#django.core.validators.MaxValueValidator" title="django.core.validators.MaxValueValidator"><code>MaxValueValidator</code></a> and <a class="reference internal" href="../validators#django.core.validators.MinValueValidator" title="django.core.validators.MinValueValidator"><code>MinValueValidator</code></a> if <code>max_value</code> and <code>min_value</code> are provided. Leading and trailing whitespace is allowed, as in Python’s <code>int()</code> function.</li> <li>Error message keys: <code>required</code>, <code>invalid</code>, <code>max_value</code>, <code>min_value</code>
</li> </ul> <p>The <code>max_value</code> and <code>min_value</code> error messages may contain <code>%(limit_value)s</code>, which will be substituted by the appropriate limit.</p> <p>Takes two optional arguments for validation:</p> <dl class="attribute"> <dt id="django.forms.IntegerField.max_value">
<code>max_value</code> </dt> 
</dl> <dl class="attribute"> <dt id="django.forms.IntegerField.min_value">
<code>min_value</code> </dt> <dd>
<p>These control the range of values permitted in the field.</p> </dd>
</dl> </dd>
</dl>   <h3 id="jsonfield"><code>JSONField</code></h3> <dl class="class" id="s-jsonfield"> <dt id="django.forms.JSONField">
<code>class JSONField(encoder=None, decoder=None, **kwargs)</code> </dt> <dd>
<p>A field which accepts JSON encoded data for a <a class="reference internal" href="../models/fields#django.db.models.JSONField" title="django.db.models.JSONField"><code>JSONField</code></a>.</p> <ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.Textarea" title="django.forms.Textarea"><code>Textarea</code></a>
</li> <li>Empty value: <code>None</code>
</li> <li>Normalizes to: A Python representation of the JSON value (usually as a <code>dict</code>, <code>list</code>, or <code>None</code>), depending on <a class="reference internal" href="#django.forms.JSONField.decoder" title="django.forms.JSONField.decoder"><code>JSONField.decoder</code></a>.</li> <li>Validates that the given value is a valid JSON.</li> <li>Error message keys: <code>required</code>, <code>invalid</code>
</li> </ul> <p>Takes two optional arguments:</p> <dl class="attribute"> <dt id="django.forms.JSONField.encoder">
<code>encoder</code> </dt> <dd>
<p>A <a class="reference external" href="https://docs.python.org/3/library/json.html#json.JSONEncoder" title="(in Python v3.10)"><code>json.JSONEncoder</code></a> subclass to serialize data types not supported by the standard JSON serializer (e.g. <code>datetime.datetime</code> or <a class="reference external" href="https://docs.python.org/3/library/uuid.html#uuid.UUID" title="(in Python v3.10)"><code>UUID</code></a>). For example, you can use the <a class="reference internal" href="../../topics/serialization#django.core.serializers.json.DjangoJSONEncoder" title="django.core.serializers.json.DjangoJSONEncoder"><code>DjangoJSONEncoder</code></a> class.</p> <p>Defaults to <code>json.JSONEncoder</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.JSONField.decoder">
<code>decoder</code> </dt> <dd>
<p>A <a class="reference external" href="https://docs.python.org/3/library/json.html#json.JSONDecoder" title="(in Python v3.10)"><code>json.JSONDecoder</code></a> subclass to deserialize the input. Your deserialization may need to account for the fact that you can’t be certain of the input type. For example, you run the risk of returning a <code>datetime</code> that was actually a string that just happened to be in the same format chosen for <code>datetime</code>s.</p> <p>The <code>decoder</code> can be used to validate the input. If <a class="reference external" href="https://docs.python.org/3/library/json.html#json.JSONDecodeError" title="(in Python v3.10)"><code>json.JSONDecodeError</code></a> is raised during the deserialization, a <code>ValidationError</code> will be raised.</p> <p>Defaults to <code>json.JSONDecoder</code>.</p> </dd>
</dl> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">If you use a <a class="reference internal" href="../../topics/forms/modelforms#django.forms.ModelForm" title="django.forms.ModelForm"><code>ModelForm</code></a>, the <code>encoder</code> and <code>decoder</code> from <a class="reference internal" href="../models/fields#django.db.models.JSONField" title="django.db.models.JSONField"><code>JSONField</code></a> will be used.</p> </div> <div class="admonition-user-friendly-forms admonition"> <p class="first admonition-title">User friendly forms</p> <p class="last"><code>JSONField</code> is not particularly user friendly in most cases. However, it is a useful way to format data from a client-side widget for submission to the server.</p> </div> </dd>
</dl>   <h3 id="multiplechoicefield"><code>MultipleChoiceField</code></h3> <dl class="class" id="s-multiplechoicefield"> <dt id="django.forms.MultipleChoiceField">
<code>class MultipleChoiceField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.SelectMultiple" title="django.forms.SelectMultiple"><code>SelectMultiple</code></a>
</li> <li>Empty value: <code>[]</code> (an empty list)</li> <li>Normalizes to: A list of strings.</li> <li>Validates that every value in the given list of values exists in the list of choices.</li> <li>Error message keys: <code>required</code>, <code>invalid_choice</code>, <code>invalid_list</code>
</li> </ul> <p>The <code>invalid_choice</code> error message may contain <code>%(value)s</code>, which will be replaced with the selected choice.</p> <p>Takes one extra required argument, <code>choices</code>, as for <a class="reference internal" href="#django.forms.ChoiceField" title="django.forms.ChoiceField"><code>ChoiceField</code></a>.</p> </dd>
</dl>   <h3 id="nullbooleanfield"><code>NullBooleanField</code></h3> <dl class="class" id="s-nullbooleanfield"> <dt id="django.forms.NullBooleanField">
<code>class NullBooleanField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.NullBooleanSelect" title="django.forms.NullBooleanSelect"><code>NullBooleanSelect</code></a>
</li> <li>Empty value: <code>None</code>
</li> <li>Normalizes to: A Python <code>True</code>, <code>False</code> or <code>None</code> value.</li> <li>Validates nothing (i.e., it never raises a <code>ValidationError</code>).</li> </ul> <p><code>NullBooleanField</code> may be used with widgets such as <a class="reference internal" href="widgets#django.forms.Select" title="django.forms.Select"><code>Select</code></a> or <a class="reference internal" href="widgets#django.forms.RadioSelect" title="django.forms.RadioSelect"><code>RadioSelect</code></a> by providing the widget <code>choices</code>:</p> <pre data-language="python">NullBooleanField(
    widget=Select(
        choices=[
            ('', 'Unknown'),
            (True, 'Yes'),
            (False, 'No'),
        ]
    )
)
</pre> </dd>
</dl>   <h3 id="regexfield"><code>RegexField</code></h3> <dl class="class" id="s-regexfield"> <dt id="django.forms.RegexField">
<code>class RegexField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a>
</li> <li>Empty value: Whatever you’ve given as <code>empty_value</code>.</li> <li>Normalizes to: A string.</li> <li>Uses <a class="reference internal" href="../validators#django.core.validators.RegexValidator" title="django.core.validators.RegexValidator"><code>RegexValidator</code></a> to validate that the given value matches a certain regular expression.</li> <li>Error message keys: <code>required</code>, <code>invalid</code>
</li> </ul> <p>Takes one required argument:</p> <dl class="attribute"> <dt id="django.forms.RegexField.regex">
<code>regex</code> </dt> <dd>
<p>A regular expression specified either as a string or a compiled regular expression object.</p> </dd>
</dl> <p>Also takes <code>max_length</code>, <code>min_length</code>, <code>strip</code>, and <code>empty_value</code> which work just as they do for <a class="reference internal" href="#django.forms.CharField" title="django.forms.CharField"><code>CharField</code></a>.</p> <dl class="attribute"> <dt id="django.forms.RegexField.strip">
<code>strip</code> </dt> <dd>
<p>Defaults to <code>False</code>. If enabled, stripping will be applied before the regex validation.</p> </dd>
</dl> </dd>
</dl>   <h3 id="slugfield"><code>SlugField</code></h3> <dl class="class" id="s-slugfield"> <dt id="django.forms.SlugField">
<code>class SlugField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a>
</li> <li>Empty value: Whatever you’ve given as <a class="reference internal" href="#django.forms.SlugField.empty_value" title="django.forms.SlugField.empty_value"><code>empty_value</code></a>.</li> <li>Normalizes to: A string.</li> <li>Uses <a class="reference internal" href="../validators#django.core.validators.validate_slug" title="django.core.validators.validate_slug"><code>validate_slug</code></a> or <a class="reference internal" href="../validators#django.core.validators.validate_unicode_slug" title="django.core.validators.validate_unicode_slug"><code>validate_unicode_slug</code></a> to validate that the given value contains only letters, numbers, underscores, and hyphens.</li> <li>Error messages: <code>required</code>, <code>invalid</code>
</li> </ul> <p>This field is intended for use in representing a model <a class="reference internal" href="../models/fields#django.db.models.SlugField" title="django.db.models.SlugField"><code>SlugField</code></a> in forms.</p> <p>Takes two optional parameters:</p> <dl class="attribute"> <dt id="django.forms.SlugField.allow_unicode">
<code>allow_unicode</code> </dt> <dd>
<p>A boolean instructing the field to accept Unicode letters in addition to ASCII letters. Defaults to <code>False</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.SlugField.empty_value">
<code>empty_value</code> </dt> <dd>
<p>The value to use to represent “empty”. Defaults to an empty string.</p> </dd>
</dl> </dd>
</dl>   <h3 id="timefield"><code>TimeField</code></h3> <dl class="class" id="s-timefield"> <dt id="django.forms.TimeField">
<code>class TimeField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.TimeInput" title="django.forms.TimeInput"><code>TimeInput</code></a>
</li> <li>Empty value: <code>None</code>
</li> <li>Normalizes to: A Python <code>datetime.time</code> object.</li> <li>Validates that the given value is either a <code>datetime.time</code> or string formatted in a particular time format.</li> <li>Error message keys: <code>required</code>, <code>invalid</code>
</li> </ul> <p>Takes one optional argument:</p> <dl class="attribute"> <dt id="django.forms.TimeField.input_formats">
<code>input_formats</code> </dt> <dd>
<p>A list of formats used to attempt to convert a string to a valid <code>datetime.time</code> object.</p> </dd>
</dl> <p>If no <code>input_formats</code> argument is provided, the default input formats are taken from <a class="reference internal" href="../settings#std:setting-TIME_INPUT_FORMATS"><code>TIME_INPUT_FORMATS</code></a> if <a class="reference internal" href="../settings#std:setting-USE_L10N"><code>USE_L10N</code></a> is <code>False</code>, or from the active locale format <code>TIME_INPUT_FORMATS</code> key if localization is enabled. See also <a class="reference internal" href="../../topics/i18n/formatting"><span class="doc">format localization</span></a>.</p> </dd>
</dl>   <h3 id="typedchoicefield"><code>TypedChoiceField</code></h3> <dl class="class" id="s-typedchoicefield"> <dt id="django.forms.TypedChoiceField">
<code>class TypedChoiceField(**kwargs)</code> </dt> <dd>
<p>Just like a <a class="reference internal" href="#django.forms.ChoiceField" title="django.forms.ChoiceField"><code>ChoiceField</code></a>, except <a class="reference internal" href="#django.forms.TypedChoiceField" title="django.forms.TypedChoiceField"><code>TypedChoiceField</code></a> takes two extra arguments, <a class="reference internal" href="#django.forms.TypedChoiceField.coerce" title="django.forms.TypedChoiceField.coerce"><code>coerce</code></a> and <a class="reference internal" href="#django.forms.TypedChoiceField.empty_value" title="django.forms.TypedChoiceField.empty_value"><code>empty_value</code></a>.</p> <ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.Select" title="django.forms.Select"><code>Select</code></a>
</li> <li>Empty value: Whatever you’ve given as <a class="reference internal" href="#django.forms.TypedChoiceField.empty_value" title="django.forms.TypedChoiceField.empty_value"><code>empty_value</code></a>.</li> <li>Normalizes to: A value of the type provided by the <a class="reference internal" href="#django.forms.TypedChoiceField.coerce" title="django.forms.TypedChoiceField.coerce"><code>coerce</code></a> argument.</li> <li>Validates that the given value exists in the list of choices and can be coerced.</li> <li>Error message keys: <code>required</code>, <code>invalid_choice</code>
</li> </ul> <p>Takes extra arguments:</p> <dl class="attribute"> <dt id="django.forms.TypedChoiceField.coerce">
<code>coerce</code> </dt> <dd>
<p>A function that takes one argument and returns a coerced value. Examples include the built-in <code>int</code>, <code>float</code>, <code>bool</code> and other types. Defaults to an identity function. Note that coercion happens after input validation, so it is possible to coerce to a value not present in <code>choices</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.TypedChoiceField.empty_value">
<code>empty_value</code> </dt> <dd>
<p>The value to use to represent “empty.” Defaults to the empty string; <code>None</code> is another common choice here. Note that this value will not be coerced by the function given in the <code>coerce</code> argument, so choose it accordingly.</p> </dd>
</dl> </dd>
</dl>   <h3 id="typedmultiplechoicefield"><code>TypedMultipleChoiceField</code></h3> <dl class="class" id="s-typedmultiplechoicefield"> <dt id="django.forms.TypedMultipleChoiceField">
<code>class TypedMultipleChoiceField(**kwargs)</code> </dt> <dd>
<p>Just like a <a class="reference internal" href="#django.forms.MultipleChoiceField" title="django.forms.MultipleChoiceField"><code>MultipleChoiceField</code></a>, except <a class="reference internal" href="#django.forms.TypedMultipleChoiceField" title="django.forms.TypedMultipleChoiceField"><code>TypedMultipleChoiceField</code></a> takes two extra arguments, <code>coerce</code> and <code>empty_value</code>.</p> <ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.SelectMultiple" title="django.forms.SelectMultiple"><code>SelectMultiple</code></a>
</li> <li>Empty value: Whatever you’ve given as <code>empty_value</code>
</li> <li>Normalizes to: A list of values of the type provided by the <code>coerce</code> argument.</li> <li>Validates that the given values exists in the list of choices and can be coerced.</li> <li>Error message keys: <code>required</code>, <code>invalid_choice</code>
</li> </ul> <p>The <code>invalid_choice</code> error message may contain <code>%(value)s</code>, which will be replaced with the selected choice.</p> <p>Takes two extra arguments, <code>coerce</code> and <code>empty_value</code>, as for <a class="reference internal" href="#django.forms.TypedChoiceField" title="django.forms.TypedChoiceField"><code>TypedChoiceField</code></a>.</p> </dd>
</dl>   <h3 id="urlfield"><code>URLField</code></h3> <dl class="class" id="s-urlfield"> <dt id="django.forms.URLField">
<code>class URLField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.URLInput" title="django.forms.URLInput"><code>URLInput</code></a>
</li> <li>Empty value: Whatever you’ve given as <code>empty_value</code>.</li> <li>Normalizes to: A string.</li> <li>Uses <a class="reference internal" href="../validators#django.core.validators.URLValidator" title="django.core.validators.URLValidator"><code>URLValidator</code></a> to validate that the given value is a valid URL.</li> <li>Error message keys: <code>required</code>, <code>invalid</code>
</li> </ul> <p>Has three optional arguments <code>max_length</code>, <code>min_length</code>, and <code>empty_value</code> which work just as they do for <a class="reference internal" href="#django.forms.CharField" title="django.forms.CharField"><code>CharField</code></a>.</p> </dd>
</dl>   <h3 id="uuidfield"><code>UUIDField</code></h3> <dl class="class" id="s-uuidfield"> <dt id="django.forms.UUIDField">
<code>class UUIDField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a>
</li> <li>Empty value: <code>None</code>
</li> <li>Normalizes to: A <a class="reference external" href="https://docs.python.org/3/library/uuid.html#uuid.UUID" title="(in Python v3.10)"><code>UUID</code></a> object.</li> <li>Error message keys: <code>required</code>, <code>invalid</code>
</li> </ul> <p>This field will accept any string format accepted as the <code>hex</code> argument to the <a class="reference external" href="https://docs.python.org/3/library/uuid.html#uuid.UUID" title="(in Python v3.10)"><code>UUID</code></a> constructor.</p> </dd>
</dl>    <h2 id="slightly-complex-built-in-field-classes">Slightly complex built-in <code>Field</code> classes</h2>  <h3 id="combofield"><code>ComboField</code></h3> <dl class="class" id="s-slightly-complex-built-in-field-classes"> <dt id="django.forms.ComboField">
<code>class ComboField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a>
</li> <li>Empty value: <code>''</code> (an empty string)</li> <li>Normalizes to: A string.</li> <li>Validates the given value against each of the fields specified as an argument to the <code>ComboField</code>.</li> <li>Error message keys: <code>required</code>, <code>invalid</code>
</li> </ul> <p>Takes one extra required argument:</p> <dl class="attribute"> <dt id="django.forms.ComboField.fields">
<code>fields</code> </dt> <dd>
<p>The list of fields that should be used to validate the field’s value (in the order in which they are provided).</p> <pre data-language="python">&gt;&gt;&gt; from django.forms import ComboField
&gt;&gt;&gt; f = ComboField(fields=[CharField(max_length=20), EmailField()])
&gt;&gt;&gt; f.clean('test@example.com')
'test@example.com'
&gt;&gt;&gt; f.clean('longemailaddress@example.com')
Traceback (most recent call last):
...
ValidationError: ['Ensure this value has at most 20 characters (it has 28).']
</pre> </dd>
</dl> </dd>
</dl>   <h3 id="multivaluefield"><code>MultiValueField</code></h3> <dl class="class" id="s-multivaluefield"> <dt id="django.forms.MultiValueField">
<code>class MultiValueField(fields=(), **kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a>
</li> <li>Empty value: <code>''</code> (an empty string)</li> <li>Normalizes to: the type returned by the <code>compress</code> method of the subclass.</li> <li>Validates the given value against each of the fields specified as an argument to the <code>MultiValueField</code>.</li> <li>Error message keys: <code>required</code>, <code>invalid</code>, <code>incomplete</code>
</li> </ul> <p>Aggregates the logic of multiple fields that together produce a single value.</p> <p>This field is abstract and must be subclassed. In contrast with the single-value fields, subclasses of <a class="reference internal" href="#django.forms.MultiValueField" title="django.forms.MultiValueField"><code>MultiValueField</code></a> must not implement <a class="reference internal" href="#django.forms.Field.clean" title="django.forms.Field.clean"><code>clean()</code></a> but instead - implement <a class="reference internal" href="#django.forms.MultiValueField.compress" title="django.forms.MultiValueField.compress"><code>compress()</code></a>.</p> <p>Takes one extra required argument:</p> <dl class="attribute"> <dt id="django.forms.MultiValueField.fields">
<code>fields</code> </dt> <dd>
<p>A tuple of fields whose values are cleaned and subsequently combined into a single value. Each value of the field is cleaned by the corresponding field in <code>fields</code> – the first value is cleaned by the first field, the second value is cleaned by the second field, etc. Once all fields are cleaned, the list of clean values is combined into a single value by <a class="reference internal" href="#django.forms.MultiValueField.compress" title="django.forms.MultiValueField.compress"><code>compress()</code></a>.</p> </dd>
</dl> <p>Also takes some optional arguments:</p> <dl class="attribute"> <dt id="django.forms.MultiValueField.require_all_fields">
<code>require_all_fields</code> </dt> <dd>
<p>Defaults to <code>True</code>, in which case a <code>required</code> validation error will be raised if no value is supplied for any field.</p> <p>When set to <code>False</code>, the <a class="reference internal" href="#django.forms.Field.required" title="django.forms.Field.required"><code>Field.required</code></a> attribute can be set to <code>False</code> for individual fields to make them optional. If no value is supplied for a required field, an <code>incomplete</code> validation error will be raised.</p> <p>A default <code>incomplete</code> error message can be defined on the <a class="reference internal" href="#django.forms.MultiValueField" title="django.forms.MultiValueField"><code>MultiValueField</code></a> subclass, or different messages can be defined on each individual field. For example:</p> <pre data-language="python">from django.core.validators import RegexValidator

class PhoneField(MultiValueField):
    def __init__(self, **kwargs):
        # Define one message for all fields.
        error_messages = {
            'incomplete': 'Enter a country calling code and a phone number.',
        }
        # Or define a different message for each field.
        fields = (
            CharField(
                error_messages={'incomplete': 'Enter a country calling code.'},
                validators=[
                    RegexValidator(r'^[0-9]+$', 'Enter a valid country calling code.'),
                ],
            ),
            CharField(
                error_messages={'incomplete': 'Enter a phone number.'},
                validators=[RegexValidator(r'^[0-9]+$', 'Enter a valid phone number.')],
            ),
            CharField(
                validators=[RegexValidator(r'^[0-9]+$', 'Enter a valid extension.')],
                required=False,
            ),
        )
        super().__init__(
            error_messages=error_messages, fields=fields,
            require_all_fields=False, **kwargs
        )
</pre> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.MultiValueField.widget">
<code>widget</code> </dt> <dd>
<p>Must be a subclass of <a class="reference internal" href="widgets#django.forms.MultiWidget" title="django.forms.MultiWidget"><code>django.forms.MultiWidget</code></a>. Default value is <a class="reference internal" href="widgets#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a>, which probably is not very useful in this case.</p> </dd>
</dl> <dl class="method"> <dt id="django.forms.MultiValueField.compress">
<code>compress(data_list)</code> </dt> <dd>
<p>Takes a list of valid values and returns a “compressed” version of those values – in a single value. For example, <a class="reference internal" href="#django.forms.SplitDateTimeField" title="django.forms.SplitDateTimeField"><code>SplitDateTimeField</code></a> is a subclass which combines a time field and a date field into a <code>datetime</code> object.</p> <p>This method must be implemented in the subclasses.</p> </dd>
</dl> </dd>
</dl>   <h3 id="splitdatetimefield"><code>SplitDateTimeField</code></h3> <dl class="class" id="s-splitdatetimefield"> <dt id="django.forms.SplitDateTimeField">
<code>class SplitDateTimeField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.SplitDateTimeWidget" title="django.forms.SplitDateTimeWidget"><code>SplitDateTimeWidget</code></a>
</li> <li>Empty value: <code>None</code>
</li> <li>Normalizes to: A Python <code>datetime.datetime</code> object.</li> <li>Validates that the given value is a <code>datetime.datetime</code> or string formatted in a particular datetime format.</li> <li>Error message keys: <code>required</code>, <code>invalid</code>, <code>invalid_date</code>, <code>invalid_time</code>
</li> </ul> <p>Takes two optional arguments:</p> <dl class="attribute"> <dt id="django.forms.SplitDateTimeField.input_date_formats">
<code>input_date_formats</code> </dt> <dd>
<p>A list of formats used to attempt to convert a string to a valid <code>datetime.date</code> object.</p> </dd>
</dl> <p>If no <code>input_date_formats</code> argument is provided, the default input formats for <a class="reference internal" href="#django.forms.DateField" title="django.forms.DateField"><code>DateField</code></a> are used.</p> <dl class="attribute"> <dt id="django.forms.SplitDateTimeField.input_time_formats">
<code>input_time_formats</code> </dt> <dd>
<p>A list of formats used to attempt to convert a string to a valid <code>datetime.time</code> object.</p> </dd>
</dl> <p>If no <code>input_time_formats</code> argument is provided, the default input formats for <a class="reference internal" href="#django.forms.TimeField" title="django.forms.TimeField"><code>TimeField</code></a> are used.</p> </dd>
</dl>    <h2 id="id2">Fields which handle relationships</h2> <p id="s-fields-which-handle-relationships">Two fields are available for representing relationships between models: <a class="reference internal" href="#django.forms.ModelChoiceField" title="django.forms.ModelChoiceField"><code>ModelChoiceField</code></a> and <a class="reference internal" href="#django.forms.ModelMultipleChoiceField" title="django.forms.ModelMultipleChoiceField"><code>ModelMultipleChoiceField</code></a>. Both of these fields require a single <code>queryset</code> parameter that is used to create the choices for the field. Upon form validation, these fields will place either one model object (in the case of <code>ModelChoiceField</code>) or multiple model objects (in the case of <code>ModelMultipleChoiceField</code>) into the <code>cleaned_data</code> dictionary of the form.</p> <p>For more complex uses, you can specify <code>queryset=None</code> when declaring the form field and then populate the <code>queryset</code> in the form’s <code>__init__()</code> method:</p> <pre data-language="python">class FooMultipleChoiceForm(forms.Form):
    foo_select = forms.ModelMultipleChoiceField(queryset=None)

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields['foo_select'].queryset = ...
</pre> <p>Both <code>ModelChoiceField</code> and <code>ModelMultipleChoiceField</code> have an <code>iterator</code> attribute which specifies the class used to iterate over the queryset when generating choices. See <a class="reference internal" href="#iterating-relationship-choices"><span class="std std-ref">Iterating relationship choices</span></a> for details.</p>  <h3 id="modelchoicefield"><code>ModelChoiceField</code></h3> <dl class="class" id="s-modelchoicefield"> <dt id="django.forms.ModelChoiceField">
<code>class ModelChoiceField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.Select" title="django.forms.Select"><code>Select</code></a>
</li> <li>Empty value: <code>None</code>
</li> <li>Normalizes to: A model instance.</li> <li>Validates that the given id exists in the queryset.</li> <li>Error message keys: <code>required</code>, <code>invalid_choice</code>
</li> </ul> <p>The <code>invalid_choice</code> error message may contain <code>%(value)s</code>, which will be replaced with the selected choice.</p> <p>Allows the selection of a single model object, suitable for representing a foreign key. Note that the default widget for <code>ModelChoiceField</code> becomes impractical when the number of entries increases. You should avoid using it for more than 100 items.</p> <p>A single argument is required:</p> <dl class="attribute"> <dt id="django.forms.ModelChoiceField.queryset">
<code>queryset</code> </dt> <dd>
<p>A <code>QuerySet</code> of model objects from which the choices for the field are derived and which is used to validate the user’s selection. It’s evaluated when the form is rendered.</p> </dd>
</dl> <p><code>ModelChoiceField</code> also takes two optional arguments:</p> <dl class="attribute"> <dt id="django.forms.ModelChoiceField.empty_label">
<code>empty_label</code> </dt> <dd>
<p>By default the <code>&lt;select&gt;</code> widget used by <code>ModelChoiceField</code> will have an empty choice at the top of the list. You can change the text of this label (which is <code>"---------"</code> by default) with the <code>empty_label</code> attribute, or you can disable the empty label entirely by setting <code>empty_label</code> to <code>None</code>:</p> <pre data-language="python"># A custom empty label
field1 = forms.ModelChoiceField(queryset=..., empty_label="(Nothing)")

# No empty label
field2 = forms.ModelChoiceField(queryset=..., empty_label=None)
</pre> <p>Note that if a <code>ModelChoiceField</code> is required and has a default initial value, no empty choice is created (regardless of the value of <code>empty_label</code>).</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.ModelChoiceField.to_field_name">
<code>to_field_name</code> </dt> <dd>
<p>This optional argument is used to specify the field to use as the value of the choices in the field’s widget. Be sure it’s a unique field for the model, otherwise the selected value could match more than one object. By default it is set to <code>None</code>, in which case the primary key of each object will be used. For example:</p> <pre data-language="python"># No custom to_field_name
field1 = forms.ModelChoiceField(queryset=...)
</pre> <p>would yield:</p> <pre data-language="html">&lt;select id="id_field1" name="field1"&gt;
&lt;option value="obj1.pk"&gt;Object1&lt;/option&gt;
&lt;option value="obj2.pk"&gt;Object2&lt;/option&gt;
...
&lt;/select&gt;
</pre> <p>and:</p> <pre data-language="python"># to_field_name provided
field2 = forms.ModelChoiceField(queryset=..., to_field_name="name")
</pre> <p>would yield:</p> <pre data-language="html">&lt;select id="id_field2" name="field2"&gt;
&lt;option value="obj1.name"&gt;Object1&lt;/option&gt;
&lt;option value="obj2.name"&gt;Object2&lt;/option&gt;
...
&lt;/select&gt;
</pre> </dd>
</dl> <p><code>ModelChoiceField</code> also has the attribute:</p> <dl class="attribute"> <dt id="django.forms.ModelChoiceField.iterator">
<code>iterator</code> </dt> <dd>
<p>The iterator class used to generate field choices from <code>queryset</code>. By default, <a class="reference internal" href="#django.forms.ModelChoiceIterator" title="django.forms.ModelChoiceIterator"><code>ModelChoiceIterator</code></a>.</p> </dd>
</dl> <p>The <code>__str__()</code> method of the model will be called to generate string representations of the objects for use in the field’s choices. To provide customized representations, subclass <code>ModelChoiceField</code> and override <code>label_from_instance</code>. This method will receive a model object and should return a string suitable for representing it. For example:</p> <pre data-language="python">from django.forms import ModelChoiceField

class MyModelChoiceField(ModelChoiceField):
    def label_from_instance(self, obj):
        return "My Object #%i" % obj.id
</pre> <div class="versionchanged"> <span class="title">Changed in Django 4.0:</span> <p>Support for containing <code>%(value)s</code> in the <code>invalid_choice</code> error message was added.</p> </div> </dd>
</dl>   <h3 id="modelmultiplechoicefield"><code>ModelMultipleChoiceField</code></h3> <dl class="class" id="s-modelmultiplechoicefield"> <dt id="django.forms.ModelMultipleChoiceField">
<code>class ModelMultipleChoiceField(**kwargs)</code> </dt> <dd>
<ul class="simple"> <li>Default widget: <a class="reference internal" href="widgets#django.forms.SelectMultiple" title="django.forms.SelectMultiple"><code>SelectMultiple</code></a>
</li> <li>Empty value: An empty <code>QuerySet</code> (<code>self.queryset.none()</code>)</li> <li>Normalizes to: A <code>QuerySet</code> of model instances.</li> <li>Validates that every id in the given list of values exists in the queryset.</li> <li>Error message keys: <code>required</code>, <code>invalid_list</code>, <code>invalid_choice</code>, <code>invalid_pk_value</code>
</li> </ul> <p>The <code>invalid_choice</code> message may contain <code>%(value)s</code> and the <code>invalid_pk_value</code> message may contain <code>%(pk)s</code>, which will be substituted by the appropriate values.</p> <p>Allows the selection of one or more model objects, suitable for representing a many-to-many relation. As with <a class="reference internal" href="#django.forms.ModelChoiceField" title="django.forms.ModelChoiceField"><code>ModelChoiceField</code></a>, you can use <code>label_from_instance</code> to customize the object representations.</p> <p>A single argument is required:</p> <dl class="attribute"> <dt id="django.forms.ModelMultipleChoiceField.queryset">
<code>queryset</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#django.forms.ModelChoiceField.queryset" title="django.forms.ModelChoiceField.queryset"><code>ModelChoiceField.queryset</code></a>.</p> </dd>
</dl> <p>Takes one optional argument:</p> <dl class="attribute"> <dt id="django.forms.ModelMultipleChoiceField.to_field_name">
<code>to_field_name</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#django.forms.ModelChoiceField.to_field_name" title="django.forms.ModelChoiceField.to_field_name"><code>ModelChoiceField.to_field_name</code></a>.</p> </dd>
</dl> <p><code>ModelMultipleChoiceField</code> also has the attribute:</p> <dl class="attribute"> <dt id="django.forms.ModelMultipleChoiceField.iterator">
<code>iterator</code> </dt> <dd>
<p>Same as <a class="reference internal" href="#django.forms.ModelChoiceField.iterator" title="django.forms.ModelChoiceField.iterator"><code>ModelChoiceField.iterator</code></a>.</p> </dd>
</dl> </dd>
</dl>   <h3 id="id3">Iterating relationship choices</h3> <p id="s-iterating-relationship-choices">By default, <a class="reference internal" href="#django.forms.ModelChoiceField" title="django.forms.ModelChoiceField"><code>ModelChoiceField</code></a> and <a class="reference internal" href="#django.forms.ModelMultipleChoiceField" title="django.forms.ModelMultipleChoiceField"><code>ModelMultipleChoiceField</code></a> use <a class="reference internal" href="#django.forms.ModelChoiceIterator" title="django.forms.ModelChoiceIterator"><code>ModelChoiceIterator</code></a> to generate their field <code>choices</code>.</p> <p>When iterated, <code>ModelChoiceIterator</code> yields 2-tuple choices containing <a class="reference internal" href="#django.forms.ModelChoiceIteratorValue" title="django.forms.ModelChoiceIteratorValue"><code>ModelChoiceIteratorValue</code></a> instances as the first <code>value</code> element in each choice. <code>ModelChoiceIteratorValue</code> wraps the choice value while maintaining a reference to the source model instance that can be used in custom widget implementations, for example, to add <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/data-*">data-* attributes</a> to <code>&lt;option&gt;</code> elements.</p> <p>For example, consider the following models:</p> <pre data-language="python">from django.db import models

class Topping(models.Model):
    name = models.CharField(max_length=100)
    price = models.DecimalField(decimal_places=2, max_digits=6)

    def __str__(self):
        return self.name

class Pizza(models.Model):
    topping = models.ForeignKey(Topping, on_delete=models.CASCADE)
</pre> <p>You can use a <a class="reference internal" href="widgets#django.forms.Select" title="django.forms.Select"><code>Select</code></a> widget subclass to include the value of <code>Topping.price</code> as the HTML attribute <code>data-price</code> for each <code>&lt;option&gt;</code> element:</p> <pre data-language="python">from django import forms

class ToppingSelect(forms.Select):
    def create_option(self, name, value, label, selected, index, subindex=None, attrs=None):
        option = super().create_option(name, value, label, selected, index, subindex, attrs)
        if value:
            option['attrs']['data-price'] = value.instance.price
        return option

class PizzaForm(forms.ModelForm):
    class Meta:
        model = Pizza
        fields = ['topping']
        widgets = {'topping': ToppingSelect}
</pre> <p>This will render the <code>Pizza.topping</code> select as:</p> <pre data-language="html">&lt;select id="id_topping" name="topping" required&gt;
&lt;option value="" selected&gt;---------&lt;/option&gt;
&lt;option value="1" data-price="1.50"&gt;mushrooms&lt;/option&gt;
&lt;option value="2" data-price="1.25"&gt;onions&lt;/option&gt;
&lt;option value="3" data-price="1.75"&gt;peppers&lt;/option&gt;
&lt;option value="4" data-price="2.00"&gt;pineapple&lt;/option&gt;
&lt;/select&gt;
</pre> <p>For more advanced usage you may subclass <code>ModelChoiceIterator</code> in order to customize the yielded 2-tuple choices.</p>  <h4 id="modelchoiceiterator"><code>ModelChoiceIterator</code></h4> <dl class="class" id="s-modelchoiceiterator"> <dt id="django.forms.ModelChoiceIterator">
<code>class ModelChoiceIterator(field)</code> </dt> <dd>
<p>The default class assigned to the <code>iterator</code> attribute of <a class="reference internal" href="#django.forms.ModelChoiceField" title="django.forms.ModelChoiceField"><code>ModelChoiceField</code></a> and <a class="reference internal" href="#django.forms.ModelMultipleChoiceField" title="django.forms.ModelMultipleChoiceField"><code>ModelMultipleChoiceField</code></a>. An iterable that yields 2-tuple choices from the queryset.</p> <p>A single argument is required:</p> <dl class="attribute"> <dt id="django.forms.ModelChoiceIterator.field">
<code>field</code> </dt> <dd>
<p>The instance of <code>ModelChoiceField</code> or <code>ModelMultipleChoiceField</code> to iterate and yield choices.</p> </dd>
</dl> <p><code>ModelChoiceIterator</code> has the following method:</p> <dl class="method"> <dt id="django.forms.ModelChoiceIterator.__iter__">
<code>__iter__()</code> </dt> <dd>
<p>Yields 2-tuple choices, in the <code>(value, label)</code> format used by <a class="reference internal" href="#django.forms.ChoiceField.choices" title="django.forms.ChoiceField.choices"><code>ChoiceField.choices</code></a>. The first <code>value</code> element is a <a class="reference internal" href="#django.forms.ModelChoiceIteratorValue" title="django.forms.ModelChoiceIteratorValue"><code>ModelChoiceIteratorValue</code></a> instance.</p> </dd>
</dl> </dd>
</dl>   <h4 id="modelchoiceiteratorvalue"><code>ModelChoiceIteratorValue</code></h4> <dl class="class" id="s-modelchoiceiteratorvalue"> <dt id="django.forms.ModelChoiceIteratorValue">
<code>class ModelChoiceIteratorValue(value, instance)</code> </dt> <dd>
<p>Two arguments are required:</p> <dl class="attribute"> <dt id="django.forms.ModelChoiceIteratorValue.value">
<code>value</code> </dt> <dd>
<p>The value of the choice. This value is used to render the <code>value</code> attribute of an HTML <code>&lt;option&gt;</code> element.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.forms.ModelChoiceIteratorValue.instance">
<code>instance</code> </dt> <dd>
<p>The model instance from the queryset. The instance can be accessed in custom <code>ChoiceWidget.create_option()</code> implementations to adjust the rendered HTML.</p> </dd>
</dl> <p><code>ModelChoiceIteratorValue</code> has the following method:</p> <dl class="method"> <dt id="django.forms.ModelChoiceIteratorValue.__str__">
<code>__str__()</code> </dt> <dd>
<p>Return <code>value</code> as a string to be rendered in HTML.</p> </dd>
</dl> </dd>
</dl>     <h2 id="creating-custom-fields">Creating custom fields</h2> <p id="s-creating-custom-fields">If the built-in <code>Field</code> classes don’t meet your needs, you can create custom <code>Field</code> classes. To do this, create a subclass of <code>django.forms.Field</code>. Its only requirements are that it implement a <code>clean()</code> method and that its <code>__init__()</code> method accept the core arguments mentioned above (<code>required</code>, <code>label</code>, <code>initial</code>, <code>widget</code>, <code>help_text</code>).</p> <p>You can also customize how a field will be accessed by overriding <a class="reference internal" href="api#django.forms.Field.get_bound_field" title="django.forms.Field.get_bound_field"><code>get_bound_field()</code></a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/4.0/ref/forms/fields/" class="_attribution-link">https://docs.djangoproject.com/en/4.0/ref/forms/fields/</a>
  </p>
</div>
