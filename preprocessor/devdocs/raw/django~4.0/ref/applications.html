<h1 id="applications">Applications</h1> <p id="s-module-django.apps">Django contains a registry of installed applications that stores configuration and provides introspection. It also maintains a list of available <a class="reference internal" href="../topics/db/models"><span class="doc">models</span></a>.</p> <p>This registry is called <a class="reference internal" href="#django.apps.apps" title="django.apps.apps"><code>apps</code></a> and it’s available in <a class="reference internal" href="#module-django.apps" title="django.apps"><code>django.apps</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; from django.apps import apps
&gt;&gt;&gt; apps.get_app_config('admin').verbose_name
'Administration'
</pre>  <h2 id="projects-and-applications">Projects and applications</h2> <p id="s-projects-and-applications">The term <strong>project</strong> describes a Django web application. The project Python package is defined primarily by a settings module, but it usually contains other things. For example, when you run <code>django-admin startproject mysite</code> you’ll get a <code>mysite</code> project directory that contains a <code>mysite</code> Python package with <code>settings.py</code>, <code>urls.py</code>, <code>asgi.py</code> and <code>wsgi.py</code>. The project package is often extended to include things like fixtures, CSS, and templates which aren’t tied to a particular application.</p> <p>A <strong>project’s root directory</strong> (the one that contains <code>manage.py</code>) is usually the container for all of a project’s applications which aren’t installed separately.</p> <p>The term <strong>application</strong> describes a Python package that provides some set of features. Applications <a class="reference internal" href="../intro/reusable-apps"><span class="doc">may be reused</span></a> in various projects.</p> <p>Applications include some combination of models, views, templates, template tags, static files, URLs, middleware, etc. They’re generally wired into projects with the <a class="reference internal" href="settings#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a> setting and optionally with other mechanisms such as URLconfs, the <a class="reference internal" href="settings#std:setting-MIDDLEWARE"><code>MIDDLEWARE</code></a> setting, or template inheritance.</p> <p>It is important to understand that a Django application is a set of code that interacts with various parts of the framework. There’s no such thing as an <code>Application</code> object. However, there’s a few places where Django needs to interact with installed applications, mainly for configuration and also for introspection. That’s why the application registry maintains metadata in an <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code>AppConfig</code></a> instance for each installed application.</p> <p>There’s no restriction that a project package can’t also be considered an application and have models, etc. (which would require adding it to <a class="reference internal" href="settings#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a>).</p>   <h2 id="configuring-applications-ref">Configuring applications</h2> <p id="s-configuring-applications">To configure an application, create an <code>apps.py</code> module inside the application, then define a subclass of <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code>AppConfig</code></a> there.</p> <p>When <a class="reference internal" href="settings#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a> contains the dotted path to an application module, by default, if Django finds exactly one <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code>AppConfig</code></a> subclass in the <code>apps.py</code> submodule, it uses that configuration for the application. This behavior may be disabled by setting <a class="reference internal" href="#django.apps.AppConfig.default" title="django.apps.AppConfig.default"><code>AppConfig.default</code></a> to <code>False</code>.</p> <p>If the <code>apps.py</code> module contains more than one <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code>AppConfig</code></a> subclass, Django will look for a single one where <a class="reference internal" href="#django.apps.AppConfig.default" title="django.apps.AppConfig.default"><code>AppConfig.default</code></a> is <code>True</code>.</p> <p>If no <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code>AppConfig</code></a> subclass is found, the base <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code>AppConfig</code></a> class will be used.</p> <p>Alternatively, <a class="reference internal" href="settings#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a> may contain the dotted path to a configuration class to specify it explicitly:</p> <pre data-language="python">INSTALLED_APPS = [
    ...
    'polls.apps.PollsAppConfig',
    ...
]
</pre>  <h3 id="for-application-authors">For application authors</h3> <p id="s-for-application-authors">If you’re creating a pluggable app called “Rock ’n’ roll”, here’s how you would provide a proper name for the admin:</p> <pre data-language="python"># rock_n_roll/apps.py

from django.apps import AppConfig

class RockNRollConfig(AppConfig):
    name = 'rock_n_roll'
    verbose_name = "Rock ’n’ roll"
</pre> <p><code>RockNRollConfig</code> will be loaded automatically when <a class="reference internal" href="settings#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a> contains <code>'rock_n_roll'</code>. If you need to prevent this, set <a class="reference internal" href="#django.apps.AppConfig.default" title="django.apps.AppConfig.default"><code>default</code></a> to <code>False</code> in the class definition.</p> <p>You can provide several <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code>AppConfig</code></a> subclasses with different behaviors. To tell Django which one to use by default, set <a class="reference internal" href="#django.apps.AppConfig.default" title="django.apps.AppConfig.default"><code>default</code></a> to <code>True</code> in its definition. If your users want to pick a non-default configuration, they must replace <code>'rock_n_roll'</code> with the dotted path to that specific class in their <a class="reference internal" href="settings#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a> setting.</p> <p>The <a class="reference internal" href="#django.apps.AppConfig.name" title="django.apps.AppConfig.name"><code>AppConfig.name</code></a> attribute tells Django which application this configuration applies to. You can define any other attribute documented in the <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code>AppConfig</code></a> API reference.</p> <p><a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code>AppConfig</code></a> subclasses may be defined anywhere. The <code>apps.py</code> convention merely allows Django to load them automatically when <a class="reference internal" href="settings#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a> contains the path to an application module rather than the path to a configuration class.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>If your code imports the application registry in an application’s <code>__init__.py</code>, the name <code>apps</code> will clash with the <code>apps</code> submodule. The best practice is to move that code to a submodule and import it. A workaround is to import the registry under a different name:</p> <pre data-language="python">from django.apps import apps as django_apps
</pre> </div> <div class="versionchanged"> <span class="title">Changed in Django 3.2:</span> <p>In previous versions, a <code>default_app_config</code> variable in the application module was used to identify the default application configuration class.</p> </div>   <h3 id="for-application-users">For application users</h3> <p id="s-for-application-users">If you’re using “Rock ’n’ roll” in a project called <code>anthology</code>, but you want it to show up as “Jazz Manouche” instead, you can provide your own configuration:</p> <pre data-language="python"># anthology/apps.py

from rock_n_roll.apps import RockNRollConfig

class JazzManoucheConfig(RockNRollConfig):
    verbose_name = "Jazz Manouche"

# anthology/settings.py

INSTALLED_APPS = [
    'anthology.apps.JazzManoucheConfig',
    # ...
]
</pre> <p>This example shows project-specific configuration classes located in a submodule called <code>apps.py</code>. This is a convention, not a requirement. <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code>AppConfig</code></a> subclasses may be defined anywhere.</p> <p>In this situation, <a class="reference internal" href="settings#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a> must contain the dotted path to the configuration class because it lives outside of an application and thus cannot be automatically detected.</p>    <h2 id="application-configuration">Application configuration</h2> <dl class="class" id="s-application-configuration"> <dt id="django.apps.AppConfig">
<code>class AppConfig</code> </dt> <dd>
<p>Application configuration objects store metadata for an application. Some attributes can be configured in <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code>AppConfig</code></a> subclasses. Others are set by Django and read-only.</p> </dd>
</dl>  <h3 id="configurable-attributes">Configurable attributes</h3> <dl class="attribute" id="s-configurable-attributes"> <dt id="django.apps.AppConfig.name">
<code>AppConfig.name</code> </dt> <dd>
<p>Full Python path to the application, e.g. <code>'django.contrib.admin'</code>.</p> <p>This attribute defines which application the configuration applies to. It must be set in all <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code>AppConfig</code></a> subclasses.</p> <p>It must be unique across a Django project.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.apps.AppConfig.label">
<code>AppConfig.label</code> </dt> <dd>
<p>Short name for the application, e.g. <code>'admin'</code></p> <p>This attribute allows relabeling an application when two applications have conflicting labels. It defaults to the last component of <code>name</code>. It should be a valid Python identifier.</p> <p>It must be unique across a Django project.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.apps.AppConfig.verbose_name">
<code>AppConfig.verbose_name</code> </dt> <dd>
<p>Human-readable name for the application, e.g. “Administration”.</p> <p>This attribute defaults to <code>label.title()</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.apps.AppConfig.path">
<code>AppConfig.path</code> </dt> <dd>
<p>Filesystem path to the application directory, e.g. <code>'/usr/lib/pythonX.Y/dist-packages/django/contrib/admin'</code>.</p> <p>In most cases, Django can automatically detect and set this, but you can also provide an explicit override as a class attribute on your <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code>AppConfig</code></a> subclass. In a few situations this is required; for instance if the app package is a <a class="reference internal" href="#namespace-package">namespace package</a> with multiple paths.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.apps.AppConfig.default">
<code>AppConfig.default</code> </dt> <dd>
<div class="versionadded"> <span class="title">New in Django 3.2.</span> </div> <p>Set this attribute to <code>False</code> to prevent Django from selecting a configuration class automatically. This is useful when <code>apps.py</code> defines only one <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code>AppConfig</code></a> subclass but you don’t want Django to use it by default.</p> <p>Set this attribute to <code>True</code> to tell Django to select a configuration class automatically. This is useful when <code>apps.py</code> defines more than one <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code>AppConfig</code></a> subclass and you want Django to use one of them by default.</p> <p>By default, this attribute isn’t set.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.apps.AppConfig.default_auto_field">
<code>AppConfig.default_auto_field</code> </dt> <dd>
<div class="versionadded"> <span class="title">New in Django 3.2.</span> </div> <p>The implicit primary key type to add to models within this app. You can use this to keep <a class="reference internal" href="models/fields#django.db.models.AutoField" title="django.db.models.AutoField"><code>AutoField</code></a> as the primary key type for third party applications.</p> <p>By default, this is the value of <a class="reference internal" href="settings#std:setting-DEFAULT_AUTO_FIELD"><code>DEFAULT_AUTO_FIELD</code></a>.</p> </dd>
</dl>   <h3 id="read-only-attributes">Read-only attributes</h3> <dl class="attribute" id="s-read-only-attributes"> <dt id="django.apps.AppConfig.module">
<code>AppConfig.module</code> </dt> <dd>
<p>Root module for the application, e.g. <code>&lt;module 'django.contrib.admin' from
'django/contrib/admin/__init__.py'&gt;</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.apps.AppConfig.models_module">
<code>AppConfig.models_module</code> </dt> <dd>
<p>Module containing the models, e.g. <code>&lt;module 'django.contrib.admin.models'
from 'django/contrib/admin/models.py'&gt;</code>.</p> <p>It may be <code>None</code> if the application doesn’t contain a <code>models</code> module. Note that the database related signals such as <a class="reference internal" href="signals#django.db.models.signals.pre_migrate" title="django.db.models.signals.pre_migrate"><code>pre_migrate</code></a> and <a class="reference internal" href="signals#django.db.models.signals.post_migrate" title="django.db.models.signals.post_migrate"><code>post_migrate</code></a> are only emitted for applications that have a <code>models</code> module.</p> </dd>
</dl>   <h3 id="methods">Methods</h3> <dl class="method" id="s-methods"> <dt id="django.apps.AppConfig.get_models">
<code>AppConfig.get_models()</code> </dt> <dd>
<p>Returns an iterable of <a class="reference internal" href="models/instances#django.db.models.Model" title="django.db.models.Model"><code>Model</code></a> classes for this application.</p> <p>Requires the app registry to be fully populated.</p> </dd>
</dl> <dl class="method"> <dt id="django.apps.AppConfig.get_model">
<code>AppConfig.get_model(model_name, require_ready=True)</code> </dt> <dd>
<p>Returns the <a class="reference internal" href="models/instances#django.db.models.Model" title="django.db.models.Model"><code>Model</code></a> with the given <code>model_name</code>. <code>model_name</code> is case-insensitive.</p> <p>Raises <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#LookupError" title="(in Python v3.10)"><code>LookupError</code></a> if no such model exists in this application.</p> <p>Requires the app registry to be fully populated unless the <code>require_ready</code> argument is set to <code>False</code>. <code>require_ready</code> behaves exactly as in <a class="reference internal" href="#django.apps.apps.get_model" title="django.apps.apps.get_model"><code>apps.get_model()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="django.apps.AppConfig.ready">
<code>AppConfig.ready()</code> </dt> <dd>
<p>Subclasses can override this method to perform initialization tasks such as registering signals. It is called as soon as the registry is fully populated.</p> <p>Although you can’t import models at the module-level where <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code>AppConfig</code></a> classes are defined, you can import them in <code>ready()</code>, using either an <code>import</code> statement or <a class="reference internal" href="#django.apps.AppConfig.get_model" title="django.apps.AppConfig.get_model"><code>get_model()</code></a>.</p> <p>If you’re registering <a class="reference internal" href="signals#module-django.db.models.signals" title="django.db.models.signals: Signals sent by the model system."><code>model signals</code></a>, you can refer to the sender by its string label instead of using the model class itself.</p> <p>Example:</p> <pre data-language="python">from django.apps import AppConfig
from django.db.models.signals import pre_save


class RockNRollConfig(AppConfig):
    # ...

    def ready(self):
        # importing model classes
        from .models import MyModel  # or...
        MyModel = self.get_model('MyModel')

        # registering signals with the model's string label
        pre_save.connect(receiver, sender='app_label.MyModel')
</pre> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">Although you can access model classes as described above, avoid interacting with the database in your <a class="reference internal" href="#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code>ready()</code></a> implementation. This includes model methods that execute queries (<a class="reference internal" href="models/instances#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a>, <a class="reference internal" href="models/instances#django.db.models.Model.delete" title="django.db.models.Model.delete"><code>delete()</code></a>, manager methods etc.), and also raw SQL queries via <code>django.db.connection</code>. Your <a class="reference internal" href="#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code>ready()</code></a> method will run during startup of every management command. For example, even though the test database configuration is separate from the production settings, <code>manage.py test</code> would still execute some queries against your <strong>production</strong> database!</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">In the usual initialization process, the <code>ready</code> method is only called once by Django. But in some corner cases, particularly in tests which are fiddling with installed applications, <code>ready</code> might be called more than once. In that case, either write idempotent methods, or put a flag on your <code>AppConfig</code> classes to prevent re-running code which should be executed exactly one time.</p> </div> </dd>
</dl>   <h3 id="namespace-package">Namespace packages as apps</h3> <p id="s-namespace-packages-as-apps">Python packages without an <code>__init__.py</code> file are known as “namespace packages” and may be spread across multiple directories at different locations on <code>sys.path</code> (see <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0420" id="index-0"><strong>PEP 420</strong></a>).</p> <p>Django applications require a single base filesystem path where Django (depending on configuration) will search for templates, static assets, etc. Thus, namespace packages may only be Django applications if one of the following is true:</p> <ol class="arabic simple"> <li>The namespace package actually has only a single location (i.e. is not spread across more than one directory.)</li> <li>The <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code>AppConfig</code></a> class used to configure the application has a <a class="reference internal" href="#django.apps.AppConfig.path" title="django.apps.AppConfig.path"><code>path</code></a> class attribute, which is the absolute directory path Django will use as the single base path for the application.</li> </ol> <p>If neither of these conditions is met, Django will raise <a class="reference internal" href="exceptions#django.core.exceptions.ImproperlyConfigured" title="django.core.exceptions.ImproperlyConfigured"><code>ImproperlyConfigured</code></a>.</p>    <h2 id="application-registry">Application registry</h2> <dl class="data" id="s-application-registry"> <dt id="django.apps.apps">
<code>apps</code> </dt> <dd>
<p>The application registry provides the following public API. Methods that aren’t listed below are considered private and may change without notice.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.apps.apps.ready">
<code>apps.ready</code> </dt> <dd>
<p>Boolean attribute that is set to <code>True</code> after the registry is fully populated and all <a class="reference internal" href="#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code>AppConfig.ready()</code></a> methods are called.</p> </dd>
</dl> <dl class="method"> <dt id="django.apps.apps.get_app_configs">
<code>apps.get_app_configs()</code> </dt> <dd>
<p>Returns an iterable of <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code>AppConfig</code></a> instances.</p> </dd>
</dl> <dl class="method"> <dt id="django.apps.apps.get_app_config">
<code>apps.get_app_config(app_label)</code> </dt> <dd>
<p>Returns an <a class="reference internal" href="#django.apps.AppConfig" title="django.apps.AppConfig"><code>AppConfig</code></a> for the application with the given <code>app_label</code>. Raises <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#LookupError" title="(in Python v3.10)"><code>LookupError</code></a> if no such application exists.</p> </dd>
</dl> <dl class="method"> <dt id="django.apps.apps.is_installed">
<code>apps.is_installed(app_name)</code> </dt> <dd>
<p>Checks whether an application with the given name exists in the registry. <code>app_name</code> is the full name of the app, e.g. <code>'django.contrib.admin'</code>.</p> </dd>
</dl> <dl class="method"> <dt id="django.apps.apps.get_model">
<code>apps.get_model(app_label, model_name, require_ready=True)</code> </dt> <dd>
<p>Returns the <a class="reference internal" href="models/instances#django.db.models.Model" title="django.db.models.Model"><code>Model</code></a> with the given <code>app_label</code> and <code>model_name</code>. As a shortcut, this method also accepts a single argument in the form <code>app_label.model_name</code>. <code>model_name</code> is case-insensitive.</p> <p>Raises <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#LookupError" title="(in Python v3.10)"><code>LookupError</code></a> if no such application or model exists. Raises <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.10)"><code>ValueError</code></a> when called with a single argument that doesn’t contain exactly one dot.</p> <p>Requires the app registry to be fully populated unless the <code>require_ready</code> argument is set to <code>False</code>.</p> <p>Setting <code>require_ready</code> to <code>False</code> allows looking up models <a class="reference internal" href="#app-loading-process"><span class="std std-ref">while the app registry is being populated</span></a>, specifically during the second phase where it imports models. Then <code>get_model()</code> has the same effect as importing the model. The main use case is to configure model classes with settings, such as <a class="reference internal" href="settings#std:setting-AUTH_USER_MODEL"><code>AUTH_USER_MODEL</code></a>.</p> <p>When <code>require_ready</code> is <code>False</code>, <code>get_model()</code> returns a model class that may not be fully functional (reverse accessors may be missing, for example) until the app registry is fully populated. For this reason, it’s best to leave <code>require_ready</code> to the default value of <code>True</code> whenever possible.</p> </dd>
</dl>   <h2 id="app-loading-process">Initialization process</h2>  <h3 id="how-applications-are-loaded">How applications are loaded</h3> <p id="s-initialization-process">When Django starts, <a class="reference internal" href="#django.setup" title="django.setup"><code>django.setup()</code></a> is responsible for populating the application registry.</p> <dl class="function"> <dt id="django.setup">
<code>setup(set_prefix=True)</code> <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/_modules/django/#setup"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Configures Django by:</p> <ul class="simple"> <li>Loading the settings.</li> <li>Setting up logging.</li> <li>If <code>set_prefix</code> is True, setting the URL resolver script prefix to <a class="reference internal" href="settings#std:setting-FORCE_SCRIPT_NAME"><code>FORCE_SCRIPT_NAME</code></a> if defined, or <code>/</code> otherwise.</li> <li>Initializing the application registry.</li> </ul> <p>This function is called automatically:</p> <ul class="simple"> <li>When running an HTTP server via Django’s WSGI support.</li> <li>When invoking a management command.</li> </ul> <p>It must be called explicitly in other cases, for instance in plain Python scripts.</p> </dd>
</dl> <p>The application registry is initialized in three stages. At each stage, Django processes all applications in the order of <a class="reference internal" href="settings#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a>.</p> <ol class="arabic"> <li>
<p class="first">First Django imports each item in <a class="reference internal" href="settings#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a>.</p> <p>If it’s an application configuration class, Django imports the root package of the application, defined by its <a class="reference internal" href="#django.apps.AppConfig.name" title="django.apps.AppConfig.name"><code>name</code></a> attribute. If it’s a Python package, Django looks for an application configuration in an <code>apps.py</code> submodule, or else creates a default application configuration.</p> <p><em>At this stage, your code shouldn’t import any models!</em></p> <p>In other words, your applications’ root packages and the modules that define your application configuration classes shouldn’t import any models, even indirectly.</p> <p>Strictly speaking, Django allows importing models once their application configuration is loaded. However, in order to avoid needless constraints on the order of <a class="reference internal" href="settings#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a>, it’s strongly recommended not import any models at this stage.</p> <p>Once this stage completes, APIs that operate on application configurations such as <a class="reference internal" href="#django.apps.apps.get_app_config" title="django.apps.apps.get_app_config"><code>get_app_config()</code></a> become usable.</p> </li> <li>
<p class="first">Then Django attempts to import the <code>models</code> submodule of each application, if there is one.</p> <p>You must define or import all models in your application’s <code>models.py</code> or <code>models/__init__.py</code>. Otherwise, the application registry may not be fully populated at this point, which could cause the ORM to malfunction.</p> <p>Once this stage completes, APIs that operate on models such as <a class="reference internal" href="#django.apps.apps.get_model" title="django.apps.apps.get_model"><code>get_model()</code></a> become usable.</p> </li> <li>Finally Django runs the <a class="reference internal" href="#django.apps.AppConfig.ready" title="django.apps.AppConfig.ready"><code>ready()</code></a> method of each application configuration. </li> </ol>   <h3 id="applications-troubleshooting">Troubleshooting</h3> <p id="s-troubleshooting">Here are some common problems that you may encounter during initialization:</p> <ul> <li>
<p class="first"><a class="reference internal" href="exceptions#django.core.exceptions.AppRegistryNotReady" title="django.core.exceptions.AppRegistryNotReady"><code>AppRegistryNotReady</code></a>: This happens when importing an application configuration or a models module triggers code that depends on the app registry.</p> <p>For example, <a class="reference internal" href="utils#django.utils.translation.gettext" title="django.utils.translation.gettext"><code>gettext()</code></a> uses the app registry to look up translation catalogs in applications. To translate at import time, you need <a class="reference internal" href="utils#django.utils.translation.gettext_lazy" title="django.utils.translation.gettext_lazy"><code>gettext_lazy()</code></a> instead. (Using <a class="reference internal" href="utils#django.utils.translation.gettext" title="django.utils.translation.gettext"><code>gettext()</code></a> would be a bug, because the translation would happen at import time, rather than at each request depending on the active language.)</p> <p>Executing database queries with the ORM at import time in models modules will also trigger this exception. The ORM cannot function properly until all models are available.</p> <p>This exception also happens if you forget to call <a class="reference internal" href="#django.setup" title="django.setup"><code>django.setup()</code></a> in a standalone Python script.</p> </li> <li>
<p class="first"><code>ImportError: cannot import name ...</code> This happens if the import sequence ends up in a loop.</p> <p>To eliminate such problems, you should minimize dependencies between your models modules and do as little work as possible at import time. To avoid executing code at import time, you can move it into a function and cache its results. The code will be executed when you first need its results. This concept is known as “lazy evaluation”.</p> </li> <li>
<code>django.contrib.admin</code> automatically performs autodiscovery of <code>admin</code> modules in installed applications. To prevent it, change your <a class="reference internal" href="settings#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a> to contain <code>'django.contrib.admin.apps.SimpleAdminConfig'</code> instead of <code>'django.contrib.admin'</code>. </li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/4.0/ref/applications/" class="_attribution-link">https://docs.djangoproject.com/en/4.0/ref/applications/</a>
  </p>
</div>
