<h1 id="the-contenttypes-framework">The contenttypes framework</h1> <p id="s-module-django.contrib.contenttypes">Django includes a <a class="reference internal" href="#module-django.contrib.contenttypes" title="django.contrib.contenttypes: Provides generic interface to installed models."><code>contenttypes</code></a> application that can track all of the models installed in your Django-powered project, providing a high-level, generic interface for working with your models.</p>  <h2 id="overview">Overview</h2> <p id="s-overview">At the heart of the contenttypes application is the <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> model, which lives at <code>django.contrib.contenttypes.models.ContentType</code>. Instances of <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> represent and store information about the models installed in your project, and new instances of <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> are automatically created whenever new models are installed.</p> <p>Instances of <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> have methods for returning the model classes they represent and for querying objects from those models. <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> also has a <a class="reference internal" href="../../topics/db/managers#custom-managers"><span class="std std-ref">custom manager</span></a> that adds methods for working with <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> and for obtaining instances of <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> for a particular model.</p> <p>Relations between your models and <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> can also be used to enable “generic” relationships between an instance of one of your models and instances of any model you have installed.</p>   <h2 id="installing-the-contenttypes-framework">Installing the contenttypes framework</h2> <p id="s-installing-the-contenttypes-framework">The contenttypes framework is included in the default <a class="reference internal" href="../settings#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a> list created by <code>django-admin startproject</code>, but if you’ve removed it or if you manually set up your <a class="reference internal" href="../settings#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a> list, you can enable it by adding <code>'django.contrib.contenttypes'</code> to your <a class="reference internal" href="../settings#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a> setting.</p> <p>It’s generally a good idea to have the contenttypes framework installed; several of Django’s other bundled applications require it:</p> <ul class="simple"> <li>The admin application uses it to log the history of each object added or changed through the admin interface.</li> <li>Django’s <a class="reference internal" href="../../topics/auth/index#module-django.contrib.auth" title="django.contrib.auth: Django's authentication framework."><code>authentication framework</code></a> uses it to tie user permissions to specific models.</li> </ul>   <h2 id="the-contenttype-model">The <code>ContentType</code> model</h2> <dl class="class" id="s-the-contenttype-model"> <dt id="django.contrib.contenttypes.models.ContentType">
<code>class ContentType</code> </dt> <dd>
<p>Each instance of <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> has two fields which, taken together, uniquely describe an installed model:</p> <dl class="attribute"> <dt id="django.contrib.contenttypes.models.ContentType.app_label">
<code>app_label</code> </dt> <dd>
<p>The name of the application the model is part of. This is taken from the <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType.app_label" title="django.contrib.contenttypes.models.ContentType.app_label"><code>app_label</code></a> attribute of the model, and includes only the <em>last</em> part of the application’s Python import path; <code>django.contrib.contenttypes</code>, for example, becomes an <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType.app_label" title="django.contrib.contenttypes.models.ContentType.app_label"><code>app_label</code></a> of <code>contenttypes</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.contrib.contenttypes.models.ContentType.model">
<code>model</code> </dt> <dd>
<p>The name of the model class.</p> </dd>
</dl> <p>Additionally, the following property is available:</p> <dl class="attribute"> <dt id="django.contrib.contenttypes.models.ContentType.name">
<code>name</code> </dt> <dd>
<p>The human-readable name of the content type. This is taken from the <a class="reference internal" href="../models/fields#django.db.models.Field.verbose_name" title="django.db.models.Field.verbose_name"><code>verbose_name</code></a> attribute of the model.</p> </dd>
</dl> </dd>
</dl> <p>Let’s look at an example to see how this works. If you already have the <a class="reference internal" href="#module-django.contrib.contenttypes" title="django.contrib.contenttypes: Provides generic interface to installed models."><code>contenttypes</code></a> application installed, and then add <a class="reference internal" href="sites#module-django.contrib.sites" title="django.contrib.sites: Lets you operate multiple websites from the same database and Django project"><code>the sites application</code></a> to your <a class="reference internal" href="../settings#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a> setting and run <code>manage.py migrate</code> to install it, the model <a class="reference internal" href="sites#django.contrib.sites.models.Site" title="django.contrib.sites.models.Site"><code>django.contrib.sites.models.Site</code></a> will be installed into your database. Along with it a new instance of <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> will be created with the following values:</p> <ul class="simple"> <li>
<a class="reference internal" href="#django.contrib.contenttypes.models.ContentType.app_label" title="django.contrib.contenttypes.models.ContentType.app_label"><code>app_label</code></a> will be set to <code>'sites'</code> (the last part of the Python path <code>django.contrib.sites</code>).</li> <li>
<a class="reference internal" href="#django.contrib.contenttypes.models.ContentType.model" title="django.contrib.contenttypes.models.ContentType.model"><code>model</code></a> will be set to <code>'site'</code>.</li> </ul>   <h2 id="methods-on-contenttype-instances">Methods on <code>ContentType</code> instances</h2> <p id="s-methods-on-contenttype-instances">Each <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> instance has methods that allow you to get from a <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> instance to the model it represents, or to retrieve objects from that model:</p> <dl class="method"> <dt id="django.contrib.contenttypes.models.ContentType.get_object_for_this_type">
<code>ContentType.get_object_for_this_type(**kwargs)</code> </dt> <dd>
<p>Takes a set of valid <a class="reference internal" href="../../topics/db/queries#field-lookups-intro"><span class="std std-ref">lookup arguments</span></a> for the model the <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> represents, and does <a class="reference internal" href="../models/querysets#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code>a get() lookup</code></a> on that model, returning the corresponding object.</p> </dd>
</dl> <dl class="method"> <dt id="django.contrib.contenttypes.models.ContentType.model_class">
<code>ContentType.model_class()</code> </dt> <dd>
<p>Returns the model class represented by this <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> instance.</p> </dd>
</dl> <p>For example, we could look up the <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> for the <a class="reference internal" href="auth#django.contrib.auth.models.User" title="django.contrib.auth.models.User"><code>User</code></a> model:</p> <pre data-language="python">&gt;&gt;&gt; from django.contrib.contenttypes.models import ContentType
&gt;&gt;&gt; user_type = ContentType.objects.get(app_label='auth', model='user')
&gt;&gt;&gt; user_type
&lt;ContentType: user&gt;
</pre> <p>And then use it to query for a particular <a class="reference internal" href="auth#django.contrib.auth.models.User" title="django.contrib.auth.models.User"><code>User</code></a>, or to get access to the <code>User</code> model class:</p> <pre data-language="python">&gt;&gt;&gt; user_type.model_class()
&lt;class 'django.contrib.auth.models.User'&gt;
&gt;&gt;&gt; user_type.get_object_for_this_type(username='Guido')
&lt;User: Guido&gt;
</pre> <p>Together, <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType.get_object_for_this_type" title="django.contrib.contenttypes.models.ContentType.get_object_for_this_type"><code>get_object_for_this_type()</code></a> and <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType.model_class" title="django.contrib.contenttypes.models.ContentType.model_class"><code>model_class()</code></a> enable two extremely important use cases:</p> <ol class="arabic simple"> <li>Using these methods, you can write high-level generic code that performs queries on any installed model – instead of importing and using a single specific model class, you can pass an <code>app_label</code> and <code>model</code> into a <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> lookup at runtime, and then work with the model class or retrieve objects from it.</li> <li>You can relate another model to <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> as a way of tying instances of it to particular model classes, and use these methods to get access to those model classes.</li> </ol> <p>Several of Django’s bundled applications make use of the latter technique. For example, <a class="reference internal" href="auth#django.contrib.auth.models.Permission" title="django.contrib.auth.models.Permission"><code>the permissions system</code></a> in Django’s authentication framework uses a <a class="reference internal" href="auth#django.contrib.auth.models.Permission" title="django.contrib.auth.models.Permission"><code>Permission</code></a> model with a foreign key to <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a>; this lets <a class="reference internal" href="auth#django.contrib.auth.models.Permission" title="django.contrib.auth.models.Permission"><code>Permission</code></a> represent concepts like “can add blog entry” or “can delete news story”.</p>  <h3 id="the-contenttypemanager">The <code>ContentTypeManager</code>
</h3> <dl class="class" id="s-the-contenttypemanager"> <dt id="django.contrib.contenttypes.models.ContentTypeManager">
<code>class ContentTypeManager</code> </dt> <dd>
<p><a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> also has a custom manager, <a class="reference internal" href="#django.contrib.contenttypes.models.ContentTypeManager" title="django.contrib.contenttypes.models.ContentTypeManager"><code>ContentTypeManager</code></a>, which adds the following methods:</p> <dl class="method"> <dt id="django.contrib.contenttypes.models.ContentTypeManager.clear_cache">
<code>clear_cache()</code> </dt> <dd>
<p>Clears an internal cache used by <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> to keep track of models for which it has created <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> instances. You probably won’t ever need to call this method yourself; Django will call it automatically when it’s needed.</p> </dd>
</dl> <dl class="method"> <dt id="django.contrib.contenttypes.models.ContentTypeManager.get_for_id">
<code>get_for_id(id)</code> </dt> <dd>
<p>Lookup a <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> by ID. Since this method uses the same shared cache as <a class="reference internal" href="#django.contrib.contenttypes.models.ContentTypeManager.get_for_model" title="django.contrib.contenttypes.models.ContentTypeManager.get_for_model"><code>get_for_model()</code></a>, it’s preferred to use this method over the usual <code>ContentType.objects.get(pk=id)</code></p> </dd>
</dl> <dl class="method"> <dt id="django.contrib.contenttypes.models.ContentTypeManager.get_for_model">
<code>get_for_model(model, for_concrete_model=True)</code> </dt> <dd>
<p>Takes either a model class or an instance of a model, and returns the <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> instance representing that model. <code>for_concrete_model=False</code> allows fetching the <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> of a proxy model.</p> </dd>
</dl> <dl class="method"> <dt id="django.contrib.contenttypes.models.ContentTypeManager.get_for_models">
<code>get_for_models(*models, for_concrete_models=True)</code> </dt> <dd>
<p>Takes a variadic number of model classes, and returns a dictionary mapping the model classes to the <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> instances representing them. <code>for_concrete_models=False</code> allows fetching the <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> of proxy models.</p> </dd>
</dl> <dl class="method"> <dt id="django.contrib.contenttypes.models.ContentTypeManager.get_by_natural_key">
<code>get_by_natural_key(app_label, model)</code> </dt> <dd>
<p>Returns the <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> instance uniquely identified by the given application label and model name. The primary purpose of this method is to allow <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> objects to be referenced via a <a class="reference internal" href="../../topics/serialization#topics-serialization-natural-keys"><span class="std std-ref">natural key</span></a> during deserialization.</p> </dd>
</dl> </dd>
</dl> <p>The <a class="reference internal" href="#django.contrib.contenttypes.models.ContentTypeManager.get_for_model" title="django.contrib.contenttypes.models.ContentTypeManager.get_for_model"><code>get_for_model()</code></a> method is especially useful when you know you need to work with a <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> but don’t want to go to the trouble of obtaining the model’s metadata to perform a manual lookup:</p> <pre data-language="python" id="module-django.contrib.contenttypes.fields">&gt;&gt;&gt; from django.contrib.auth.models import User
&gt;&gt;&gt; ContentType.objects.get_for_model(User)
&lt;ContentType: user&gt;
</pre>    <h2 id="id1">Generic relations</h2> <p id="s-generic-relations">Adding a foreign key from one of your own models to <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> allows your model to effectively tie itself to another model class, as in the example of the <a class="reference internal" href="auth#django.contrib.auth.models.Permission" title="django.contrib.auth.models.Permission"><code>Permission</code></a> model above. But it’s possible to go one step further and use <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> to enable truly generic (sometimes called “polymorphic”) relationships between models.</p> <p>For example, it could be used for a tagging system like so:</p> <pre data-language="python">from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType
from django.db import models

class TaggedItem(models.Model):
    tag = models.SlugField()
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey('content_type', 'object_id')

    def __str__(self):
        return self.tag
</pre> <p>A normal <a class="reference internal" href="../models/fields#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a> can only “point to” one other model, which means that if the <code>TaggedItem</code> model used a <a class="reference internal" href="../models/fields#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a> it would have to choose one and only one model to store tags for. The contenttypes application provides a special field type (<code>GenericForeignKey</code>) which works around this and allows the relationship to be with any model:</p> <dl class="class"> <dt id="django.contrib.contenttypes.fields.GenericForeignKey">
<code>class GenericForeignKey</code> </dt> <dd>
<p>There are three parts to setting up a <a class="reference internal" href="#django.contrib.contenttypes.fields.GenericForeignKey" title="django.contrib.contenttypes.fields.GenericForeignKey"><code>GenericForeignKey</code></a>:</p> <ol class="arabic simple"> <li>Give your model a <a class="reference internal" href="../models/fields#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a> to <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a>. The usual name for this field is “content_type”.</li> <li>Give your model a field that can store primary key values from the models you’ll be relating to. For most models, this means a <a class="reference internal" href="../models/fields#django.db.models.PositiveIntegerField" title="django.db.models.PositiveIntegerField"><code>PositiveIntegerField</code></a>. The usual name for this field is “object_id”.</li> <li>Give your model a <a class="reference internal" href="#django.contrib.contenttypes.fields.GenericForeignKey" title="django.contrib.contenttypes.fields.GenericForeignKey"><code>GenericForeignKey</code></a>, and pass it the names of the two fields described above. If these fields are named “content_type” and “object_id”, you can omit this – those are the default field names <a class="reference internal" href="#django.contrib.contenttypes.fields.GenericForeignKey" title="django.contrib.contenttypes.fields.GenericForeignKey"><code>GenericForeignKey</code></a> will look for.</li> </ol> <dl class="attribute"> <dt id="django.contrib.contenttypes.fields.GenericForeignKey.for_concrete_model">
<code>for_concrete_model</code> </dt> <dd>
<p>If <code>False</code>, the field will be able to reference proxy models. Default is <code>True</code>. This mirrors the <code>for_concrete_model</code> argument to <a class="reference internal" href="#django.contrib.contenttypes.models.ContentTypeManager.get_for_model" title="django.contrib.contenttypes.models.ContentTypeManager.get_for_model"><code>get_for_model()</code></a>.</p> </dd>
</dl> </dd>
</dl> <div class="admonition-primary-key-type-compatibility admonition"> <p class="first admonition-title">Primary key type compatibility</p> <p>The “object_id” field doesn’t have to be the same type as the primary key fields on the related models, but their primary key values must be coercible to the same type as the “object_id” field by its <a class="reference internal" href="../models/fields#django.db.models.Field.get_db_prep_value" title="django.db.models.Field.get_db_prep_value"><code>get_db_prep_value()</code></a> method.</p> <p>For example, if you want to allow generic relations to models with either <a class="reference internal" href="../models/fields#django.db.models.IntegerField" title="django.db.models.IntegerField"><code>IntegerField</code></a> or <a class="reference internal" href="../models/fields#django.db.models.CharField" title="django.db.models.CharField"><code>CharField</code></a> primary key fields, you can use <a class="reference internal" href="../models/fields#django.db.models.CharField" title="django.db.models.CharField"><code>CharField</code></a> for the “object_id” field on your model since integers can be coerced to strings by <a class="reference internal" href="../models/fields#django.db.models.Field.get_db_prep_value" title="django.db.models.Field.get_db_prep_value"><code>get_db_prep_value()</code></a>.</p> <p>For maximum flexibility you can use a <a class="reference internal" href="../models/fields#django.db.models.TextField" title="django.db.models.TextField"><code>TextField</code></a> which doesn’t have a maximum length defined, however this may incur significant performance penalties depending on your database backend.</p> <p class="last">There is no one-size-fits-all solution for which field type is best. You should evaluate the models you expect to be pointing to and determine which solution will be most effective for your use case.</p> </div> <div class="admonition-serializing-references-to-contenttype-objects admonition"> <p class="first admonition-title">Serializing references to <code>ContentType</code> objects</p> <p class="last">If you’re serializing data (for example, when generating <a class="reference internal" href="../../topics/testing/tools#django.test.TransactionTestCase.fixtures" title="django.test.TransactionTestCase.fixtures"><code>fixtures</code></a>) from a model that implements generic relations, you should probably be using a natural key to uniquely identify related <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> objects. See <a class="reference internal" href="../../topics/serialization#topics-serialization-natural-keys"><span class="std std-ref">natural keys</span></a> and <a class="reference internal" href="../django-admin#cmdoption-dumpdata-natural-foreign"><code>dumpdata --natural-foreign</code></a> for more information.</p> </div> <p>This will enable an API similar to the one used for a normal <a class="reference internal" href="../models/fields#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a>; each <code>TaggedItem</code> will have a <code>content_object</code> field that returns the object it’s related to, and you can also assign to that field or use it when creating a <code>TaggedItem</code>:</p> <pre data-language="python">&gt;&gt;&gt; from django.contrib.auth.models import User
&gt;&gt;&gt; guido = User.objects.get(username='Guido')
&gt;&gt;&gt; t = TaggedItem(content_object=guido, tag='bdfl')
&gt;&gt;&gt; t.save()
&gt;&gt;&gt; t.content_object
&lt;User: Guido&gt;
</pre> <p>If the related object is deleted, the <code>content_type</code> and <code>object_id</code> fields remain set to their original values and the <code>GenericForeignKey</code> returns <code>None</code>:</p> <pre data-language="python">&gt;&gt;&gt; guido.delete()
&gt;&gt;&gt; t.content_object  # returns None
</pre> <p>Due to the way <a class="reference internal" href="#django.contrib.contenttypes.fields.GenericForeignKey" title="django.contrib.contenttypes.fields.GenericForeignKey"><code>GenericForeignKey</code></a> is implemented, you cannot use such fields directly with filters (<code>filter()</code> and <code>exclude()</code>, for example) via the database API. Because a <a class="reference internal" href="#django.contrib.contenttypes.fields.GenericForeignKey" title="django.contrib.contenttypes.fields.GenericForeignKey"><code>GenericForeignKey</code></a> isn’t a normal field object, these examples will <em>not</em> work:</p> <pre data-language="python"># This will fail
&gt;&gt;&gt; TaggedItem.objects.filter(content_object=guido)
# This will also fail
&gt;&gt;&gt; TaggedItem.objects.get(content_object=guido)
</pre> <p>Likewise, <a class="reference internal" href="#django.contrib.contenttypes.fields.GenericForeignKey" title="django.contrib.contenttypes.fields.GenericForeignKey"><code>GenericForeignKey</code></a>s does not appear in <a class="reference internal" href="../../topics/forms/modelforms#django.forms.ModelForm" title="django.forms.ModelForm"><code>ModelForm</code></a>s.</p>  <h3 id="reverse-generic-relations">Reverse generic relations</h3> <dl class="class" id="s-reverse-generic-relations"> <dt id="django.contrib.contenttypes.fields.GenericRelation">
<code>class GenericRelation</code> </dt> <dd>
<dl class="attribute"> <dt id="django.contrib.contenttypes.fields.GenericRelation.related_query_name">
<code>related_query_name</code> </dt> <dd>
<p>The relation on the related object back to this object doesn’t exist by default. Setting <code>related_query_name</code> creates a relation from the related object back to this one. This allows querying and filtering from the related object.</p> </dd>
</dl> </dd>
</dl> <p>If you know which models you’ll be using most often, you can also add a “reverse” generic relationship to enable an additional API. For example:</p> <pre data-language="python">from django.contrib.contenttypes.fields import GenericRelation
from django.db import models

class Bookmark(models.Model):
    url = models.URLField()
    tags = GenericRelation(TaggedItem)
</pre> <p><code>Bookmark</code> instances will each have a <code>tags</code> attribute, which can be used to retrieve their associated <code>TaggedItems</code>:</p> <pre data-language="python">&gt;&gt;&gt; b = Bookmark(url='https://www.djangoproject.com/')
&gt;&gt;&gt; b.save()
&gt;&gt;&gt; t1 = TaggedItem(content_object=b, tag='django')
&gt;&gt;&gt; t1.save()
&gt;&gt;&gt; t2 = TaggedItem(content_object=b, tag='python')
&gt;&gt;&gt; t2.save()
&gt;&gt;&gt; b.tags.all()
&lt;QuerySet [&lt;TaggedItem: django&gt;, &lt;TaggedItem: python&gt;]&gt;
</pre> <p>You can also use <code>add()</code>, <code>create()</code>, or <code>set()</code> to create relationships:</p> <pre data-language="python">&gt;&gt;&gt; t3 = TaggedItem(tag='Web development')
&gt;&gt;&gt; b.tags.add(t3, bulk=False)
&gt;&gt;&gt; b.tags.create(tag='Web framework')
&lt;TaggedItem: Web framework&gt;
&gt;&gt;&gt; b.tags.all()
&lt;QuerySet [&lt;TaggedItem: django&gt;, &lt;TaggedItem: python&gt;, &lt;TaggedItem: Web development&gt;, &lt;TaggedItem: Web framework&gt;]&gt;
&gt;&gt;&gt; b.tags.set([t1, t3])
&gt;&gt;&gt; b.tags.all()
&lt;QuerySet [&lt;TaggedItem: django&gt;, &lt;TaggedItem: Web development&gt;]&gt;
</pre> <p>The <code>remove()</code> call will bulk delete the specified model objects:</p> <pre data-language="python">&gt;&gt;&gt; b.tags.remove(t3)
&gt;&gt;&gt; b.tags.all()
&lt;QuerySet [&lt;TaggedItem: django&gt;]&gt;
&gt;&gt;&gt; TaggedItem.objects.all()
&lt;QuerySet [&lt;TaggedItem: django&gt;]&gt;
</pre> <p>The <code>clear()</code> method can be used to bulk delete all related objects for an instance:</p> <pre data-language="python">&gt;&gt;&gt; b.tags.clear()
&gt;&gt;&gt; b.tags.all()
&lt;QuerySet []&gt;
&gt;&gt;&gt; TaggedItem.objects.all()
&lt;QuerySet []&gt;
</pre> <p>Defining <a class="reference internal" href="#django.contrib.contenttypes.fields.GenericRelation" title="django.contrib.contenttypes.fields.GenericRelation"><code>GenericRelation</code></a> with <code>related_query_name</code> set allows querying from the related object:</p> <pre data-language="python">tags = GenericRelation(TaggedItem, related_query_name='bookmark')
</pre> <p>This enables filtering, ordering, and other query operations on <code>Bookmark</code> from <code>TaggedItem</code>:</p> <pre data-language="python">&gt;&gt;&gt; # Get all tags belonging to bookmarks containing `django` in the url
&gt;&gt;&gt; TaggedItem.objects.filter(bookmark__url__contains='django')
&lt;QuerySet [&lt;TaggedItem: django&gt;, &lt;TaggedItem: python&gt;]&gt;
</pre> <p>If you don’t add the <code>related_query_name</code>, you can do the same types of lookups manually:</p> <pre data-language="python">&gt;&gt;&gt; bookmarks = Bookmark.objects.filter(url__contains='django')
&gt;&gt;&gt; bookmark_type = ContentType.objects.get_for_model(Bookmark)
&gt;&gt;&gt; TaggedItem.objects.filter(content_type__pk=bookmark_type.id, object_id__in=bookmarks)
&lt;QuerySet [&lt;TaggedItem: django&gt;, &lt;TaggedItem: python&gt;]&gt;
</pre> <p>Just as <a class="reference internal" href="#django.contrib.contenttypes.fields.GenericForeignKey" title="django.contrib.contenttypes.fields.GenericForeignKey"><code>GenericForeignKey</code></a> accepts the names of the content-type and object-ID fields as arguments, so too does <a class="reference internal" href="#django.contrib.contenttypes.fields.GenericRelation" title="django.contrib.contenttypes.fields.GenericRelation"><code>GenericRelation</code></a>; if the model which has the generic foreign key is using non-default names for those fields, you must pass the names of the fields when setting up a <a class="reference internal" href="#django.contrib.contenttypes.fields.GenericRelation" title="django.contrib.contenttypes.fields.GenericRelation"><code>GenericRelation</code></a> to it. For example, if the <code>TaggedItem</code> model referred to above used fields named <code>content_type_fk</code> and <code>object_primary_key</code> to create its generic foreign key, then a <a class="reference internal" href="#django.contrib.contenttypes.fields.GenericRelation" title="django.contrib.contenttypes.fields.GenericRelation"><code>GenericRelation</code></a> back to it would need to be defined like so:</p> <pre data-language="python">tags = GenericRelation(
    TaggedItem,
    content_type_field='content_type_fk',
    object_id_field='object_primary_key',
)
</pre> <p>Note also, that if you delete an object that has a <a class="reference internal" href="#django.contrib.contenttypes.fields.GenericRelation" title="django.contrib.contenttypes.fields.GenericRelation"><code>GenericRelation</code></a>, any objects which have a <a class="reference internal" href="#django.contrib.contenttypes.fields.GenericForeignKey" title="django.contrib.contenttypes.fields.GenericForeignKey"><code>GenericForeignKey</code></a> pointing at it will be deleted as well. In the example above, this means that if a <code>Bookmark</code> object were deleted, any <code>TaggedItem</code> objects pointing at it would be deleted at the same time.</p> <p>Unlike <a class="reference internal" href="../models/fields#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a>, <a class="reference internal" href="#django.contrib.contenttypes.fields.GenericForeignKey" title="django.contrib.contenttypes.fields.GenericForeignKey"><code>GenericForeignKey</code></a> does not accept an <a class="reference internal" href="../models/fields#django.db.models.ForeignKey.on_delete" title="django.db.models.ForeignKey.on_delete"><code>on_delete</code></a> argument to customize this behavior; if desired, you can avoid the cascade-deletion by not using <a class="reference internal" href="#django.contrib.contenttypes.fields.GenericRelation" title="django.contrib.contenttypes.fields.GenericRelation"><code>GenericRelation</code></a>, and alternate behavior can be provided via the <a class="reference internal" href="../signals#django.db.models.signals.pre_delete" title="django.db.models.signals.pre_delete"><code>pre_delete</code></a> signal.</p>   <h3 id="generic-relations-and-aggregation">Generic relations and aggregation</h3> <p id="s-generic-relations-and-aggregation"><a class="reference internal" href="../../topics/db/aggregation"><span class="doc">Django’s database aggregation API</span></a> works with a <a class="reference internal" href="#django.contrib.contenttypes.fields.GenericRelation" title="django.contrib.contenttypes.fields.GenericRelation"><code>GenericRelation</code></a>. For example, you can find out how many tags all the bookmarks have:</p> <pre data-language="python" id="module-django.contrib.contenttypes.forms">&gt;&gt;&gt; Bookmark.objects.aggregate(Count('tags'))
{'tags__count': 3}
</pre>   <h3 id="generic-relation-in-forms">Generic relation in forms</h3> <p id="s-generic-relation-in-forms">The <a class="reference internal" href="#module-django.contrib.contenttypes.forms" title="django.contrib.contenttypes.forms"><code>django.contrib.contenttypes.forms</code></a> module provides:</p> <ul class="simple"> <li><a class="reference internal" href="#django.contrib.contenttypes.forms.BaseGenericInlineFormSet" title="django.contrib.contenttypes.forms.BaseGenericInlineFormSet"><code>BaseGenericInlineFormSet</code></a></li> <li>A formset factory, <a class="reference internal" href="#django.contrib.contenttypes.forms.generic_inlineformset_factory" title="django.contrib.contenttypes.forms.generic_inlineformset_factory"><code>generic_inlineformset_factory()</code></a>, for use with <a class="reference internal" href="#django.contrib.contenttypes.fields.GenericForeignKey" title="django.contrib.contenttypes.fields.GenericForeignKey"><code>GenericForeignKey</code></a>.</li> </ul> <dl class="class"> <dt id="django.contrib.contenttypes.forms.BaseGenericInlineFormSet">
<code>class BaseGenericInlineFormSet</code> </dt> 
</dl> <dl class="function" id="module-django.contrib.contenttypes.admin"> <dt id="django.contrib.contenttypes.forms.generic_inlineformset_factory">
<code>generic_inlineformset_factory(model, form=ModelForm, formset=BaseGenericInlineFormSet, ct_field="content_type", fk_field="object_id", fields=None, exclude=None, extra=3, can_order=False, can_delete=True, max_num=None, formfield_callback=None, validate_max=False, for_concrete_model=True, min_num=None, validate_min=False, absolute_max=None, can_delete_extra=True)</code> </dt> <dd>
<p>Returns a <code>GenericInlineFormSet</code> using <a class="reference internal" href="../forms/models#django.forms.models.modelformset_factory" title="django.forms.models.modelformset_factory"><code>modelformset_factory()</code></a>.</p> <p>You must provide <code>ct_field</code> and <code>fk_field</code> if they are different from the defaults, <code>content_type</code> and <code>object_id</code> respectively. Other parameters are similar to those documented in <a class="reference internal" href="../forms/models#django.forms.models.modelformset_factory" title="django.forms.models.modelformset_factory"><code>modelformset_factory()</code></a> and <a class="reference internal" href="../forms/models#django.forms.models.inlineformset_factory" title="django.forms.models.inlineformset_factory"><code>inlineformset_factory()</code></a>.</p> <p>The <code>for_concrete_model</code> argument corresponds to the <a class="reference internal" href="#django.contrib.contenttypes.fields.GenericForeignKey.for_concrete_model" title="django.contrib.contenttypes.fields.GenericForeignKey.for_concrete_model"><code>for_concrete_model</code></a> argument on <code>GenericForeignKey</code>.</p> <div class="versionchanged"> <span class="title">Changed in Django 3.2:</span> <p>The <code>absolute_max</code> and <code>can_delete_extra</code> arguments were added.</p> </div> </dd>
</dl>   <h3 id="generic-relations-in-admin">Generic relations in admin</h3> <p id="s-generic-relations-in-admin">The <a class="reference internal" href="#module-django.contrib.contenttypes.admin" title="django.contrib.contenttypes.admin"><code>django.contrib.contenttypes.admin</code></a> module provides <a class="reference internal" href="#django.contrib.contenttypes.admin.GenericTabularInline" title="django.contrib.contenttypes.admin.GenericTabularInline"><code>GenericTabularInline</code></a> and <a class="reference internal" href="#django.contrib.contenttypes.admin.GenericStackedInline" title="django.contrib.contenttypes.admin.GenericStackedInline"><code>GenericStackedInline</code></a> (subclasses of <a class="reference internal" href="#django.contrib.contenttypes.admin.GenericInlineModelAdmin" title="django.contrib.contenttypes.admin.GenericInlineModelAdmin"><code>GenericInlineModelAdmin</code></a>)</p> <p>These classes and functions enable the use of generic relations in forms and the admin. See the <a class="reference internal" href="../../topics/forms/modelforms"><span class="doc">model formset</span></a> and <a class="reference internal" href="admin/index#using-generic-relations-as-an-inline"><span class="std std-ref">admin</span></a> documentation for more information.</p> <dl class="class"> <dt id="django.contrib.contenttypes.admin.GenericInlineModelAdmin">
<code>class GenericInlineModelAdmin</code> </dt> <dd>
<p>The <a class="reference internal" href="#django.contrib.contenttypes.admin.GenericInlineModelAdmin" title="django.contrib.contenttypes.admin.GenericInlineModelAdmin"><code>GenericInlineModelAdmin</code></a> class inherits all properties from an <a class="reference internal" href="admin/index#django.contrib.admin.InlineModelAdmin" title="django.contrib.admin.InlineModelAdmin"><code>InlineModelAdmin</code></a> class. However, it adds a couple of its own for working with the generic relation:</p> <dl class="attribute"> <dt id="django.contrib.contenttypes.admin.GenericInlineModelAdmin.ct_field">
<code>ct_field</code> </dt> <dd>
<p>The name of the <a class="reference internal" href="#django.contrib.contenttypes.models.ContentType" title="django.contrib.contenttypes.models.ContentType"><code>ContentType</code></a> foreign key field on the model. Defaults to <code>content_type</code>.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.contrib.contenttypes.admin.GenericInlineModelAdmin.ct_fk_field">
<code>ct_fk_field</code> </dt> <dd>
<p>The name of the integer field that represents the ID of the related object. Defaults to <code>object_id</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="django.contrib.contenttypes.admin.GenericTabularInline">
<code>class GenericTabularInline</code> </dt> 
</dl> <dl class="class"> <dt id="django.contrib.contenttypes.admin.GenericStackedInline">
<code>class GenericStackedInline</code> </dt> <dd>
<p>Subclasses of <a class="reference internal" href="#django.contrib.contenttypes.admin.GenericInlineModelAdmin" title="django.contrib.contenttypes.admin.GenericInlineModelAdmin"><code>GenericInlineModelAdmin</code></a> with stacked and tabular layouts, respectively.</p> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/4.0/ref/contrib/contenttypes/" class="_attribution-link">https://docs.djangoproject.com/en/4.0/ref/contrib/contenttypes/</a>
  </p>
</div>
