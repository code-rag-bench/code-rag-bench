<h1 id="asynchronous-support">Asynchronous support</h1> <p id="s-asynchronous-support">Django has support for writing asynchronous (“async”) views, along with an entirely async-enabled request stack if you are running under <a class="reference internal" href="../howto/deployment/asgi/index"><span class="doc">ASGI</span></a>. Async views will still work under WSGI, but with performance penalties, and without the ability to have efficient long-running requests.</p> <p>We’re still working on async support for the ORM and other parts of Django. You can expect to see this in future releases. For now, you can use the <a class="reference internal" href="#asgiref.sync.sync_to_async" title="asgiref.sync.sync_to_async"><code>sync_to_async()</code></a> adapter to interact with the sync parts of Django. There is also a whole range of async-native Python libraries that you can integrate with.</p>  <h2 id="async-views">Async views</h2> <p id="s-async-views">Any view can be declared async by making the callable part of it return a coroutine - commonly, this is done using <code>async def</code>. For a function-based view, this means declaring the whole view using <code>async def</code>. For a class-based view, this means making its <code>__call__()</code> method an <code>async def</code> (not its <code>__init__()</code> or <code>as_view()</code>).</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Django uses <code>asyncio.iscoroutinefunction</code> to test if your view is asynchronous or not. If you implement your own method of returning a coroutine, ensure you set the <code>_is_coroutine</code> attribute of the view to <code>asyncio.coroutines._is_coroutine</code> so this function returns <code>True</code>.</p> </div> <p>Under a WSGI server, async views will run in their own, one-off event loop. This means you can use async features, like concurrent async HTTP requests, without any issues, but you will not get the benefits of an async stack.</p> <p>The main benefits are the ability to service hundreds of connections without using Python threads. This allows you to use slow streaming, long-polling, and other exciting response types.</p> <p>If you want to use these, you will need to deploy Django using <a class="reference internal" href="../howto/deployment/asgi/index"><span class="doc">ASGI</span></a> instead.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>You will only get the benefits of a fully-asynchronous request stack if you have <em>no synchronous middleware</em> loaded into your site. If there is a piece of synchronous middleware, then Django must use a thread per request to safely emulate a synchronous environment for it.</p> <p class="last">Middleware can be built to support <a class="reference internal" href="http/middleware#async-middleware"><span class="std std-ref">both sync and async</span></a> contexts. Some of Django’s middleware is built like this, but not all. To see what middleware Django has to adapt, you can turn on debug logging for the <code>django.request</code> logger and look for log messages about <em>“Synchronous middleware … adapted”</em>.</p> </div> <p>In both ASGI and WSGI mode, you can still safely use asynchronous support to run code concurrently rather than serially. This is especially handy when dealing with external APIs or data stores.</p> <p>If you want to call a part of Django that is still synchronous, like the ORM, you will need to wrap it in a <a class="reference internal" href="#asgiref.sync.sync_to_async" title="asgiref.sync.sync_to_async"><code>sync_to_async()</code></a> call. For example:</p> <pre data-language="python">from asgiref.sync import sync_to_async

results = await sync_to_async(Blog.objects.get, thread_sensitive=True)(pk=123)
</pre> <p>You may find it easier to move any ORM code into its own function and call that entire function using <a class="reference internal" href="#asgiref.sync.sync_to_async" title="asgiref.sync.sync_to_async"><code>sync_to_async()</code></a>. For example:</p> <pre data-language="python">from asgiref.sync import sync_to_async

def _get_blog(pk):
    return Blog.objects.select_related('author').get(pk=pk)

get_blog = sync_to_async(_get_blog, thread_sensitive=True)
</pre> <p>If you accidentally try to call a part of Django that is still synchronous-only from an async view, you will trigger Django’s <a class="reference internal" href="#async-safety"><span class="std std-ref">asynchronous safety protection</span></a> to protect your data from corruption.</p>  <h3 id="performance">Performance</h3> <p id="s-performance">When running in a mode that does not match the view (e.g. an async view under WSGI, or a traditional sync view under ASGI), Django must emulate the other call style to allow your code to run. This context-switch causes a small performance penalty of around a millisecond.</p> <p>This is also true of middleware. Django will attempt to minimize the number of context-switches between sync and async. If you have an ASGI server, but all your middleware and views are synchronous, it will switch just once, before it enters the middleware stack.</p> <p>However, if you put synchronous middleware between an ASGI server and an asynchronous view, it will have to switch into sync mode for the middleware and then back to async mode for the view. Django will also hold the sync thread open for middleware exception propagation. This may not be noticeable at first, but adding this penalty of one thread per request can remove any async performance advantage.</p> <p>You should do your own performance testing to see what effect ASGI versus WSGI has on your code. In some cases, there may be a performance increase even for a purely synchronous codebase under ASGI because the request-handling code is still all running asynchronously. In general you will only want to enable ASGI mode if you have asynchronous code in your project.</p>    <h2 id="id1">Async safety</h2> <dl class="envvar" id="s-async-safety"> <dt id="envvar-DJANGO_ALLOW_ASYNC_UNSAFE">
<code>DJANGO_ALLOW_ASYNC_UNSAFE</code> </dt> 
</dl> <p>Certain key parts of Django are not able to operate safely in an async environment, as they have global state that is not coroutine-aware. These parts of Django are classified as “async-unsafe”, and are protected from execution in an async environment. The ORM is the main example, but there are other parts that are also protected in this way.</p> <p>If you try to run any of these parts from a thread where there is a <em>running event loop</em>, you will get a <a class="reference internal" href="../ref/exceptions#django.core.exceptions.SynchronousOnlyOperation" title="django.core.exceptions.SynchronousOnlyOperation"><code>SynchronousOnlyOperation</code></a> error. Note that you don’t have to be inside an async function directly to have this error occur. If you have called a sync function directly from an async function, without using <a class="reference internal" href="#asgiref.sync.sync_to_async" title="asgiref.sync.sync_to_async"><code>sync_to_async()</code></a> or similar, then it can also occur. This is because your code is still running in a thread with an active event loop, even though it may not be declared as async code.</p> <p>If you encounter this error, you should fix your code to not call the offending code from an async context. Instead, write your code that talks to async-unsafe functions in its own, sync function, and call that using <a class="reference internal" href="#asgiref.sync.sync_to_async" title="asgiref.sync.sync_to_async"><code>asgiref.sync.sync_to_async()</code></a> (or any other way of running sync code in its own thread).</p> <p>The async context can be imposed upon you by the environment in which you are running your Django code. For example, <a class="reference external" href="https://jupyter.org/">Jupyter</a> notebooks and <a class="reference external" href="https://ipython.org">IPython</a> interactive shells both transparently provide an active event loop so that it is easier to interact with asynchronous APIs.</p> <p>If you’re using an IPython shell, you can disable this event loop by running:</p> <pre data-language="python">%autoawait off
</pre> <p>as a command at the IPython prompt. This will allow you to run synchronous code without generating <a class="reference internal" href="../ref/exceptions#django.core.exceptions.SynchronousOnlyOperation" title="django.core.exceptions.SynchronousOnlyOperation"><code>SynchronousOnlyOperation</code></a> errors; however, you also won’t be able to <code>await</code> asynchronous APIs. To turn the event loop back on, run:</p> <pre data-language="python">%autoawait on
</pre> <p>If you’re in an environment other than IPython (or you can’t turn off <code>autoawait</code> in IPython for some reason), you are <em>certain</em> there is no chance of your code being run concurrently, and you <em>absolutely</em> need to run your sync code from an async context, then you can disable the warning by setting the <a class="reference internal" href="#envvar-DJANGO_ALLOW_ASYNC_UNSAFE" id="index-0"><code>DJANGO_ALLOW_ASYNC_UNSAFE</code></a> environment variable to any value.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">If you enable this option and there is concurrent access to the async-unsafe parts of Django, you may suffer data loss or corruption. Be very careful and do not use this in production environments.</p> </div> <p>If you need to do this from within Python, do that with <code>os.environ</code>:</p> <pre data-language="python">import os

os.environ["DJANGO_ALLOW_ASYNC_UNSAFE"] = "true"
</pre>   <h2 id="async-adapter-functions">Async adapter functions</h2> <p id="s-async-adapter-functions">It is necessary to adapt the calling style when calling sync code from an async context, or vice-versa. For this there are two adapter functions, from the <code>asgiref.sync</code> module: <a class="reference internal" href="#asgiref.sync.async_to_sync" title="asgiref.sync.async_to_sync"><code>async_to_sync()</code></a> and <a class="reference internal" href="#asgiref.sync.sync_to_async" title="asgiref.sync.sync_to_async"><code>sync_to_async()</code></a>. They are used to transition between the calling styles while preserving compatibility.</p> <p>These adapter functions are widely used in Django. The <a class="reference external" href="https://pypi.org/project/asgiref/">asgiref</a> package itself is part of the Django project, and it is automatically installed as a dependency when you install Django with <code>pip</code>.</p>  <h3 id="async-to-sync"><code>async_to_sync()</code></h3> <dl class="function" id="s-async-to-sync"> <dt id="asgiref.sync.async_to_sync">
<code>async_to_sync(async_function, force_new_loop=False)</code> </dt> 
</dl> <p>Takes an async function and returns a sync function that wraps it. Can be used as either a direct wrapper or a decorator:</p> <pre data-language="python">from asgiref.sync import async_to_sync

async def get_data(...):
    ...

sync_get_data = async_to_sync(get_data)

@async_to_sync
async def get_other_data(...):
    ...
</pre> <p>The async function is run in the event loop for the current thread, if one is present. If there is no current event loop, a new event loop is spun up specifically for the single async invocation and shut down again once it completes. In either situation, the async function will execute on a different thread to the calling code.</p> <p>Threadlocals and contextvars values are preserved across the boundary in both directions.</p> <p><a class="reference internal" href="#asgiref.sync.async_to_sync" title="asgiref.sync.async_to_sync"><code>async_to_sync()</code></a> is essentially a more powerful version of the <a class="reference external" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.run" title="(in Python v3.10)"><code>asyncio.run()</code></a> function in Python’s standard library. As well as ensuring threadlocals work, it also enables the <code>thread_sensitive</code> mode of <a class="reference internal" href="#asgiref.sync.sync_to_async" title="asgiref.sync.sync_to_async"><code>sync_to_async()</code></a> when that wrapper is used below it.</p>   <h3 id="sync-to-async"><code>sync_to_async()</code></h3> <dl class="function" id="s-sync-to-async"> <dt id="asgiref.sync.sync_to_async">
<code>sync_to_async(sync_function, thread_sensitive=True)</code> </dt> 
</dl> <p>Takes a sync function and returns an async function that wraps it. Can be used as either a direct wrapper or a decorator:</p> <pre data-language="python">from asgiref.sync import sync_to_async

async_function = sync_to_async(sync_function, thread_sensitive=False)
async_function = sync_to_async(sensitive_sync_function, thread_sensitive=True)

@sync_to_async
def sync_function(...):
    ...
</pre> <p>Threadlocals and contextvars values are preserved across the boundary in both directions.</p> <p>Sync functions tend to be written assuming they all run in the main thread, so <a class="reference internal" href="#asgiref.sync.sync_to_async" title="asgiref.sync.sync_to_async"><code>sync_to_async()</code></a> has two threading modes:</p> <ul class="simple"> <li>
<code>thread_sensitive=True</code> (the default): the sync function will run in the same thread as all other <code>thread_sensitive</code> functions. This will be the main thread, if the main thread is synchronous and you are using the <a class="reference internal" href="#asgiref.sync.async_to_sync" title="asgiref.sync.async_to_sync"><code>async_to_sync()</code></a> wrapper.</li> <li>
<code>thread_sensitive=False</code>: the sync function will run in a brand new thread which is then closed once the invocation completes.</li> </ul> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last"><code>asgiref</code> version 3.3.0 changed the default value of the <code>thread_sensitive</code> parameter to <code>True</code>. This is a safer default, and in many cases interacting with Django the correct value, but be sure to evaluate uses of <code>sync_to_async()</code> if updating <code>asgiref</code> from a prior version.</p> </div> <p>Thread-sensitive mode is quite special, and does a lot of work to run all functions in the same thread. Note, though, that it <em>relies on usage of</em> <a class="reference internal" href="#asgiref.sync.async_to_sync" title="asgiref.sync.async_to_sync"><code>async_to_sync()</code></a> <em>above it in the stack</em> to correctly run things on the main thread. If you use <code>asyncio.run()</code> or similar, it will fall back to running thread-sensitive functions in a single, shared thread, but this will not be the main thread.</p> <p>The reason this is needed in Django is that many libraries, specifically database adapters, require that they are accessed in the same thread that they were created in. Also a lot of existing Django code assumes it all runs in the same thread, e.g. middleware adding things to a request for later use in views.</p> <p>Rather than introduce potential compatibility issues with this code, we instead opted to add this mode so that all existing Django sync code runs in the same thread and thus is fully compatible with async mode. Note that sync code will always be in a <em>different</em> thread to any async code that is calling it, so you should avoid passing raw database handles or other thread-sensitive references around.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/4.0/topics/async/" class="_attribution-link">https://docs.djangoproject.com/en/4.0/topics/async/</a>
  </p>
</div>
