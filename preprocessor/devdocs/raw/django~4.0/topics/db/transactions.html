<h1 id="database-transactions">Database transactions</h1> <p id="s-module-django.db.transaction">Django gives you a few ways to control how database transactions are managed.</p>  <h2 id="managing-database-transactions">Managing database transactions</h2>  <h3 id="django-s-default-transaction-behavior">Django’s default transaction behavior</h3> <p id="s-managing-database-transactions">Django’s default behavior is to run in autocommit mode. Each query is immediately committed to the database, unless a transaction is active. <a class="reference internal" href="#autocommit-details"><span class="std std-ref">See below for details</span></a>.</p> <p>Django uses transactions or savepoints automatically to guarantee the integrity of ORM operations that require multiple queries, especially <a class="reference internal" href="queries#topics-db-queries-delete"><span class="std std-ref">delete()</span></a> and <a class="reference internal" href="queries#topics-db-queries-update"><span class="std std-ref">update()</span></a> queries.</p> <p>Django’s <a class="reference internal" href="../testing/tools#django.test.TestCase" title="django.test.TestCase"><code>TestCase</code></a> class also wraps each test in a transaction for performance reasons.</p>   <h3 id="id1">Tying transactions to HTTP requests</h3> <p id="s-tying-transactions-to-http-requests">A common way to handle transactions on the web is to wrap each request in a transaction. Set <a class="reference internal" href="../../ref/settings#std:setting-DATABASE-ATOMIC_REQUESTS"><code>ATOMIC_REQUESTS</code></a> to <code>True</code> in the configuration of each database for which you want to enable this behavior.</p> <p>It works like this. Before calling a view function, Django starts a transaction. If the response is produced without problems, Django commits the transaction. If the view produces an exception, Django rolls back the transaction.</p> <p>You may perform subtransactions using savepoints in your view code, typically with the <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> context manager. However, at the end of the view, either all or none of the changes will be committed.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">While the simplicity of this transaction model is appealing, it also makes it inefficient when traffic increases. Opening a transaction for every view has some overhead. The impact on performance depends on the query patterns of your application and on how well your database handles locking.</p> </div> <div class="admonition-per-request-transactions-and-streaming-responses admonition"> <p class="first admonition-title">Per-request transactions and streaming responses</p> <p>When a view returns a <a class="reference internal" href="../../ref/request-response#django.http.StreamingHttpResponse" title="django.http.StreamingHttpResponse"><code>StreamingHttpResponse</code></a>, reading the contents of the response will often execute code to generate the content. Since the view has already returned, such code runs outside of the transaction.</p> <p class="last">Generally speaking, it isn’t advisable to write to the database while generating a streaming response, since there’s no sensible way to handle errors after starting to send the response.</p> </div> <p>In practice, this feature wraps every view function in the <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> decorator described below.</p> <p>Note that only the execution of your view is enclosed in the transactions. Middleware runs outside of the transaction, and so does the rendering of template responses.</p> <p>When <a class="reference internal" href="../../ref/settings#std:setting-DATABASE-ATOMIC_REQUESTS"><code>ATOMIC_REQUESTS</code></a> is enabled, it’s still possible to prevent views from running in a transaction.</p> <dl class="function"> <dt id="django.db.transaction.non_atomic_requests">
<code>non_atomic_requests(using=None)</code> </dt> <dd>
<p>This decorator will negate the effect of <a class="reference internal" href="../../ref/settings#std:setting-DATABASE-ATOMIC_REQUESTS"><code>ATOMIC_REQUESTS</code></a> for a given view:</p> <pre data-language="python">from django.db import transaction

@transaction.non_atomic_requests
def my_view(request):
    do_stuff()

@transaction.non_atomic_requests(using='other')
def my_other_view(request):
    do_stuff_on_the_other_database()
</pre> <p>It only works if it’s applied to the view itself.</p> </dd>
</dl>   <h3 id="controlling-transactions-explicitly">Controlling transactions explicitly</h3> <p id="s-controlling-transactions-explicitly">Django provides a single API to control database transactions.</p> <dl class="function"> <dt id="django.db.transaction.atomic">
<code>atomic(using=None, savepoint=True, durable=False)</code> </dt> <dd>
<p>Atomicity is the defining property of database transactions. <code>atomic</code> allows us to create a block of code within which the atomicity on the database is guaranteed. If the block of code is successfully completed, the changes are committed to the database. If there is an exception, the changes are rolled back.</p> <p><code>atomic</code> blocks can be nested. In this case, when an inner block completes successfully, its effects can still be rolled back if an exception is raised in the outer block at a later point.</p> <p>It is sometimes useful to ensure an <code>atomic</code> block is always the outermost <code>atomic</code> block, ensuring that any database changes are committed when the block is exited without errors. This is known as durability and can be achieved by setting <code>durable=True</code>. If the <code>atomic</code> block is nested within another it raises a <code>RuntimeError</code>.</p> <p><code>atomic</code> is usable both as a <a class="reference external" href="https://docs.python.org/3/glossary.html#term-decorator" title="(in Python v3.10)"><span class="xref std std-term">decorator</span></a>:</p> <pre data-language="python">from django.db import transaction

@transaction.atomic
def viewfunc(request):
    # This code executes inside a transaction.
    do_stuff()
</pre> <p>and as a <a class="reference external" href="https://docs.python.org/3/glossary.html#term-context-manager" title="(in Python v3.10)"><span class="xref std std-term">context manager</span></a>:</p> <pre data-language="python">from django.db import transaction

def viewfunc(request):
    # This code executes in autocommit mode (Django's default).
    do_stuff()

    with transaction.atomic():
        # This code executes inside a transaction.
        do_more_stuff()
</pre> <p>Wrapping <code>atomic</code> in a try/except block allows for natural handling of integrity errors:</p> <pre data-language="python">from django.db import IntegrityError, transaction

@transaction.atomic
def viewfunc(request):
    create_parent()

    try:
        with transaction.atomic():
            generate_relationships()
    except IntegrityError:
        handle_exception()

    add_children()
</pre> <p>In this example, even if <code>generate_relationships()</code> causes a database error by breaking an integrity constraint, you can execute queries in <code>add_children()</code>, and the changes from <code>create_parent()</code> are still there and bound to the same transaction. Note that any operations attempted in <code>generate_relationships()</code> will already have been rolled back safely when <code>handle_exception()</code> is called, so the exception handler can also operate on the database if necessary.</p> <div class="admonition-avoid-catching-exceptions-inside-atomic admonition"> <p class="first admonition-title">Avoid catching exceptions inside <code>atomic</code>!</p> <p>When exiting an <code>atomic</code> block, Django looks at whether it’s exited normally or with an exception to determine whether to commit or roll back. If you catch and handle exceptions inside an <code>atomic</code> block, you may hide from Django the fact that a problem has happened. This can result in unexpected behavior.</p> <p>This is mostly a concern for <a class="reference internal" href="../../ref/exceptions#django.db.DatabaseError" title="django.db.DatabaseError"><code>DatabaseError</code></a> and its subclasses such as <a class="reference internal" href="../../ref/exceptions#django.db.IntegrityError" title="django.db.IntegrityError"><code>IntegrityError</code></a>. After such an error, the transaction is broken and Django will perform a rollback at the end of the <code>atomic</code> block. If you attempt to run database queries before the rollback happens, Django will raise a <a class="reference internal" href="../../ref/exceptions#django.db.transaction.TransactionManagementError" title="django.db.transaction.TransactionManagementError"><code>TransactionManagementError</code></a>. You may also encounter this behavior when an ORM-related signal handler raises an exception.</p> <p>The correct way to catch database errors is around an <code>atomic</code> block as shown above. If necessary, add an extra <code>atomic</code> block for this purpose. This pattern has another advantage: it delimits explicitly which operations will be rolled back if an exception occurs.</p> <p class="last">If you catch exceptions raised by raw SQL queries, Django’s behavior is unspecified and database-dependent.</p> </div> <div class="admonition-you-may-need-to-manually-revert-model-state-when-rolling-back-a-transaction admonition"> <p class="first admonition-title">You may need to manually revert model state when rolling back a transaction.</p> <p>The values of a model’s fields won’t be reverted when a transaction rollback happens. This could lead to an inconsistent model state unless you manually restore the original field values.</p> <p>For example, given <code>MyModel</code> with an <code>active</code> field, this snippet ensures that the <code>if obj.active</code> check at the end uses the correct value if updating <code>active</code> to <code>True</code> fails in the transaction:</p> <pre data-language="python">from django.db import DatabaseError, transaction

obj = MyModel(active=False)
obj.active = True
try:
    with transaction.atomic():
        obj.save()
except DatabaseError:
    obj.active = False

if obj.active:
    ...
</pre> </div> <p>In order to guarantee atomicity, <code>atomic</code> disables some APIs. Attempting to commit, roll back, or change the autocommit state of the database connection within an <code>atomic</code> block will raise an exception.</p> <p><code>atomic</code> takes a <code>using</code> argument which should be the name of a database. If this argument isn’t provided, Django uses the <code>"default"</code> database.</p> <p>Under the hood, Django’s transaction management code:</p> <ul class="simple"> <li>opens a transaction when entering the outermost <code>atomic</code> block;</li> <li>creates a savepoint when entering an inner <code>atomic</code> block;</li> <li>releases or rolls back to the savepoint when exiting an inner block;</li> <li>commits or rolls back the transaction when exiting the outermost block.</li> </ul> <p>You can disable the creation of savepoints for inner blocks by setting the <code>savepoint</code> argument to <code>False</code>. If an exception occurs, Django will perform the rollback when exiting the first parent block with a savepoint if there is one, and the outermost block otherwise. Atomicity is still guaranteed by the outer transaction. This option should only be used if the overhead of savepoints is noticeable. It has the drawback of breaking the error handling described above.</p> <p>You may use <code>atomic</code> when autocommit is turned off. It will only use savepoints, even for the outermost block.</p> </dd>
</dl> <div class="admonition-performance-considerations admonition"> <p class="first admonition-title">Performance considerations</p> <p class="last">Open transactions have a performance cost for your database server. To minimize this overhead, keep your transactions as short as possible. This is especially important if you’re using <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> in long-running processes, outside of Django’s request / response cycle.</p> </div> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last"><a class="reference internal" href="../testing/tools#django.test.TestCase" title="django.test.TestCase"><code>django.test.TestCase</code></a> disables the durability check to allow testing durable atomic blocks in a transaction for performance reasons. Use <a class="reference internal" href="../testing/tools#django.test.TransactionTestCase" title="django.test.TransactionTestCase"><code>django.test.TransactionTestCase</code></a> for testing durability.</p> </div> <div class="versionchanged"> <span class="title">Changed in Django 3.2:</span> <p>The <code>durable</code> argument was added.</p> </div>    <h2 id="autocommit">Autocommit</h2>  <h3 id="autocommit-details">Why Django uses autocommit</h3> <p id="s-autocommit">In the SQL standards, each SQL query starts a transaction, unless one is already active. Such transactions must then be explicitly committed or rolled back.</p> <p>This isn’t always convenient for application developers. To alleviate this problem, most databases provide an autocommit mode. When autocommit is turned on and no transaction is active, each SQL query gets wrapped in its own transaction. In other words, not only does each such query start a transaction, but the transaction also gets automatically committed or rolled back, depending on whether the query succeeded.</p> <p><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0249" id="index-0"><strong>PEP 249</strong></a>, the Python Database API Specification v2.0, requires autocommit to be initially turned off. Django overrides this default and turns autocommit on.</p> <p>To avoid this, you can <a class="reference internal" href="#deactivate-transaction-management"><span class="std std-ref">deactivate the transaction management</span></a>, but it isn’t recommended.</p>   <h3 id="deactivate-transaction-management">Deactivating transaction management</h3> <p id="s-deactivating-transaction-management">You can totally disable Django’s transaction management for a given database by setting <a class="reference internal" href="../../ref/settings#std:setting-DATABASE-AUTOCOMMIT"><code>AUTOCOMMIT</code></a> to <code>False</code> in its configuration. If you do this, Django won’t enable autocommit, and won’t perform any commits. You’ll get the regular behavior of the underlying database library.</p> <p>This requires you to commit explicitly every transaction, even those started by Django or by third-party libraries. Thus, this is best used in situations where you want to run your own transaction-controlling middleware or do something really strange.</p>    <h2 id="performing-actions-after-commit">Performing actions after commit</h2> <p id="s-performing-actions-after-commit">Sometimes you need to perform an action related to the current database transaction, but only if the transaction successfully commits. Examples might include a <a class="reference external" href="https://pypi.org/project/celery/">Celery</a> task, an email notification, or a cache invalidation.</p> <p>Django provides the <a class="reference internal" href="#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code>on_commit()</code></a> function to register callback functions that should be executed after a transaction is successfully committed:</p> <dl class="function"> <dt id="django.db.transaction.on_commit">
<code>on_commit(func, using=None)</code> </dt> 
</dl> <p>Pass any function (that takes no arguments) to <a class="reference internal" href="#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code>on_commit()</code></a>:</p> <pre data-language="python">from django.db import transaction

def do_something():
    pass  # send a mail, invalidate a cache, fire off a Celery task, etc.

transaction.on_commit(do_something)
</pre> <p>You can also wrap your function in a lambda:</p> <pre data-language="python">transaction.on_commit(lambda: some_celery_task.delay('arg1'))
</pre> <p>The function you pass in will be called immediately after a hypothetical database write made where <code>on_commit()</code> is called would be successfully committed.</p> <p>If you call <code>on_commit()</code> while there isn’t an active transaction, the callback will be executed immediately.</p> <p>If that hypothetical database write is instead rolled back (typically when an unhandled exception is raised in an <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> block), your function will be discarded and never called.</p>  <h3 id="savepoints">Savepoints</h3> <p id="s-savepoints">Savepoints (i.e. nested <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> blocks) are handled correctly. That is, an <a class="reference internal" href="#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code>on_commit()</code></a> callable registered after a savepoint (in a nested <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> block) will be called after the outer transaction is committed, but not if a rollback to that savepoint or any previous savepoint occurred during the transaction:</p> <pre data-language="python">with transaction.atomic():  # Outer atomic, start a new transaction
    transaction.on_commit(foo)

    with transaction.atomic():  # Inner atomic block, create a savepoint
        transaction.on_commit(bar)

# foo() and then bar() will be called when leaving the outermost block
</pre> <p>On the other hand, when a savepoint is rolled back (due to an exception being raised), the inner callable will not be called:</p> <pre data-language="python">with transaction.atomic():  # Outer atomic, start a new transaction
    transaction.on_commit(foo)

    try:
        with transaction.atomic():  # Inner atomic block, create a savepoint
            transaction.on_commit(bar)
            raise SomeError()  # Raising an exception - abort the savepoint
    except SomeError:
        pass

# foo() will be called, but not bar()
</pre>   <h3 id="order-of-execution">Order of execution</h3> <p id="s-order-of-execution">On-commit functions for a given transaction are executed in the order they were registered.</p>   <h3 id="exception-handling">Exception handling</h3> <p id="s-exception-handling">If one on-commit function within a given transaction raises an uncaught exception, no later registered functions in that same transaction will run. This is the same behavior as if you’d executed the functions sequentially yourself without <a class="reference internal" href="#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code>on_commit()</code></a>.</p>   <h3 id="timing-of-execution">Timing of execution</h3> <p id="s-timing-of-execution">Your callbacks are executed <em>after</em> a successful commit, so a failure in a callback will not cause the transaction to roll back. They are executed conditionally upon the success of the transaction, but they are not <em>part</em> of the transaction. For the intended use cases (mail notifications, Celery tasks, etc.), this should be fine. If it’s not (if your follow-up action is so critical that its failure should mean the failure of the transaction itself), then you don’t want to use the <a class="reference internal" href="#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code>on_commit()</code></a> hook. Instead, you may want <a class="reference external" href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">two-phase commit</a> such as the <a class="reference external" href="https://www.psycopg.org/docs/usage.html#tpc" title="(in Psycopg v2.9)"><span class="xref std std-ref">psycopg Two-Phase Commit protocol support</span></a> and the <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0249#optional-two-phase-commit-extensions" id="index-1"><strong>optional Two-Phase Commit Extensions in the Python DB-API specification</strong></a>.</p> <p>Callbacks are not run until autocommit is restored on the connection following the commit (because otherwise any queries done in a callback would open an implicit transaction, preventing the connection from going back into autocommit mode).</p> <p>When in autocommit mode and outside of an <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> block, the function will run immediately, not on commit.</p> <p>On-commit functions only work with <a class="reference internal" href="#managing-autocommit"><span class="std std-ref">autocommit mode</span></a> and the <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> (or <a class="reference internal" href="../../ref/settings#std:setting-DATABASE-ATOMIC_REQUESTS"><code>ATOMIC_REQUESTS</code></a>) transaction API. Calling <a class="reference internal" href="#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code>on_commit()</code></a> when autocommit is disabled and you are not within an atomic block will result in an error.</p>   <h3 id="use-in-tests">Use in tests</h3> <p id="s-use-in-tests">Django’s <a class="reference internal" href="../testing/tools#django.test.TestCase" title="django.test.TestCase"><code>TestCase</code></a> class wraps each test in a transaction and rolls back that transaction after each test, in order to provide test isolation. This means that no transaction is ever actually committed, thus your <a class="reference internal" href="#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code>on_commit()</code></a> callbacks will never be run.</p> <p>You can overcome this limitation by using <a class="reference internal" href="../testing/tools#django.test.TestCase.captureOnCommitCallbacks" title="django.test.TestCase.captureOnCommitCallbacks"><code>TestCase.captureOnCommitCallbacks()</code></a>. This captures your <a class="reference internal" href="#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code>on_commit()</code></a> callbacks in a list, allowing you to make assertions on them, or emulate the transaction committing by calling them.</p> <p>Another way to overcome the limitation is to use <a class="reference internal" href="../testing/tools#django.test.TransactionTestCase" title="django.test.TransactionTestCase"><code>TransactionTestCase</code></a> instead of <a class="reference internal" href="../testing/tools#django.test.TestCase" title="django.test.TestCase"><code>TestCase</code></a>. This will mean your transactions are committed, and the callbacks will run. However <a class="reference internal" href="../testing/tools#django.test.TransactionTestCase" title="django.test.TransactionTestCase"><code>TransactionTestCase</code></a> flushes the database between tests, which is significantly slower than <a class="reference internal" href="../testing/tools#django.test.TestCase" title="django.test.TestCase"><code>TestCase</code></a>’s isolation.</p>   <h3 id="why-no-rollback-hook">Why no rollback hook?</h3> <p id="s-why-no-rollback-hook">A rollback hook is harder to implement robustly than a commit hook, since a variety of things can cause an implicit rollback.</p> <p>For instance, if your database connection is dropped because your process was killed without a chance to shut down gracefully, your rollback hook will never run.</p> <p>But there is a solution: instead of doing something during the atomic block (transaction) and then undoing it if the transaction fails, use <a class="reference internal" href="#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code>on_commit()</code></a> to delay doing it in the first place until after the transaction succeeds. It’s a lot easier to undo something you never did in the first place!</p>    <h2 id="low-level-apis">Low-level APIs</h2> <div class="admonition warning" id="s-low-level-apis"> <p class="first admonition-title">Warning</p> <p>Always prefer <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> if possible at all. It accounts for the idiosyncrasies of each database and prevents invalid operations.</p> <p class="last">The low level APIs are only useful if you’re implementing your own transaction management.</p> </div>  <h3 id="id2">Autocommit</h3> <p id="s-managing-autocommit">Django provides an API in the <a class="reference internal" href="#module-django.db.transaction" title="django.db.transaction"><code>django.db.transaction</code></a> module to manage the autocommit state of each database connection.</p> <dl class="function"> <dt id="django.db.transaction.get_autocommit">
<code>get_autocommit(using=None)</code> </dt> 
</dl> <dl class="function"> <dt id="django.db.transaction.set_autocommit">
<code>set_autocommit(autocommit, using=None)</code> </dt> 
</dl> <p>These functions take a <code>using</code> argument which should be the name of a database. If it isn’t provided, Django uses the <code>"default"</code> database.</p> <p>Autocommit is initially turned on. If you turn it off, it’s your responsibility to restore it.</p> <p>Once you turn autocommit off, you get the default behavior of your database adapter, and Django won’t help you. Although that behavior is specified in <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0249" id="index-2"><strong>PEP 249</strong></a>, implementations of adapters aren’t always consistent with one another. Review the documentation of the adapter you’re using carefully.</p> <p>You must ensure that no transaction is active, usually by issuing a <a class="reference internal" href="#django.db.transaction.commit" title="django.db.transaction.commit"><code>commit()</code></a> or a <a class="reference internal" href="#django.db.transaction.rollback" title="django.db.transaction.rollback"><code>rollback()</code></a>, before turning autocommit back on.</p> <p>Django will refuse to turn autocommit off when an <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> block is active, because that would break atomicity.</p>   <h3 id="transactions">Transactions</h3> <p id="s-transactions">A transaction is an atomic set of database queries. Even if your program crashes, the database guarantees that either all the changes will be applied, or none of them.</p> <p>Django doesn’t provide an API to start a transaction. The expected way to start a transaction is to disable autocommit with <a class="reference internal" href="#django.db.transaction.set_autocommit" title="django.db.transaction.set_autocommit"><code>set_autocommit()</code></a>.</p> <p>Once you’re in a transaction, you can choose either to apply the changes you’ve performed until this point with <a class="reference internal" href="#django.db.transaction.commit" title="django.db.transaction.commit"><code>commit()</code></a>, or to cancel them with <a class="reference internal" href="#django.db.transaction.rollback" title="django.db.transaction.rollback"><code>rollback()</code></a>. These functions are defined in <a class="reference internal" href="#module-django.db.transaction" title="django.db.transaction"><code>django.db.transaction</code></a>.</p> <dl class="function"> <dt id="django.db.transaction.commit">
<code>commit(using=None)</code> </dt> 
</dl> <dl class="function"> <dt id="django.db.transaction.rollback">
<code>rollback(using=None)</code> </dt> 
</dl> <p>These functions take a <code>using</code> argument which should be the name of a database. If it isn’t provided, Django uses the <code>"default"</code> database.</p> <p>Django will refuse to commit or to rollback when an <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> block is active, because that would break atomicity.</p>   <h3 id="id3">Savepoints</h3> <p id="s-topics-db-transactions-savepoints">A savepoint is a marker within a transaction that enables you to roll back part of a transaction, rather than the full transaction. Savepoints are available with the SQLite, PostgreSQL, Oracle, and MySQL (when using the InnoDB storage engine) backends. Other backends provide the savepoint functions, but they’re empty operations – they don’t actually do anything.</p> <p>Savepoints aren’t especially useful if you are using autocommit, the default behavior of Django. However, once you open a transaction with <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a>, you build up a series of database operations awaiting a commit or rollback. If you issue a rollback, the entire transaction is rolled back. Savepoints provide the ability to perform a fine-grained rollback, rather than the full rollback that would be performed by <code>transaction.rollback()</code>.</p> <p>When the <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> decorator is nested, it creates a savepoint to allow partial commit or rollback. You’re strongly encouraged to use <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> rather than the functions described below, but they’re still part of the public API, and there’s no plan to deprecate them.</p> <p>Each of these functions takes a <code>using</code> argument which should be the name of a database for which the behavior applies. If no <code>using</code> argument is provided then the <code>"default"</code> database is used.</p> <p>Savepoints are controlled by three functions in <a class="reference internal" href="#module-django.db.transaction" title="django.db.transaction"><code>django.db.transaction</code></a>:</p> <dl class="function"> <dt id="django.db.transaction.savepoint">
<code>savepoint(using=None)</code> </dt> <dd>
<p>Creates a new savepoint. This marks a point in the transaction that is known to be in a “good” state. Returns the savepoint ID (<code>sid</code>).</p> </dd>
</dl> <dl class="function"> <dt id="django.db.transaction.savepoint_commit">
<code>savepoint_commit(sid, using=None)</code> </dt> <dd>
<p>Releases savepoint <code>sid</code>. The changes performed since the savepoint was created become part of the transaction.</p> </dd>
</dl> <dl class="function"> <dt id="django.db.transaction.savepoint_rollback">
<code>savepoint_rollback(sid, using=None)</code> </dt> <dd>
<p>Rolls back the transaction to savepoint <code>sid</code>.</p> </dd>
</dl> <p>These functions do nothing if savepoints aren’t supported or if the database is in autocommit mode.</p> <p>In addition, there’s a utility function:</p> <dl class="function"> <dt id="django.db.transaction.clean_savepoints">
<code>clean_savepoints(using=None)</code> </dt> <dd>
<p>Resets the counter used to generate unique savepoint IDs.</p> </dd>
</dl> <p>The following example demonstrates the use of savepoints:</p> <pre data-language="python">from django.db import transaction

# open a transaction
@transaction.atomic
def viewfunc(request):

    a.save()
    # transaction now contains a.save()

    sid = transaction.savepoint()

    b.save()
    # transaction now contains a.save() and b.save()

    if want_to_keep_b:
        transaction.savepoint_commit(sid)
        # open transaction still contains a.save() and b.save()
    else:
        transaction.savepoint_rollback(sid)
        # open transaction now contains only a.save()
</pre> <p>Savepoints may be used to recover from a database error by performing a partial rollback. If you’re doing this inside an <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> block, the entire block will still be rolled back, because it doesn’t know you’ve handled the situation at a lower level! To prevent this, you can control the rollback behavior with the following functions.</p> <dl class="function"> <dt id="django.db.transaction.get_rollback">
<code>get_rollback(using=None)</code> </dt> 
</dl> <dl class="function"> <dt id="django.db.transaction.set_rollback">
<code>set_rollback(rollback, using=None)</code> </dt> 
</dl> <p>Setting the rollback flag to <code>True</code> forces a rollback when exiting the innermost atomic block. This may be useful to trigger a rollback without raising an exception.</p> <p>Setting it to <code>False</code> prevents such a rollback. Before doing that, make sure you’ve rolled back the transaction to a known-good savepoint within the current atomic block! Otherwise you’re breaking atomicity and data corruption may occur.</p>    <h2 id="database-specific-notes">Database-specific notes</h2>  <h3 id="id4">Savepoints in SQLite</h3> <p id="s-database-specific-notes">While SQLite supports savepoints, a flaw in the design of the <a class="reference external" href="https://docs.python.org/3/library/sqlite3.html#module-sqlite3" title="(in Python v3.10)"><code>sqlite3</code></a> module makes them hardly usable.</p> <p>When autocommit is enabled, savepoints don’t make sense. When it’s disabled, <a class="reference external" href="https://docs.python.org/3/library/sqlite3.html#module-sqlite3" title="(in Python v3.10)"><code>sqlite3</code></a> commits implicitly before savepoint statements. (In fact, it commits before any statement other than <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> and <code>REPLACE</code>.) This bug has two consequences:</p> <ul class="simple"> <li>The low level APIs for savepoints are only usable inside a transaction ie. inside an <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> block.</li> <li>It’s impossible to use <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> when autocommit is turned off.</li> </ul>   <h3 id="transactions-in-mysql">Transactions in MySQL</h3> <p id="s-transactions-in-mysql">If you’re using MySQL, your tables may or may not support transactions; it depends on your MySQL version and the table types you’re using. (By “table types,” we mean something like “InnoDB” or “MyISAM”.) MySQL transaction peculiarities are outside the scope of this article, but the MySQL site has <a class="reference external" href="https://dev.mysql.com/doc/refman/en/sql-transactional-statements.html">information on MySQL transactions</a>.</p> <p>If your MySQL setup does <em>not</em> support transactions, then Django will always function in autocommit mode: statements will be executed and committed as soon as they’re called. If your MySQL setup <em>does</em> support transactions, Django will handle transactions as explained in this document.</p>   <h3 id="handling-exceptions-within-postgresql-transactions">Handling exceptions within PostgreSQL transactions</h3> <div class="admonition note" id="s-handling-exceptions-within-postgresql-transactions"> <p class="first admonition-title">Note</p> <p class="last">This section is relevant only if you’re implementing your own transaction management. This problem cannot occur in Django’s default mode and <a class="reference internal" href="#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> handles it automatically.</p> </div> <p>Inside a transaction, when a call to a PostgreSQL cursor raises an exception (typically <code>IntegrityError</code>), all subsequent SQL in the same transaction will fail with the error “current transaction is aborted, queries ignored until end of transaction block”. While the basic use of <code>save()</code> is unlikely to raise an exception in PostgreSQL, there are more advanced usage patterns which might, such as saving objects with unique fields, saving using the force_insert/force_update flag, or invoking custom SQL.</p> <p>There are several ways to recover from this sort of error.</p>  <h4 id="transaction-rollback">Transaction rollback</h4> <p id="s-transaction-rollback">The first option is to roll back the entire transaction. For example:</p> <pre data-language="python">a.save() # Succeeds, but may be undone by transaction rollback
try:
    b.save() # Could throw exception
except IntegrityError:
    transaction.rollback()
c.save() # Succeeds, but a.save() may have been undone
</pre> <p>Calling <code>transaction.rollback()</code> rolls back the entire transaction. Any uncommitted database operations will be lost. In this example, the changes made by <code>a.save()</code> would be lost, even though that operation raised no error itself.</p>   <h4 id="savepoint-rollback">Savepoint rollback</h4> <p id="s-savepoint-rollback">You can use <a class="reference internal" href="#topics-db-transactions-savepoints"><span class="std std-ref">savepoints</span></a> to control the extent of a rollback. Before performing a database operation that could fail, you can set or update the savepoint; that way, if the operation fails, you can roll back the single offending operation, rather than the entire transaction. For example:</p> <pre data-language="python">a.save() # Succeeds, and never undone by savepoint rollback
sid = transaction.savepoint()
try:
    b.save() # Could throw exception
    transaction.savepoint_commit(sid)
except IntegrityError:
    transaction.savepoint_rollback(sid)
c.save() # Succeeds, and a.save() is never undone
</pre> <p>In this example, <code>a.save()</code> will not be undone in the case where <code>b.save()</code> raises an exception.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/4.0/topics/db/transactions/" class="_attribution-link">https://docs.djangoproject.com/en/4.0/topics/db/transactions/</a>
  </p>
</div>
