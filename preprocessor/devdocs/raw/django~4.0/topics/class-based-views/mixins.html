<h1 id="using-mixins-with-class-based-views">Using mixins with class-based views</h1> <div class="admonition caution" id="s-using-mixins-with-class-based-views"> <p class="first admonition-title">Caution</p> <p class="last">This is an advanced topic. A working knowledge of <a class="reference internal" href="index"><span class="doc">Django’s class-based views</span></a> is advised before exploring these techniques.</p> </div> <p>Django’s built-in class-based views provide a lot of functionality, but some of it you may want to use separately. For instance, you may want to write a view that renders a template to make the HTTP response, but you can’t use <a class="reference internal" href="../../ref/class-based-views/base#django.views.generic.base.TemplateView" title="django.views.generic.base.TemplateView"><code>TemplateView</code></a>; perhaps you need to render a template only on <code>POST</code>, with <code>GET</code> doing something else entirely. While you could use <a class="reference internal" href="../../ref/template-response#django.template.response.TemplateResponse" title="django.template.response.TemplateResponse"><code>TemplateResponse</code></a> directly, this will likely result in duplicate code.</p> <p>For this reason, Django also provides a number of mixins that provide more discrete functionality. Template rendering, for instance, is encapsulated in the <a class="reference internal" href="../../ref/class-based-views/mixins-simple#django.views.generic.base.TemplateResponseMixin" title="django.views.generic.base.TemplateResponseMixin"><code>TemplateResponseMixin</code></a>. The Django reference documentation contains <a class="reference internal" href="../../ref/class-based-views/mixins"><span class="doc">full documentation of all the mixins</span></a>.</p>  <h2 id="context-and-template-responses">Context and template responses</h2> <p id="s-context-and-template-responses">Two central mixins are provided that help in providing a consistent interface to working with templates in class-based views.</p> <dl class="docutils"> <dt>
 <a class="reference internal" href="../../ref/class-based-views/mixins-simple#django.views.generic.base.TemplateResponseMixin" title="django.views.generic.base.TemplateResponseMixin"><code>TemplateResponseMixin</code></a>
</dt> <dd>
<p class="first">Every built in view which returns a <a class="reference internal" href="../../ref/template-response#django.template.response.TemplateResponse" title="django.template.response.TemplateResponse"><code>TemplateResponse</code></a> will call the <a class="reference internal" href="../../ref/class-based-views/mixins-simple#django.views.generic.base.TemplateResponseMixin.render_to_response" title="django.views.generic.base.TemplateResponseMixin.render_to_response"><code>render_to_response()</code></a> method that <code>TemplateResponseMixin</code> provides. Most of the time this will be called for you (for instance, it is called by the <code>get()</code> method implemented by both <a class="reference internal" href="../../ref/class-based-views/base#django.views.generic.base.TemplateView" title="django.views.generic.base.TemplateView"><code>TemplateView</code></a> and <a class="reference internal" href="../../ref/class-based-views/generic-display#django.views.generic.detail.DetailView" title="django.views.generic.detail.DetailView"><code>DetailView</code></a>); similarly, it’s unlikely that you’ll need to override it, although if you want your response to return something not rendered via a Django template then you’ll want to do it. For an example of this, see the <a class="reference internal" href="#jsonresponsemixin-example"><span class="std std-ref">JSONResponseMixin example</span></a>.</p> <p class="last"><code>render_to_response()</code> itself calls <a class="reference internal" href="../../ref/class-based-views/mixins-simple#django.views.generic.base.TemplateResponseMixin.get_template_names" title="django.views.generic.base.TemplateResponseMixin.get_template_names"><code>get_template_names()</code></a>, which by default will look up <a class="reference internal" href="../../ref/class-based-views/mixins-simple#django.views.generic.base.TemplateResponseMixin.template_name" title="django.views.generic.base.TemplateResponseMixin.template_name"><code>template_name</code></a> on the class-based view; two other mixins (<a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectTemplateResponseMixin" title="django.views.generic.detail.SingleObjectTemplateResponseMixin"><code>SingleObjectTemplateResponseMixin</code></a> and <a class="reference internal" href="../../ref/class-based-views/mixins-multiple-object#django.views.generic.list.MultipleObjectTemplateResponseMixin" title="django.views.generic.list.MultipleObjectTemplateResponseMixin"><code>MultipleObjectTemplateResponseMixin</code></a>) override this to provide more flexible defaults when dealing with actual objects.</p> </dd> <dt>
 <a class="reference internal" href="../../ref/class-based-views/mixins-simple#django.views.generic.base.ContextMixin" title="django.views.generic.base.ContextMixin"><code>ContextMixin</code></a>
</dt> <dd>Every built in view which needs context data, such as for rendering a template (including <code>TemplateResponseMixin</code> above), should call <a class="reference internal" href="../../ref/class-based-views/mixins-simple#django.views.generic.base.ContextMixin.get_context_data" title="django.views.generic.base.ContextMixin.get_context_data"><code>get_context_data()</code></a> passing any data they want to ensure is in there as keyword arguments. <code>get_context_data()</code> returns a dictionary; in <code>ContextMixin</code> it returns its keyword arguments, but it is common to override this to add more members to the dictionary. You can also use the <a class="reference internal" href="../../ref/class-based-views/mixins-simple#django.views.generic.base.ContextMixin.extra_context" title="django.views.generic.base.ContextMixin.extra_context"><code>extra_context</code></a> attribute.</dd> </dl>   <h2 id="building-up-django-s-generic-class-based-views">Building up Django’s generic class-based views</h2> <p id="s-building-up-django-s-generic-class-based-views">Let’s look at how two of Django’s generic class-based views are built out of mixins providing discrete functionality. We’ll consider <a class="reference internal" href="../../ref/class-based-views/generic-display#django.views.generic.detail.DetailView" title="django.views.generic.detail.DetailView"><code>DetailView</code></a>, which renders a “detail” view of an object, and <a class="reference internal" href="../../ref/class-based-views/generic-display#django.views.generic.list.ListView" title="django.views.generic.list.ListView"><code>ListView</code></a>, which will render a list of objects, typically from a queryset, and optionally paginate them. This will introduce us to four mixins which between them provide useful functionality when working with either a single Django object, or multiple objects.</p> <p>There are also mixins involved in the generic edit views (<a class="reference internal" href="../../ref/class-based-views/generic-editing#django.views.generic.edit.FormView" title="django.views.generic.edit.FormView"><code>FormView</code></a>, and the model-specific views <a class="reference internal" href="../../ref/class-based-views/generic-editing#django.views.generic.edit.CreateView" title="django.views.generic.edit.CreateView"><code>CreateView</code></a>, <a class="reference internal" href="../../ref/class-based-views/generic-editing#django.views.generic.edit.UpdateView" title="django.views.generic.edit.UpdateView"><code>UpdateView</code></a> and <a class="reference internal" href="../../ref/class-based-views/generic-editing#django.views.generic.edit.DeleteView" title="django.views.generic.edit.DeleteView"><code>DeleteView</code></a>), and in the date-based generic views. These are covered in the <a class="reference internal" href="../../ref/class-based-views/mixins"><span class="doc">mixin reference documentation</span></a>.</p>  <h3 id="detailview-working-with-a-single-django-object">
<code>DetailView</code>: working with a single Django object</h3> <p id="s-detailview-working-with-a-single-django-object">To show the detail of an object, we basically need to do two things: we need to look up the object and then we need to make a <a class="reference internal" href="../../ref/template-response#django.template.response.TemplateResponse" title="django.template.response.TemplateResponse"><code>TemplateResponse</code></a> with a suitable template, and that object as context.</p> <p>To get the object, <a class="reference internal" href="../../ref/class-based-views/generic-display#django.views.generic.detail.DetailView" title="django.views.generic.detail.DetailView"><code>DetailView</code></a> relies on <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectMixin" title="django.views.generic.detail.SingleObjectMixin"><code>SingleObjectMixin</code></a>, which provides a <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectMixin.get_object" title="django.views.generic.detail.SingleObjectMixin.get_object"><code>get_object()</code></a> method that figures out the object based on the URL of the request (it looks for <code>pk</code> and <code>slug</code> keyword arguments as declared in the URLConf, and looks the object up either from the <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectMixin.model" title="django.views.generic.detail.SingleObjectMixin.model"><code>model</code></a> attribute on the view, or the <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectMixin.queryset" title="django.views.generic.detail.SingleObjectMixin.queryset"><code>queryset</code></a> attribute if that’s provided). <code>SingleObjectMixin</code> also overrides <a class="reference internal" href="../../ref/class-based-views/mixins-simple#django.views.generic.base.ContextMixin.get_context_data" title="django.views.generic.base.ContextMixin.get_context_data"><code>get_context_data()</code></a>, which is used across all Django’s built in class-based views to supply context data for template renders.</p> <p>To then make a <a class="reference internal" href="../../ref/template-response#django.template.response.TemplateResponse" title="django.template.response.TemplateResponse"><code>TemplateResponse</code></a>, <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#DetailView" title="DetailView"><code>DetailView</code></a> uses <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectTemplateResponseMixin" title="django.views.generic.detail.SingleObjectTemplateResponseMixin"><code>SingleObjectTemplateResponseMixin</code></a>, which extends <a class="reference internal" href="../../ref/class-based-views/mixins-simple#django.views.generic.base.TemplateResponseMixin" title="django.views.generic.base.TemplateResponseMixin"><code>TemplateResponseMixin</code></a>, overriding <a class="reference internal" href="../../ref/class-based-views/mixins-simple#django.views.generic.base.TemplateResponseMixin.get_template_names" title="django.views.generic.base.TemplateResponseMixin.get_template_names"><code>get_template_names()</code></a> as discussed above. It actually provides a fairly sophisticated set of options, but the main one that most people are going to use is <code>&lt;app_label&gt;/&lt;model_name&gt;_detail.html</code>. The <code>_detail</code> part can be changed by setting <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectTemplateResponseMixin.template_name_suffix" title="django.views.generic.detail.SingleObjectTemplateResponseMixin.template_name_suffix"><code>template_name_suffix</code></a> on a subclass to something else. (For instance, the <a class="reference internal" href="generic-editing"><span class="doc">generic edit views</span></a> use <code>_form</code> for create and update views, and <code>_confirm_delete</code> for delete views.)</p>   <h3 id="listview-working-with-many-django-objects">
<code>ListView</code>: working with many Django objects</h3> <p id="s-listview-working-with-many-django-objects">Lists of objects follow roughly the same pattern: we need a (possibly paginated) list of objects, typically a <a class="reference internal" href="../../ref/models/querysets#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a>, and then we need to make a <a class="reference internal" href="../../ref/template-response#django.template.response.TemplateResponse" title="django.template.response.TemplateResponse"><code>TemplateResponse</code></a> with a suitable template using that list of objects.</p> <p>To get the objects, <a class="reference internal" href="../../ref/class-based-views/generic-display#django.views.generic.list.ListView" title="django.views.generic.list.ListView"><code>ListView</code></a> uses <a class="reference internal" href="../../ref/class-based-views/mixins-multiple-object#django.views.generic.list.MultipleObjectMixin" title="django.views.generic.list.MultipleObjectMixin"><code>MultipleObjectMixin</code></a>, which provides both <a class="reference internal" href="../../ref/class-based-views/mixins-multiple-object#django.views.generic.list.MultipleObjectMixin.get_queryset" title="django.views.generic.list.MultipleObjectMixin.get_queryset"><code>get_queryset()</code></a> and <a class="reference internal" href="../../ref/class-based-views/mixins-multiple-object#django.views.generic.list.MultipleObjectMixin.paginate_queryset" title="django.views.generic.list.MultipleObjectMixin.paginate_queryset"><code>paginate_queryset()</code></a>. Unlike with <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectMixin" title="django.views.generic.detail.SingleObjectMixin"><code>SingleObjectMixin</code></a>, there’s no need to key off parts of the URL to figure out the queryset to work with, so the default uses the <a class="reference internal" href="../../ref/class-based-views/mixins-multiple-object#django.views.generic.list.MultipleObjectMixin.queryset" title="django.views.generic.list.MultipleObjectMixin.queryset"><code>queryset</code></a> or <a class="reference internal" href="../../ref/class-based-views/mixins-multiple-object#django.views.generic.list.MultipleObjectMixin.model" title="django.views.generic.list.MultipleObjectMixin.model"><code>model</code></a> attribute on the view class. A common reason to override <a class="reference internal" href="../../ref/class-based-views/mixins-multiple-object#django.views.generic.list.MultipleObjectMixin.get_queryset" title="django.views.generic.list.MultipleObjectMixin.get_queryset"><code>get_queryset()</code></a> here would be to dynamically vary the objects, such as depending on the current user or to exclude posts in the future for a blog.</p> <p><a class="reference internal" href="../../ref/class-based-views/mixins-multiple-object#django.views.generic.list.MultipleObjectMixin" title="django.views.generic.list.MultipleObjectMixin"><code>MultipleObjectMixin</code></a> also overrides <a class="reference internal" href="../../ref/class-based-views/mixins-simple#django.views.generic.base.ContextMixin.get_context_data" title="django.views.generic.base.ContextMixin.get_context_data"><code>get_context_data()</code></a> to include appropriate context variables for pagination (providing dummies if pagination is disabled). It relies on <code>object_list</code> being passed in as a keyword argument, which <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#ListView" title="ListView"><code>ListView</code></a> arranges for it.</p> <p>To make a <a class="reference internal" href="../../ref/template-response#django.template.response.TemplateResponse" title="django.template.response.TemplateResponse"><code>TemplateResponse</code></a>, <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#ListView" title="ListView"><code>ListView</code></a> then uses <a class="reference internal" href="../../ref/class-based-views/mixins-multiple-object#django.views.generic.list.MultipleObjectTemplateResponseMixin" title="django.views.generic.list.MultipleObjectTemplateResponseMixin"><code>MultipleObjectTemplateResponseMixin</code></a>; as with <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectTemplateResponseMixin" title="django.views.generic.detail.SingleObjectTemplateResponseMixin"><code>SingleObjectTemplateResponseMixin</code></a> above, this overrides <code>get_template_names()</code> to provide <a class="reference internal" href="../../ref/class-based-views/mixins-multiple-object#django.views.generic.list.MultipleObjectTemplateResponseMixin" title="django.views.generic.list.MultipleObjectTemplateResponseMixin"><code>a range of
options</code></a>, with the most commonly-used being <code>&lt;app_label&gt;/&lt;model_name&gt;_list.html</code>, with the <code>_list</code> part again being taken from the <a class="reference internal" href="../../ref/class-based-views/mixins-multiple-object#django.views.generic.list.MultipleObjectTemplateResponseMixin.template_name_suffix" title="django.views.generic.list.MultipleObjectTemplateResponseMixin.template_name_suffix"><code>template_name_suffix</code></a> attribute. (The date based generic views use suffixes such as <code>_archive</code>, <code>_archive_year</code> and so on to use different templates for the various specialized date-based list views.)</p>    <h2 id="using-django-s-class-based-view-mixins">Using Django’s class-based view mixins</h2> <p id="s-using-django-s-class-based-view-mixins">Now we’ve seen how Django’s generic class-based views use the provided mixins, let’s look at other ways we can combine them. We’re still going to be combining them with either built-in class-based views, or other generic class-based views, but there are a range of rarer problems you can solve than are provided for by Django out of the box.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>Not all mixins can be used together, and not all generic class based views can be used with all other mixins. Here we present a few examples that do work; if you want to bring together other functionality then you’ll have to consider interactions between attributes and methods that overlap between the different classes you’re using, and how <a class="reference external" href="https://www.python.org/download/releases/2.3/mro/">method resolution order</a> will affect which versions of the methods will be called in what order.</p> <p>The reference documentation for Django’s <a class="reference internal" href="../../ref/class-based-views/index"><span class="doc">class-based views</span></a> and <a class="reference internal" href="../../ref/class-based-views/mixins"><span class="doc">class-based view mixins</span></a> will help you in understanding which attributes and methods are likely to cause conflict between different classes and mixins.</p> <p class="last">If in doubt, it’s often better to back off and base your work on <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#View" title="View"><code>View</code></a> or <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#TemplateView" title="TemplateView"><code>TemplateView</code></a>, perhaps with <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectMixin" title="django.views.generic.detail.SingleObjectMixin"><code>SingleObjectMixin</code></a> and <a class="reference internal" href="../../ref/class-based-views/mixins-multiple-object#django.views.generic.list.MultipleObjectMixin" title="django.views.generic.list.MultipleObjectMixin"><code>MultipleObjectMixin</code></a>. Although you will probably end up writing more code, it is more likely to be clearly understandable to someone else coming to it later, and with fewer interactions to worry about you will save yourself some thinking. (Of course, you can always dip into Django’s implementation of the generic class-based views for inspiration on how to tackle problems.)</p> </div>  <h3 id="using-singleobjectmixin-with-view">Using <code>SingleObjectMixin</code> with View</h3> <p id="s-using-singleobjectmixin-with-view">If we want to write a class-based view that responds only to <code>POST</code>, we’ll subclass <a class="reference internal" href="../../ref/class-based-views/base#django.views.generic.base.View" title="django.views.generic.base.View"><code>View</code></a> and write a <code>post()</code> method in the subclass. However if we want our processing to work on a particular object, identified from the URL, we’ll want the functionality provided by <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectMixin" title="django.views.generic.detail.SingleObjectMixin"><code>SingleObjectMixin</code></a>.</p> <p>We’ll demonstrate this with the <code>Author</code> model we used in the <a class="reference internal" href="generic-display"><span class="doc">generic class-based views introduction</span></a>.</p> <div class="literal-block-wrapper docutils container" id="id1"> <div class="code-block-caption"><span class="caption-text">views.py</span></div> <pre data-language="python">from django.http import HttpResponseForbidden, HttpResponseRedirect
from django.urls import reverse
from django.views import View
from django.views.generic.detail import SingleObjectMixin
from books.models import Author

class RecordInterestView(SingleObjectMixin, View):
    """Records the current user's interest in an author."""
    model = Author

    def post(self, request, *args, **kwargs):
        if not request.user.is_authenticated:
            return HttpResponseForbidden()

        # Look up the author we're interested in.
        self.object = self.get_object()
        # Actually record interest somehow here!

        return HttpResponseRedirect(reverse('author-detail', kwargs={'pk': self.object.pk}))
</pre> </div> <p>In practice you’d probably want to record the interest in a key-value store rather than in a relational database, so we’ve left that bit out. The only bit of the view that needs to worry about using <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectMixin" title="django.views.generic.detail.SingleObjectMixin"><code>SingleObjectMixin</code></a> is where we want to look up the author we’re interested in, which it does with a call to <code>self.get_object()</code>. Everything else is taken care of for us by the mixin.</p> <p>We can hook this into our URLs easily enough:</p> <div class="literal-block-wrapper docutils container" id="id2"> <div class="code-block-caption"><span class="caption-text">urls.py</span></div> <pre data-language="python">from django.urls import path
from books.views import RecordInterestView

urlpatterns = [
    #...
    path('author/&lt;int:pk&gt;/interest/', RecordInterestView.as_view(), name='author-interest'),
]
</pre> </div> <p>Note the <code>pk</code> named group, which <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectMixin.get_object" title="django.views.generic.detail.SingleObjectMixin.get_object"><code>get_object()</code></a> uses to look up the <code>Author</code> instance. You could also use a slug, or any of the other features of <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectMixin" title="django.views.generic.detail.SingleObjectMixin"><code>SingleObjectMixin</code></a>.</p>   <h3 id="using-singleobjectmixin-with-listview">Using <code>SingleObjectMixin</code> with <code>ListView</code>
</h3> <p id="s-using-singleobjectmixin-with-listview"><a class="reference internal" href="../../ref/class-based-views/generic-display#django.views.generic.list.ListView" title="django.views.generic.list.ListView"><code>ListView</code></a> provides built-in pagination, but you might want to paginate a list of objects that are all linked (by a foreign key) to another object. In our publishing example, you might want to paginate through all the books by a particular publisher.</p> <p>One way to do this is to combine <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#ListView" title="ListView"><code>ListView</code></a> with <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectMixin" title="django.views.generic.detail.SingleObjectMixin"><code>SingleObjectMixin</code></a>, so that the queryset for the paginated list of books can hang off the publisher found as the single object. In order to do this, we need to have two different querysets:</p> <dl class="docutils"> <dt>
<code>Book queryset for use by</code> <a class="reference internal" href="../../ref/class-based-views/generic-display#django.views.generic.list.ListView" title="django.views.generic.list.ListView"><code>ListView</code></a>
</dt> <dd>Since we have access to the <code>Publisher</code> whose books we want to list, we override <code>get_queryset()</code> and use the <code>Publisher</code>’s <a class="reference internal" href="../db/queries#backwards-related-objects"><span class="std std-ref">reverse foreign key manager</span></a>.</dd> <dt>
<code>Publisher queryset for use in</code> <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectMixin.get_object" title="django.views.generic.detail.SingleObjectMixin.get_object"><code>get_object()</code></a>
</dt> <dd>We’ll rely on the default implementation of <code>get_object()</code> to fetch the correct <code>Publisher</code> object. However, we need to explicitly pass a <code>queryset</code> argument because otherwise the default implementation of <code>get_object()</code> would call <code>get_queryset()</code> which we have overridden to return <code>Book</code> objects instead of <code>Publisher</code> ones.</dd> </dl> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">We have to think carefully about <code>get_context_data()</code>. Since both <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectMixin" title="django.views.generic.detail.SingleObjectMixin"><code>SingleObjectMixin</code></a> and <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#ListView" title="ListView"><code>ListView</code></a> will put things in the context data under the value of <code>context_object_name</code> if it’s set, we’ll instead explicitly ensure the <code>Publisher</code> is in the context data. <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#ListView" title="ListView"><code>ListView</code></a> will add in the suitable <code>page_obj</code> and <code>paginator</code> for us providing we remember to call <code>super()</code>.</p> </div> <p>Now we can write a new <code>PublisherDetailView</code>:</p> <pre data-language="python">from django.views.generic import ListView
from django.views.generic.detail import SingleObjectMixin
from books.models import Publisher

class PublisherDetailView(SingleObjectMixin, ListView):
    paginate_by = 2
    template_name = "books/publisher_detail.html"

    def get(self, request, *args, **kwargs):
        self.object = self.get_object(queryset=Publisher.objects.all())
        return super().get(request, *args, **kwargs)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['publisher'] = self.object
        return context

    def get_queryset(self):
        return self.object.book_set.all()
</pre> <p>Notice how we set <code>self.object</code> within <code>get()</code> so we can use it again later in <code>get_context_data()</code> and <code>get_queryset()</code>. If you don’t set <code>template_name</code>, the template will default to the normal <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#ListView" title="ListView"><code>ListView</code></a> choice, which in this case would be <code>"books/book_list.html"</code> because it’s a list of books; <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#ListView" title="ListView"><code>ListView</code></a> knows nothing about <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectMixin" title="django.views.generic.detail.SingleObjectMixin"><code>SingleObjectMixin</code></a>, so it doesn’t have any clue this view is anything to do with a <code>Publisher</code>.</p> <p>The <code>paginate_by</code> is deliberately small in the example so you don’t have to create lots of books to see the pagination working! Here’s the template you’d want to use:</p> <pre data-language="markup">{% extends "base.html" %}

{% block content %}
    &lt;h2&gt;Publisher {{ publisher.name }}&lt;/h2&gt;

    &lt;ol&gt;
      {% for book in page_obj %}
        &lt;li&gt;{{ book.title }}&lt;/li&gt;
      {% endfor %}
    &lt;/ol&gt;

    &lt;div class="pagination"&gt;
        &lt;span class="step-links"&gt;
            {% if page_obj.has_previous %}
                &lt;a href="?page={{ page_obj.previous_page_number }}"&gt;previous&lt;/a&gt;
            {% endif %}

            &lt;span class="current"&gt;
                Page {{ page_obj.number }} of {{ paginator.num_pages }}.
            &lt;/span&gt;

            {% if page_obj.has_next %}
                &lt;a href="?page={{ page_obj.next_page_number }}"&gt;next&lt;/a&gt;
            {% endif %}
        &lt;/span&gt;
    &lt;/div&gt;
{% endblock %}
</pre>    <h2 id="avoid-anything-more-complex">Avoid anything more complex</h2> <p id="s-avoid-anything-more-complex">Generally you can use <a class="reference internal" href="../../ref/class-based-views/mixins-simple#django.views.generic.base.TemplateResponseMixin" title="django.views.generic.base.TemplateResponseMixin"><code>TemplateResponseMixin</code></a> and <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectMixin" title="django.views.generic.detail.SingleObjectMixin"><code>SingleObjectMixin</code></a> when you need their functionality. As shown above, with a bit of care you can even combine <code>SingleObjectMixin</code> with <a class="reference internal" href="../../ref/class-based-views/generic-display#django.views.generic.list.ListView" title="django.views.generic.list.ListView"><code>ListView</code></a>. However things get increasingly complex as you try to do so, and a good rule of thumb is:</p> <div class="admonition hint"> <p class="first admonition-title">Hint</p> <p class="last">Each of your views should use only mixins or views from one of the groups of generic class-based views: <a class="reference internal" href="generic-display"><span class="doc">detail, list</span></a>, <a class="reference internal" href="generic-editing"><span class="doc">editing</span></a> and date. For example it’s fine to combine <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#TemplateView" title="TemplateView"><code>TemplateView</code></a> (built in view) with <a class="reference internal" href="../../ref/class-based-views/mixins-multiple-object#django.views.generic.list.MultipleObjectMixin" title="django.views.generic.list.MultipleObjectMixin"><code>MultipleObjectMixin</code></a> (generic list), but you’re likely to have problems combining <code>SingleObjectMixin</code> (generic detail) with <code>MultipleObjectMixin</code> (generic list).</p> </div> <p>To show what happens when you try to get more sophisticated, we show an example that sacrifices readability and maintainability when there is a simpler solution. First, let’s look at a naive attempt to combine <a class="reference internal" href="../../ref/class-based-views/generic-display#django.views.generic.detail.DetailView" title="django.views.generic.detail.DetailView"><code>DetailView</code></a> with <a class="reference internal" href="../../ref/class-based-views/mixins-editing#django.views.generic.edit.FormMixin" title="django.views.generic.edit.FormMixin"><code>FormMixin</code></a> to enable us to <code>POST</code> a Django <a class="reference internal" href="../../ref/forms/api#django.forms.Form" title="django.forms.Form"><code>Form</code></a> to the same URL as we’re displaying an object using <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#DetailView" title="DetailView"><code>DetailView</code></a>.</p>  <h3 id="using-formmixin-with-detailview">Using <code>FormMixin</code> with <code>DetailView</code>
</h3> <p id="s-using-formmixin-with-detailview">Think back to our earlier example of using <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#View" title="View"><code>View</code></a> and <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectMixin" title="django.views.generic.detail.SingleObjectMixin"><code>SingleObjectMixin</code></a> together. We were recording a user’s interest in a particular author; say now that we want to let them leave a message saying why they like them. Again, let’s assume we’re not going to store this in a relational database but instead in something more esoteric that we won’t worry about here.</p> <p>At this point it’s natural to reach for a <a class="reference internal" href="../../ref/forms/api#django.forms.Form" title="django.forms.Form"><code>Form</code></a> to encapsulate the information sent from the user’s browser to Django. Say also that we’re heavily invested in <a class="reference external" href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST</a>, so we want to use the same URL for displaying the author as for capturing the message from the user. Let’s rewrite our <code>AuthorDetailView</code> to do that.</p> <p>We’ll keep the <code>GET</code> handling from <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#DetailView" title="DetailView"><code>DetailView</code></a>, although we’ll have to add a <a class="reference internal" href="../../ref/forms/api#django.forms.Form" title="django.forms.Form"><code>Form</code></a> into the context data so we can render it in the template. We’ll also want to pull in form processing from <a class="reference internal" href="../../ref/class-based-views/mixins-editing#django.views.generic.edit.FormMixin" title="django.views.generic.edit.FormMixin"><code>FormMixin</code></a>, and write a bit of code so that on <code>POST</code> the form gets called appropriately.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">We use <a class="reference internal" href="../../ref/class-based-views/mixins-editing#django.views.generic.edit.FormMixin" title="django.views.generic.edit.FormMixin"><code>FormMixin</code></a> and implement <code>post()</code> ourselves rather than try to mix <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#DetailView" title="DetailView"><code>DetailView</code></a> with <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#FormView" title="FormView"><code>FormView</code></a> (which provides a suitable <code>post()</code> already) because both of the views implement <code>get()</code>, and things would get much more confusing.</p> </div> <p>Our new <code>AuthorDetailView</code> looks like this:</p> <pre data-language="python"># CAUTION: you almost certainly do not want to do this.
# It is provided as part of a discussion of problems you can
# run into when combining different generic class-based view
# functionality that is not designed to be used together.

from django import forms
from django.http import HttpResponseForbidden
from django.urls import reverse
from django.views.generic import DetailView
from django.views.generic.edit import FormMixin
from books.models import Author

class AuthorInterestForm(forms.Form):
    message = forms.CharField()

class AuthorDetailView(FormMixin, DetailView):
    model = Author
    form_class = AuthorInterestForm

    def get_success_url(self):
        return reverse('author-detail', kwargs={'pk': self.object.pk})

    def post(self, request, *args, **kwargs):
        if not request.user.is_authenticated:
            return HttpResponseForbidden()
        self.object = self.get_object()
        form = self.get_form()
        if form.is_valid():
            return self.form_valid(form)
        else:
            return self.form_invalid(form)

    def form_valid(self, form):
        # Here, we would record the user's interest using the message
        # passed in form.cleaned_data['message']
        return super().form_valid(form)
</pre> <p><code>get_success_url()</code> provides somewhere to redirect to, which gets used in the default implementation of <code>form_valid()</code>. We have to provide our own <code>post()</code> as noted earlier.</p>   <h3 id="a-better-solution">A better solution</h3> <p id="s-a-better-solution">The number of subtle interactions between <a class="reference internal" href="../../ref/class-based-views/mixins-editing#django.views.generic.edit.FormMixin" title="django.views.generic.edit.FormMixin"><code>FormMixin</code></a> and <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#DetailView" title="DetailView"><code>DetailView</code></a> is already testing our ability to manage things. It’s unlikely you’d want to write this kind of class yourself.</p> <p>In this case, you could write the <code>post()</code> method yourself, keeping <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#DetailView" title="DetailView"><code>DetailView</code></a> as the only generic functionality, although writing <a class="reference internal" href="../../ref/forms/api#django.forms.Form" title="django.forms.Form"><code>Form</code></a> handling code involves a lot of duplication.</p> <p>Alternatively, it would still be less work than the above approach to have a separate view for processing the form, which could use <a class="reference internal" href="../../ref/class-based-views/generic-editing#django.views.generic.edit.FormView" title="django.views.generic.edit.FormView"><code>FormView</code></a> distinct from <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#DetailView" title="DetailView"><code>DetailView</code></a> without concerns.</p>   <h3 id="an-alternative-better-solution">An alternative better solution</h3> <p id="s-an-alternative-better-solution">What we’re really trying to do here is to use two different class based views from the same URL. So why not do just that? We have a very clear division here: <code>GET</code> requests should get the <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#DetailView" title="DetailView"><code>DetailView</code></a> (with the <a class="reference internal" href="../../ref/forms/api#django.forms.Form" title="django.forms.Form"><code>Form</code></a> added to the context data), and <code>POST</code> requests should get the <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#FormView" title="FormView"><code>FormView</code></a>. Let’s set up those views first.</p> <p>The <code>AuthorDetailView</code> view is almost the same as <a class="reference internal" href="generic-display#generic-views-extra-work"><span class="std std-ref">when we first introduced AuthorDetailView</span></a>; we have to write our own <code>get_context_data()</code> to make the <code>AuthorInterestForm</code> available to the template. We’ll skip the <code>get_object()</code> override from before for clarity:</p> <pre data-language="python">from django import forms
from django.views.generic import DetailView
from books.models import Author

class AuthorInterestForm(forms.Form):
    message = forms.CharField()

class AuthorDetailView(DetailView):
    model = Author

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['form'] = AuthorInterestForm()
        return context
</pre> <p>Then the <code>AuthorInterestForm</code> is a <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#FormView" title="FormView"><code>FormView</code></a>, but we have to bring in <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectMixin" title="django.views.generic.detail.SingleObjectMixin"><code>SingleObjectMixin</code></a> so we can find the author we’re talking about, and we have to remember to set <code>template_name</code> to ensure that form errors will render the same template as <code>AuthorDetailView</code> is using on <code>GET</code>:</p> <pre data-language="python">from django.http import HttpResponseForbidden
from django.urls import reverse
from django.views.generic import FormView
from django.views.generic.detail import SingleObjectMixin

class AuthorInterestFormView(SingleObjectMixin, FormView):
    template_name = 'books/author_detail.html'
    form_class = AuthorInterestForm
    model = Author

    def post(self, request, *args, **kwargs):
        if not request.user.is_authenticated:
            return HttpResponseForbidden()
        self.object = self.get_object()
        return super().post(request, *args, **kwargs)

    def get_success_url(self):
        return reverse('author-detail', kwargs={'pk': self.object.pk})
</pre> <p>Finally we bring this together in a new <code>AuthorView</code> view. We already know that calling <a class="reference internal" href="../../ref/class-based-views/base#django.views.generic.base.View.as_view" title="django.views.generic.base.View.as_view"><code>as_view()</code></a> on a class-based view gives us something that behaves exactly like a function based view, so we can do that at the point we choose between the two subviews.</p> <p>You can pass through keyword arguments to <a class="reference internal" href="../../ref/class-based-views/base#django.views.generic.base.View.as_view" title="django.views.generic.base.View.as_view"><code>as_view()</code></a> in the same way you would in your URLconf, such as if you wanted the <code>AuthorInterestFormView</code> behavior to also appear at another URL but using a different template:</p> <pre data-language="python">from django.views import View

class AuthorView(View):

    def get(self, request, *args, **kwargs):
        view = AuthorDetailView.as_view()
        return view(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        view = AuthorInterestFormView.as_view()
        return view(request, *args, **kwargs)
</pre> <p>This approach can also be used with any other generic class-based views or your own class-based views inheriting directly from <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#View" title="View"><code>View</code></a> or <a class="reference internal" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/flattened-index/#TemplateView" title="TemplateView"><code>TemplateView</code></a>, as it keeps the different views as separate as possible.</p>    <h2 id="jsonresponsemixin-example">More than just HTML</h2> <p id="s-more-than-just-html">Where class-based views shine is when you want to do the same thing many times. Suppose you’re writing an API, and every view should return JSON instead of rendered HTML.</p> <p>We can create a mixin class to use in all of our views, handling the conversion to JSON once.</p> <p>For example, a JSON mixin might look something like this:</p> <pre data-language="python">from django.http import JsonResponse

class JSONResponseMixin:
    """
    A mixin that can be used to render a JSON response.
    """
    def render_to_json_response(self, context, **response_kwargs):
        """
        Returns a JSON response, transforming 'context' to make the payload.
        """
        return JsonResponse(
            self.get_data(context),
            **response_kwargs
        )

    def get_data(self, context):
        """
        Returns an object that will be serialized as JSON by json.dumps().
        """
        # Note: This is *EXTREMELY* naive; in reality, you'll need
        # to do much more complex handling to ensure that arbitrary
        # objects -- such as Django model instances or querysets
        # -- can be serialized as JSON.
        return context
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Check out the <a class="reference internal" href="../serialization"><span class="doc">Serializing Django objects</span></a> documentation for more information on how to correctly transform Django models and querysets into JSON.</p> </div> <p>This mixin provides a <code>render_to_json_response()</code> method with the same signature as <a class="reference internal" href="../../ref/class-based-views/mixins-simple#django.views.generic.base.TemplateResponseMixin.render_to_response" title="django.views.generic.base.TemplateResponseMixin.render_to_response"><code>render_to_response()</code></a>. To use it, we need to mix it into a <code>TemplateView</code> for example, and override <code>render_to_response()</code> to call <code>render_to_json_response()</code> instead:</p> <pre data-language="python">from django.views.generic import TemplateView

class JSONView(JSONResponseMixin, TemplateView):
    def render_to_response(self, context, **response_kwargs):
        return self.render_to_json_response(context, **response_kwargs)
</pre> <p>Equally we could use our mixin with one of the generic views. We can make our own version of <a class="reference internal" href="../../ref/class-based-views/generic-display#django.views.generic.detail.DetailView" title="django.views.generic.detail.DetailView"><code>DetailView</code></a> by mixing <code>JSONResponseMixin</code> with the <a class="reference internal" href="../../ref/class-based-views/generic-display#django.views.generic.detail.BaseDetailView" title="django.views.generic.detail.BaseDetailView"><code>BaseDetailView</code></a> – (the <a class="reference internal" href="../../ref/class-based-views/generic-display#django.views.generic.detail.DetailView" title="django.views.generic.detail.DetailView"><code>DetailView</code></a> before template rendering behavior has been mixed in):</p> <pre data-language="python">from django.views.generic.detail import BaseDetailView

class JSONDetailView(JSONResponseMixin, BaseDetailView):
    def render_to_response(self, context, **response_kwargs):
        return self.render_to_json_response(context, **response_kwargs)
</pre> <p>This view can then be deployed in the same way as any other <a class="reference internal" href="../../ref/class-based-views/generic-display#django.views.generic.detail.DetailView" title="django.views.generic.detail.DetailView"><code>DetailView</code></a>, with exactly the same behavior – except for the format of the response.</p> <p>If you want to be really adventurous, you could even mix a <a class="reference internal" href="../../ref/class-based-views/generic-display#django.views.generic.detail.DetailView" title="django.views.generic.detail.DetailView"><code>DetailView</code></a> subclass that is able to return <em>both</em> HTML and JSON content, depending on some property of the HTTP request, such as a query argument or an HTTP header. Mix in both the <code>JSONResponseMixin</code> and a <a class="reference internal" href="../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectTemplateResponseMixin" title="django.views.generic.detail.SingleObjectTemplateResponseMixin"><code>SingleObjectTemplateResponseMixin</code></a>, and override the implementation of <a class="reference internal" href="../../ref/class-based-views/mixins-simple#django.views.generic.base.TemplateResponseMixin.render_to_response" title="django.views.generic.base.TemplateResponseMixin.render_to_response"><code>render_to_response()</code></a> to defer to the appropriate rendering method depending on the type of response that the user requested:</p> <pre data-language="python">from django.views.generic.detail import SingleObjectTemplateResponseMixin

class HybridDetailView(JSONResponseMixin, SingleObjectTemplateResponseMixin, BaseDetailView):
    def render_to_response(self, context):
        # Look for a 'format=json' GET argument
        if self.request.GET.get('format') == 'json':
            return self.render_to_json_response(context)
        else:
            return super().render_to_response(context)
</pre> <p>Because of the way that Python resolves method overloading, the call to <code>super().render_to_response(context)</code> ends up calling the <a class="reference internal" href="../../ref/class-based-views/mixins-simple#django.views.generic.base.TemplateResponseMixin.render_to_response" title="django.views.generic.base.TemplateResponseMixin.render_to_response"><code>render_to_response()</code></a> implementation of <a class="reference internal" href="../../ref/class-based-views/mixins-simple#django.views.generic.base.TemplateResponseMixin" title="django.views.generic.base.TemplateResponseMixin"><code>TemplateResponseMixin</code></a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/4.0/topics/class-based-views/mixins/" class="_attribution-link">https://docs.djangoproject.com/en/4.0/topics/class-based-views/mixins/</a>
  </p>
</div>
