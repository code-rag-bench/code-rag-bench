<h1 id="testing-tools">Testing tools</h1> <p id="s-testing-tools">Django provides a small set of tools that come in handy when writing tests.</p>  <h2 id="test-client">The test client</h2> <p id="s-the-test-client">The test client is a Python class that acts as a dummy web browser, allowing you to test your views and interact with your Django-powered application programmatically.</p> <p>Some of the things you can do with the test client are:</p> <ul class="simple"> <li>Simulate GET and POST requests on a URL and observe the response – everything from low-level HTTP (result headers and status codes) to page content.</li> <li>See the chain of redirects (if any) and check the URL and status code at each step.</li> <li>Test that a given request is rendered by a given Django template, with a template context that contains certain values.</li> </ul> <p>Note that the test client is not intended to be a replacement for <a class="reference external" href="https://www.selenium.dev/">Selenium</a> or other “in-browser” frameworks. Django’s test client has a different focus. In short:</p> <ul class="simple"> <li>Use Django’s test client to establish that the correct template is being rendered and that the template is passed the correct context data.</li> <li>Use in-browser frameworks like <a class="reference external" href="https://www.selenium.dev/">Selenium</a> to test <em>rendered</em> HTML and the <em>behavior</em> of web pages, namely JavaScript functionality. Django also provides special support for those frameworks; see the section on <a class="reference internal" href="#django.test.LiveServerTestCase" title="django.test.LiveServerTestCase"><code>LiveServerTestCase</code></a> for more details.</li> </ul> <p>A comprehensive test suite should use a combination of both test types.</p>  <h3 id="overview-and-a-quick-example">Overview and a quick example</h3> <p id="s-overview-and-a-quick-example">To use the test client, instantiate <code>django.test.Client</code> and retrieve web pages:</p> <pre data-language="python">&gt;&gt;&gt; from django.test import Client
&gt;&gt;&gt; c = Client()
&gt;&gt;&gt; response = c.post('/login/', {'username': 'john', 'password': 'smith'})
&gt;&gt;&gt; response.status_code
200
&gt;&gt;&gt; response = c.get('/customer/details/')
&gt;&gt;&gt; response.content
b'&lt;!DOCTYPE html...'
</pre> <p>As this example suggests, you can instantiate <code>Client</code> from within a session of the Python interactive interpreter.</p> <p>Note a few important things about how the test client works:</p> <ul> <li>The test client does <em>not</em> require the web server to be running. In fact, it will run just fine with no web server running at all! That’s because it avoids the overhead of HTTP and deals directly with the Django framework. This helps make the unit tests run quickly. </li> <li>
<p class="first">When retrieving pages, remember to specify the <em>path</em> of the URL, not the whole domain. For example, this is correct:</p> <pre data-language="python">&gt;&gt;&gt; c.get('/login/')
</pre> <p>This is incorrect:</p> <pre data-language="python">&gt;&gt;&gt; c.get('https://www.example.com/login/')
</pre> <p>The test client is not capable of retrieving web pages that are not powered by your Django project. If you need to retrieve other web pages, use a Python standard library module such as <a class="reference external" href="https://docs.python.org/3/library/urllib.html#module-urllib" title="(in Python v3.10)"><code>urllib</code></a>.</p> </li> <li>To resolve URLs, the test client uses whatever URLconf is pointed-to by your <a class="reference internal" href="../../ref/settings#std:setting-ROOT_URLCONF"><code>ROOT_URLCONF</code></a> setting. </li> <li>
<p class="first">Although the above example would work in the Python interactive interpreter, some of the test client’s functionality, notably the template-related functionality, is only available <em>while tests are running</em>.</p> <p>The reason for this is that Django’s test runner performs a bit of black magic in order to determine which template was loaded by a given view. This black magic (essentially a patching of Django’s template system in memory) only happens during test running.</p> </li> <li>
<p class="first">By default, the test client will disable any CSRF checks performed by your site.</p> <p>If, for some reason, you <em>want</em> the test client to perform CSRF checks, you can create an instance of the test client that enforces CSRF checks. To do this, pass in the <code>enforce_csrf_checks</code> argument when you construct your client:</p> <pre data-language="python">&gt;&gt;&gt; from django.test import Client
&gt;&gt;&gt; csrf_client = Client(enforce_csrf_checks=True)
</pre> </li> </ul>   <h3 id="making-requests">Making requests</h3> <p id="s-making-requests">Use the <code>django.test.Client</code> class to make requests.</p> <dl class="class"> <dt id="django.test.Client">
<code>class Client(enforce_csrf_checks=False, json_encoder=DjangoJSONEncoder, **defaults)</code> </dt> <dd>
<p>It requires no arguments at time of construction. However, you can use keyword arguments to specify some default headers. For example, this will send a <code>User-Agent</code> HTTP header in each request:</p> <pre data-language="python">&gt;&gt;&gt; c = Client(HTTP_USER_AGENT='Mozilla/5.0')
</pre> <p>The values from the <code>extra</code> keyword arguments passed to <a class="reference internal" href="#django.test.Client.get" title="django.test.Client.get"><code>get()</code></a>, <a class="reference internal" href="#django.test.Client.post" title="django.test.Client.post"><code>post()</code></a>, etc. have precedence over the defaults passed to the class constructor.</p> <p>The <code>enforce_csrf_checks</code> argument can be used to test CSRF protection (see above).</p> <p>The <code>json_encoder</code> argument allows setting a custom JSON encoder for the JSON serialization that’s described in <a class="reference internal" href="#django.test.Client.post" title="django.test.Client.post"><code>post()</code></a>.</p> <p>The <code>raise_request_exception</code> argument allows controlling whether or not exceptions raised during the request should also be raised in the test. Defaults to <code>True</code>.</p> <p>Once you have a <code>Client</code> instance, you can call any of the following methods:</p> <dl class="method"> <dt id="django.test.Client.get">
<code>get(path, data=None, follow=False, secure=False, **extra)</code> </dt> <dd>
<p>Makes a GET request on the provided <code>path</code> and returns a <code>Response</code> object, which is documented below.</p> <p>The key-value pairs in the <code>data</code> dictionary are used to create a GET data payload. For example:</p> <pre data-language="python">&gt;&gt;&gt; c = Client()
&gt;&gt;&gt; c.get('/customers/details/', {'name': 'fred', 'age': 7})
</pre> <p>…will result in the evaluation of a GET request equivalent to:</p> <pre data-language="python">/customers/details/?name=fred&amp;age=7
</pre> <p>The <code>extra</code> keyword arguments parameter can be used to specify headers to be sent in the request. For example:</p> <pre data-language="python">&gt;&gt;&gt; c = Client()
&gt;&gt;&gt; c.get('/customers/details/', {'name': 'fred', 'age': 7},
...       HTTP_ACCEPT='application/json')
</pre> <p>…will send the HTTP header <code>HTTP_ACCEPT</code> to the details view, which is a good way to test code paths that use the <a class="reference internal" href="../../ref/request-response#django.http.HttpRequest.accepts" title="django.http.HttpRequest.accepts"><code>django.http.HttpRequest.accepts()</code></a> method.</p> <div class="admonition-cgi-specification admonition"> <p class="first admonition-title">CGI specification</p> <p class="last">The headers sent via <code>**extra</code> should follow <a class="reference external" href="https://www.w3.org/CGI/">CGI</a> specification. For example, emulating a different “Host” header as sent in the HTTP request from the browser to the server should be passed as <code>HTTP_HOST</code>.</p> </div> <p>If you already have the GET arguments in URL-encoded form, you can use that encoding instead of using the data argument. For example, the previous GET request could also be posed as:</p> <pre data-language="python">&gt;&gt;&gt; c = Client()
&gt;&gt;&gt; c.get('/customers/details/?name=fred&amp;age=7')
</pre> <p>If you provide a URL with both an encoded GET data and a data argument, the data argument will take precedence.</p> <p>If you set <code>follow</code> to <code>True</code> the client will follow any redirects and a <code>redirect_chain</code> attribute will be set in the response object containing tuples of the intermediate urls and status codes.</p> <p>If you had a URL <code>/redirect_me/</code> that redirected to <code>/next/</code>, that redirected to <code>/final/</code>, this is what you’d see:</p> <pre data-language="python">&gt;&gt;&gt; response = c.get('/redirect_me/', follow=True)
&gt;&gt;&gt; response.redirect_chain
[('http://testserver/next/', 302), ('http://testserver/final/', 302)]
</pre> <p>If you set <code>secure</code> to <code>True</code> the client will emulate an HTTPS request.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.Client.post">
<code>post(path, data=None, content_type=MULTIPART_CONTENT, follow=False, secure=False, **extra)</code> </dt> <dd>
<p>Makes a POST request on the provided <code>path</code> and returns a <code>Response</code> object, which is documented below.</p> <p>The key-value pairs in the <code>data</code> dictionary are used to submit POST data. For example:</p> <pre data-language="python">&gt;&gt;&gt; c = Client()
&gt;&gt;&gt; c.post('/login/', {'name': 'fred', 'passwd': 'secret'})
</pre> <p>…will result in the evaluation of a POST request to this URL:</p> <pre data-language="python">/login/
</pre> <p>…with this POST data:</p> <pre data-language="python">name=fred&amp;passwd=secret
</pre> <p>If you provide <code>content_type</code> as <em class="mimetype">application/json</em>, the <code>data</code> is serialized using <a class="reference external" href="https://docs.python.org/3/library/json.html#json.dumps" title="(in Python v3.10)"><code>json.dumps()</code></a> if it’s a dict, list, or tuple. Serialization is performed with <a class="reference internal" href="../serialization#django.core.serializers.json.DjangoJSONEncoder" title="django.core.serializers.json.DjangoJSONEncoder"><code>DjangoJSONEncoder</code></a> by default, and can be overridden by providing a <code>json_encoder</code> argument to <a class="reference internal" href="#django.test.Client" title="django.test.Client"><code>Client</code></a>. This serialization also happens for <a class="reference internal" href="#django.test.Client.put" title="django.test.Client.put"><code>put()</code></a>, <a class="reference internal" href="#django.test.Client.patch" title="django.test.Client.patch"><code>patch()</code></a>, and <a class="reference internal" href="#django.test.Client.delete" title="django.test.Client.delete"><code>delete()</code></a> requests.</p> <p>If you provide any other <code>content_type</code> (e.g. <em class="mimetype">text/xml</em> for an XML payload), the contents of <code>data</code> are sent as-is in the POST request, using <code>content_type</code> in the HTTP <code>Content-Type</code> header.</p> <p>If you don’t provide a value for <code>content_type</code>, the values in <code>data</code> will be transmitted with a content type of <em class="mimetype">multipart/form-data</em>. In this case, the key-value pairs in <code>data</code> will be encoded as a multipart message and used to create the POST data payload.</p> <p>To submit multiple values for a given key – for example, to specify the selections for a <code>&lt;select multiple&gt;</code> – provide the values as a list or tuple for the required key. For example, this value of <code>data</code> would submit three selected values for the field named <code>choices</code>:</p> <pre data-language="python">{'choices': ('a', 'b', 'd')}
</pre> <p>Submitting files is a special case. To POST a file, you need only provide the file field name as a key, and a file handle to the file you wish to upload as a value. For example:</p> <pre data-language="python">&gt;&gt;&gt; c = Client()
&gt;&gt;&gt; with open('wishlist.doc', 'rb') as fp:
...     c.post('/customers/wishes/', {'name': 'fred', 'attachment': fp})
</pre> <p>(The name <code>attachment</code> here is not relevant; use whatever name your file-processing code expects.)</p> <p>You may also provide any file-like object (e.g., <a class="reference external" href="https://docs.python.org/3/library/io.html#io.StringIO" title="(in Python v3.10)"><code>StringIO</code></a> or <a class="reference external" href="https://docs.python.org/3/library/io.html#io.BytesIO" title="(in Python v3.10)"><code>BytesIO</code></a>) as a file handle. If you’re uploading to an <a class="reference internal" href="../../ref/models/fields#django.db.models.ImageField" title="django.db.models.ImageField"><code>ImageField</code></a>, the object needs a <code>name</code> attribute that passes the <a class="reference internal" href="../../ref/validators#django.core.validators.validate_image_file_extension" title="django.core.validators.validate_image_file_extension"><code>validate_image_file_extension</code></a> validator. For example:</p> <pre data-language="python">&gt;&gt;&gt; from io import BytesIO
&gt;&gt;&gt; img = BytesIO(b'mybinarydata')
&gt;&gt;&gt; img.name = 'myimage.jpg'
</pre> <p>Note that if you wish to use the same file handle for multiple <code>post()</code> calls then you will need to manually reset the file pointer between posts. The easiest way to do this is to manually close the file after it has been provided to <code>post()</code>, as demonstrated above.</p> <p>You should also ensure that the file is opened in a way that allows the data to be read. If your file contains binary data such as an image, this means you will need to open the file in <code>rb</code> (read binary) mode.</p> <p>The <code>extra</code> argument acts the same as for <a class="reference internal" href="#django.test.Client.get" title="django.test.Client.get"><code>Client.get()</code></a>.</p> <p>If the URL you request with a POST contains encoded parameters, these parameters will be made available in the request.GET data. For example, if you were to make the request:</p> <pre data-language="python">&gt;&gt;&gt; c.post('/login/?visitor=true', {'name': 'fred', 'passwd': 'secret'})
</pre> <p>… the view handling this request could interrogate request.POST to retrieve the username and password, and could interrogate request.GET to determine if the user was a visitor.</p> <p>If you set <code>follow</code> to <code>True</code> the client will follow any redirects and a <code>redirect_chain</code> attribute will be set in the response object containing tuples of the intermediate urls and status codes.</p> <p>If you set <code>secure</code> to <code>True</code> the client will emulate an HTTPS request.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.Client.head">
<code>head(path, data=None, follow=False, secure=False, **extra)</code> </dt> <dd>
<p>Makes a HEAD request on the provided <code>path</code> and returns a <code>Response</code> object. This method works just like <a class="reference internal" href="#django.test.Client.get" title="django.test.Client.get"><code>Client.get()</code></a>, including the <code>follow</code>, <code>secure</code> and <code>extra</code> arguments, except it does not return a message body.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.Client.options">
<code>options(path, data='', content_type='application/octet-stream', follow=False, secure=False, **extra)</code> </dt> <dd>
<p>Makes an OPTIONS request on the provided <code>path</code> and returns a <code>Response</code> object. Useful for testing RESTful interfaces.</p> <p>When <code>data</code> is provided, it is used as the request body, and a <code>Content-Type</code> header is set to <code>content_type</code>.</p> <p>The <code>follow</code>, <code>secure</code> and <code>extra</code> arguments act the same as for <a class="reference internal" href="#django.test.Client.get" title="django.test.Client.get"><code>Client.get()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.Client.put">
<code>put(path, data='', content_type='application/octet-stream', follow=False, secure=False, **extra)</code> </dt> <dd>
<p>Makes a PUT request on the provided <code>path</code> and returns a <code>Response</code> object. Useful for testing RESTful interfaces.</p> <p>When <code>data</code> is provided, it is used as the request body, and a <code>Content-Type</code> header is set to <code>content_type</code>.</p> <p>The <code>follow</code>, <code>secure</code> and <code>extra</code> arguments act the same as for <a class="reference internal" href="#django.test.Client.get" title="django.test.Client.get"><code>Client.get()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.Client.patch">
<code>patch(path, data='', content_type='application/octet-stream', follow=False, secure=False, **extra)</code> </dt> <dd>
<p>Makes a PATCH request on the provided <code>path</code> and returns a <code>Response</code> object. Useful for testing RESTful interfaces.</p> <p>The <code>follow</code>, <code>secure</code> and <code>extra</code> arguments act the same as for <a class="reference internal" href="#django.test.Client.get" title="django.test.Client.get"><code>Client.get()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.Client.delete">
<code>delete(path, data='', content_type='application/octet-stream', follow=False, secure=False, **extra)</code> </dt> <dd>
<p>Makes a DELETE request on the provided <code>path</code> and returns a <code>Response</code> object. Useful for testing RESTful interfaces.</p> <p>When <code>data</code> is provided, it is used as the request body, and a <code>Content-Type</code> header is set to <code>content_type</code>.</p> <p>The <code>follow</code>, <code>secure</code> and <code>extra</code> arguments act the same as for <a class="reference internal" href="#django.test.Client.get" title="django.test.Client.get"><code>Client.get()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.Client.trace">
<code>trace(path, follow=False, secure=False, **extra)</code> </dt> <dd>
<p>Makes a TRACE request on the provided <code>path</code> and returns a <code>Response</code> object. Useful for simulating diagnostic probes.</p> <p>Unlike the other request methods, <code>data</code> is not provided as a keyword parameter in order to comply with <a class="rfc reference external" href="https://tools.ietf.org/html/rfc7231.html#section-4.3.8" id="index-0"><strong>RFC 7231#section-4.3.8</strong></a>, which mandates that TRACE requests must not have a body.</p> <p>The <code>follow</code>, <code>secure</code>, and <code>extra</code> arguments act the same as for <a class="reference internal" href="#django.test.Client.get" title="django.test.Client.get"><code>Client.get()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.Client.login">
<code>login(**credentials)</code> </dt> <dd>
<p>If your site uses Django’s <a class="reference internal" href="../auth/index"><span class="doc">authentication system</span></a> and you deal with logging in users, you can use the test client’s <code>login()</code> method to simulate the effect of a user logging into the site.</p> <p>After you call this method, the test client will have all the cookies and session data required to pass any login-based tests that may form part of a view.</p> <p>The format of the <code>credentials</code> argument depends on which <a class="reference internal" href="../auth/customizing#authentication-backends"><span class="std std-ref">authentication backend</span></a> you’re using (which is configured by your <a class="reference internal" href="../../ref/settings#std:setting-AUTHENTICATION_BACKENDS"><code>AUTHENTICATION_BACKENDS</code></a> setting). If you’re using the standard authentication backend provided by Django (<code>ModelBackend</code>), <code>credentials</code> should be the user’s username and password, provided as keyword arguments:</p> <pre data-language="python">&gt;&gt;&gt; c = Client()
&gt;&gt;&gt; c.login(username='fred', password='secret')

# Now you can access a view that's only available to logged-in users.
</pre> <p>If you’re using a different authentication backend, this method may require different credentials. It requires whichever credentials are required by your backend’s <code>authenticate()</code> method.</p> <p><code>login()</code> returns <code>True</code> if it the credentials were accepted and login was successful.</p> <p>Finally, you’ll need to remember to create user accounts before you can use this method. As we explained above, the test runner is executed using a test database, which contains no users by default. As a result, user accounts that are valid on your production site will not work under test conditions. You’ll need to create users as part of the test suite – either manually (using the Django model API) or with a test fixture. Remember that if you want your test user to have a password, you can’t set the user’s password by setting the password attribute directly – you must use the <a class="reference internal" href="../../ref/contrib/auth#django.contrib.auth.models.User.set_password" title="django.contrib.auth.models.User.set_password"><code>set_password()</code></a> function to store a correctly hashed password. Alternatively, you can use the <a class="reference internal" href="../../ref/contrib/auth#django.contrib.auth.models.UserManager.create_user" title="django.contrib.auth.models.UserManager.create_user"><code>create_user()</code></a> helper method to create a new user with a correctly hashed password.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.Client.force_login">
<code>force_login(user, backend=None)</code> </dt> <dd>
<p>If your site uses Django’s <a class="reference internal" href="../auth/index"><span class="doc">authentication system</span></a>, you can use the <code>force_login()</code> method to simulate the effect of a user logging into the site. Use this method instead of <a class="reference internal" href="#django.test.Client.login" title="django.test.Client.login"><code>login()</code></a> when a test requires a user be logged in and the details of how a user logged in aren’t important.</p> <p>Unlike <code>login()</code>, this method skips the authentication and verification steps: inactive users (<a class="reference internal" href="../../ref/contrib/auth#django.contrib.auth.models.User.is_active" title="django.contrib.auth.models.User.is_active"><code>is_active=False</code></a>) are permitted to login and the user’s credentials don’t need to be provided.</p> <p>The user will have its <code>backend</code> attribute set to the value of the <code>backend</code> argument (which should be a dotted Python path string), or to <code>settings.AUTHENTICATION_BACKENDS[0]</code> if a value isn’t provided. The <a class="reference internal" href="../auth/default#django.contrib.auth.authenticate" title="django.contrib.auth.authenticate"><code>authenticate()</code></a> function called by <a class="reference internal" href="#django.test.Client.login" title="django.test.Client.login"><code>login()</code></a> normally annotates the user like this.</p> <p>This method is faster than <code>login()</code> since the expensive password hashing algorithms are bypassed. Also, you can speed up <code>login()</code> by <a class="reference internal" href="overview#speeding-up-tests-auth-hashers"><span class="std std-ref">using a weaker hasher while testing</span></a>.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.Client.logout">
<code>logout()</code> </dt> <dd>
<p>If your site uses Django’s <a class="reference internal" href="../auth/index"><span class="doc">authentication system</span></a>, the <code>logout()</code> method can be used to simulate the effect of a user logging out of your site.</p> <p>After you call this method, the test client will have all the cookies and session data cleared to defaults. Subsequent requests will appear to come from an <a class="reference internal" href="../../ref/contrib/auth#django.contrib.auth.models.AnonymousUser" title="django.contrib.auth.models.AnonymousUser"><code>AnonymousUser</code></a>.</p> </dd>
</dl> </dd>
</dl>   <h3 id="testing-responses">Testing responses</h3> <p id="s-testing-responses">The <code>get()</code> and <code>post()</code> methods both return a <code>Response</code> object. This <code>Response</code> object is <em>not</em> the same as the <code>HttpResponse</code> object returned by Django views; the test response object has some additional data useful for test code to verify.</p> <p>Specifically, a <code>Response</code> object has the following attributes:</p> <dl class="class"> <dt id="django.test.Response">
<code>class Response</code> </dt> <dd>
<dl class="attribute"> <dt id="django.test.Response.client">
<code>client</code> </dt> <dd>
<p>The test client that was used to make the request that resulted in the response.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.test.Response.content">
<code>content</code> </dt> <dd>
<p>The body of the response, as a bytestring. This is the final page content as rendered by the view, or any error message.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.test.Response.context">
<code>context</code> </dt> <dd>
<p>The template <code>Context</code> instance that was used to render the template that produced the response content.</p> <p>If the rendered page used multiple templates, then <code>context</code> will be a list of <code>Context</code> objects, in the order in which they were rendered.</p> <p>Regardless of the number of templates used during rendering, you can retrieve context values using the <code>[]</code> operator. For example, the context variable <code>name</code> could be retrieved using:</p> <pre data-language="python">&gt;&gt;&gt; response = client.get('/foo/')
&gt;&gt;&gt; response.context['name']
'Arthur'
</pre> <div class="admonition-not-using-django-templates admonition"> <p class="first admonition-title">Not using Django templates?</p> <p class="last">This attribute is only populated when using the <a class="reference internal" href="../templates#django.template.backends.django.DjangoTemplates" title="django.template.backends.django.DjangoTemplates"><code>DjangoTemplates</code></a> backend. If you’re using another template engine, <a class="reference internal" href="../../ref/template-response#django.template.response.SimpleTemplateResponse.context_data" title="django.template.response.SimpleTemplateResponse.context_data"><code>context_data</code></a> may be a suitable alternative on responses with that attribute.</p> </div> </dd>
</dl> <dl class="attribute"> <dt id="django.test.Response.exc_info">
<code>exc_info</code> </dt> <dd>
<p>A tuple of three values that provides information about the unhandled exception, if any, that occurred during the view.</p> <p>The values are (type, value, traceback), the same as returned by Python’s <a class="reference external" href="https://docs.python.org/3/library/sys.html#sys.exc_info" title="(in Python v3.10)"><code>sys.exc_info()</code></a>. Their meanings are:</p> <ul class="simple"> <li>
<em>type</em>: The type of the exception.</li> <li>
<em>value</em>: The exception instance.</li> <li>
<em>traceback</em>: A traceback object which encapsulates the call stack at the point where the exception originally occurred.</li> </ul> <p>If no exception occurred, then <code>exc_info</code> will be <code>None</code>.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.Response.json">
<code>json(**kwargs)</code> </dt> <dd>
<p>The body of the response, parsed as JSON. Extra keyword arguments are passed to <a class="reference external" href="https://docs.python.org/3/library/json.html#json.loads" title="(in Python v3.10)"><code>json.loads()</code></a>. For example:</p> <pre data-language="python">&gt;&gt;&gt; response = client.get('/foo/')
&gt;&gt;&gt; response.json()['name']
'Arthur'
</pre> <p>If the <code>Content-Type</code> header is not <code>"application/json"</code>, then a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.10)"><code>ValueError</code></a> will be raised when trying to parse the response.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.test.Response.request">
<code>request</code> </dt> <dd>
<p>The request data that stimulated the response.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.test.Response.wsgi_request">
<code>wsgi_request</code> </dt> <dd>
<p>The <code>WSGIRequest</code> instance generated by the test handler that generated the response.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.test.Response.status_code">
<code>status_code</code> </dt> <dd>
<p>The HTTP status of the response, as an integer. For a full list of defined codes, see the <a class="reference external" href="https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml">IANA status code registry</a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.test.Response.templates">
<code>templates</code> </dt> <dd>
<p>A list of <code>Template</code> instances used to render the final content, in the order they were rendered. For each template in the list, use <code>template.name</code> to get the template’s file name, if the template was loaded from a file. (The name is a string such as <code>'admin/index.html'</code>.)</p> <div class="admonition-not-using-django-templates admonition"> <p class="first admonition-title">Not using Django templates?</p> <p class="last">This attribute is only populated when using the <a class="reference internal" href="../templates#django.template.backends.django.DjangoTemplates" title="django.template.backends.django.DjangoTemplates"><code>DjangoTemplates</code></a> backend. If you’re using another template engine, <a class="reference internal" href="../../ref/template-response#django.template.response.SimpleTemplateResponse.template_name" title="django.template.response.SimpleTemplateResponse.template_name"><code>template_name</code></a> may be a suitable alternative if you only need the name of the template used for rendering.</p> </div> </dd>
</dl> <dl class="attribute"> <dt id="django.test.Response.resolver_match">
<code>resolver_match</code> </dt> <dd>
<p>An instance of <a class="reference internal" href="../../ref/urlresolvers#django.urls.ResolverMatch" title="django.urls.ResolverMatch"><code>ResolverMatch</code></a> for the response. You can use the <a class="reference internal" href="../../ref/urlresolvers#django.urls.ResolverMatch.func" title="django.urls.ResolverMatch.func"><code>func</code></a> attribute, for example, to verify the view that served the response:</p> <pre data-language="python"># my_view here is a function based view
self.assertEqual(response.resolver_match.func, my_view)

# class-based views need to be compared by name, as the functions
# generated by as_view() won't be equal
self.assertEqual(response.resolver_match.func.__name__, MyView.as_view().__name__)
</pre> <p>If the given URL is not found, accessing this attribute will raise a <a class="reference internal" href="../../ref/exceptions#django.urls.Resolver404" title="django.urls.Resolver404"><code>Resolver404</code></a> exception.</p> </dd>
</dl> </dd>
</dl> <p>As with a normal response, you can also access the headers through <a class="reference internal" href="../../ref/request-response#django.http.HttpResponse.headers" title="django.http.HttpResponse.headers"><code>HttpResponse.headers</code></a>. For example, you could determine the content type of a response using <code>response.headers['Content-Type']</code>.</p>   <h3 id="exceptions">Exceptions</h3> <p id="s-exceptions">If you point the test client at a view that raises an exception and <code>Client.raise_request_exception</code> is <code>True</code>, that exception will be visible in the test case. You can then use a standard <code>try ... except</code> block or <a class="reference external" href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertRaises" title="(in Python v3.10)"><code>assertRaises()</code></a> to test for exceptions.</p> <p>The only exceptions that are not visible to the test client are <a class="reference internal" href="../http/views#django.http.Http404" title="django.http.Http404"><code>Http404</code></a>, <a class="reference internal" href="../../ref/exceptions#django.core.exceptions.PermissionDenied" title="django.core.exceptions.PermissionDenied"><code>PermissionDenied</code></a>, <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#SystemExit" title="(in Python v3.10)"><code>SystemExit</code></a>, and <a class="reference internal" href="../../ref/exceptions#django.core.exceptions.SuspiciousOperation" title="django.core.exceptions.SuspiciousOperation"><code>SuspiciousOperation</code></a>. Django catches these exceptions internally and converts them into the appropriate HTTP response codes. In these cases, you can check <code>response.status_code</code> in your test.</p> <p>If <code>Client.raise_request_exception</code> is <code>False</code>, the test client will return a 500 response as would be returned to a browser. The response has the attribute <a class="reference internal" href="#django.test.Response.exc_info" title="django.test.Response.exc_info"><code>exc_info</code></a> to provide information about the unhandled exception.</p>   <h3 id="persistent-state">Persistent state</h3> <p id="s-persistent-state">The test client is stateful. If a response returns a cookie, then that cookie will be stored in the test client and sent with all subsequent <code>get()</code> and <code>post()</code> requests.</p> <p>Expiration policies for these cookies are not followed. If you want a cookie to expire, either delete it manually or create a new <code>Client</code> instance (which will effectively delete all cookies).</p> <p>A test client has two attributes that store persistent state information. You can access these properties as part of a test condition.</p> <dl class="attribute"> <dt id="django.test.Client.cookies">
<code>Client.cookies</code> </dt> <dd>
<p>A Python <a class="reference external" href="https://docs.python.org/3/library/http.cookies.html#http.cookies.SimpleCookie" title="(in Python v3.10)"><code>SimpleCookie</code></a> object, containing the current values of all the client cookies. See the documentation of the <a class="reference external" href="https://docs.python.org/3/library/http.cookies.html#module-http.cookies" title="(in Python v3.10)"><code>http.cookies</code></a> module for more.</p> </dd>
</dl> <dl class="attribute"> <dt id="django.test.Client.session">
<code>Client.session</code> </dt> <dd>
<p>A dictionary-like object containing session information. See the <a class="reference internal" href="../http/sessions"><span class="doc">session documentation</span></a> for full details.</p> <p>To modify the session and then save it, it must be stored in a variable first (because a new <code>SessionStore</code> is created every time this property is accessed):</p> <pre data-language="python">def test_something(self):
    session = self.client.session
    session['somekey'] = 'test'
    session.save()
</pre> </dd>
</dl>   <h3 id="setting-the-language">Setting the language</h3> <p id="s-setting-the-language">When testing applications that support internationalization and localization, you might want to set the language for a test client request. The method for doing so depends on whether or not the <a class="reference internal" href="../../ref/middleware#django.middleware.locale.LocaleMiddleware" title="django.middleware.locale.LocaleMiddleware"><code>LocaleMiddleware</code></a> is enabled.</p> <p>If the middleware is enabled, the language can be set by creating a cookie with a name of <a class="reference internal" href="../../ref/settings#std:setting-LANGUAGE_COOKIE_NAME"><code>LANGUAGE_COOKIE_NAME</code></a> and a value of the language code:</p> <pre data-language="python">from django.conf import settings

def test_language_using_cookie(self):
    self.client.cookies.load({settings.LANGUAGE_COOKIE_NAME: 'fr'})
    response = self.client.get('/')
    self.assertEqual(response.content, b"Bienvenue sur mon site.")
</pre> <p>or by including the <code>Accept-Language</code> HTTP header in the request:</p> <pre data-language="python">def test_language_using_header(self):
    response = self.client.get('/', HTTP_ACCEPT_LANGUAGE='fr')
    self.assertEqual(response.content, b"Bienvenue sur mon site.")
</pre> <p>More details are in <a class="reference internal" href="../i18n/translation#how-django-discovers-language-preference"><span class="std std-ref">How Django discovers language preference</span></a>.</p> <p>If the middleware isn’t enabled, the active language may be set using <a class="reference internal" href="../../ref/utils#django.utils.translation.override" title="django.utils.translation.override"><code>translation.override()</code></a>:</p> <pre data-language="python">from django.utils import translation

def test_language_using_override(self):
    with translation.override('fr'):
        response = self.client.get('/')
    self.assertEqual(response.content, b"Bienvenue sur mon site.")
</pre> <p>More details are in <a class="reference internal" href="../i18n/translation#explicitly-setting-the-active-language"><span class="std std-ref">Explicitly setting the active language</span></a>.</p>   <h3 id="example">Example</h3> <p id="s-example">The following is a unit test using the test client:</p> <pre data-language="python">import unittest
from django.test import Client

class SimpleTest(unittest.TestCase):
    def setUp(self):
        # Every test needs a client.
        self.client = Client()

    def test_details(self):
        # Issue a GET request.
        response = self.client.get('/customer/details/')

        # Check that the response is 200 OK.
        self.assertEqual(response.status_code, 200)

        # Check that the rendered context contains 5 customers.
        self.assertEqual(len(response.context['customers']), 5)
</pre> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="advanced#django.test.RequestFactory" title="django.test.RequestFactory"><code>django.test.RequestFactory</code></a></p> </div>    <h2 id="django-testcase-subclasses">Provided test case classes</h2> <p id="s-provided-test-case-classes">Normal Python unit test classes extend a base class of <a class="reference external" href="https://docs.python.org/3/library/unittest.html#unittest.TestCase" title="(in Python v3.10)"><code>unittest.TestCase</code></a>. Django provides a few extensions of this base class:</p> <div class="figure" id="id4"> <a class="reference internal image-reference" href="https://docs.djangoproject.com/en/4.0/_images/django_unittest_classes_hierarchy.svg" id="testcase-hierarchy-diagram"><img alt="Hierarchy of Django unit testing classes (TestCase subclasses)" height="328" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bD0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSItMiAyMDAgNTA4IDMyOCIgd2lkdGg9IjUwOHB0IiBoZWlnaHQ9IjMyOHB0Ij48bWV0YWRhdGEgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj48ZGM6ZGF0ZT4yMDEzLTA3LTAxIDExOjQ4WjwvZGM6ZGF0ZT48IS0tIFByb2R1Y2VkIGJ5IE9tbmlHcmFmZmxlIFByb2Zlc3Npb25hbCA1LjQuMSAtLT48L21ldGFkYXRhPjxkZWZzPjxmaWx0ZXIgaWQ9IlNoYWRvdyIgZmlsdGVyVW5pdHM9InVzZXJTcGFjZU9uVXNlIj48ZmVHYXVzc2lhbkJsdXIgaW49IlNvdXJjZUFscGhhIiByZXN1bHQ9ImJsdXIiIHN0ZERldmlhdGlvbj0iMy40ODgiLz48ZmVPZmZzZXQgaW49ImJsdXIiIHJlc3VsdD0ib2Zmc2V0IiBkeD0iMCIgZHk9IjQiLz48ZmVGbG9vZCBmbG9vZC1jb2xvcj0iYmxhY2siIGZsb29kLW9wYWNpdHk9Ii43NSIgcmVzdWx0PSJmbG9vZCIvPjxmZUNvbXBvc2l0ZSBpbj0iZmxvb2QiIGluMj0ib2Zmc2V0IiBvcGVyYXRvcj0iaW4iLz48L2ZpbHRlcj48Zm9udC1mYWNlIGZvbnQtZmFtaWx5PSJDb3VyaWVyIiBmb250LXNpemU9IjEyIiB1bml0cy1wZXItZW09IjEwMDAiIHVuZGVybGluZS1wb3NpdGlvbj0iLTE3OC4yMjI2NiIgdW5kZXJsaW5lLXRoaWNrbmVzcz0iNTcuNjE3MTg4IiBzbG9wZT0iLTFlMyIgeC1oZWlnaHQ9IjQ2Mi40MDIzNCIgY2FwLWhlaWdodD0iNTk0LjcyNjU2IiBhc2NlbnQ9Ijc1My45MDYyNSIgZGVzY2VudD0iLTI0Ni4wOTM3NSIgZm9udC1zdHlsZT0iaXRhbGljIiBmb250LXdlaWdodD0iNTAwIj48Zm9udC1mYWNlLXNyYz48Zm9udC1mYWNlLW5hbWUgbmFtZT0iQ291cmllci1PYmxpcXVlIi8+PC9mb250LWZhY2Utc3JjPjwvZm9udC1mYWNlPjxmb250LWZhY2UgZm9udC1mYW1pbHk9IkNvdXJpZXIiIGZvbnQtc2l6ZT0iMTIiIHVuaXRzLXBlci1lbT0iMTAwMCIgdW5kZXJsaW5lLXBvc2l0aW9uPSItMTc4LjIyMjY2IiB1bmRlcmxpbmUtdGhpY2tuZXNzPSI1Ny42MTcxODgiIHNsb3BlPSIwIiB4LWhlaWdodD0iNDYyLjQwMjM0IiBjYXAtaGVpZ2h0PSI1OTQuNzI2NTYiIGFzY2VudD0iNzUzLjkwNjI1IiBkZXNjZW50PSItMjQ2LjA5Mzc1IiBmb250LXdlaWdodD0iNTAwIj48Zm9udC1mYWNlLXNyYz48Zm9udC1mYWNlLW5hbWUgbmFtZT0iQ291cmllciIvPjwvZm9udC1mYWNlLXNyYz48L2ZvbnQtZmFjZT48bGluZWFyR3JhZGllbnQgeDE9IjAiIHgyPSIxIiBpZD0iR3JhZGllbnQiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IndoaXRlIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjYWFhIi8+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9Ik9ial9HcmFkaWVudCIgeGw6aHJlZj0iI0dyYWRpZW50IiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDM2OSA0NTkpIHJvdGF0ZSg5MCkgc2NhbGUoMjcpIi8+PGxpbmVhckdyYWRpZW50IGlkPSJPYmpfR3JhZGllbnRfMiIgeGw6aHJlZj0iI0dyYWRpZW50IiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNSA0NTkpIHJvdGF0ZSg5MCkgc2NhbGUoMjcpIi8+PGxpbmVhckdyYWRpZW50IGlkPSJPYmpfR3JhZGllbnRfMyIgeGw6aHJlZj0iI0dyYWRpZW50IiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNSAzODcpIHJvdGF0ZSg5MCkgc2NhbGUoMjcpIi8+PGxpbmVhckdyYWRpZW50IGlkPSJPYmpfR3JhZGllbnRfNCIgeGw6aHJlZj0iI0dyYWRpZW50IiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNSAzMTUpIHJvdGF0ZSg5MCkgc2NhbGUoMjcpIi8+PGxpbmVhckdyYWRpZW50IGlkPSJPYmpfR3JhZGllbnRfNSIgeGw6aHJlZj0iI0dyYWRpZW50IiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNSAyMzQpIHJvdGF0ZSg5MCkgc2NhbGUoMjcpIi8+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG92ZXJmbG93PSJ2aXNpYmxlIiBtYXJrZXJVbml0cz0ic3Ryb2tlV2lkdGgiIGlkPSJVTUxJbmhlcml0YW5jZV9NYXJrZXIiIHZpZXdCb3g9Ii0xIC03IDEyIDE0IiBtYXJrZXJXaWR0aD0iMTIiIG1hcmtlckhlaWdodD0iMTQiIGNvbG9yPSJibGFjayI+PGc+PHBhdGggZD0iTSA5LjU5OTk5OTQgMCBMIDAgLTUuNTk5OTk5NyBMIDAgNS41OTk5OTk3IFoiIGZpbGw9Im5vbmUiIHN0cm9rZT0iY3VycmVudENvbG9yIiBzdHJva2Utd2lkdGg9IjEiLz48L2c+PC9tYXJrZXI+PC9kZWZzPjxnIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLW9wYWNpdHk9IjEiIHN0cm9rZS1kYXNoYXJyYXk9Im5vbmUiIGZpbGw9Im5vbmUiIGZpbGwtb3BhY2l0eT0iMSI+PHRpdGxlPkNhbmV2YXMgMTwvdGl0bGU+PHJlY3QgZmlsbD0id2hpdGUiIHdpZHRoPSI1NTkiIGhlaWdodD0iNzgzIi8+PGc+PHRpdGxlPkNhbHF1ZSAxPC90aXRsZT48Zz48dXNlIHhsOmhyZWY9IiNpZDE4X0dyYXBoaWMiIGZpbHRlcj0idXJsKCNTaGFkb3cpIi8+PHVzZSB4bDpocmVmPSIjaWQxM19HcmFwaGljIiBmaWx0ZXI9InVybCgjU2hhZG93KSIvPjx1c2UgeGw6aHJlZj0iI2lkNl9HcmFwaGljIiBmaWx0ZXI9InVybCgjU2hhZG93KSIvPjx1c2UgeGw6aHJlZj0iI2lkN19HcmFwaGljIiBmaWx0ZXI9InVybCgjU2hhZG93KSIvPjx1c2UgeGw6aHJlZj0iI2lkOF9HcmFwaGljIiBmaWx0ZXI9InVybCgjU2hhZG93KSIvPjx1c2UgeGw6aHJlZj0iI2lkOV9HcmFwaGljIiBmaWx0ZXI9InVybCgjU2hhZG93KSIvPjx1c2UgeGw6aHJlZj0iI2lkMTBfR3JhcGhpYyIgZmlsdGVyPSJ1cmwoI1NoYWRvdykiLz48L2c+PGcgaWQ9ImlkMThfR3JhcGhpYyI+PHJlY3QgeD0iMTgiIHk9IjIxNiIgd2lkdGg9IjQ2OCIgaGVpZ2h0PSI2MyIgZmlsbD0id2hpdGUiLz48cmVjdCB4PSIxOCIgeT0iMjE2IiB3aWR0aD0iNDY4IiBoZWlnaHQ9IjYzIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMSIvPjx0ZXh0IHRyYW5zZm9ybT0idHJhbnNsYXRlKDIzIDIyMSkiIGZpbGw9ImJsYWNrIj48dHNwYW4gZm9udC1mYW1pbHk9IkNvdXJpZXIiIGZvbnQtc2l6ZT0iMTIiIGZvbnQtc3R5bGU9Iml0YWxpYyIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iMzQyLjc4MTI1IiB5PSIxMSIgdGV4dExlbmd0aD0iMTE1LjIxODc1Ij5zdGFuZGFyZCBsaWJyYXJ5PC90c3Bhbj48dHNwYW4gZm9udC1mYW1pbHk9IkNvdXJpZXIiIGZvbnQtc2l6ZT0iMTIiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjQwMC4zOTA2MiIgeT0iNTMiIHRleHRMZW5ndGg9IjU3LjYwOTM3NSI+dW5pdHRlc3Q8L3RzcGFuPjwvdGV4dD48L2c+PGcgaWQ9ImlkMTNfR3JhcGhpYyI+PHJlY3QgeD0iMTgiIHk9IjI5NyIgd2lkdGg9IjQ2OCIgaGVpZ2h0PSIyMDciIGZpbGw9IndoaXRlIi8+PHJlY3QgeD0iMTgiIHk9IjI5NyIgd2lkdGg9IjQ2OCIgaGVpZ2h0PSIyMDciIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIxIi8+PHRleHQgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjMgMzAyKSIgZmlsbD0iYmxhY2siPjx0c3BhbiBmb250LWZhbWlseT0iQ291cmllciIgZm9udC1zaXplPSIxMiIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iMzc4Ljc4NzEiIHk9IjExIiB0ZXh0TGVuZ3RoPSI3OS4yMTI4OSI+ZGphbmdvLnRlc3Q8L3RzcGFuPjwvdGV4dD48L2c+PGcgaWQ9ImlkNl9HcmFwaGljIj48cGF0aCBkPSJNIDI5MyA0NTkgTCA0NDUgNDU5IEMgNDQ3Ljc2MTQyIDQ1OSA0NTAgNDYxLjIzODU4IDQ1MCA0NjQgTCA0NTAgNDgxIEMgNDUwIDQ4My43NjE0MiA0NDcuNzYxNDIgNDg2IDQ0NSA0ODYgTCAyOTMgNDg2IEMgMjkwLjIzODU4IDQ4NiAyODggNDgzLjc2MTQyIDI4OCA0ODEgQyAyODggNDgxIDI4OCA0ODEgMjg4IDQ4MSBMIDI4OCA0NjQgQyAyODggNDYxLjIzODU4IDI5MC4yMzg1OCA0NTkgMjkzIDQ1OSBDIDI5MyA0NTkgMjkzIDQ1OSAyOTMgNDU5IFoiIGZpbGw9InVybCgjT2JqX0dyYWRpZW50KSIvPjxwYXRoIGQ9Ik0gMjkzIDQ1OSBMIDQ0NSA0NTkgQyA0NDcuNzYxNDIgNDU5IDQ1MCA0NjEuMjM4NTggNDUwIDQ2NCBMIDQ1MCA0ODEgQyA0NTAgNDgzLjc2MTQyIDQ0Ny43NjE0MiA0ODYgNDQ1IDQ4NiBMIDI5MyA0ODYgQyAyOTAuMjM4NTggNDg2IDI4OCA0ODMuNzYxNDIgMjg4IDQ4MSBDIDI4OCA0ODEgMjg4IDQ4MSAyODggNDgxIEwgMjg4IDQ2NCBDIDI4OCA0NjEuMjM4NTggMjkwLjIzODU4IDQ1OSAyOTMgNDU5IEMgMjkzIDQ1OSAyOTMgNDU5IDI5MyA0NTkgWiIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEiLz48dGV4dCB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyOTMgNDY1LjUpIiBmaWxsPSJibGFjayI+PHRzcGFuIGZvbnQtZmFtaWx5PSJDb3VyaWVyIiBmb250LXNpemU9IjEyIiBmb250LXdlaWdodD0iNTAwIiB4PSIxMS4xODk0NTMiIHk9IjExIiB0ZXh0TGVuZ3RoPSIxMjkuNjIxMDkiPkxpdmVTZXJ2ZXJUZXN0Q2FzZTwvdHNwYW4+PC90ZXh0PjwvZz48ZyBpZD0iaWQ3X0dyYXBoaWMiPjxwYXRoIGQ9Ik0gNTkgNDU5IEwgMjExIDQ1OSBDIDIxMy43NjE0MiA0NTkgMjE2IDQ2MS4yMzg1OCAyMTYgNDY0IEwgMjE2IDQ4MSBDIDIxNiA0ODMuNzYxNDIgMjEzLjc2MTQyIDQ4NiAyMTEgNDg2IEwgNTkgNDg2IEMgNTYuMjM4NTc2IDQ4NiA1NCA0ODMuNzYxNDIgNTQgNDgxIEMgNTQgNDgxIDU0IDQ4MSA1NCA0ODEgTCA1NCA0NjQgQyA1NCA0NjEuMjM4NTggNTYuMjM4NTc2IDQ1OSA1OSA0NTkgQyA1OSA0NTkgNTkgNDU5IDU5IDQ1OSBaIiBmaWxsPSJ1cmwoI09ial9HcmFkaWVudF8yKSIvPjxwYXRoIGQ9Ik0gNTkgNDU5IEwgMjExIDQ1OSBDIDIxMy43NjE0MiA0NTkgMjE2IDQ2MS4yMzg1OCAyMTYgNDY0IEwgMjE2IDQ4MSBDIDIxNiA0ODMuNzYxNDIgMjEzLjc2MTQyIDQ4NiAyMTEgNDg2IEwgNTkgNDg2IEMgNTYuMjM4NTc2IDQ4NiA1NCA0ODMuNzYxNDIgNTQgNDgxIEMgNTQgNDgxIDU0IDQ4MSA1NCA0ODEgTCA1NCA0NjQgQyA1NCA0NjEuMjM4NTggNTYuMjM4NTc2IDQ1OSA1OSA0NTkgQyA1OSA0NTkgNTkgNDU5IDU5IDQ1OSBaIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMSIvPjx0ZXh0IHRyYW5zZm9ybT0idHJhbnNsYXRlKDU5IDQ2NS41KSIgZmlsbD0iYmxhY2siPjx0c3BhbiBmb250LWZhbWlseT0iQ291cmllciIgZm9udC1zaXplPSIxMiIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iNDcuMTk1MzEyIiB5PSIxMSIgdGV4dExlbmd0aD0iNTcuNjA5Mzc1Ij5UZXN0Q2FzZTwvdHNwYW4+PC90ZXh0PjwvZz48ZyBpZD0iaWQ4X0dyYXBoaWMiPjxwYXRoIGQ9Ik0gNTkgMzg3IEwgMjExIDM4NyBDIDIxMy43NjE0MiAzODcgMjE2IDM4OS4yMzg1OCAyMTYgMzkyIEwgMjE2IDQwOSBDIDIxNiA0MTEuNzYxNDIgMjEzLjc2MTQyIDQxNCAyMTEgNDE0IEwgNTkgNDE0IEMgNTYuMjM4NTc2IDQxNCA1NCA0MTEuNzYxNDIgNTQgNDA5IEMgNTQgNDA5IDU0IDQwOSA1NCA0MDkgTCA1NCAzOTIgQyA1NCAzODkuMjM4NTggNTYuMjM4NTc2IDM4NyA1OSAzODcgQyA1OSAzODcgNTkgMzg3IDU5IDM4NyBaIiBmaWxsPSJ1cmwoI09ial9HcmFkaWVudF8zKSIvPjxwYXRoIGQ9Ik0gNTkgMzg3IEwgMjExIDM4NyBDIDIxMy43NjE0MiAzODcgMjE2IDM4OS4yMzg1OCAyMTYgMzkyIEwgMjE2IDQwOSBDIDIxNiA0MTEuNzYxNDIgMjEzLjc2MTQyIDQxNCAyMTEgNDE0IEwgNTkgNDE0IEMgNTYuMjM4NTc2IDQxNCA1NCA0MTEuNzYxNDIgNTQgNDA5IEMgNTQgNDA5IDU0IDQwOSA1NCA0MDkgTCA1NCAzOTIgQyA1NCAzODkuMjM4NTggNTYuMjM4NTc2IDM4NyA1OSAzODcgQyA1OSAzODcgNTkgMzg3IDU5IDM4NyBaIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMSIvPjx0ZXh0IHRyYW5zZm9ybT0idHJhbnNsYXRlKDU5IDM5My41KSIgZmlsbD0iYmxhY2siPjx0c3BhbiBmb250LWZhbWlseT0iQ291cmllciIgZm9udC1zaXplPSIxMiIgZm9udC13ZWlnaHQ9IjUwMCIgeD0iNy41ODg4NjciIHk9IjExIiB0ZXh0TGVuZ3RoPSIxMzYuODIyMjY2Ij5UcmFuc2FjdGlvblRlc3RDYXNlPC90c3Bhbj48L3RleHQ+PC9nPjxnIGlkPSJpZDlfR3JhcGhpYyI+PHBhdGggZD0iTSA1OSAzMTUgTCAyMTEgMzE1IEMgMjEzLjc2MTQyIDMxNSAyMTYgMzE3LjIzODU4IDIxNiAzMjAgTCAyMTYgMzM3IEMgMjE2IDMzOS43NjE0MiAyMTMuNzYxNDIgMzQyIDIxMSAzNDIgTCA1OSAzNDIgQyA1Ni4yMzg1NzYgMzQyIDU0IDMzOS43NjE0MiA1NCAzMzcgQyA1NCAzMzcgNTQgMzM3IDU0IDMzNyBMIDU0IDMyMCBDIDU0IDMxNy4yMzg1OCA1Ni4yMzg1NzYgMzE1IDU5IDMxNSBDIDU5IDMxNSA1OSAzMTUgNTkgMzE1IFoiIGZpbGw9InVybCgjT2JqX0dyYWRpZW50XzQpIi8+PHBhdGggZD0iTSA1OSAzMTUgTCAyMTEgMzE1IEMgMjEzLjc2MTQyIDMxNSAyMTYgMzE3LjIzODU4IDIxNiAzMjAgTCAyMTYgMzM3IEMgMjE2IDMzOS43NjE0MiAyMTMuNzYxNDIgMzQyIDIxMSAzNDIgTCA1OSAzNDIgQyA1Ni4yMzg1NzYgMzQyIDU0IDMzOS43NjE0MiA1NCAzMzcgQyA1NCAzMzcgNTQgMzM3IDU0IDMzNyBMIDU0IDMyMCBDIDU0IDMxNy4yMzg1OCA1Ni4yMzg1NzYgMzE1IDU5IDMxNSBDIDU5IDMxNSA1OSAzMTUgNTkgMzE1IFoiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIxIi8+PHRleHQgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTkgMzIxLjUpIiBmaWxsPSJibGFjayI+PHRzcGFuIGZvbnQtZmFtaWx5PSJDb3VyaWVyIiBmb250LXNpemU9IjEyIiBmb250LXdlaWdodD0iNTAwIiB4PSIyNS41OTE3OTciIHk9IjExIiB0ZXh0TGVuZ3RoPSIxMDAuODE2NDA2Ij5TaW1wbGVUZXN0Q2FzZTwvdHNwYW4+PC90ZXh0PjwvZz48ZyBpZD0iaWQxMF9HcmFwaGljIj48cGF0aCBkPSJNIDU5IDIzNCBMIDIxMSAyMzQgQyAyMTMuNzYxNDIgMjM0IDIxNiAyMzYuMjM4NTggMjE2IDIzOSBMIDIxNiAyNTYgQyAyMTYgMjU4Ljc2MTQyIDIxMy43NjE0MiAyNjEgMjExIDI2MSBMIDU5IDI2MSBDIDU2LjIzODU3NiAyNjEgNTQgMjU4Ljc2MTQyIDU0IDI1NiBDIDU0IDI1NiA1NCAyNTYgNTQgMjU2IEwgNTQgMjM5IEMgNTQgMjM2LjIzODU4IDU2LjIzODU3NiAyMzQgNTkgMjM0IEMgNTkgMjM0IDU5IDIzNCA1OSAyMzQgWiIgZmlsbD0idXJsKCNPYmpfR3JhZGllbnRfNSkiLz48cGF0aCBkPSJNIDU5IDIzNCBMIDIxMSAyMzQgQyAyMTMuNzYxNDIgMjM0IDIxNiAyMzYuMjM4NTggMjE2IDIzOSBMIDIxNiAyNTYgQyAyMTYgMjU4Ljc2MTQyIDIxMy43NjE0MiAyNjEgMjExIDI2MSBMIDU5IDI2MSBDIDU2LjIzODU3NiAyNjEgNTQgMjU4Ljc2MTQyIDU0IDI1NiBDIDU0IDI1NiA1NCAyNTYgNTQgMjU2IEwgNTQgMjM5IEMgNTQgMjM2LjIzODU4IDU2LjIzODU3NiAyMzQgNTkgMjM0IEMgNTkgMjM0IDU5IDIzNCA1OSAyMzQgWiIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjEiLz48dGV4dCB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1OSAyNDAuNSkiIGZpbGw9ImJsYWNrIj48dHNwYW4gZm9udC1mYW1pbHk9IkNvdXJpZXIiIGZvbnQtc2l6ZT0iMTIiIGZvbnQtd2VpZ2h0PSI1MDAiIHg9IjQ3LjE5NTMxMiIgeT0iMTEiIHRleHRMZW5ndGg9IjU3LjYwOTM3NSI+VGVzdENhc2U8L3RzcGFuPjwvdGV4dD48L2c+PHBhdGggZD0iTSAxMzUgNDU5IEwgMTM1IDQ0NS45IEwgMTM1IDQyNy4xIEwgMTM1IDQyNS4xIiBtYXJrZXItZW5kPSJ1cmwoI1VNTEluaGVyaXRhbmNlX01hcmtlcikiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIxIi8+PHBhdGggZD0iTSAxMzUgMzg3IEwgMTM1IDM3My45IEwgMTM1IDM1NS4xIEwgMTM1IDM1My4xIiBtYXJrZXItZW5kPSJ1cmwoI1VNTEluaGVyaXRhbmNlX01hcmtlcikiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIxIi8+PHBhdGggZD0iTSAxMzUgMzE1IEwgMTM1IDMwMS45IEwgMTM1IDI3NC4xIEwgMTM1IDI3Mi4xIiBtYXJrZXItZW5kPSJ1cmwoI1VNTEluaGVyaXRhbmNlX01hcmtlcikiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIxIi8+PHBhdGggZD0iTSAzNjkgNDU5IEwgMzY5IDQ0NS45IEwgMzY5IDQwMC41IEwgMjI5LjEgNDAwLjUgTCAyMjcuMSA0MDAuNSIgbWFya2VyLWVuZD0idXJsKCNVTUxJbmhlcml0YW5jZV9NYXJrZXIpIiBzdHJva2U9ImJsYWNrIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMSIvPjwvZz48L2c+PC9zdmc+Cg==" width="508"></a> <p class="caption"><span class="caption-text">Hierarchy of Django unit testing classes</span></p> </div> <p>You can convert a normal <a class="reference external" href="https://docs.python.org/3/library/unittest.html#unittest.TestCase" title="(in Python v3.10)"><code>unittest.TestCase</code></a> to any of the subclasses: change the base class of your test from <code>unittest.TestCase</code> to the subclass. All of the standard Python unit test functionality will be available, and it will be augmented with some useful additions as described in each section below.</p>  <h3 id="simpletestcase"><code>SimpleTestCase</code></h3> <dl class="class" id="s-simpletestcase"> <dt id="django.test.SimpleTestCase">
<code>class SimpleTestCase</code> </dt> 
</dl> <p>A subclass of <a class="reference external" href="https://docs.python.org/3/library/unittest.html#unittest.TestCase" title="(in Python v3.10)"><code>unittest.TestCase</code></a> that adds this functionality:</p> <ul class="simple"> <li>Some useful assertions like:<ul> <li>Checking that a callable <a class="reference internal" href="#django.test.SimpleTestCase.assertRaisesMessage" title="django.test.SimpleTestCase.assertRaisesMessage"><code>raises a certain exception</code></a>.</li> <li>Checking that a callable <a class="reference internal" href="#django.test.SimpleTestCase.assertWarnsMessage" title="django.test.SimpleTestCase.assertWarnsMessage"><code>triggers a certain warning</code></a>.</li> <li>Testing form field <a class="reference internal" href="#django.test.SimpleTestCase.assertFieldOutput" title="django.test.SimpleTestCase.assertFieldOutput"><code>rendering and error treatment</code></a>.</li> <li>Testing <a class="reference internal" href="#django.test.SimpleTestCase.assertContains" title="django.test.SimpleTestCase.assertContains"><code>HTML responses for the presence/lack of a given fragment</code></a>.</li> <li>Verifying that a template <a class="reference internal" href="#django.test.SimpleTestCase.assertTemplateUsed" title="django.test.SimpleTestCase.assertTemplateUsed"><code>has/hasn't been used to generate a given
response content</code></a>.</li> <li>Verifying that two <a class="reference internal" href="#django.test.SimpleTestCase.assertURLEqual" title="django.test.SimpleTestCase.assertURLEqual"><code>URLs</code></a> are equal.</li> <li>Verifying an HTTP <a class="reference internal" href="#django.test.SimpleTestCase.assertRedirects" title="django.test.SimpleTestCase.assertRedirects"><code>redirect</code></a> is performed by the app.</li> <li>Robustly testing two <a class="reference internal" href="#django.test.SimpleTestCase.assertHTMLEqual" title="django.test.SimpleTestCase.assertHTMLEqual"><code>HTML fragments</code></a> for equality/inequality or <a class="reference internal" href="#django.test.SimpleTestCase.assertInHTML" title="django.test.SimpleTestCase.assertInHTML"><code>containment</code></a>.</li> <li>Robustly testing two <a class="reference internal" href="#django.test.SimpleTestCase.assertXMLEqual" title="django.test.SimpleTestCase.assertXMLEqual"><code>XML fragments</code></a> for equality/inequality.</li> <li>Robustly testing two <a class="reference internal" href="#django.test.SimpleTestCase.assertJSONEqual" title="django.test.SimpleTestCase.assertJSONEqual"><code>JSON fragments</code></a> for equality.</li> </ul> </li> <li>The ability to run tests with <a class="reference internal" href="#overriding-settings"><span class="std std-ref">modified settings</span></a>.</li> <li>Using the <a class="reference internal" href="#django.test.SimpleTestCase.client" title="django.test.SimpleTestCase.client"><code>client</code></a> <a class="reference internal" href="#django.test.Client" title="django.test.Client"><code>Client</code></a>.</li> </ul> <p>If your tests make any database queries, use subclasses <a class="reference internal" href="#django.test.TransactionTestCase" title="django.test.TransactionTestCase"><code>TransactionTestCase</code></a> or <a class="reference internal" href="#django.test.TestCase" title="django.test.TestCase"><code>TestCase</code></a>.</p> <dl class="attribute"> <dt id="django.test.SimpleTestCase.databases">
<code>SimpleTestCase.databases</code> </dt> <dd>
<p><a class="reference internal" href="#django.test.SimpleTestCase" title="django.test.SimpleTestCase"><code>SimpleTestCase</code></a> disallows database queries by default. This helps to avoid executing write queries which will affect other tests since each <code>SimpleTestCase</code> test isn’t run in a transaction. If you aren’t concerned about this problem, you can disable this behavior by setting the <code>databases</code> class attribute to <code>'__all__'</code> on your test class.</p> </dd>
</dl> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p><code>SimpleTestCase</code> and its subclasses (e.g. <code>TestCase</code>, …) rely on <code>setUpClass()</code> and <code>tearDownClass()</code> to perform some class-wide initialization (e.g. overriding settings). If you need to override those methods, don’t forget to call the <code>super</code> implementation:</p> <pre data-language="python">class MyTestCase(TestCase):

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        ...

    @classmethod
    def tearDownClass(cls):
        ...
        super().tearDownClass()
</pre> <p class="last">Be sure to account for Python’s behavior if an exception is raised during <code>setUpClass()</code>. If that happens, neither the tests in the class nor <code>tearDownClass()</code> are run. In the case of <a class="reference internal" href="#django.test.TestCase" title="django.test.TestCase"><code>django.test.TestCase</code></a>, this will leak the transaction created in <code>super()</code> which results in various symptoms including a segmentation fault on some platforms (reported on macOS). If you want to intentionally raise an exception such as <a class="reference external" href="https://docs.python.org/3/library/unittest.html#unittest.SkipTest" title="(in Python v3.10)"><code>unittest.SkipTest</code></a> in <code>setUpClass()</code>, be sure to do it before calling <code>super()</code> to avoid this.</p> </div>   <h3 id="transactiontestcase"><code>TransactionTestCase</code></h3> <dl class="class" id="s-transactiontestcase"> <dt id="django.test.TransactionTestCase">
<code>class TransactionTestCase</code> </dt> 
</dl> <p><code>TransactionTestCase</code> inherits from <a class="reference internal" href="#django.test.SimpleTestCase" title="django.test.SimpleTestCase"><code>SimpleTestCase</code></a> to add some database-specific features:</p> <ul class="simple"> <li>Resetting the database to a known state at the beginning of each test to ease testing and using the ORM.</li> <li>Database <a class="reference internal" href="#django.test.TransactionTestCase.fixtures" title="django.test.TransactionTestCase.fixtures"><code>fixtures</code></a>.</li> <li>Test <a class="reference internal" href="#skipping-tests"><span class="std std-ref">skipping based on database backend features</span></a>.</li> <li>The remaining specialized <a class="reference internal" href="#django.test.TransactionTestCase.assertQuerysetEqual" title="django.test.TransactionTestCase.assertQuerysetEqual"><code>assert*</code></a> methods.</li> </ul> <p>Django’s <a class="reference internal" href="#django.test.TestCase" title="django.test.TestCase"><code>TestCase</code></a> class is a more commonly used subclass of <code>TransactionTestCase</code> that makes use of database transaction facilities to speed up the process of resetting the database to a known state at the beginning of each test. A consequence of this, however, is that some database behaviors cannot be tested within a Django <code>TestCase</code> class. For instance, you cannot test that a block of code is executing within a transaction, as is required when using <a class="reference internal" href="../../ref/models/querysets#django.db.models.query.QuerySet.select_for_update" title="django.db.models.query.QuerySet.select_for_update"><code>select_for_update()</code></a>. In those cases, you should use <code>TransactionTestCase</code>.</p> <p><code>TransactionTestCase</code> and <code>TestCase</code> are identical except for the manner in which the database is reset to a known state and the ability for test code to test the effects of commit and rollback:</p> <ul class="simple"> <li>A <code>TransactionTestCase</code> resets the database after the test runs by truncating all tables. A <code>TransactionTestCase</code> may call commit and rollback and observe the effects of these calls on the database.</li> <li>A <code>TestCase</code>, on the other hand, does not truncate tables after a test. Instead, it encloses the test code in a database transaction that is rolled back at the end of the test. This guarantees that the rollback at the end of the test restores the database to its initial state.</li> </ul> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p><code>TestCase</code> running on a database that does not support rollback (e.g. MySQL with the MyISAM storage engine), and all instances of <code>TransactionTestCase</code>, will roll back at the end of the test by deleting all data from the test database.</p> <p class="last">Apps <a class="reference internal" href="overview#test-case-serialized-rollback"><span class="std std-ref">will not see their data reloaded</span></a>; if you need this functionality (for example, third-party apps should enable this) you can set <code>serialized_rollback = True</code> inside the <code>TestCase</code> body.</p> </div>   <h3 id="testcase"><code>TestCase</code></h3> <dl class="class" id="s-testcase"> <dt id="django.test.TestCase">
<code>class TestCase</code> </dt> 
</dl> <p>This is the most common class to use for writing tests in Django. It inherits from <a class="reference internal" href="#django.test.TransactionTestCase" title="django.test.TransactionTestCase"><code>TransactionTestCase</code></a> (and by extension <a class="reference internal" href="#django.test.SimpleTestCase" title="django.test.SimpleTestCase"><code>SimpleTestCase</code></a>). If your Django application doesn’t use a database, use <a class="reference internal" href="#django.test.SimpleTestCase" title="django.test.SimpleTestCase"><code>SimpleTestCase</code></a>.</p> <p>The class:</p> <ul class="simple"> <li>Wraps the tests within two nested <a class="reference internal" href="../db/transactions#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> blocks: one for the whole class and one for each test. Therefore, if you want to test some specific database transaction behavior, use <a class="reference internal" href="#django.test.TransactionTestCase" title="django.test.TransactionTestCase"><code>TransactionTestCase</code></a>.</li> <li>Checks deferrable database constraints at the end of each test.</li> </ul> <p>It also provides an additional method:</p> <dl class="classmethod"> <dt id="django.test.TestCase.setUpTestData">
<code>classmethod TestCase.setUpTestData()</code> </dt> <dd>
<p>The class-level <code>atomic</code> block described above allows the creation of initial data at the class level, once for the whole <code>TestCase</code>. This technique allows for faster tests as compared to using <code>setUp()</code>.</p> <p>For example:</p> <pre data-language="python">from django.test import TestCase

class MyTests(TestCase):
    @classmethod
    def setUpTestData(cls):
        # Set up data for the whole TestCase
        cls.foo = Foo.objects.create(bar="Test")
        ...

    def test1(self):
        # Some test using self.foo
        ...

    def test2(self):
        # Some other test using self.foo
        ...
</pre> <p>Note that if the tests are run on a database with no transaction support (for instance, MySQL with the MyISAM engine), <code>setUpTestData()</code> will be called before each test, negating the speed benefits.</p> <div class="versionchanged"> <span class="title">Changed in Django 3.2:</span> <p>Objects assigned to class attributes in <code>setUpTestData()</code> must support creating deep copies with <a class="reference external" href="https://docs.python.org/3/library/copy.html#copy.deepcopy" title="(in Python v3.10)"><code>copy.deepcopy()</code></a> in order to isolate them from alterations performed by each test methods. In previous versions of Django these objects were reused and changes made to them were persisted between test methods.</p> </div> </dd>
</dl> <dl class="classmethod"> <dt id="django.test.TestCase.captureOnCommitCallbacks">
<code>classmethod TestCase.captureOnCommitCallbacks(using=DEFAULT_DB_ALIAS, execute=False)</code> </dt> <dd>
<div class="versionadded"> <span class="title">New in Django 3.2.</span> </div> <p>Returns a context manager that captures <a class="reference internal" href="../db/transactions#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code>transaction.on_commit()</code></a> callbacks for the given database connection. It returns a list that contains, on exit of the context, the captured callback functions. From this list you can make assertions on the callbacks or call them to invoke their side effects, emulating a commit.</p> <p><code>using</code> is the alias of the database connection to capture callbacks for.</p> <p>If <code>execute</code> is <code>True</code>, all the callbacks will be called as the context manager exits, if no exception occurred. This emulates a commit after the wrapped block of code.</p> <p>For example:</p> <pre data-language="python">from django.core import mail
from django.test import TestCase


class ContactTests(TestCase):
    def test_post(self):
        with self.captureOnCommitCallbacks(execute=True) as callbacks:
            response = self.client.post(
                '/contact/',
                {'message': 'I like your site'},
            )

        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(callbacks), 1)
        self.assertEqual(len(mail.outbox), 1)
        self.assertEqual(mail.outbox[0].subject, 'Contact Form')
        self.assertEqual(mail.outbox[0].body, 'I like your site')
</pre> <div class="versionchanged"> <span class="title">Changed in Django 4.0:</span> <p>In older versions, new callbacks added while executing <a class="reference internal" href="../db/transactions#django.db.transaction.on_commit" title="django.db.transaction.on_commit"><code>transaction.on_commit()</code></a> callbacks were not captured.</p> </div> </dd>
</dl>   <h3 id="live-test-server"><code>LiveServerTestCase</code></h3> <dl class="class" id="s-liveservertestcase"> <dt id="django.test.LiveServerTestCase">
<code>class LiveServerTestCase</code> </dt> 
</dl> <p><code>LiveServerTestCase</code> does basically the same as <a class="reference internal" href="#django.test.TransactionTestCase" title="django.test.TransactionTestCase"><code>TransactionTestCase</code></a> with one extra feature: it launches a live Django server in the background on setup, and shuts it down on teardown. This allows the use of automated test clients other than the <a class="reference internal" href="#test-client"><span class="std std-ref">Django dummy client</span></a> such as, for example, the <a class="reference external" href="https://www.selenium.dev/">Selenium</a> client, to execute a series of functional tests inside a browser and simulate a real user’s actions.</p> <p>The live server listens on <code>localhost</code> and binds to port 0 which uses a free port assigned by the operating system. The server’s URL can be accessed with <code>self.live_server_url</code> during the tests.</p> <p>To demonstrate how to use <code>LiveServerTestCase</code>, let’s write a Selenium test. First of all, you need to install the <a class="reference external" href="https://pypi.org/project/selenium/">selenium package</a> into your Python path:</p>       <pre data-language="console">$ python -m pip install selenium
</pre>   <div class="highlight"><pre><span class="gp">...\&gt;</span> py -m pip install selenium
</pre></div>   <p>Then, add a <code>LiveServerTestCase</code>-based test to your app’s tests module (for example: <code>myapp/tests.py</code>). For this example, we’ll assume you’re using the <a class="reference internal" href="../../ref/contrib/staticfiles#module-django.contrib.staticfiles" title="django.contrib.staticfiles: An app for handling static files."><code>staticfiles</code></a> app and want to have static files served during the execution of your tests similar to what we get at development time with <code>DEBUG=True</code>, i.e. without having to collect them using <a class="reference internal" href="../../ref/contrib/staticfiles#django-admin-collectstatic"><code>collectstatic</code></a>. We’ll use the <a class="reference internal" href="../../ref/contrib/staticfiles#django.contrib.staticfiles.testing.StaticLiveServerTestCase" title="django.contrib.staticfiles.testing.StaticLiveServerTestCase"><code>StaticLiveServerTestCase</code></a> subclass which provides that functionality. Replace it with <code>django.test.LiveServerTestCase</code> if you don’t need that.</p> <p>The code for this test may look as follows:</p> <pre data-language="python">from django.contrib.staticfiles.testing import StaticLiveServerTestCase
from selenium.webdriver.firefox.webdriver import WebDriver

class MySeleniumTests(StaticLiveServerTestCase):
    fixtures = ['user-data.json']

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.selenium = WebDriver()
        cls.selenium.implicitly_wait(10)

    @classmethod
    def tearDownClass(cls):
        cls.selenium.quit()
        super().tearDownClass()

    def test_login(self):
        self.selenium.get('%s%s' % (self.live_server_url, '/login/'))
        username_input = self.selenium.find_element_by_name("username")
        username_input.send_keys('myuser')
        password_input = self.selenium.find_element_by_name("password")
        password_input.send_keys('secret')
        self.selenium.find_element_by_xpath('//input[@value="Log in"]').click()
</pre> <p>Finally, you may run the test as follows:</p>       <pre data-language="console">$ ./manage.py test myapp.tests.MySeleniumTests.test_login
</pre>   <div class="highlight"><pre><span class="gp">...\&gt;</span> manage.py test myapp.tests.MySeleniumTests.test_login
</pre></div>   <p>This example will automatically open Firefox then go to the login page, enter the credentials and press the “Log in” button. Selenium offers other drivers in case you do not have Firefox installed or wish to use another browser. The example above is just a tiny fraction of what the Selenium client can do; check out the <a class="reference external" href="https://selenium-python.readthedocs.io/api.html">full reference</a> for more details.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>When using an in-memory SQLite database to run the tests, the same database connection will be shared by two threads in parallel: the thread in which the live server is run and the thread in which the test case is run. It’s important to prevent simultaneous database queries via this shared connection by the two threads, as that may sometimes randomly cause the tests to fail. So you need to ensure that the two threads don’t access the database at the same time. In particular, this means that in some cases (for example, just after clicking a link or submitting a form), you might need to check that a response is received by Selenium and that the next page is loaded before proceeding with further test execution. Do this, for example, by making Selenium wait until the <code>&lt;body&gt;</code> HTML tag is found in the response (requires Selenium &gt; 2.13):</p> <pre data-language="python">def test_login(self):
    from selenium.webdriver.support.wait import WebDriverWait
    timeout = 2
    ...
    self.selenium.find_element_by_xpath('//input[@value="Log in"]').click()
    # Wait until the response is received
    WebDriverWait(self.selenium, timeout).until(
        lambda driver: driver.find_element_by_tag_name('body'))
</pre> <p class="last">The tricky thing here is that there’s really no such thing as a “page load,” especially in modern web apps that generate HTML dynamically after the server generates the initial document. So, checking for the presence of <code>&lt;body&gt;</code> in the response might not necessarily be appropriate for all use cases. Please refer to the <a class="reference external" href="https://web.archive.org/web/20160129132110/http://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions#Q:_WebDriver_fails_to_find_elements_/_Does_not_block_on_page_loa">Selenium FAQ</a> and <a class="reference external" href="https://www.selenium.dev/documentation/webdriver/waits/#explicit-wait">Selenium documentation</a> for more information.</p> </div>    <h2 id="test-cases-features">Test cases features</h2>  <h3 id="default-test-client">Default test client</h3> <dl class="attribute" id="s-test-cases-features"> <dt id="django.test.SimpleTestCase.client">
<code>SimpleTestCase.client</code> </dt> 
</dl> <p>Every test case in a <code>django.test.*TestCase</code> instance has access to an instance of a Django test client. This client can be accessed as <code>self.client</code>. This client is recreated for each test, so you don’t have to worry about state (such as cookies) carrying over from one test to another.</p> <p>This means, instead of instantiating a <code>Client</code> in each test:</p> <pre data-language="python">import unittest
from django.test import Client

class SimpleTest(unittest.TestCase):
    def test_details(self):
        client = Client()
        response = client.get('/customer/details/')
        self.assertEqual(response.status_code, 200)

    def test_index(self):
        client = Client()
        response = client.get('/customer/index/')
        self.assertEqual(response.status_code, 200)
</pre> <p>…you can refer to <code>self.client</code>, like so:</p> <pre data-language="python">from django.test import TestCase

class SimpleTest(TestCase):
    def test_details(self):
        response = self.client.get('/customer/details/')
        self.assertEqual(response.status_code, 200)

    def test_index(self):
        response = self.client.get('/customer/index/')
        self.assertEqual(response.status_code, 200)
</pre>   <h3 id="customizing-the-test-client">Customizing the test client</h3> <dl class="attribute" id="s-customizing-the-test-client"> <dt id="django.test.SimpleTestCase.client_class">
<code>SimpleTestCase.client_class</code> </dt> 
</dl> <p>If you want to use a different <code>Client</code> class (for example, a subclass with customized behavior), use the <a class="reference internal" href="#django.test.SimpleTestCase.client_class" title="django.test.SimpleTestCase.client_class"><code>client_class</code></a> class attribute:</p> <pre data-language="python">from django.test import Client, TestCase

class MyTestClient(Client):
    # Specialized methods for your environment
    ...

class MyTest(TestCase):
    client_class = MyTestClient

    def test_my_stuff(self):
        # Here self.client is an instance of MyTestClient...
        call_some_test_code()
</pre>   <h3 id="topics-testing-fixtures">Fixture loading</h3> <dl class="attribute" id="s-fixture-loading"> <dt id="django.test.TransactionTestCase.fixtures">
<code>TransactionTestCase.fixtures</code> </dt> 
</dl> <p>A test case for a database-backed website isn’t much use if there isn’t any data in the database. Tests are more readable and it’s more maintainable to create objects using the ORM, for example in <a class="reference internal" href="#django.test.TestCase.setUpTestData" title="django.test.TestCase.setUpTestData"><code>TestCase.setUpTestData()</code></a>, however, you can also use fixtures.</p> <p>A fixture is a collection of data that Django knows how to import into a database. For example, if your site has user accounts, you might set up a fixture of fake user accounts in order to populate your database during tests.</p> <p>The most straightforward way of creating a fixture is to use the <a class="reference internal" href="../../ref/django-admin#django-admin-dumpdata"><code>manage.py dumpdata</code></a> command. This assumes you already have some data in your database. See the <a class="reference internal" href="../../ref/django-admin#django-admin-dumpdata"><code>dumpdata
documentation</code></a> for more details.</p> <p>Once you’ve created a fixture and placed it in a <code>fixtures</code> directory in one of your <a class="reference internal" href="../../ref/settings#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a>, you can use it in your unit tests by specifying a <code>fixtures</code> class attribute on your <a class="reference internal" href="#django.test.TestCase" title="django.test.TestCase"><code>django.test.TestCase</code></a> subclass:</p> <pre data-language="python">from django.test import TestCase
from myapp.models import Animal

class AnimalTestCase(TestCase):
    fixtures = ['mammals.json', 'birds']

    def setUp(self):
        # Test definitions as before.
        call_setup_methods()

    def test_fluffy_animals(self):
        # A test that uses the fixtures.
        call_some_test_code()
</pre> <p>Here’s specifically what will happen:</p> <ul class="simple"> <li>At the start of each test, before <code>setUp()</code> is run, Django will flush the database, returning the database to the state it was in directly after <a class="reference internal" href="../../ref/django-admin#django-admin-migrate"><code>migrate</code></a> was called.</li> <li>Then, all the named fixtures are installed. In this example, Django will install any JSON fixture named <code>mammals</code>, followed by any fixture named <code>birds</code>. See the <a class="reference internal" href="../../ref/django-admin#django-admin-loaddata"><code>loaddata</code></a> documentation for more details on defining and installing fixtures.</li> </ul> <p>For performance reasons, <a class="reference internal" href="#django.test.TestCase" title="django.test.TestCase"><code>TestCase</code></a> loads fixtures once for the entire test class, before <a class="reference internal" href="#django.test.TestCase.setUpTestData" title="django.test.TestCase.setUpTestData"><code>setUpTestData()</code></a>, instead of before each test, and it uses transactions to clean the database before each test. In any case, you can be certain that the outcome of a test will not be affected by another test or by the order of test execution.</p> <p>By default, fixtures are only loaded into the <code>default</code> database. If you are using multiple databases and set <a class="reference internal" href="#django.test.TransactionTestCase.databases" title="django.test.TransactionTestCase.databases"><code>TransactionTestCase.databases</code></a>, fixtures will be loaded into all specified databases.</p>   <h3 id="urlconf-configuration">URLconf configuration</h3> <p id="s-urlconf-configuration">If your application provides views, you may want to include tests that use the test client to exercise those views. However, an end user is free to deploy the views in your application at any URL of their choosing. This means that your tests can’t rely upon the fact that your views will be available at a particular URL. Decorate your test class or test method with <code>@override_settings(ROOT_URLCONF=...)</code> for URLconf configuration.</p>   <h3 id="testing-multi-db">Multi-database support</h3> <dl class="attribute" id="s-multi-database-support"> <dt id="django.test.TransactionTestCase.databases">
<code>TransactionTestCase.databases</code> </dt> 
</dl> <p>Django sets up a test database corresponding to every database that is defined in the <a class="reference internal" href="../../ref/settings#std:setting-DATABASES"><code>DATABASES</code></a> definition in your settings and referred to by at least one test through <code>databases</code>.</p> <p>However, a big part of the time taken to run a Django <code>TestCase</code> is consumed by the call to <code>flush</code> that ensures that you have a clean database at the start of each test run. If you have multiple databases, multiple flushes are required (one for each database), which can be a time consuming activity – especially if your tests don’t need to test multi-database activity.</p> <p>As an optimization, Django only flushes the <code>default</code> database at the start of each test run. If your setup contains multiple databases, and you have a test that requires every database to be clean, you can use the <code>databases</code> attribute on the test suite to request extra databases to be flushed.</p> <p>For example:</p> <pre data-language="python">class TestMyViews(TransactionTestCase):
    databases = {'default', 'other'}

    def test_index_page_view(self):
        call_some_test_code()
</pre> <p>This test case will flush the <code>default</code> and <code>other</code> test databases before running <code>test_index_page_view</code>. You can also use <code>'__all__'</code> to specify that all of the test databases must be flushed.</p> <p>The <code>databases</code> flag also controls which databases the <a class="reference internal" href="#django.test.TransactionTestCase.fixtures" title="django.test.TransactionTestCase.fixtures"><code>TransactionTestCase.fixtures</code></a> are loaded into. By default, fixtures are only loaded into the <code>default</code> database.</p> <p>Queries against databases not in <code>databases</code> will give assertion errors to prevent state leaking between tests.</p> <dl class="attribute"> <dt id="django.test.TestCase.databases">
<code>TestCase.databases</code> </dt> 
</dl> <p>By default, only the <code>default</code> database will be wrapped in a transaction during a <code>TestCase</code>’s execution and attempts to query other databases will result in assertion errors to prevent state leaking between tests.</p> <p>Use the <code>databases</code> class attribute on the test class to request transaction wrapping against non-<code>default</code> databases.</p> <p>For example:</p> <pre data-language="python">class OtherDBTests(TestCase):
    databases = {'other'}

    def test_other_db_query(self):
        ...
</pre> <p>This test will only allow queries against the <code>other</code> database. Just like for <a class="reference internal" href="#django.test.SimpleTestCase.databases" title="django.test.SimpleTestCase.databases"><code>SimpleTestCase.databases</code></a> and <a class="reference internal" href="#django.test.TransactionTestCase.databases" title="django.test.TransactionTestCase.databases"><code>TransactionTestCase.databases</code></a>, the <code>'__all__'</code> constant can be used to specify that the test should allow queries to all databases.</p>   <h3 id="id1">Overriding settings</h3> <div class="admonition warning" id="s-overriding-settings"> <p class="first admonition-title">Warning</p> <p class="last">Use the functions below to temporarily alter the value of settings in tests. Don’t manipulate <code>django.conf.settings</code> directly as Django won’t restore the original values after such manipulations.</p> </div> <dl class="method"> <dt id="django.test.SimpleTestCase.settings">
<code>SimpleTestCase.settings()</code> </dt> 
</dl> <p>For testing purposes it’s often useful to change a setting temporarily and revert to the original value after running the testing code. For this use case Django provides a standard Python context manager (see <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0343" id="index-1"><strong>PEP 343</strong></a>) called <a class="reference internal" href="#django.test.SimpleTestCase.settings" title="django.test.SimpleTestCase.settings"><code>settings()</code></a>, which can be used like this:</p> <pre data-language="python">from django.test import TestCase

class LoginTestCase(TestCase):

    def test_login(self):

        # First check for the default behavior
        response = self.client.get('/sekrit/')
        self.assertRedirects(response, '/accounts/login/?next=/sekrit/')

        # Then override the LOGIN_URL setting
        with self.settings(LOGIN_URL='/other/login/'):
            response = self.client.get('/sekrit/')
            self.assertRedirects(response, '/other/login/?next=/sekrit/')
</pre> <p>This example will override the <a class="reference internal" href="../../ref/settings#std:setting-LOGIN_URL"><code>LOGIN_URL</code></a> setting for the code in the <code>with</code> block and reset its value to the previous state afterward.</p> <dl class="method"> <dt id="django.test.SimpleTestCase.modify_settings">
<code>SimpleTestCase.modify_settings()</code> </dt> 
</dl> <p>It can prove unwieldy to redefine settings that contain a list of values. In practice, adding or removing values is often sufficient. Django provides the <a class="reference internal" href="#django.test.SimpleTestCase.modify_settings" title="django.test.SimpleTestCase.modify_settings"><code>modify_settings()</code></a> context manager for easier settings changes:</p> <pre data-language="python">from django.test import TestCase

class MiddlewareTestCase(TestCase):

    def test_cache_middleware(self):
        with self.modify_settings(MIDDLEWARE={
            'append': 'django.middleware.cache.FetchFromCacheMiddleware',
            'prepend': 'django.middleware.cache.UpdateCacheMiddleware',
            'remove': [
                'django.contrib.sessions.middleware.SessionMiddleware',
                'django.contrib.auth.middleware.AuthenticationMiddleware',
                'django.contrib.messages.middleware.MessageMiddleware',
            ],
        }):
            response = self.client.get('/')
            # ...
</pre> <p>For each action, you can supply either a list of values or a string. When the value already exists in the list, <code>append</code> and <code>prepend</code> have no effect; neither does <code>remove</code> when the value doesn’t exist.</p> <dl class="function"> <dt id="django.test.override_settings">
<code>override_settings()</code> </dt> 
</dl> <p>In case you want to override a setting for a test method, Django provides the <a class="reference internal" href="#django.test.override_settings" title="django.test.override_settings"><code>override_settings()</code></a> decorator (see <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0318" id="index-2"><strong>PEP 318</strong></a>). It’s used like this:</p> <pre data-language="python">from django.test import TestCase, override_settings

class LoginTestCase(TestCase):

    @override_settings(LOGIN_URL='/other/login/')
    def test_login(self):
        response = self.client.get('/sekrit/')
        self.assertRedirects(response, '/other/login/?next=/sekrit/')
</pre> <p>The decorator can also be applied to <a class="reference internal" href="#django.test.TestCase" title="django.test.TestCase"><code>TestCase</code></a> classes:</p> <pre data-language="python">from django.test import TestCase, override_settings

@override_settings(LOGIN_URL='/other/login/')
class LoginTestCase(TestCase):

    def test_login(self):
        response = self.client.get('/sekrit/')
        self.assertRedirects(response, '/other/login/?next=/sekrit/')
</pre> <dl class="function"> <dt id="django.test.modify_settings">
<code>modify_settings()</code> </dt> 
</dl> <p>Likewise, Django provides the <a class="reference internal" href="#django.test.modify_settings" title="django.test.modify_settings"><code>modify_settings()</code></a> decorator:</p> <pre data-language="python">from django.test import TestCase, modify_settings

class MiddlewareTestCase(TestCase):

    @modify_settings(MIDDLEWARE={
        'append': 'django.middleware.cache.FetchFromCacheMiddleware',
        'prepend': 'django.middleware.cache.UpdateCacheMiddleware',
    })
    def test_cache_middleware(self):
        response = self.client.get('/')
        # ...
</pre> <p>The decorator can also be applied to test case classes:</p> <pre data-language="python">from django.test import TestCase, modify_settings

@modify_settings(MIDDLEWARE={
    'append': 'django.middleware.cache.FetchFromCacheMiddleware',
    'prepend': 'django.middleware.cache.UpdateCacheMiddleware',
})
class MiddlewareTestCase(TestCase):

    def test_cache_middleware(self):
        response = self.client.get('/')
        # ...
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">When given a class, these decorators modify the class directly and return it; they don’t create and return a modified copy of it. So if you try to tweak the above examples to assign the return value to a different name than <code>LoginTestCase</code> or <code>MiddlewareTestCase</code>, you may be surprised to find that the original test case classes are still equally affected by the decorator. For a given class, <a class="reference internal" href="#django.test.modify_settings" title="django.test.modify_settings"><code>modify_settings()</code></a> is always applied after <a class="reference internal" href="#django.test.override_settings" title="django.test.override_settings"><code>override_settings()</code></a>.</p> </div> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>The settings file contains some settings that are only consulted during initialization of Django internals. If you change them with <code>override_settings</code>, the setting is changed if you access it via the <code>django.conf.settings</code> module, however, Django’s internals access it differently. Effectively, using <a class="reference internal" href="#django.test.override_settings" title="django.test.override_settings"><code>override_settings()</code></a> or <a class="reference internal" href="#django.test.modify_settings" title="django.test.modify_settings"><code>modify_settings()</code></a> with these settings is probably not going to do what you expect it to do.</p> <p>We do not recommend altering the <a class="reference internal" href="../../ref/settings#std:setting-DATABASES"><code>DATABASES</code></a> setting. Altering the <a class="reference internal" href="../../ref/settings#std:setting-CACHES"><code>CACHES</code></a> setting is possible, but a bit tricky if you are using internals that make using of caching, like <a class="reference internal" href="../http/sessions#module-django.contrib.sessions" title="django.contrib.sessions: Provides session management for Django projects."><code>django.contrib.sessions</code></a>. For example, you will have to reinitialize the session backend in a test that uses cached sessions and overrides <a class="reference internal" href="../../ref/settings#std:setting-CACHES"><code>CACHES</code></a>.</p> <p class="last">Finally, avoid aliasing your settings as module-level constants as <code>override_settings()</code> won’t work on such values since they are only evaluated the first time the module is imported.</p> </div> <p>You can also simulate the absence of a setting by deleting it after settings have been overridden, like this:</p> <pre data-language="python">@override_settings()
def test_something(self):
    del settings.LOGIN_URL
    ...
</pre> <p>When overriding settings, make sure to handle the cases in which your app’s code uses a cache or similar feature that retains state even if the setting is changed. Django provides the <a class="reference internal" href="../../ref/signals#django.test.signals.setting_changed" title="django.test.signals.setting_changed"><code>django.test.signals.setting_changed</code></a> signal that lets you register callbacks to clean up and otherwise reset state when settings are changed.</p> <p>Django itself uses this signal to reset various data:</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">Overridden settings</th> <th class="head">Data reset</th> </tr> </thead>  <tr>
<td>USE_TZ, TIME_ZONE</td> <td>Databases timezone</td> </tr> <tr>
<td>TEMPLATES</td> <td>Template engines</td> </tr> <tr>
<td>SERIALIZATION_MODULES</td> <td>Serializers cache</td> </tr> <tr>
<td>LOCALE_PATHS, LANGUAGE_CODE</td> <td>Default translation and loaded translations</td> </tr> <tr>
<td>MEDIA_ROOT, DEFAULT_FILE_STORAGE</td> <td>Default file storage</td> </tr>  </table>   <h3 id="emptying-test-outbox">Emptying the test outbox</h3> <p id="s-emptying-the-test-outbox">If you use any of Django’s custom <code>TestCase</code> classes, the test runner will clear the contents of the test email outbox at the start of each test case.</p> <p>For more detail on email services during tests, see <a class="reference internal" href="#email-services">Email services</a> below.</p>   <h3 id="id2">Assertions</h3> <p id="s-assertions">As Python’s normal <a class="reference external" href="https://docs.python.org/3/library/unittest.html#unittest.TestCase" title="(in Python v3.10)"><code>unittest.TestCase</code></a> class implements assertion methods such as <a class="reference external" href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertTrue" title="(in Python v3.10)"><code>assertTrue()</code></a> and <a class="reference external" href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertEqual" title="(in Python v3.10)"><code>assertEqual()</code></a>, Django’s custom <a class="reference internal" href="#django.test.TestCase" title="django.test.TestCase"><code>TestCase</code></a> class provides a number of custom assertion methods that are useful for testing web applications:</p> <p>The failure messages given by most of these assertion methods can be customized with the <code>msg_prefix</code> argument. This string will be prefixed to any failure message generated by the assertion. This allows you to provide additional details that may help you to identify the location and cause of a failure in your test suite.</p> <dl class="method"> <dt id="django.test.SimpleTestCase.assertRaisesMessage">
<code>SimpleTestCase.assertRaisesMessage(expected_exception, expected_message, callable, *args, **kwargs)</code> </dt> <dt>
<code>SimpleTestCase.assertRaisesMessage(expected_exception, expected_message)</code> </dt> <dd>
<p>Asserts that execution of <code>callable</code> raises <code>expected_exception</code> and that <code>expected_message</code> is found in the exception’s message. Any other outcome is reported as a failure. It’s a simpler version of <a class="reference external" href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertRaisesRegex" title="(in Python v3.10)"><code>unittest.TestCase.assertRaisesRegex()</code></a> with the difference that <code>expected_message</code> isn’t treated as a regular expression.</p> <p>If only the <code>expected_exception</code> and <code>expected_message</code> parameters are given, returns a context manager so that the code being tested can be written inline rather than as a function:</p> <pre data-language="python">with self.assertRaisesMessage(ValueError, 'invalid literal for int()'):
    int('a')
</pre> </dd>
</dl> <dl class="method"> <dt id="django.test.SimpleTestCase.assertWarnsMessage">
<code>SimpleTestCase.assertWarnsMessage(expected_warning, expected_message, callable, *args, **kwargs)</code> </dt> <dt>
<code>SimpleTestCase.assertWarnsMessage(expected_warning, expected_message)</code> </dt> <dd>
<p>Analogous to <a class="reference internal" href="#django.test.SimpleTestCase.assertRaisesMessage" title="django.test.SimpleTestCase.assertRaisesMessage"><code>SimpleTestCase.assertRaisesMessage()</code></a> but for <a class="reference external" href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertWarnsRegex" title="(in Python v3.10)"><code>assertWarnsRegex()</code></a> instead of <a class="reference external" href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertRaisesRegex" title="(in Python v3.10)"><code>assertRaisesRegex()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.SimpleTestCase.assertFieldOutput">
<code>SimpleTestCase.assertFieldOutput(fieldclass, valid, invalid, field_args=None, field_kwargs=None, empty_value='')</code> </dt> <dd>
<p>Asserts that a form field behaves correctly with various inputs.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>fieldclass</strong> – the class of the field to be tested.</li> <li>
<strong>valid</strong> – a dictionary mapping valid inputs to their expected cleaned values.</li> <li>
<strong>invalid</strong> – a dictionary mapping invalid inputs to one or more raised error messages.</li> <li>
<strong>field_args</strong> – the args passed to instantiate the field.</li> <li>
<strong>field_kwargs</strong> – the kwargs passed to instantiate the field.</li> <li>
<strong>empty_value</strong> – the expected clean output for inputs in <code>empty_values</code>.</li> </ul> </td> </tr>  </table> <p>For example, the following code tests that an <code>EmailField</code> accepts <code>a@a.com</code> as a valid email address, but rejects <code>aaa</code> with a reasonable error message:</p> <pre data-language="python">self.assertFieldOutput(EmailField, {'a@a.com': 'a@a.com'}, {'aaa': ['Enter a valid email address.']})
</pre> </dd>
</dl> <dl class="method"> <dt id="django.test.SimpleTestCase.assertFormError">
<code>SimpleTestCase.assertFormError(response, form, field, errors, msg_prefix='')</code> </dt> <dd>
<p>Asserts that a field on a form raises the provided list of errors when rendered on the form.</p> <p><code>response</code> must be a response instance returned by the <a class="reference internal" href="#django.test.Response" title="django.test.Response"><code>test client</code></a>.</p> <p><code>form</code> is the name the <code>Form</code> instance was given in the template context of the response.</p> <p><code>field</code> is the name of the field on the form to check. If <code>field</code> has a value of <code>None</code>, non-field errors (errors you can access via <a class="reference internal" href="../../ref/forms/api#django.forms.Form.non_field_errors" title="django.forms.Form.non_field_errors"><code>form.non_field_errors()</code></a>) will be checked.</p> <p><code>errors</code> is an error string, or a list of error strings, that are expected as a result of form validation.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.SimpleTestCase.assertFormsetError">
<code>SimpleTestCase.assertFormsetError(response, formset, form_index, field, errors, msg_prefix='')</code> </dt> <dd>
<p>Asserts that the <code>formset</code> raises the provided list of errors when rendered.</p> <p><code>response</code> must be a response instance returned by the <a class="reference internal" href="#django.test.Response" title="django.test.Response"><code>test client</code></a>.</p> <p><code>formset</code> is the name the <code>Formset</code> instance was given in the template context of the response.</p> <p><code>form_index</code> is the number of the form within the <code>Formset</code>. If <code>form_index</code> has a value of <code>None</code>, non-form errors (errors you can access via <code>formset.non_form_errors()</code>) will be checked.</p> <p><code>field</code> is the name of the field on the form to check. If <code>field</code> has a value of <code>None</code>, non-field errors (errors you can access via <a class="reference internal" href="../../ref/forms/api#django.forms.Form.non_field_errors" title="django.forms.Form.non_field_errors"><code>form.non_field_errors()</code></a>) will be checked.</p> <p><code>errors</code> is an error string, or a list of error strings, that are expected as a result of form validation.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.SimpleTestCase.assertContains">
<code>SimpleTestCase.assertContains(response, text, count=None, status_code=200, msg_prefix='', html=False)</code> </dt> <dd>
<p>Asserts that a <a class="reference internal" href="../../ref/request-response#django.http.HttpResponse" title="django.http.HttpResponse"><code>response</code></a> produced the given <a class="reference internal" href="../../ref/request-response#django.http.HttpResponse.status_code" title="django.http.HttpResponse.status_code"><code>status_code</code></a> and that <code>text</code> appears in its <a class="reference internal" href="../../ref/request-response#django.http.HttpResponse.content" title="django.http.HttpResponse.content"><code>content</code></a>. If <code>count</code> is provided, <code>text</code> must occur exactly <code>count</code> times in the response.</p> <p>Set <code>html</code> to <code>True</code> to handle <code>text</code> as HTML. The comparison with the response content will be based on HTML semantics instead of character-by-character equality. Whitespace is ignored in most cases, attribute ordering is not significant. See <a class="reference internal" href="#django.test.SimpleTestCase.assertHTMLEqual" title="django.test.SimpleTestCase.assertHTMLEqual"><code>assertHTMLEqual()</code></a> for more details.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.SimpleTestCase.assertNotContains">
<code>SimpleTestCase.assertNotContains(response, text, status_code=200, msg_prefix='', html=False)</code> </dt> <dd>
<p>Asserts that a <a class="reference internal" href="../../ref/request-response#django.http.HttpResponse" title="django.http.HttpResponse"><code>response</code></a> produced the given <a class="reference internal" href="../../ref/request-response#django.http.HttpResponse.status_code" title="django.http.HttpResponse.status_code"><code>status_code</code></a> and that <code>text</code> does <em>not</em> appear in its <a class="reference internal" href="../../ref/request-response#django.http.HttpResponse.content" title="django.http.HttpResponse.content"><code>content</code></a>.</p> <p>Set <code>html</code> to <code>True</code> to handle <code>text</code> as HTML. The comparison with the response content will be based on HTML semantics instead of character-by-character equality. Whitespace is ignored in most cases, attribute ordering is not significant. See <a class="reference internal" href="#django.test.SimpleTestCase.assertHTMLEqual" title="django.test.SimpleTestCase.assertHTMLEqual"><code>assertHTMLEqual()</code></a> for more details.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.SimpleTestCase.assertTemplateUsed">
<code>SimpleTestCase.assertTemplateUsed(response, template_name, msg_prefix='', count=None)</code> </dt> <dd>
<p>Asserts that the template with the given name was used in rendering the response.</p> <p><code>response</code> must be a response instance returned by the <a class="reference internal" href="#django.test.Response" title="django.test.Response"><code>test client</code></a>.</p> <p><code>template_name</code> should be a string such as <code>'admin/index.html'</code>.</p> <p>The <code>count</code> argument is an integer indicating the number of times the template should be rendered. Default is <code>None</code>, meaning that the template should be rendered one or more times.</p> <p>You can use this as a context manager, like this:</p> <pre data-language="python">with self.assertTemplateUsed('index.html'):
    render_to_string('index.html')
with self.assertTemplateUsed(template_name='index.html'):
    render_to_string('index.html')
</pre> </dd>
</dl> <dl class="method"> <dt id="django.test.SimpleTestCase.assertTemplateNotUsed">
<code>SimpleTestCase.assertTemplateNotUsed(response, template_name, msg_prefix='')</code> </dt> <dd>
<p>Asserts that the template with the given name was <em>not</em> used in rendering the response.</p> <p>You can use this as a context manager in the same way as <a class="reference internal" href="#django.test.SimpleTestCase.assertTemplateUsed" title="django.test.SimpleTestCase.assertTemplateUsed"><code>assertTemplateUsed()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.SimpleTestCase.assertURLEqual">
<code>SimpleTestCase.assertURLEqual(url1, url2, msg_prefix='')</code> </dt> <dd>
<p>Asserts that two URLs are the same, ignoring the order of query string parameters except for parameters with the same name. For example, <code>/path/?x=1&amp;y=2</code> is equal to <code>/path/?y=2&amp;x=1</code>, but <code>/path/?a=1&amp;a=2</code> isn’t equal to <code>/path/?a=2&amp;a=1</code>.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.SimpleTestCase.assertRedirects">
<code>SimpleTestCase.assertRedirects(response, expected_url, status_code=302, target_status_code=200, msg_prefix='', fetch_redirect_response=True)</code> </dt> <dd>
<p>Asserts that the <a class="reference internal" href="../../ref/request-response#django.http.HttpResponse" title="django.http.HttpResponse"><code>response</code></a> returned a <a class="reference internal" href="../../ref/request-response#django.http.HttpResponse.status_code" title="django.http.HttpResponse.status_code"><code>status_code</code></a> redirect status, redirected to <code>expected_url</code> (including any <code>GET</code> data), and that the final page was received with <code>target_status_code</code>.</p> <p>If your request used the <code>follow</code> argument, the <code>expected_url</code> and <code>target_status_code</code> will be the url and status code for the final point of the redirect chain.</p> <p>If <code>fetch_redirect_response</code> is <code>False</code>, the final page won’t be loaded. Since the test client can’t fetch external URLs, this is particularly useful if <code>expected_url</code> isn’t part of your Django app.</p> <p>Scheme is handled correctly when making comparisons between two URLs. If there isn’t any scheme specified in the location where we are redirected to, the original request’s scheme is used. If present, the scheme in <code>expected_url</code> is the one used to make the comparisons to.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.SimpleTestCase.assertHTMLEqual">
<code>SimpleTestCase.assertHTMLEqual(html1, html2, msg=None)</code> </dt> <dd>
<p>Asserts that the strings <code>html1</code> and <code>html2</code> are equal. The comparison is based on HTML semantics. The comparison takes following things into account:</p> <ul class="simple"> <li>Whitespace before and after HTML tags is ignored.</li> <li>All types of whitespace are considered equivalent.</li> <li>All open tags are closed implicitly, e.g. when a surrounding tag is closed or the HTML document ends.</li> <li>Empty tags are equivalent to their self-closing version.</li> <li>The ordering of attributes of an HTML element is not significant.</li> <li>Boolean attributes (like <code>checked</code>) without an argument are equal to attributes that equal in name and value (see the examples).</li> <li>Text, character references, and entity references that refer to the same character are equivalent.</li> </ul> <p>The following examples are valid tests and don’t raise any <code>AssertionError</code>:</p> <pre data-language="python">self.assertHTMLEqual(
    '&lt;p&gt;Hello &lt;b&gt;&amp;#x27;world&amp;#x27;!&lt;/p&gt;',
    '''&lt;p&gt;
        Hello   &lt;b&gt;&amp;#39;world&amp;#39;! &lt;/b&gt;
    &lt;/p&gt;'''
)
self.assertHTMLEqual(
    '&lt;input type="checkbox" checked="checked" id="id_accept_terms" /&gt;',
    '&lt;input id="id_accept_terms" type="checkbox" checked&gt;'
)
</pre> <p><code>html1</code> and <code>html2</code> must contain HTML. An <code>AssertionError</code> will be raised if one of them cannot be parsed.</p> <p>Output in case of error can be customized with the <code>msg</code> argument.</p> <div class="versionchanged"> <span class="title">Changed in Django 4.0:</span> <p>In older versions, any attribute (not only boolean attributes) without a value was considered equal to an attribute with the same name and value.</p> </div> </dd>
</dl> <dl class="method"> <dt id="django.test.SimpleTestCase.assertHTMLNotEqual">
<code>SimpleTestCase.assertHTMLNotEqual(html1, html2, msg=None)</code> </dt> <dd>
<p>Asserts that the strings <code>html1</code> and <code>html2</code> are <em>not</em> equal. The comparison is based on HTML semantics. See <a class="reference internal" href="#django.test.SimpleTestCase.assertHTMLEqual" title="django.test.SimpleTestCase.assertHTMLEqual"><code>assertHTMLEqual()</code></a> for details.</p> <p><code>html1</code> and <code>html2</code> must contain HTML. An <code>AssertionError</code> will be raised if one of them cannot be parsed.</p> <p>Output in case of error can be customized with the <code>msg</code> argument.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.SimpleTestCase.assertXMLEqual">
<code>SimpleTestCase.assertXMLEqual(xml1, xml2, msg=None)</code> </dt> <dd>
<p>Asserts that the strings <code>xml1</code> and <code>xml2</code> are equal. The comparison is based on XML semantics. Similarly to <a class="reference internal" href="#django.test.SimpleTestCase.assertHTMLEqual" title="django.test.SimpleTestCase.assertHTMLEqual"><code>assertHTMLEqual()</code></a>, the comparison is made on parsed content, hence only semantic differences are considered, not syntax differences. When invalid XML is passed in any parameter, an <code>AssertionError</code> is always raised, even if both strings are identical.</p> <p>XML declaration, document type, processing instructions, and comments are ignored. Only the root element and its children are compared.</p> <p>Output in case of error can be customized with the <code>msg</code> argument.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.SimpleTestCase.assertXMLNotEqual">
<code>SimpleTestCase.assertXMLNotEqual(xml1, xml2, msg=None)</code> </dt> <dd>
<p>Asserts that the strings <code>xml1</code> and <code>xml2</code> are <em>not</em> equal. The comparison is based on XML semantics. See <a class="reference internal" href="#django.test.SimpleTestCase.assertXMLEqual" title="django.test.SimpleTestCase.assertXMLEqual"><code>assertXMLEqual()</code></a> for details.</p> <p>Output in case of error can be customized with the <code>msg</code> argument.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.SimpleTestCase.assertInHTML">
<code>SimpleTestCase.assertInHTML(needle, haystack, count=None, msg_prefix='')</code> </dt> <dd>
<p>Asserts that the HTML fragment <code>needle</code> is contained in the <code>haystack</code> one.</p> <p>If the <code>count</code> integer argument is specified, then additionally the number of <code>needle</code> occurrences will be strictly verified.</p> <p>Whitespace in most cases is ignored, and attribute ordering is not significant. See <a class="reference internal" href="#django.test.SimpleTestCase.assertHTMLEqual" title="django.test.SimpleTestCase.assertHTMLEqual"><code>assertHTMLEqual()</code></a> for more details.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.SimpleTestCase.assertJSONEqual">
<code>SimpleTestCase.assertJSONEqual(raw, expected_data, msg=None)</code> </dt> <dd>
<p>Asserts that the JSON fragments <code>raw</code> and <code>expected_data</code> are equal. Usual JSON non-significant whitespace rules apply as the heavyweight is delegated to the <a class="reference external" href="https://docs.python.org/3/library/json.html#module-json" title="(in Python v3.10)"><code>json</code></a> library.</p> <p>Output in case of error can be customized with the <code>msg</code> argument.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.SimpleTestCase.assertJSONNotEqual">
<code>SimpleTestCase.assertJSONNotEqual(raw, expected_data, msg=None)</code> </dt> <dd>
<p>Asserts that the JSON fragments <code>raw</code> and <code>expected_data</code> are <em>not</em> equal. See <a class="reference internal" href="#django.test.SimpleTestCase.assertJSONEqual" title="django.test.SimpleTestCase.assertJSONEqual"><code>assertJSONEqual()</code></a> for further details.</p> <p>Output in case of error can be customized with the <code>msg</code> argument.</p> </dd>
</dl> <dl class="method"> <dt id="django.test.TransactionTestCase.assertQuerysetEqual">
<code>TransactionTestCase.assertQuerysetEqual(qs, values, transform=None, ordered=True, msg=None)</code> </dt> <dd>
<p>Asserts that a queryset <code>qs</code> matches a particular iterable of values <code>values</code>.</p> <p>If <code>transform</code> is provided, <code>values</code> is compared to a list produced by applying <code>transform</code> to each member of <code>qs</code>.</p> <p>By default, the comparison is also ordering dependent. If <code>qs</code> doesn’t provide an implicit ordering, you can set the <code>ordered</code> parameter to <code>False</code>, which turns the comparison into a <code>collections.Counter</code> comparison. If the order is undefined (if the given <code>qs</code> isn’t ordered and the comparison is against more than one ordered value), a <code>ValueError</code> is raised.</p> <p>Output in case of error can be customized with the <code>msg</code> argument.</p> <div class="versionchanged"> <span class="title">Changed in Django 3.2:</span> <p>The default value of <code>transform</code> argument was changed to <code>None</code>.</p> </div> <div class="versionadded"> <span class="title">New in Django 3.2:</span> <p>Support for direct comparison between querysets was added.</p> </div> <div class="deprecated"> <p><span class="versionmodified">Deprecated since version 3.2: </span>If <code>transform</code> is not provided and <code>values</code> is a list of strings, it’s compared to a list produced by applying <code>repr()</code> to each member of <code>qs</code>. This behavior is deprecated and will be removed in Django 4.1. If you need it, explicitly set <code>transform</code> to <code>repr</code>.</p> </div> </dd>
</dl> <dl class="method"> <dt id="django.test.TransactionTestCase.assertNumQueries">
<code>TransactionTestCase.assertNumQueries(num, func, *args, **kwargs)</code> </dt> <dd>
<p>Asserts that when <code>func</code> is called with <code>*args</code> and <code>**kwargs</code> that <code>num</code> database queries are executed.</p> <p>If a <code>"using"</code> key is present in <code>kwargs</code> it is used as the database alias for which to check the number of queries:</p> <pre data-language="python">self.assertNumQueries(7, using='non_default_db')
</pre> <p>If you wish to call a function with a <code>using</code> parameter you can do it by wrapping the call with a <code>lambda</code> to add an extra parameter:</p> <pre data-language="python">self.assertNumQueries(7, lambda: my_function(using=7))
</pre> <p>You can also use this as a context manager:</p> <pre data-language="python">with self.assertNumQueries(2):
    Person.objects.create(name="Aaron")
    Person.objects.create(name="Daniel")
</pre> </dd>
</dl>   <h3 id="topics-tagging-tests">Tagging tests</h3> <p id="s-tagging-tests">You can tag your tests so you can easily run a particular subset. For example, you might label fast or slow tests:</p> <pre data-language="python">from django.test import tag

class SampleTestCase(TestCase):

    @tag('fast')
    def test_fast(self):
        ...

    @tag('slow')
    def test_slow(self):
        ...

    @tag('slow', 'core')
    def test_slow_but_core(self):
        ...
</pre> <p>You can also tag a test case:</p> <pre data-language="python">@tag('slow', 'core')
class SampleTestCase(TestCase):
    ...
</pre> <p>Subclasses inherit tags from superclasses, and methods inherit tags from their class. Given:</p> <pre data-language="python">@tag('foo')
class SampleTestCaseChild(SampleTestCase):

    @tag('bar')
    def test(self):
        ...
</pre> <p><code>SampleTestCaseChild.test</code> will be labeled with <code>'slow'</code>, <code>'core'</code>, <code>'bar'</code>, and <code>'foo'</code>.</p> <p>Then you can choose which tests to run. For example, to run only fast tests:</p>       <pre data-language="console">$ ./manage.py test --tag=fast
</pre>   <div class="highlight"><pre><span class="gp">...\&gt;</span> manage.py test --tag=fast
</pre></div>   <p>Or to run fast tests and the core one (even though it’s slow):</p>       <pre data-language="console">$ ./manage.py test --tag=fast --tag=core
</pre>   <div class="highlight"><pre><span class="gp">...\&gt;</span> manage.py test --tag=fast --tag=core
</pre></div>   <p>You can also exclude tests by tag. To run core tests if they are not slow:</p>       <pre data-language="console">$ ./manage.py test --tag=core --exclude-tag=slow
</pre>   <div class="highlight"><pre><span class="gp">...\&gt;</span> manage.py test --tag=core --exclude-tag=slow
</pre></div>   <p><a class="reference internal" href="../../ref/django-admin#cmdoption-test-exclude-tag"><code>test --exclude-tag</code></a> has precedence over <a class="reference internal" href="../../ref/django-admin#cmdoption-test-tag"><code>test --tag</code></a>, so if a test has two tags and you select one of them and exclude the other, the test won’t be run.</p>    <h2 id="async-tests">Testing asynchronous code</h2> <p id="s-testing-asynchronous-code">If you merely want to test the output of your asynchronous views, the standard test client will run them inside their own asynchronous loop without any extra work needed on your part.</p> <p>However, if you want to write fully-asynchronous tests for a Django project, you will need to take several things into account.</p> <p>Firstly, your tests must be <code>async def</code> methods on the test class (in order to give them an asynchronous context). Django will automatically detect any <code>async def</code> tests and wrap them so they run in their own event loop.</p> <p>If you are testing from an asynchronous function, you must also use the asynchronous test client. This is available as <code>django.test.AsyncClient</code>, or as <code>self.async_client</code> on any test.</p> <p><code>AsyncClient</code> has the same methods and signatures as the synchronous (normal) test client, with two exceptions:</p> <ul> <li>The <code>follow</code> parameter is not supported. </li> <li>
<p class="first">Headers passed as <code>extra</code> keyword arguments should not have the <code>HTTP_</code> prefix required by the synchronous client (see <a class="reference internal" href="#django.test.Client.get" title="django.test.Client.get"><code>Client.get()</code></a>). For example, here is how to set an HTTP <code>Accept</code> header:</p> <pre data-language="python">&gt;&gt;&gt; c = AsyncClient()
&gt;&gt;&gt; c.get(
...     '/customers/details/',
...     {'name': 'fred', 'age': 7},
...     ACCEPT='application/json'
... )
</pre> </li> </ul> <p>Using <code>AsyncClient</code> any method that makes a request must be awaited:</p> <pre data-language="python">async def test_my_thing(self):
    response = await self.async_client.get('/some-url/')
    self.assertEqual(response.status_code, 200)
</pre> <p>The asynchronous client can also call synchronous views; it runs through Django’s <a class="reference internal" href="../async"><span class="doc">asynchronous request path</span></a>, which supports both. Any view called through the <code>AsyncClient</code> will get an <code>ASGIRequest</code> object for its <code>request</code> rather than the <code>WSGIRequest</code> that the normal client creates.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>If you are using test decorators, they must be async-compatible to ensure they work correctly. Django’s built-in decorators will behave correctly, but third-party ones may appear to not execute (they will “wrap” the wrong part of the execution flow and not your test).</p> <p>If you need to use these decorators, then you should decorate your test methods with <a class="reference internal" href="../async#asgiref.sync.async_to_sync" title="asgiref.sync.async_to_sync"><code>async_to_sync()</code></a> <em>inside</em> of them instead:</p> <pre data-language="python">from asgiref.sync import async_to_sync
from django.test import TestCase

class MyTests(TestCase):

    @mock.patch(...)
    @async_to_sync
    async def test_my_thing(self):
        ...
</pre> </div>   <h2 id="topics-testing-email">Email services</h2> <p id="s-email-services">If any of your Django views send email using <a class="reference internal" href="../email"><span class="doc">Django’s email functionality</span></a>, you probably don’t want to send email each time you run a test using that view. For this reason, Django’s test runner automatically redirects all Django-sent email to a dummy outbox. This lets you test every aspect of sending email – from the number of messages sent to the contents of each message – without actually sending the messages.</p> <p>The test runner accomplishes this by transparently replacing the normal email backend with a testing backend. (Don’t worry – this has no effect on any other email senders outside of Django, such as your machine’s mail server, if you’re running one.)</p> <dl class="data"> <dt id="django.core.mail.django.core.mail.outbox">
<code>django.core.mail.outbox</code> </dt> 
</dl> <p>During test running, each outgoing email is saved in <code>django.core.mail.outbox</code>. This is a list of all <a class="reference internal" href="../email#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>EmailMessage</code></a> instances that have been sent. The <code>outbox</code> attribute is a special attribute that is created <em>only</em> when the <code>locmem</code> email backend is used. It doesn’t normally exist as part of the <a class="reference internal" href="../email#module-django.core.mail" title="django.core.mail: Helpers to easily send email."><code>django.core.mail</code></a> module and you can’t import it directly. The code below shows how to access this attribute correctly.</p> <p>Here’s an example test that examines <code>django.core.mail.outbox</code> for length and contents:</p> <pre data-language="python">from django.core import mail
from django.test import TestCase

class EmailTest(TestCase):
    def test_send_email(self):
        # Send message.
        mail.send_mail(
            'Subject here', 'Here is the message.',
            'from@example.com', ['to@example.com'],
            fail_silently=False,
        )

        # Test that one message has been sent.
        self.assertEqual(len(mail.outbox), 1)

        # Verify that the subject of the first message is correct.
        self.assertEqual(mail.outbox[0].subject, 'Subject here')
</pre> <p>As noted <a class="reference internal" href="#emptying-test-outbox"><span class="std std-ref">previously</span></a>, the test outbox is emptied at the start of every test in a Django <code>*TestCase</code>. To empty the outbox manually, assign the empty list to <code>mail.outbox</code>:</p> <pre data-language="python">from django.core import mail

# Empty the test outbox
mail.outbox = []
</pre>   <h2 id="topics-testing-management-commands">Management Commands</h2> <p id="s-management-commands">Management commands can be tested with the <a class="reference internal" href="../../ref/django-admin#django.core.management.call_command" title="django.core.management.call_command"><code>call_command()</code></a> function. The output can be redirected into a <code>StringIO</code> instance:</p> <pre data-language="python">from io import StringIO
from django.core.management import call_command
from django.test import TestCase

class ClosepollTest(TestCase):
    def test_command_output(self):
        out = StringIO()
        call_command('closepoll', stdout=out)
        self.assertIn('Expected output', out.getvalue())
</pre>   <h2 id="id3">Skipping tests</h2> <p id="s-skipping-tests">The unittest library provides the <a class="reference external" href="https://docs.python.org/3/library/unittest.html#unittest.skipIf" title="(in Python v3.10)"><code>@skipIf</code></a> and <a class="reference external" href="https://docs.python.org/3/library/unittest.html#unittest.skipUnless" title="(in Python v3.10)"><code>@skipUnless</code></a> decorators to allow you to skip tests if you know ahead of time that those tests are going to fail under certain conditions.</p> <p>For example, if your test requires a particular optional library in order to succeed, you could decorate the test case with <a class="reference external" href="https://docs.python.org/3/library/unittest.html#unittest.skipIf" title="(in Python v3.10)"><code>@skipIf</code></a>. Then, the test runner will report that the test wasn’t executed and why, instead of failing the test or omitting the test altogether.</p> <p>To supplement these test skipping behaviors, Django provides two additional skip decorators. Instead of testing a generic boolean, these decorators check the capabilities of the database, and skip the test if the database doesn’t support a specific named feature.</p> <p>The decorators use a string identifier to describe database features. This string corresponds to attributes of the database connection features class. See <a class="reference external" href="https://github.com/django/django/blob/main/django/db/backends/base/features.py">django.db.backends.base.features.BaseDatabaseFeatures class</a> for a full list of database features that can be used as a basis for skipping tests.</p> <dl class="function"> <dt id="django.test.skipIfDBFeature">
<code>skipIfDBFeature(*feature_name_strings)</code> </dt> 
</dl> <p>Skip the decorated test or <code>TestCase</code> if all of the named database features are supported.</p> <p>For example, the following test will not be executed if the database supports transactions (e.g., it would <em>not</em> run under PostgreSQL, but it would under MySQL with MyISAM tables):</p> <pre data-language="python">class MyTests(TestCase):
    @skipIfDBFeature('supports_transactions')
    def test_transaction_behavior(self):
        # ... conditional test code
        pass
</pre> <dl class="function"> <dt id="django.test.skipUnlessDBFeature">
<code>skipUnlessDBFeature(*feature_name_strings)</code> </dt> 
</dl> <p>Skip the decorated test or <code>TestCase</code> if any of the named database features are <em>not</em> supported.</p> <p>For example, the following test will only be executed if the database supports transactions (e.g., it would run under PostgreSQL, but <em>not</em> under MySQL with MyISAM tables):</p> <pre data-language="python">class MyTests(TestCase):
    @skipUnlessDBFeature('supports_transactions')
    def test_transaction_behavior(self):
        # ... conditional test code
        pass
</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/4.0/topics/testing/tools/" class="_attribution-link">https://docs.djangoproject.com/en/4.0/topics/testing/tools/</a>
  </p>
</div>
