<h1 id="working-with-forms">Working with forms</h1> <div class="admonition-about-this-document admonition" id="s-working-with-forms"> <p class="first admonition-title">About this document</p> <p class="last">This document provides an introduction to the basics of web forms and how they are handled in Django. For a more detailed look at specific areas of the forms API, see <a class="reference internal" href="../../ref/forms/api"><span class="doc">The Forms API</span></a>, <a class="reference internal" href="../../ref/forms/fields"><span class="doc">Form fields</span></a>, and <a class="reference internal" href="../../ref/forms/validation"><span class="doc">Form and field validation</span></a>.</p> </div> <p>Unless you’re planning to build websites and applications that do nothing but publish content, and don’t accept input from your visitors, you’re going to need to understand and use forms.</p> <p>Django provides a range of tools and libraries to help you build forms to accept input from site visitors, and then process and respond to the input.</p>  <h2 id="html-forms">HTML forms</h2> <p id="s-html-forms">In HTML, a form is a collection of elements inside <code>&lt;form&gt;...&lt;/form&gt;</code> that allow a visitor to do things like enter text, select options, manipulate objects or controls, and so on, and then send that information back to the server.</p> <p>Some of these form interface elements - text input or checkboxes - are built into HTML itself. Others are much more complex; an interface that pops up a date picker or allows you to move a slider or manipulate controls will typically use JavaScript and CSS as well as HTML form <code>&lt;input&gt;</code> elements to achieve these effects.</p> <p>As well as its <code>&lt;input&gt;</code> elements, a form must specify two things:</p> <ul class="simple"> <li>
<em>where</em>: the URL to which the data corresponding to the user’s input should be returned</li> <li>
<em>how</em>: the HTTP method the data should be returned by</li> </ul> <p>As an example, the login form for the Django admin contains several <code>&lt;input&gt;</code> elements: one of <code>type="text"</code> for the username, one of <code>type="password"</code> for the password, and one of <code>type="submit"</code> for the “Log in” button. It also contains some hidden text fields that the user doesn’t see, which Django uses to determine what to do next.</p> <p>It also tells the browser that the form data should be sent to the URL specified in the <code>&lt;form&gt;</code>’s <code>action</code> attribute - <code>/admin/</code> - and that it should be sent using the HTTP mechanism specified by the <code>method</code> attribute - <code>post</code>.</p> <p>When the <code>&lt;input type="submit" value="Log in"&gt;</code> element is triggered, the data is returned to <code>/admin/</code>.</p>  <h3 id="get-and-post">
<code>GET</code> and <code>POST</code>
</h3> <p id="s-get-and-post"><code>GET</code> and <code>POST</code> are the only HTTP methods to use when dealing with forms.</p> <p>Django’s login form is returned using the <code>POST</code> method, in which the browser bundles up the form data, encodes it for transmission, sends it to the server, and then receives back its response.</p> <p><code>GET</code>, by contrast, bundles the submitted data into a string, and uses this to compose a URL. The URL contains the address where the data must be sent, as well as the data keys and values. You can see this in action if you do a search in the Django documentation, which will produce a URL of the form <code>https://docs.djangoproject.com/search/?q=forms&amp;release=1</code>.</p> <p><code>GET</code> and <code>POST</code> are typically used for different purposes.</p> <p>Any request that could be used to change the state of the system - for example, a request that makes changes in the database - should use <code>POST</code>. <code>GET</code> should be used only for requests that do not affect the state of the system.</p> <p><code>GET</code> would also be unsuitable for a password form, because the password would appear in the URL, and thus, also in browser history and server logs, all in plain text. Neither would it be suitable for large quantities of data, or for binary data, such as an image. A web application that uses <code>GET</code> requests for admin forms is a security risk: it can be easy for an attacker to mimic a form’s request to gain access to sensitive parts of the system. <code>POST</code>, coupled with other protections like Django’s <a class="reference internal" href="../../ref/csrf"><span class="doc">CSRF protection</span></a> offers more control over access.</p> <p>On the other hand, <code>GET</code> is suitable for things like a web search form, because the URLs that represent a <code>GET</code> request can easily be bookmarked, shared, or resubmitted.</p>    <h2 id="django-s-role-in-forms">Django’s role in forms</h2> <p id="s-django-s-role-in-forms">Handling forms is a complex business. Consider Django’s admin, where numerous items of data of several different types may need to be prepared for display in a form, rendered as HTML, edited using a convenient interface, returned to the server, validated and cleaned up, and then saved or passed on for further processing.</p> <p>Django’s form functionality can simplify and automate vast portions of this work, and can also do it more securely than most programmers would be able to do in code they wrote themselves.</p> <p>Django handles three distinct parts of the work involved in forms:</p> <ul class="simple"> <li>preparing and restructuring data to make it ready for rendering</li> <li>creating HTML forms for the data</li> <li>receiving and processing submitted forms and data from the client</li> </ul> <p>It is <em>possible</em> to write code that does all of this manually, but Django can take care of it all for you.</p>   <h2 id="forms-in-django">Forms in Django</h2> <p id="s-forms-in-django">We’ve described HTML forms briefly, but an HTML <code>&lt;form&gt;</code> is just one part of the machinery required.</p> <p>In the context of a web application, ‘form’ might refer to that HTML <code>&lt;form&gt;</code>, or to the Django <a class="reference internal" href="../../ref/forms/api#django.forms.Form" title="django.forms.Form"><code>Form</code></a> that produces it, or to the structured data returned when it is submitted, or to the end-to-end working collection of these parts.</p>  <h3 id="the-django-form-class">The Django <a class="reference internal" href="../../ref/forms/api#django.forms.Form" title="django.forms.Form"><code>Form</code></a> class</h3> <p id="s-the-django-form-class">At the heart of this system of components is Django’s <a class="reference internal" href="../../ref/forms/api#django.forms.Form" title="django.forms.Form"><code>Form</code></a> class. In much the same way that a Django model describes the logical structure of an object, its behavior, and the way its parts are represented to us, a <a class="reference internal" href="../../ref/forms/api#django.forms.Form" title="django.forms.Form"><code>Form</code></a> class describes a form and determines how it works and appears.</p> <p>In a similar way that a model class’s fields map to database fields, a form class’s fields map to HTML form <code>&lt;input&gt;</code> elements. (A <a class="reference internal" href="modelforms#django.forms.ModelForm" title="django.forms.ModelForm"><code>ModelForm</code></a> maps a model class’s fields to HTML form <code>&lt;input&gt;</code> elements via a <a class="reference internal" href="../../ref/forms/api#django.forms.Form" title="django.forms.Form"><code>Form</code></a>; this is what the Django admin is based upon.)</p> <p>A form’s fields are themselves classes; they manage form data and perform validation when a form is submitted. A <a class="reference internal" href="../../ref/forms/fields#django.forms.DateField" title="django.forms.DateField"><code>DateField</code></a> and a <a class="reference internal" href="../../ref/forms/fields#django.forms.FileField" title="django.forms.FileField"><code>FileField</code></a> handle very different kinds of data and have to do different things with it.</p> <p>A form field is represented to a user in the browser as an HTML “widget” - a piece of user interface machinery. Each field type has an appropriate default <a class="reference internal" href="../../ref/forms/widgets"><span class="doc">Widget class</span></a>, but these can be overridden as required.</p>   <h3 id="instantiating-processing-and-rendering-forms">Instantiating, processing, and rendering forms</h3> <p id="s-instantiating-processing-and-rendering-forms">When rendering an object in Django, we generally:</p> <ol class="arabic simple"> <li>get hold of it in the view (fetch it from the database, for example)</li> <li>pass it to the template context</li> <li>expand it to HTML markup using template variables</li> </ol> <p>Rendering a form in a template involves nearly the same work as rendering any other kind of object, but there are some key differences.</p> <p>In the case of a model instance that contained no data, it would rarely if ever be useful to do anything with it in a template. On the other hand, it makes perfect sense to render an unpopulated form - that’s what we do when we want the user to populate it.</p> <p>So when we handle a model instance in a view, we typically retrieve it from the database. When we’re dealing with a form we typically instantiate it in the view.</p> <p>When we instantiate a form, we can opt to leave it empty or pre-populate it, for example with:</p> <ul class="simple"> <li>data from a saved model instance (as in the case of admin forms for editing)</li> <li>data that we have collated from other sources</li> <li>data received from a previous HTML form submission</li> </ul> <p>The last of these cases is the most interesting, because it’s what makes it possible for users not just to read a website, but to send information back to it too.</p>    <h2 id="building-a-form">Building a form</h2>  <h3 id="the-work-that-needs-to-be-done">The work that needs to be done</h3> <p id="s-building-a-form">Suppose you want to create a simple form on your website, in order to obtain the user’s name. You’d need something like this in your template:</p> <pre data-language="markup">&lt;form action="/your-name/" method="post"&gt;
    &lt;label for="your_name"&gt;Your name: &lt;/label&gt;
    &lt;input id="your_name" type="text" name="your_name" value="{{ current_name }}"&gt;
    &lt;input type="submit" value="OK"&gt;
&lt;/form&gt;
</pre> <p>This tells the browser to return the form data to the URL <code>/your-name/</code>, using the <code>POST</code> method. It will display a text field, labeled “Your name:”, and a button marked “OK”. If the template context contains a <code>current_name</code> variable, that will be used to pre-fill the <code>your_name</code> field.</p> <p>You’ll need a view that renders the template containing the HTML form, and that can supply the <code>current_name</code> field as appropriate.</p> <p>When the form is submitted, the <code>POST</code> request which is sent to the server will contain the form data.</p> <p>Now you’ll also need a view corresponding to that <code>/your-name/</code> URL which will find the appropriate key/value pairs in the request, and then process them.</p> <p>This is a very simple form. In practice, a form might contain dozens or hundreds of fields, many of which might need to be pre-populated, and we might expect the user to work through the edit-submit cycle several times before concluding the operation.</p> <p>We might require some validation to occur in the browser, even before the form is submitted; we might want to use much more complex fields, that allow the user to do things like pick dates from a calendar and so on.</p> <p>At this point it’s much easier to get Django to do most of this work for us.</p>   <h3 id="building-a-form-in-django">Building a form in Django</h3>  <h4 id="the-form-class">The <a class="reference internal" href="../../ref/forms/api#django.forms.Form" title="django.forms.Form"><code>Form</code></a> class</h4> <p id="s-building-a-form-in-django">We already know what we want our HTML form to look like. Our starting point for it in Django is this:</p> <div class="literal-block-wrapper docutils container" id="id1"> <div class="code-block-caption"><span class="caption-text">forms.py</span></div> <pre data-language="python">from django import forms

class NameForm(forms.Form):
    your_name = forms.CharField(label='Your name', max_length=100)
</pre> </div> <p>This defines a <a class="reference internal" href="../../ref/forms/api#django.forms.Form" title="django.forms.Form"><code>Form</code></a> class with a single field (<code>your_name</code>). We’ve applied a human-friendly label to the field, which will appear in the <code>&lt;label&gt;</code> when it’s rendered (although in this case, the <a class="reference internal" href="../../ref/forms/fields#django.forms.Field.label" title="django.forms.Field.label"><code>label</code></a> we specified is actually the same one that would be generated automatically if we had omitted it).</p> <p>The field’s maximum allowable length is defined by <a class="reference internal" href="../../ref/forms/fields#django.forms.CharField.max_length" title="django.forms.CharField.max_length"><code>max_length</code></a>. This does two things. It puts a <code>maxlength="100"</code> on the HTML <code>&lt;input&gt;</code> (so the browser should prevent the user from entering more than that number of characters in the first place). It also means that when Django receives the form back from the browser, it will validate the length of the data.</p> <p>A <a class="reference internal" href="../../ref/forms/api#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance has an <a class="reference internal" href="../../ref/forms/api#django.forms.Form.is_valid" title="django.forms.Form.is_valid"><code>is_valid()</code></a> method, which runs validation routines for all its fields. When this method is called, if all fields contain valid data, it will:</p> <ul class="simple"> <li>return <code>True</code>
</li> <li>place the form’s data in its <a class="reference internal" href="../../ref/forms/api#django.forms.Form.cleaned_data" title="django.forms.Form.cleaned_data"><code>cleaned_data</code></a> attribute.</li> </ul> <p>The whole form, when rendered for the first time, will look like:</p> <pre data-language="markup">&lt;label for="your_name"&gt;Your name: &lt;/label&gt;
&lt;input id="your_name" type="text" name="your_name" maxlength="100" required&gt;
</pre> <p>Note that it <strong>does not</strong> include the <code>&lt;form&gt;</code> tags, or a submit button. We’ll have to provide those ourselves in the template.</p>   <h4 id="using-a-form-in-a-view">The view</h4> <p id="s-the-view">Form data sent back to a Django website is processed by a view, generally the same view which published the form. This allows us to reuse some of the same logic.</p> <p>To handle the form we need to instantiate it in the view for the URL where we want it to be published:</p> <div class="literal-block-wrapper docutils container" id="id2"> <div class="code-block-caption"><span class="caption-text">views.py</span></div> <pre data-language="python">from django.http import HttpResponseRedirect
from django.shortcuts import render

from .forms import NameForm

def get_name(request):
    # if this is a POST request we need to process the form data
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = NameForm(request.POST)
        # check whether it's valid:
        if form.is_valid():
            # process the data in form.cleaned_data as required
            # ...
            # redirect to a new URL:
            return HttpResponseRedirect('/thanks/')

    # if a GET (or any other method) we'll create a blank form
    else:
        form = NameForm()

    return render(request, 'name.html', {'form': form})
</pre> </div> <p>If we arrive at this view with a <code>GET</code> request, it will create an empty form instance and place it in the template context to be rendered. This is what we can expect to happen the first time we visit the URL.</p> <p>If the form is submitted using a <code>POST</code> request, the view will once again create a form instance and populate it with data from the request: <code>form =
NameForm(request.POST)</code> This is called “binding data to the form” (it is now a <em>bound</em> form).</p> <p>We call the form’s <code>is_valid()</code> method; if it’s not <code>True</code>, we go back to the template with the form. This time the form is no longer empty (<em>unbound</em>) so the HTML form will be populated with the data previously submitted, where it can be edited and corrected as required.</p> <p>If <code>is_valid()</code> is <code>True</code>, we’ll now be able to find all the validated form data in its <code>cleaned_data</code> attribute. We can use this data to update the database or do other processing before sending an HTTP redirect to the browser telling it where to go next.</p>   <h4 id="topics-forms-index-basic-form-template">The template</h4> <p id="s-the-template">We don’t need to do much in our <code>name.html</code> template:</p> <pre data-language="markup">&lt;form action="/your-name/" method="post"&gt;
    {% csrf_token %}
    {{ form }}
    &lt;input type="submit" value="Submit"&gt;
&lt;/form&gt;
</pre> <p>All the form’s fields and their attributes will be unpacked into HTML markup from that <code>{{ form }}</code> by Django’s template language.</p> <div class="admonition-forms-and-cross-site-request-forgery-protection admonition"> <p class="first admonition-title">Forms and Cross Site Request Forgery protection</p> <p class="last">Django ships with an easy-to-use <a class="reference internal" href="../../ref/csrf"><span class="doc">protection against Cross Site Request Forgeries</span></a>. When submitting a form via <code>POST</code> with CSRF protection enabled you must use the <a class="reference internal" href="../../ref/templates/builtins#std:templatetag-csrf_token"><code>csrf_token</code></a> template tag as in the preceding example. However, since CSRF protection is not directly tied to forms in templates, this tag is omitted from the following examples in this document.</p> </div> <div class="admonition-html5-input-types-and-browser-validation admonition"> <p class="first admonition-title">HTML5 input types and browser validation</p> <p class="last">If your form includes a <a class="reference internal" href="../../ref/forms/fields#django.forms.URLField" title="django.forms.URLField"><code>URLField</code></a>, an <a class="reference internal" href="../../ref/forms/fields#django.forms.EmailField" title="django.forms.EmailField"><code>EmailField</code></a> or any integer field type, Django will use the <code>url</code>, <code>email</code> and <code>number</code> HTML5 input types. By default, browsers may apply their own validation on these fields, which may be stricter than Django’s validation. If you would like to disable this behavior, set the <code>novalidate</code> attribute on the <code>form</code> tag, or specify a different widget on the field, like <a class="reference internal" href="../../ref/forms/widgets#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a>.</p> </div> <p>We now have a working web form, described by a Django <a class="reference internal" href="../../ref/forms/api#django.forms.Form" title="django.forms.Form"><code>Form</code></a>, processed by a view, and rendered as an HTML <code>&lt;form&gt;</code>.</p> <p>That’s all you need to get started, but the forms framework puts a lot more at your fingertips. Once you understand the basics of the process described above, you should be prepared to understand other features of the forms system and ready to learn a bit more about the underlying machinery.</p>     <h2 id="more-about-django-form-classes">More about Django Form classes</h2> <p id="s-more-about-django-form-classes">All form classes are created as subclasses of either <a class="reference internal" href="../../ref/forms/api#django.forms.Form" title="django.forms.Form"><code>django.forms.Form</code></a> or <a class="reference internal" href="modelforms#django.forms.ModelForm" title="django.forms.ModelForm"><code>django.forms.ModelForm</code></a>. You can think of <code>ModelForm</code> as a subclass of <code>Form</code>. <code>Form</code> and <code>ModelForm</code> actually inherit common functionality from a (private) <code>BaseForm</code> class, but this implementation detail is rarely important.</p> <div class="admonition-models-and-forms admonition"> <p class="first admonition-title">Models and Forms</p> <p class="last">In fact if your form is going to be used to directly add or edit a Django model, a <a class="reference internal" href="modelforms"><span class="doc">ModelForm</span></a> can save you a great deal of time, effort, and code, because it will build a form, along with the appropriate fields and their attributes, from a <code>Model</code> class.</p> </div>  <h3 id="bound-and-unbound-form-instances">Bound and unbound form instances</h3> <p id="s-bound-and-unbound-form-instances">The distinction between <a class="reference internal" href="../../ref/forms/api#ref-forms-api-bound-unbound"><span class="std std-ref">Bound and unbound forms</span></a> is important:</p> <ul class="simple"> <li>An unbound form has no data associated with it. When rendered to the user, it will be empty or will contain default values.</li> <li>A bound form has submitted data, and hence can be used to tell if that data is valid. If an invalid bound form is rendered, it can include inline error messages telling the user what data to correct.</li> </ul> <p>The form’s <a class="reference internal" href="../../ref/forms/api#django.forms.Form.is_bound" title="django.forms.Form.is_bound"><code>is_bound</code></a> attribute will tell you whether a form has data bound to it or not.</p>   <h3 id="more-on-fields">More on fields</h3> <p id="s-more-on-fields">Consider a more useful form than our minimal example above, which we could use to implement “contact me” functionality on a personal website:</p> <div class="literal-block-wrapper docutils container" id="id3"> <div class="code-block-caption"><span class="caption-text">forms.py</span></div> <pre data-language="python">from django import forms

class ContactForm(forms.Form):
    subject = forms.CharField(max_length=100)
    message = forms.CharField(widget=forms.Textarea)
    sender = forms.EmailField()
    cc_myself = forms.BooleanField(required=False)
</pre> </div> <p>Our earlier form used a single field, <code>your_name</code>, a <a class="reference internal" href="../../ref/forms/fields#django.forms.CharField" title="django.forms.CharField"><code>CharField</code></a>. In this case, our form has four fields: <code>subject</code>, <code>message</code>, <code>sender</code> and <code>cc_myself</code>. <a class="reference internal" href="../../ref/forms/fields#django.forms.CharField" title="django.forms.CharField"><code>CharField</code></a>, <a class="reference internal" href="../../ref/forms/fields#django.forms.EmailField" title="django.forms.EmailField"><code>EmailField</code></a> and <a class="reference internal" href="../../ref/forms/fields#django.forms.BooleanField" title="django.forms.BooleanField"><code>BooleanField</code></a> are just three of the available field types; a full list can be found in <a class="reference internal" href="../../ref/forms/fields"><span class="doc">Form fields</span></a>.</p>  <h4 id="widgets">Widgets</h4> <p id="s-widgets">Each form field has a corresponding <a class="reference internal" href="../../ref/forms/widgets"><span class="doc">Widget class</span></a>, which in turn corresponds to an HTML form widget such as <code>&lt;input
type="text"&gt;</code>.</p> <p>In most cases, the field will have a sensible default widget. For example, by default, a <a class="reference internal" href="../../ref/forms/fields#django.forms.CharField" title="django.forms.CharField"><code>CharField</code></a> will have a <a class="reference internal" href="../../ref/forms/widgets#django.forms.TextInput" title="django.forms.TextInput"><code>TextInput</code></a> widget, that produces an <code>&lt;input type="text"&gt;</code> in the HTML. If you needed <code>&lt;textarea&gt;</code> instead, you’d specify the appropriate widget when defining your form field, as we have done for the <code>message</code> field.</p>   <h4 id="field-data">Field data</h4> <p id="s-field-data">Whatever the data submitted with a form, once it has been successfully validated by calling <code>is_valid()</code> (and <code>is_valid()</code> has returned <code>True</code>), the validated form data will be in the <code>form.cleaned_data</code> dictionary. This data will have been nicely converted into Python types for you.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">You can still access the unvalidated data directly from <code>request.POST</code> at this point, but the validated data is better.</p> </div> <p>In the contact form example above, <code>cc_myself</code> will be a boolean value. Likewise, fields such as <a class="reference internal" href="../../ref/forms/fields#django.forms.IntegerField" title="django.forms.IntegerField"><code>IntegerField</code></a> and <a class="reference internal" href="../../ref/forms/fields#django.forms.FloatField" title="django.forms.FloatField"><code>FloatField</code></a> convert values to a Python <code>int</code> and <code>float</code> respectively.</p> <p>Here’s how the form data could be processed in the view that handles this form:</p> <div class="literal-block-wrapper docutils container" id="id4"> <div class="code-block-caption"><span class="caption-text">views.py</span></div> <pre data-language="python">from django.core.mail import send_mail

if form.is_valid():
    subject = form.cleaned_data['subject']
    message = form.cleaned_data['message']
    sender = form.cleaned_data['sender']
    cc_myself = form.cleaned_data['cc_myself']

    recipients = ['info@example.com']
    if cc_myself:
        recipients.append(sender)

    send_mail(subject, message, sender, recipients)
    return HttpResponseRedirect('/thanks/')
</pre> </div> <div class="admonition tip"> <p class="first admonition-title">Tip</p> <p class="last">For more on sending email from Django, see <a class="reference internal" href="../email"><span class="doc">Sending email</span></a>.</p> </div> <p>Some field types need some extra handling. For example, files that are uploaded using a form need to be handled differently (they can be retrieved from <code>request.FILES</code>, rather than <code>request.POST</code>). For details of how to handle file uploads with your form, see <a class="reference internal" href="../../ref/forms/api#binding-uploaded-files"><span class="std std-ref">Binding uploaded files to a form</span></a>.</p>     <h2 id="working-with-form-templates">Working with form templates</h2> <p id="s-working-with-form-templates">All you need to do to get your form into a template is to place the form instance into the template context. So if your form is called <code>form</code> in the context, <code>{{ form }}</code> will render its <code>&lt;label&gt;</code> and <code>&lt;input&gt;</code> elements appropriately.</p>  <h3 id="form-rendering-options">Form rendering options</h3> <div class="admonition-additional-form-template-furniture admonition" id="s-form-rendering-options"> <p class="first admonition-title">Additional form template furniture</p> <p class="last">Don’t forget that a form’s output does <em>not</em> include the surrounding <code>&lt;form&gt;</code> tags, or the form’s <code>submit</code> control. You will have to provide these yourself.</p> </div> <p>There are other output options though for the <code>&lt;label&gt;</code>/<code>&lt;input&gt;</code> pairs:</p> <ul class="simple"> <li>
<code>{{ form.as_table }}</code> will render them as table cells wrapped in <code>&lt;tr&gt;</code> tags</li> <li>
<code>{{ form.as_p }}</code> will render them wrapped in <code>&lt;p&gt;</code> tags</li> <li>
<code>{{ form.as_ul }}</code> will render them wrapped in <code>&lt;li&gt;</code> tags</li> </ul> <p>Note that you’ll have to provide the surrounding <code>&lt;table&gt;</code> or <code>&lt;ul&gt;</code> elements yourself.</p> <p>Here’s the output of <code>{{ form.as_p }}</code> for our <code>ContactForm</code> instance:</p> <pre data-language="markup">&lt;p&gt;&lt;label for="id_subject"&gt;Subject:&lt;/label&gt;
    &lt;input id="id_subject" type="text" name="subject" maxlength="100" required&gt;&lt;/p&gt;
&lt;p&gt;&lt;label for="id_message"&gt;Message:&lt;/label&gt;
    &lt;textarea name="message" id="id_message" required&gt;&lt;/textarea&gt;&lt;/p&gt;
&lt;p&gt;&lt;label for="id_sender"&gt;Sender:&lt;/label&gt;
    &lt;input type="email" name="sender" id="id_sender" required&gt;&lt;/p&gt;
&lt;p&gt;&lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt;
    &lt;input type="checkbox" name="cc_myself" id="id_cc_myself"&gt;&lt;/p&gt;
</pre> <p>Note that each form field has an ID attribute set to <code>id_&lt;field-name&gt;</code>, which is referenced by the accompanying label tag. This is important in ensuring that forms are accessible to assistive technology such as screen reader software. You can also <a class="reference internal" href="../../ref/forms/api#ref-forms-api-configuring-label"><span class="std std-ref">customize the way in which labels and ids are generated</span></a>.</p> <p>See <a class="reference internal" href="../../ref/forms/api#ref-forms-api-outputting-html"><span class="std std-ref">Outputting forms as HTML</span></a> for more on this.</p>   <h3 id="rendering-fields-manually">Rendering fields manually</h3> <p id="s-rendering-fields-manually">We don’t have to let Django unpack the form’s fields; we can do it manually if we like (allowing us to reorder the fields, for example). Each field is available as an attribute of the form using <code>{{ form.name_of_field }}</code>, and in a Django template, will be rendered appropriately. For example:</p> <pre data-language="markup">{{ form.non_field_errors }}
&lt;div class="fieldWrapper"&gt;
    {{ form.subject.errors }}
    &lt;label for="{{ form.subject.id_for_label }}"&gt;Email subject:&lt;/label&gt;
    {{ form.subject }}
&lt;/div&gt;
&lt;div class="fieldWrapper"&gt;
    {{ form.message.errors }}
    &lt;label for="{{ form.message.id_for_label }}"&gt;Your message:&lt;/label&gt;
    {{ form.message }}
&lt;/div&gt;
&lt;div class="fieldWrapper"&gt;
    {{ form.sender.errors }}
    &lt;label for="{{ form.sender.id_for_label }}"&gt;Your email address:&lt;/label&gt;
    {{ form.sender }}
&lt;/div&gt;
&lt;div class="fieldWrapper"&gt;
    {{ form.cc_myself.errors }}
    &lt;label for="{{ form.cc_myself.id_for_label }}"&gt;CC yourself?&lt;/label&gt;
    {{ form.cc_myself }}
&lt;/div&gt;
</pre> <p>Complete <code>&lt;label&gt;</code> elements can also be generated using the <a class="reference internal" href="../../ref/forms/api#django.forms.BoundField.label_tag" title="django.forms.BoundField.label_tag"><code>label_tag()</code></a>. For example:</p> <pre data-language="markup">&lt;div class="fieldWrapper"&gt;
    {{ form.subject.errors }}
    {{ form.subject.label_tag }}
    {{ form.subject }}
&lt;/div&gt;
</pre>  <h4 id="rendering-form-error-messages">Rendering form error messages</h4> <p id="s-rendering-form-error-messages">The price of this flexibility is a bit more work. Until now we haven’t had to worry about how to display form errors, because that’s taken care of for us. In this example we have had to make sure we take care of any errors for each field and any errors for the form as a whole. Note <code>{{ form.non_field_errors }}</code> at the top of the form and the template lookup for errors on each field.</p> <p>Using <code>{{ form.name_of_field.errors }}</code> displays a list of form errors, rendered as an unordered list. This might look like:</p> <pre data-language="markup">&lt;ul class="errorlist"&gt;
    &lt;li&gt;Sender is required.&lt;/li&gt;
&lt;/ul&gt;
</pre> <p>The list has a CSS class of <code>errorlist</code> to allow you to style its appearance. If you wish to further customize the display of errors you can do so by looping over them:</p> <pre data-language="markup">{% if form.subject.errors %}
    &lt;ol&gt;
    {% for error in form.subject.errors %}
        &lt;li&gt;&lt;strong&gt;{{ error|escape }}&lt;/strong&gt;&lt;/li&gt;
    {% endfor %}
    &lt;/ol&gt;
{% endif %}
</pre> <p>Non-field errors (and/or hidden field errors that are rendered at the top of the form when using helpers like <code>form.as_p()</code>) will be rendered with an additional class of <code>nonfield</code> to help distinguish them from field-specific errors. For example, <code>{{ form.non_field_errors }}</code> would look like:</p> <pre data-language="markup">&lt;ul class="errorlist nonfield"&gt;
    &lt;li&gt;Generic validation error&lt;/li&gt;
&lt;/ul&gt;
</pre> <p>See <a class="reference internal" href="../../ref/forms/api"><span class="doc">The Forms API</span></a> for more on errors, styling, and working with form attributes in templates.</p>    <h3 id="looping-over-the-form-s-fields">Looping over the form’s fields</h3> <p id="s-looping-over-the-form-s-fields">If you’re using the same HTML for each of your form fields, you can reduce duplicate code by looping through each field in turn using a <code>{% for %}</code> loop:</p> <pre data-language="markup">{% for field in form %}
    &lt;div class="fieldWrapper"&gt;
        {{ field.errors }}
        {{ field.label_tag }} {{ field }}
        {% if field.help_text %}
        &lt;p class="help"&gt;{{ field.help_text|safe }}&lt;/p&gt;
        {% endif %}
    &lt;/div&gt;
{% endfor %}
</pre> <p>Useful attributes on <code>{{ field }}</code> include:</p> <dl class="docutils"> <dt>
<code>{{ field.label }}</code> </dt> <dd>The label of the field, e.g. <code>Email address</code>.</dd> <dt>
<code>{{ field.label_tag }}</code> </dt> <dd>
<p class="first">The field’s label wrapped in the appropriate HTML <code>&lt;label&gt;</code> tag. This includes the form’s <a class="reference internal" href="../../ref/forms/api#django.forms.Form.label_suffix" title="django.forms.Form.label_suffix"><code>label_suffix</code></a>. For example, the default <code>label_suffix</code> is a colon:</p> <pre data-language="python">&lt;label for="id_email"&gt;Email address:&lt;/label&gt;
</pre> </dd> <dt>
<code>{{ field.id_for_label }}</code> </dt> <dd>The ID that will be used for this field (<code>id_email</code> in the example above). If you are constructing the label manually, you may want to use this in lieu of <code>label_tag</code>. It’s also useful, for example, if you have some inline JavaScript and want to avoid hardcoding the field’s ID.</dd> <dt>
<code>{{ field.value }}</code> </dt> <dd>The value of the field. e.g <code>someone@example.com</code>.</dd> <dt>
<code>{{ field.html_name }}</code> </dt> <dd>The name of the field that will be used in the input element’s name field. This takes the form prefix into account, if it has been set.</dd> <dt>
<code>{{ field.help_text }}</code> </dt> <dd>Any help text that has been associated with the field.</dd> <dt>
<code>{{ field.errors }}</code> </dt> <dd>Outputs a <code>&lt;ul class="errorlist"&gt;</code> containing any validation errors corresponding to this field. You can customize the presentation of the errors with a <code>{% for error in field.errors %}</code> loop. In this case, each object in the loop is a string containing the error message.</dd> <dt>
<code>{{ field.is_hidden }}</code> </dt> <dd>This attribute is <code>True</code> if the form field is a hidden field and <code>False</code> otherwise. It’s not particularly useful as a template variable, but could be useful in conditional tests such as:</dd> </dl> <pre data-language="markup">{% if field.is_hidden %}
   {# Do something special #}
{% endif %}
</pre> <dl class="docutils"> <dt>
<code>{{ field.field }}</code> </dt> <dd>The <a class="reference internal" href="../../ref/forms/fields#django.forms.Field" title="django.forms.Field"><code>Field</code></a> instance from the form class that this <a class="reference internal" href="../../ref/forms/api#django.forms.BoundField" title="django.forms.BoundField"><code>BoundField</code></a> wraps. You can use it to access <a class="reference internal" href="../../ref/forms/fields#django.forms.Field" title="django.forms.Field"><code>Field</code></a> attributes, e.g. <code>{{ char_field.field.max_length }}</code>.</dd> </dl> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last">For a complete list of attributes and methods, see <a class="reference internal" href="../../ref/forms/api#django.forms.BoundField" title="django.forms.BoundField"><code>BoundField</code></a>.</p> </div>  <h4 id="looping-over-hidden-and-visible-fields">Looping over hidden and visible fields</h4> <p id="s-looping-over-hidden-and-visible-fields">If you’re manually laying out a form in a template, as opposed to relying on Django’s default form layout, you might want to treat <code>&lt;input type="hidden"&gt;</code> fields differently from non-hidden fields. For example, because hidden fields don’t display anything, putting error messages “next to” the field could cause confusion for your users – so errors for those fields should be handled differently.</p> <p>Django provides two methods on a form that allow you to loop over the hidden and visible fields independently: <code>hidden_fields()</code> and <code>visible_fields()</code>. Here’s a modification of an earlier example that uses these two methods:</p> <pre data-language="markup">{# Include the hidden fields #}
{% for hidden in form.hidden_fields %}
{{ hidden }}
{% endfor %}
{# Include the visible fields #}
{% for field in form.visible_fields %}
    &lt;div class="fieldWrapper"&gt;
        {{ field.errors }}
        {{ field.label_tag }} {{ field }}
    &lt;/div&gt;
{% endfor %}
</pre> <p>This example does not handle any errors in the hidden fields. Usually, an error in a hidden field is a sign of form tampering, since normal form interaction won’t alter them. However, you could easily insert some error displays for those form errors, as well.</p>    <h3 id="reusable-form-templates">Reusable form templates</h3> <p id="s-reusable-form-templates">If your site uses the same rendering logic for forms in multiple places, you can reduce duplication by saving the form’s loop in a standalone template and overriding the forms <a class="reference internal" href="../../ref/forms/api#django.forms.Form.template_name" title="django.forms.Form.template_name"><code>template_name</code></a> attribute to render the form using the custom template. The below example will result in <code>{{ form }}</code> being rendered as the output of the <code>form_snippet.html</code> template.</p> <p>In your templates:</p> <pre data-language="markup"># In your template:
{{ form }}

# In form_snippet.html:
{% for field in form %}
    &lt;div class="fieldWrapper"&gt;
        {{ field.errors }}
        {{ field.label_tag }} {{ field }}
    &lt;/div&gt;
{% endfor %}
</pre> <p>In your form:</p> <pre data-language="python">class MyForm(forms.Form):
    template_name = 'form_snippet.html'
    ...
</pre> <div class="versionchanged"> <span class="title">Changed in Django 4.0:</span> <p>Template rendering of forms was added.</p> </div>    <h2 id="further-topics">Further topics</h2> <p id="s-further-topics">This covers the basics, but forms can do a whole lot more:</p>  <ul> <li class="toctree-l1">
<a class="reference internal" href="formsets">Formsets</a><ul> <li class="toctree-l2"><a class="reference internal" href="formsets#using-initial-data-with-a-formset">Using initial data with a formset</a></li> <li class="toctree-l2"><a class="reference internal" href="formsets#limiting-the-maximum-number-of-forms">Limiting the maximum number of forms</a></li> <li class="toctree-l2"><a class="reference internal" href="formsets#limiting-the-maximum-number-of-instantiated-forms">Limiting the maximum number of instantiated forms</a></li> <li class="toctree-l2"><a class="reference internal" href="formsets#formset-validation">Formset validation</a></li> <li class="toctree-l2"><a class="reference internal" href="formsets#validating-the-number-of-forms-in-a-formset">Validating the number of forms in a formset</a></li> <li class="toctree-l2"><a class="reference internal" href="formsets#dealing-with-ordering-and-deletion-of-forms">Dealing with ordering and deletion of forms</a></li> <li class="toctree-l2"><a class="reference internal" href="formsets#adding-additional-fields-to-a-formset">Adding additional fields to a formset</a></li> <li class="toctree-l2"><a class="reference internal" href="formsets#passing-custom-parameters-to-formset-forms">Passing custom parameters to formset forms</a></li> <li class="toctree-l2"><a class="reference internal" href="formsets#customizing-a-formset-s-prefix">Customizing a formset’s prefix</a></li> <li class="toctree-l2"><a class="reference internal" href="formsets#using-a-formset-in-views-and-templates">Using a formset in views and templates</a></li> </ul> </li> <li class="toctree-l1">
<a class="reference internal" href="modelforms">Creating forms from models</a><ul> <li class="toctree-l2"><a class="reference internal" href="modelforms#modelform"><code>ModelForm</code></a></li> <li class="toctree-l2"><a class="reference internal" href="modelforms#model-formsets">Model formsets</a></li> <li class="toctree-l2"><a class="reference internal" href="modelforms#inline-formsets">Inline formsets</a></li> </ul> </li> <li class="toctree-l1">
<a class="reference internal" href="media">Form Assets (the <code>Media</code> class)</a><ul> <li class="toctree-l2"><a class="reference internal" href="media#assets-as-a-static-definition">Assets as a static definition</a></li> <li class="toctree-l2"><a class="reference internal" href="media#media-as-a-dynamic-property"><code>Media</code> as a dynamic property</a></li> <li class="toctree-l2"><a class="reference internal" href="media#paths-in-asset-definitions">Paths in asset definitions</a></li> <li class="toctree-l2"><a class="reference internal" href="media#media-objects"><code>Media</code> objects</a></li> <li class="toctree-l2"><a class="reference internal" href="media#media-on-forms"><code>Media</code> on Forms</a></li> </ul> </li> </ul>  <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt><a class="reference internal" href="../../ref/forms/index"><span class="doc">The Forms Reference</span></a></dt> <dd>Covers the full API reference, including form fields, form widgets, and form and field validation.</dd> </dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/4.0/topics/forms/index/" class="_attribution-link">https://docs.djangoproject.com/en/4.0/topics/forms/index/</a>
  </p>
</div>
