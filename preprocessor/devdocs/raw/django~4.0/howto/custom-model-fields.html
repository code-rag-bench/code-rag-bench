<h1 id="how-to-create-custom-model-fields">How to create custom model fields</h1>  <h2 id="introduction">Introduction</h2> <p id="s-how-to-create-custom-model-fields">The <a class="reference internal" href="../topics/db/models"><span class="doc">model reference</span></a> documentation explains how to use Django’s standard field classes – <a class="reference internal" href="../ref/models/fields#django.db.models.CharField" title="django.db.models.CharField"><code>CharField</code></a>, <a class="reference internal" href="../ref/models/fields#django.db.models.DateField" title="django.db.models.DateField"><code>DateField</code></a>, etc. For many purposes, those classes are all you’ll need. Sometimes, though, the Django version won’t meet your precise requirements, or you’ll want to use a field that is entirely different from those shipped with Django.</p> <p>Django’s built-in field types don’t cover every possible database column type – only the common types, such as <code>VARCHAR</code> and <code>INTEGER</code>. For more obscure column types, such as geographic polygons or even user-created types such as <a class="reference external" href="https://www.postgresql.org/docs/current/sql-createtype.html">PostgreSQL custom types</a>, you can define your own Django <code>Field</code> subclasses.</p> <p>Alternatively, you may have a complex Python object that can somehow be serialized to fit into a standard database column type. This is another case where a <code>Field</code> subclass will help you use your object with your models.</p>  <h3 id="our-example-object">Our example object</h3> <p id="s-our-example-object">Creating custom fields requires a bit of attention to detail. To make things easier to follow, we’ll use a consistent example throughout this document: wrapping a Python object representing the deal of cards in a hand of <a class="reference external" href="https://en.wikipedia.org/wiki/Contract_bridge">Bridge</a>. Don’t worry, you don’t have to know how to play Bridge to follow this example. You only need to know that 52 cards are dealt out equally to four players, who are traditionally called <em>north</em>, <em>east</em>, <em>south</em> and <em>west</em>. Our class looks something like this:</p> <pre data-language="python">class Hand:
    """A hand of cards (bridge style)"""

    def __init__(self, north, east, south, west):
        # Input parameters are lists of cards ('Ah', '9s', etc.)
        self.north = north
        self.east = east
        self.south = south
        self.west = west

    # ... (other possibly useful methods omitted) ...
</pre> <p>This is an ordinary Python class, with nothing Django-specific about it. We’d like to be able to do things like this in our models (we assume the <code>hand</code> attribute on the model is an instance of <code>Hand</code>):</p> <pre data-language="python">example = MyModel.objects.get(pk=1)
print(example.hand.north)

new_hand = Hand(north, east, south, west)
example.hand = new_hand
example.save()
</pre> <p>We assign to and retrieve from the <code>hand</code> attribute in our model just like any other Python class. The trick is to tell Django how to handle saving and loading such an object.</p> <p>In order to use the <code>Hand</code> class in our models, we <strong>do not</strong> have to change this class at all. This is ideal, because it means you can easily write model support for existing classes where you cannot change the source code.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">You might only be wanting to take advantage of custom database column types and deal with the data as standard Python types in your models; strings, or floats, for example. This case is similar to our <code>Hand</code> example and we’ll note any differences as we go along.</p> </div>    <h2 id="background-theory">Background theory</h2>  <h3 id="database-storage">Database storage</h3> <p id="s-background-theory">Let’s start with model fields. If you break it down, a model field provides a way to take a normal Python object – string, boolean, <code>datetime</code>, or something more complex like <code>Hand</code> – and convert it to and from a format that is useful when dealing with the database. (Such a format is also useful for serialization, but as we’ll see later, that is easier once you have the database side under control).</p> <p>Fields in a model must somehow be converted to fit into an existing database column type. Different databases provide different sets of valid column types, but the rule is still the same: those are the only types you have to work with. Anything you want to store in the database must fit into one of those types.</p> <p>Normally, you’re either writing a Django field to match a particular database column type, or you will need a way to convert your data to, say, a string.</p> <p>For our <code>Hand</code> example, we could convert the card data to a string of 104 characters by concatenating all the cards together in a pre-determined order – say, all the <em>north</em> cards first, then the <em>east</em>, <em>south</em> and <em>west</em> cards. So <code>Hand</code> objects can be saved to text or character columns in the database.</p>   <h3 id="what-does-a-field-class-do">What does a field class do?</h3> <p id="s-what-does-a-field-class-do">All of Django’s fields (and when we say <em>fields</em> in this document, we always mean model fields and not <a class="reference internal" href="../ref/forms/fields"><span class="doc">form fields</span></a>) are subclasses of <a class="reference internal" href="../ref/models/fields#django.db.models.Field" title="django.db.models.Field"><code>django.db.models.Field</code></a>. Most of the information that Django records about a field is common to all fields – name, help text, uniqueness and so forth. Storing all that information is handled by <code>Field</code>. We’ll get into the precise details of what <code>Field</code> can do later on; for now, suffice it to say that everything descends from <code>Field</code> and then customizes key pieces of the class behavior.</p> <p>It’s important to realize that a Django field class is not what is stored in your model attributes. The model attributes contain normal Python objects. The field classes you define in a model are actually stored in the <code>Meta</code> class when the model class is created (the precise details of how this is done are unimportant here). This is because the field classes aren’t necessary when you’re just creating and modifying attributes. Instead, they provide the machinery for converting between the attribute value and what is stored in the database or sent to the <a class="reference internal" href="../topics/serialization"><span class="doc">serializer</span></a>.</p> <p>Keep this in mind when creating your own custom fields. The Django <code>Field</code> subclass you write provides the machinery for converting between your Python instances and the database/serializer values in various ways (there are differences between storing a value and using a value for lookups, for example). If this sounds a bit tricky, don’t worry – it will become clearer in the examples below. Just remember that you will often end up creating two classes when you want a custom field:</p> <ul class="simple"> <li>The first class is the Python object that your users will manipulate. They will assign it to the model attribute, they will read from it for displaying purposes, things like that. This is the <code>Hand</code> class in our example.</li> <li>The second class is the <code>Field</code> subclass. This is the class that knows how to convert your first class back and forth between its permanent storage form and the Python form.</li> </ul>    <h2 id="writing-a-field-subclass">Writing a field subclass</h2> <p id="s-writing-a-field-subclass">When planning your <a class="reference internal" href="../ref/models/fields#django.db.models.Field" title="django.db.models.Field"><code>Field</code></a> subclass, first give some thought to which existing <a class="reference internal" href="../ref/models/fields#django.db.models.Field" title="django.db.models.Field"><code>Field</code></a> class your new field is most similar to. Can you subclass an existing Django field and save yourself some work? If not, you should subclass the <a class="reference internal" href="../ref/models/fields#django.db.models.Field" title="django.db.models.Field"><code>Field</code></a> class, from which everything is descended.</p> <p>Initializing your new field is a matter of separating out any arguments that are specific to your case from the common arguments and passing the latter to the <code>__init__()</code> method of <a class="reference internal" href="../ref/models/fields#django.db.models.Field" title="django.db.models.Field"><code>Field</code></a> (or your parent class).</p> <p>In our example, we’ll call our field <code>HandField</code>. (It’s a good idea to call your <a class="reference internal" href="../ref/models/fields#django.db.models.Field" title="django.db.models.Field"><code>Field</code></a> subclass <code>&lt;Something&gt;Field</code>, so it’s easily identifiable as a <a class="reference internal" href="../ref/models/fields#django.db.models.Field" title="django.db.models.Field"><code>Field</code></a> subclass.) It doesn’t behave like any existing field, so we’ll subclass directly from <a class="reference internal" href="../ref/models/fields#django.db.models.Field" title="django.db.models.Field"><code>Field</code></a>:</p> <pre data-language="python">from django.db import models

class HandField(models.Field):

    description = "A hand of cards (bridge style)"

    def __init__(self, *args, **kwargs):
        kwargs['max_length'] = 104
        super().__init__(*args, **kwargs)
</pre> <p>Our <code>HandField</code> accepts most of the standard field options (see the list below), but we ensure it has a fixed length, since it only needs to hold 52 card values plus their suits; 104 characters in total.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>Many of Django’s model fields accept options that they don’t do anything with. For example, you can pass both <a class="reference internal" href="../ref/models/fields#django.db.models.Field.editable" title="django.db.models.Field.editable"><code>editable</code></a> and <a class="reference internal" href="../ref/models/fields#django.db.models.DateField.auto_now" title="django.db.models.DateField.auto_now"><code>auto_now</code></a> to a <a class="reference internal" href="../ref/models/fields#django.db.models.DateField" title="django.db.models.DateField"><code>django.db.models.DateField</code></a> and it will ignore the <a class="reference internal" href="../ref/models/fields#django.db.models.Field.editable" title="django.db.models.Field.editable"><code>editable</code></a> parameter (<a class="reference internal" href="../ref/models/fields#django.db.models.DateField.auto_now" title="django.db.models.DateField.auto_now"><code>auto_now</code></a> being set implies <code>editable=False</code>). No error is raised in this case.</p> <p class="last">This behavior simplifies the field classes, because they don’t need to check for options that aren’t necessary. They pass all the options to the parent class and then don’t use them later on. It’s up to you whether you want your fields to be more strict about the options they select, or to use the more permissive behavior of the current fields.</p> </div> <p>The <code>Field.__init__()</code> method takes the following parameters:</p> <ul class="simple"> <li><a class="reference internal" href="../ref/models/fields#django.db.models.Field.verbose_name" title="django.db.models.Field.verbose_name"><code>verbose_name</code></a></li> <li><code>name</code></li> <li><a class="reference internal" href="../ref/models/fields#django.db.models.Field.primary_key" title="django.db.models.Field.primary_key"><code>primary_key</code></a></li> <li><a class="reference internal" href="../ref/models/fields#django.db.models.CharField.max_length" title="django.db.models.CharField.max_length"><code>max_length</code></a></li> <li><a class="reference internal" href="../ref/models/fields#django.db.models.Field.unique" title="django.db.models.Field.unique"><code>unique</code></a></li> <li><a class="reference internal" href="../ref/models/fields#django.db.models.Field.blank" title="django.db.models.Field.blank"><code>blank</code></a></li> <li><a class="reference internal" href="../ref/models/fields#django.db.models.Field.null" title="django.db.models.Field.null"><code>null</code></a></li> <li><a class="reference internal" href="../ref/models/fields#django.db.models.Field.db_index" title="django.db.models.Field.db_index"><code>db_index</code></a></li> <li>
<code>rel</code>: Used for related fields (like <a class="reference internal" href="../ref/models/fields#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a>). For advanced use only.</li> <li><a class="reference internal" href="../ref/models/fields#django.db.models.Field.default" title="django.db.models.Field.default"><code>default</code></a></li> <li><a class="reference internal" href="../ref/models/fields#django.db.models.Field.editable" title="django.db.models.Field.editable"><code>editable</code></a></li> <li>
<code>serialize</code>: If <code>False</code>, the field will not be serialized when the model is passed to Django’s <a class="reference internal" href="../topics/serialization"><span class="doc">serializers</span></a>. Defaults to <code>True</code>.</li> <li><a class="reference internal" href="../ref/models/fields#django.db.models.Field.unique_for_date" title="django.db.models.Field.unique_for_date"><code>unique_for_date</code></a></li> <li><a class="reference internal" href="../ref/models/fields#django.db.models.Field.unique_for_month" title="django.db.models.Field.unique_for_month"><code>unique_for_month</code></a></li> <li><a class="reference internal" href="../ref/models/fields#django.db.models.Field.unique_for_year" title="django.db.models.Field.unique_for_year"><code>unique_for_year</code></a></li> <li><a class="reference internal" href="../ref/models/fields#django.db.models.Field.choices" title="django.db.models.Field.choices"><code>choices</code></a></li> <li><a class="reference internal" href="../ref/models/fields#django.db.models.Field.help_text" title="django.db.models.Field.help_text"><code>help_text</code></a></li> <li><a class="reference internal" href="../ref/models/fields#django.db.models.Field.db_column" title="django.db.models.Field.db_column"><code>db_column</code></a></li> <li>
<a class="reference internal" href="../ref/models/fields#django.db.models.Field.db_tablespace" title="django.db.models.Field.db_tablespace"><code>db_tablespace</code></a>: Only for index creation, if the backend supports <a class="reference internal" href="../topics/db/tablespaces"><span class="doc">tablespaces</span></a>. You can usually ignore this option.</li> <li>
<a class="reference internal" href="../ref/models/fields#django.db.models.Field.auto_created" title="django.db.models.Field.auto_created"><code>auto_created</code></a>: <code>True</code> if the field was automatically created, as for the <a class="reference internal" href="../ref/models/fields#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code>OneToOneField</code></a> used by model inheritance. For advanced use only.</li> </ul> <p>All of the options without an explanation in the above list have the same meaning they do for normal Django fields. See the <a class="reference internal" href="../ref/models/fields"><span class="doc">field documentation</span></a> for examples and details.</p>  <h3 id="custom-field-deconstruct-method">Field deconstruction</h3> <p id="s-field-deconstruction">The counterpoint to writing your <code>__init__()</code> method is writing the <a class="reference internal" href="../ref/models/fields#django.db.models.Field.deconstruct" title="django.db.models.Field.deconstruct"><code>deconstruct()</code></a> method. It’s used during <a class="reference internal" href="../topics/migrations"><span class="doc">model migrations</span></a> to tell Django how to take an instance of your new field and reduce it to a serialized form - in particular, what arguments to pass to <code>__init__()</code> to re-create it.</p> <p>If you haven’t added any extra options on top of the field you inherited from, then there’s no need to write a new <code>deconstruct()</code> method. If, however, you’re changing the arguments passed in <code>__init__()</code> (like we are in <code>HandField</code>), you’ll need to supplement the values being passed.</p> <p><code>deconstruct()</code> returns a tuple of four items: the field’s attribute name, the full import path of the field class, the positional arguments (as a list), and the keyword arguments (as a dict). Note this is different from the <code>deconstruct()</code> method <a class="reference internal" href="../topics/migrations#custom-deconstruct-method"><span class="std std-ref">for custom classes</span></a> which returns a tuple of three things.</p> <p>As a custom field author, you don’t need to care about the first two values; the base <code>Field</code> class has all the code to work out the field’s attribute name and import path. You do, however, have to care about the positional and keyword arguments, as these are likely the things you are changing.</p> <p>For example, in our <code>HandField</code> class we’re always forcibly setting max_length in <code>__init__()</code>. The <code>deconstruct()</code> method on the base <code>Field</code> class will see this and try to return it in the keyword arguments; thus, we can drop it from the keyword arguments for readability:</p> <pre data-language="python">from django.db import models

class HandField(models.Field):

    def __init__(self, *args, **kwargs):
        kwargs['max_length'] = 104
        super().__init__(*args, **kwargs)

    def deconstruct(self):
        name, path, args, kwargs = super().deconstruct()
        del kwargs["max_length"]
        return name, path, args, kwargs
</pre> <p>If you add a new keyword argument, you need to write code in <code>deconstruct()</code> that puts its value into <code>kwargs</code> yourself. You should also omit the value from <code>kwargs</code> when it isn’t necessary to reconstruct the state of the field, such as when the default value is being used:</p> <pre data-language="python">from django.db import models

class CommaSepField(models.Field):
    "Implements comma-separated storage of lists"

    def __init__(self, separator=",", *args, **kwargs):
        self.separator = separator
        super().__init__(*args, **kwargs)

    def deconstruct(self):
        name, path, args, kwargs = super().deconstruct()
        # Only include kwarg if it's not the default
        if self.separator != ",":
            kwargs['separator'] = self.separator
        return name, path, args, kwargs
</pre> <p>More complex examples are beyond the scope of this document, but remember - for any configuration of your Field instance, <code>deconstruct()</code> must return arguments that you can pass to <code>__init__</code> to reconstruct that state.</p> <p>Pay extra attention if you set new default values for arguments in the <code>Field</code> superclass; you want to make sure they’re always included, rather than disappearing if they take on the old default value.</p> <p>In addition, try to avoid returning values as positional arguments; where possible, return values as keyword arguments for maximum future compatibility. If you change the names of things more often than their position in the constructor’s argument list, you might prefer positional, but bear in mind that people will be reconstructing your field from the serialized version for quite a while (possibly years), depending how long your migrations live for.</p> <p>You can see the results of deconstruction by looking in migrations that include the field, and you can test deconstruction in unit tests by deconstructing and reconstructing the field:</p> <pre data-language="python">name, path, args, kwargs = my_field_instance.deconstruct()
new_instance = MyField(*args, **kwargs)
self.assertEqual(my_field_instance.some_attribute, new_instance.some_attribute)
</pre>   <h3 id="changing-a-custom-field-s-base-class">Changing a custom field’s base class</h3> <p id="s-changing-a-custom-field-s-base-class">You can’t change the base class of a custom field because Django won’t detect the change and make a migration for it. For example, if you start with:</p> <pre data-language="python">class CustomCharField(models.CharField):
    ...
</pre> <p>and then decide that you want to use <code>TextField</code> instead, you can’t change the subclass like this:</p> <pre data-language="python">class CustomCharField(models.TextField):
    ...
</pre> <p>Instead, you must create a new custom field class and update your models to reference it:</p> <pre data-language="python">class CustomCharField(models.CharField):
    ...

class CustomTextField(models.TextField):
    ...
</pre> <p>As discussed in <a class="reference internal" href="../topics/migrations#migrations-removing-model-fields"><span class="std std-ref">removing fields</span></a>, you must retain the original <code>CustomCharField</code> class as long as you have migrations that reference it.</p>   <h3 id="documenting-your-custom-field">Documenting your custom field</h3> <p id="s-documenting-your-custom-field">As always, you should document your field type, so users will know what it is. In addition to providing a docstring for it, which is useful for developers, you can also allow users of the admin app to see a short description of the field type via the <a class="reference internal" href="../ref/contrib/admin/admindocs"><span class="doc">django.contrib.admindocs</span></a> application. To do this provide descriptive text in a <a class="reference internal" href="../ref/models/fields#django.db.models.Field.description" title="django.db.models.Field.description"><code>description</code></a> class attribute of your custom field. In the above example, the description displayed by the <code>admindocs</code> application for a <code>HandField</code> will be ‘A hand of cards (bridge style)’.</p> <p>In the <a class="reference internal" href="../ref/contrib/admin/admindocs#module-django.contrib.admindocs" title="django.contrib.admindocs: Django's admin documentation generator."><code>django.contrib.admindocs</code></a> display, the field description is interpolated with <code>field.__dict__</code> which allows the description to incorporate arguments of the field. For example, the description for <a class="reference internal" href="../ref/models/fields#django.db.models.CharField" title="django.db.models.CharField"><code>CharField</code></a> is:</p> <pre data-language="python">description = _("String (up to %(max_length)s)")
</pre>   <h3 id="useful-methods">Useful methods</h3> <p id="s-useful-methods">Once you’ve created your <a class="reference internal" href="../ref/models/fields#django.db.models.Field" title="django.db.models.Field"><code>Field</code></a> subclass, you might consider overriding a few standard methods, depending on your field’s behavior. The list of methods below is in approximately decreasing order of importance, so start from the top.</p>  <h4 id="id1">Custom database types</h4> <p id="s-custom-database-types">Say you’ve created a PostgreSQL custom type called <code>mytype</code>. You can subclass <code>Field</code> and implement the <a class="reference internal" href="../ref/models/fields#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code>db_type()</code></a> method, like so:</p> <pre data-language="python">from django.db import models

class MytypeField(models.Field):
    def db_type(self, connection):
        return 'mytype'
</pre> <p>Once you have <code>MytypeField</code>, you can use it in any model, just like any other <code>Field</code> type:</p> <pre data-language="python">class Person(models.Model):
    name = models.CharField(max_length=80)
    something_else = MytypeField()
</pre> <p>If you aim to build a database-agnostic application, you should account for differences in database column types. For example, the date/time column type in PostgreSQL is called <code>timestamp</code>, while the same column in MySQL is called <code>datetime</code>. You can handle this in a <a class="reference internal" href="../ref/models/fields#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code>db_type()</code></a> method by checking the <code>connection.vendor</code> attribute. Current built-in vendor names are: <code>sqlite</code>, <code>postgresql</code>, <code>mysql</code>, and <code>oracle</code>.</p> <p>For example:</p> <pre data-language="python">class MyDateField(models.Field):
    def db_type(self, connection):
        if connection.vendor == 'mysql':
            return 'datetime'
        else:
            return 'timestamp'
</pre> <p>The <a class="reference internal" href="../ref/models/fields#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code>db_type()</code></a> and <a class="reference internal" href="../ref/models/fields#django.db.models.Field.rel_db_type" title="django.db.models.Field.rel_db_type"><code>rel_db_type()</code></a> methods are called by Django when the framework constructs the <code>CREATE TABLE</code> statements for your application – that is, when you first create your tables. The methods are also called when constructing a <code>WHERE</code> clause that includes the model field – that is, when you retrieve data using QuerySet methods like <code>get()</code>, <code>filter()</code>, and <code>exclude()</code> and have the model field as an argument. They are not called at any other time, so it can afford to execute slightly complex code, such as the <code>connection.settings_dict</code> check in the above example.</p> <p>Some database column types accept parameters, such as <code>CHAR(25)</code>, where the parameter <code>25</code> represents the maximum column length. In cases like these, it’s more flexible if the parameter is specified in the model rather than being hard-coded in the <code>db_type()</code> method. For example, it wouldn’t make much sense to have a <code>CharMaxlength25Field</code>, shown here:</p> <pre data-language="python"># This is a silly example of hard-coded parameters.
class CharMaxlength25Field(models.Field):
    def db_type(self, connection):
        return 'char(25)'

# In the model:
class MyModel(models.Model):
    # ...
    my_field = CharMaxlength25Field()
</pre> <p>The better way of doing this would be to make the parameter specifiable at run time – i.e., when the class is instantiated. To do that, implement <code>Field.__init__()</code>, like so:</p> <pre data-language="python"># This is a much more flexible example.
class BetterCharField(models.Field):
    def __init__(self, max_length, *args, **kwargs):
        self.max_length = max_length
        super().__init__(*args, **kwargs)

    def db_type(self, connection):
        return 'char(%s)' % self.max_length

# In the model:
class MyModel(models.Model):
    # ...
    my_field = BetterCharField(25)
</pre> <p>Finally, if your column requires truly complex SQL setup, return <code>None</code> from <a class="reference internal" href="../ref/models/fields#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code>db_type()</code></a>. This will cause Django’s SQL creation code to skip over this field. You are then responsible for creating the column in the right table in some other way, but this gives you a way to tell Django to get out of the way.</p> <p>The <a class="reference internal" href="../ref/models/fields#django.db.models.Field.rel_db_type" title="django.db.models.Field.rel_db_type"><code>rel_db_type()</code></a> method is called by fields such as <code>ForeignKey</code> and <code>OneToOneField</code> that point to another field to determine their database column data types. For example, if you have an <code>UnsignedAutoField</code>, you also need the foreign keys that point to that field to use the same data type:</p> <pre data-language="python"># MySQL unsigned integer (range 0 to 4294967295).
class UnsignedAutoField(models.AutoField):
    def db_type(self, connection):
        return 'integer UNSIGNED AUTO_INCREMENT'

    def rel_db_type(self, connection):
        return 'integer UNSIGNED'
</pre>   <h4 id="id2">Converting values to Python objects</h4> <p id="s-converting-values-to-python-objects">If your custom <a class="reference internal" href="../ref/models/fields#django.db.models.Field" title="django.db.models.Field"><code>Field</code></a> class deals with data structures that are more complex than strings, dates, integers, or floats, then you may need to override <a class="reference internal" href="../ref/models/fields#django.db.models.Field.from_db_value" title="django.db.models.Field.from_db_value"><code>from_db_value()</code></a> and <a class="reference internal" href="../ref/models/fields#django.db.models.Field.to_python" title="django.db.models.Field.to_python"><code>to_python()</code></a>.</p> <p>If present for the field subclass, <code>from_db_value()</code> will be called in all circumstances when the data is loaded from the database, including in aggregates and <a class="reference internal" href="../ref/models/querysets#django.db.models.query.QuerySet.values" title="django.db.models.query.QuerySet.values"><code>values()</code></a> calls.</p> <p><code>to_python()</code> is called by deserialization and during the <a class="reference internal" href="../ref/models/instances#django.db.models.Model.clean" title="django.db.models.Model.clean"><code>clean()</code></a> method used from forms.</p> <p>As a general rule, <code>to_python()</code> should deal gracefully with any of the following arguments:</p> <ul class="simple"> <li>An instance of the correct type (e.g., <code>Hand</code> in our ongoing example).</li> <li>A string</li> <li>
<code>None</code> (if the field allows <code>null=True</code>)</li> </ul> <p>In our <code>HandField</code> class, we’re storing the data as a VARCHAR field in the database, so we need to be able to process strings and <code>None</code> in the <code>from_db_value()</code>. In <code>to_python()</code>, we need to also handle <code>Hand</code> instances:</p> <pre data-language="python">import re

from django.core.exceptions import ValidationError
from django.db import models
from django.utils.translation import gettext_lazy as _

def parse_hand(hand_string):
    """Takes a string of cards and splits into a full hand."""
    p1 = re.compile('.{26}')
    p2 = re.compile('..')
    args = [p2.findall(x) for x in p1.findall(hand_string)]
    if len(args) != 4:
        raise ValidationError(_("Invalid input for a Hand instance"))
    return Hand(*args)

class HandField(models.Field):
    # ...

    def from_db_value(self, value, expression, connection):
        if value is None:
            return value
        return parse_hand(value)

    def to_python(self, value):
        if isinstance(value, Hand):
            return value

        if value is None:
            return value

        return parse_hand(value)
</pre> <p>Notice that we always return a <code>Hand</code> instance from these methods. That’s the Python object type we want to store in the model’s attribute.</p> <p>For <code>to_python()</code>, if anything goes wrong during value conversion, you should raise a <a class="reference internal" href="../ref/exceptions#django.core.exceptions.ValidationError" title="django.core.exceptions.ValidationError"><code>ValidationError</code></a> exception.</p>   <h4 id="id3">Converting Python objects to query values</h4> <p id="s-converting-python-objects-to-query-values">Since using a database requires conversion in both ways, if you override <a class="reference internal" href="../ref/models/fields#django.db.models.Field.from_db_value" title="django.db.models.Field.from_db_value"><code>from_db_value()</code></a> you also have to override <a class="reference internal" href="../ref/models/fields#django.db.models.Field.get_prep_value" title="django.db.models.Field.get_prep_value"><code>get_prep_value()</code></a> to convert Python objects back to query values.</p> <p>For example:</p> <pre data-language="python">class HandField(models.Field):
    # ...

    def get_prep_value(self, value):
        return ''.join([''.join(l) for l in (value.north,
                value.east, value.south, value.west)])
</pre> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">If your custom field uses the <code>CHAR</code>, <code>VARCHAR</code> or <code>TEXT</code> types for MySQL, you must make sure that <a class="reference internal" href="../ref/models/fields#django.db.models.Field.get_prep_value" title="django.db.models.Field.get_prep_value"><code>get_prep_value()</code></a> always returns a string type. MySQL performs flexible and unexpected matching when a query is performed on these types and the provided value is an integer, which can cause queries to include unexpected objects in their results. This problem cannot occur if you always return a string type from <a class="reference internal" href="../ref/models/fields#django.db.models.Field.get_prep_value" title="django.db.models.Field.get_prep_value"><code>get_prep_value()</code></a>.</p> </div>   <h4 id="id4">Converting query values to database values</h4> <p id="s-converting-query-values-to-database-values">Some data types (for example, dates) need to be in a specific format before they can be used by a database backend. <a class="reference internal" href="../ref/models/fields#django.db.models.Field.get_db_prep_value" title="django.db.models.Field.get_db_prep_value"><code>get_db_prep_value()</code></a> is the method where those conversions should be made. The specific connection that will be used for the query is passed as the <code>connection</code> parameter. This allows you to use backend-specific conversion logic if it is required.</p> <p>For example, Django uses the following method for its <a class="reference internal" href="../ref/models/fields#django.db.models.BinaryField" title="django.db.models.BinaryField"><code>BinaryField</code></a>:</p> <pre data-language="python">def get_db_prep_value(self, value, connection, prepared=False):
    value = super().get_db_prep_value(value, connection, prepared)
    if value is not None:
        return connection.Database.Binary(value)
    return value
</pre> <p>In case your custom field needs a special conversion when being saved that is not the same as the conversion used for normal query parameters, you can override <a class="reference internal" href="../ref/models/fields#django.db.models.Field.get_db_prep_save" title="django.db.models.Field.get_db_prep_save"><code>get_db_prep_save()</code></a>.</p>   <h4 id="id5">Preprocessing values before saving</h4> <p id="s-preprocessing-values-before-saving">If you want to preprocess the value just before saving, you can use <a class="reference internal" href="../ref/models/fields#django.db.models.Field.pre_save" title="django.db.models.Field.pre_save"><code>pre_save()</code></a>. For example, Django’s <a class="reference internal" href="../ref/models/fields#django.db.models.DateTimeField" title="django.db.models.DateTimeField"><code>DateTimeField</code></a> uses this method to set the attribute correctly in the case of <a class="reference internal" href="../ref/models/fields#django.db.models.DateField.auto_now" title="django.db.models.DateField.auto_now"><code>auto_now</code></a> or <a class="reference internal" href="../ref/models/fields#django.db.models.DateField.auto_now_add" title="django.db.models.DateField.auto_now_add"><code>auto_now_add</code></a>.</p> <p>If you do override this method, you must return the value of the attribute at the end. You should also update the model’s attribute if you make any changes to the value so that code holding references to the model will always see the correct value.</p>   <h4 id="specifying-form-field-for-model-field">Specifying the form field for a model field</h4> <p id="s-specifying-the-form-field-for-a-model-field">To customize the form field used by <a class="reference internal" href="../topics/forms/modelforms#django.forms.ModelForm" title="django.forms.ModelForm"><code>ModelForm</code></a>, you can override <a class="reference internal" href="../ref/models/fields#django.db.models.Field.formfield" title="django.db.models.Field.formfield"><code>formfield()</code></a>.</p> <p>The form field class can be specified via the <code>form_class</code> and <code>choices_form_class</code> arguments; the latter is used if the field has choices specified, the former otherwise. If these arguments are not provided, <a class="reference internal" href="../ref/forms/fields#django.forms.CharField" title="django.forms.CharField"><code>CharField</code></a> or <a class="reference internal" href="../ref/forms/fields#django.forms.TypedChoiceField" title="django.forms.TypedChoiceField"><code>TypedChoiceField</code></a> will be used.</p> <p>All of the <code>kwargs</code> dictionary is passed directly to the form field’s <code>__init__()</code> method. Normally, all you need to do is set up a good default for the <code>form_class</code> (and maybe <code>choices_form_class</code>) argument and then delegate further handling to the parent class. This might require you to write a custom form field (and even a form widget). See the <a class="reference internal" href="../topics/forms/index"><span class="doc">forms documentation</span></a> for information about this.</p> <p>Continuing our ongoing example, we can write the <a class="reference internal" href="../ref/models/fields#django.db.models.Field.formfield" title="django.db.models.Field.formfield"><code>formfield()</code></a> method as:</p> <pre data-language="python">class HandField(models.Field):
    # ...

    def formfield(self, **kwargs):
        # This is a fairly standard way to set up some defaults
        # while letting the caller override them.
        defaults = {'form_class': MyFormField}
        defaults.update(kwargs)
        return super().formfield(**defaults)
</pre> <p>This assumes we’ve imported a <code>MyFormField</code> field class (which has its own default widget). This document doesn’t cover the details of writing custom form fields.</p>   <h4 id="id6">Emulating built-in field types</h4> <p id="s-emulating-built-in-field-types">If you have created a <a class="reference internal" href="../ref/models/fields#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code>db_type()</code></a> method, you don’t need to worry about <a class="reference internal" href="../ref/models/fields#django.db.models.Field.get_internal_type" title="django.db.models.Field.get_internal_type"><code>get_internal_type()</code></a> – it won’t be used much. Sometimes, though, your database storage is similar in type to some other field, so you can use that other field’s logic to create the right column.</p> <p>For example:</p> <pre data-language="python">class HandField(models.Field):
    # ...

    def get_internal_type(self):
        return 'CharField'
</pre> <p>No matter which database backend we are using, this will mean that <a class="reference internal" href="../ref/django-admin#django-admin-migrate"><code>migrate</code></a> and other SQL commands create the right column type for storing a string.</p> <p>If <a class="reference internal" href="../ref/models/fields#django.db.models.Field.get_internal_type" title="django.db.models.Field.get_internal_type"><code>get_internal_type()</code></a> returns a string that is not known to Django for the database backend you are using – that is, it doesn’t appear in <code>django.db.backends.&lt;db_name&gt;.base.DatabaseWrapper.data_types</code> – the string will still be used by the serializer, but the default <a class="reference internal" href="../ref/models/fields#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code>db_type()</code></a> method will return <code>None</code>. See the documentation of <a class="reference internal" href="../ref/models/fields#django.db.models.Field.db_type" title="django.db.models.Field.db_type"><code>db_type()</code></a> for reasons why this might be useful. Putting a descriptive string in as the type of the field for the serializer is a useful idea if you’re ever going to be using the serializer output in some other place, outside of Django.</p>   <h4 id="converting-model-field-to-serialization">Converting field data for serialization</h4> <p id="s-converting-field-data-for-serialization">To customize how the values are serialized by a serializer, you can override <a class="reference internal" href="../ref/models/fields#django.db.models.Field.value_to_string" title="django.db.models.Field.value_to_string"><code>value_to_string()</code></a>. Using <a class="reference internal" href="../ref/models/fields#django.db.models.Field.value_from_object" title="django.db.models.Field.value_from_object"><code>value_from_object()</code></a> is the best way to get the field’s value prior to serialization. For example, since <code>HandField</code> uses strings for its data storage anyway, we can reuse some existing conversion code:</p> <pre data-language="python">class HandField(models.Field):
    # ...

    def value_to_string(self, obj):
        value = self.value_from_object(obj)
        return self.get_prep_value(value)
</pre>    <h3 id="some-general-advice">Some general advice</h3> <p id="s-some-general-advice">Writing a custom field can be a tricky process, particularly if you’re doing complex conversions between your Python types and your database and serialization formats. Here are a couple of tips to make things go more smoothly:</p> <ol class="arabic simple"> <li>Look at the existing Django fields (in <code>django/db/models/fields/__init__.py</code>) for inspiration. Try to find a field that’s similar to what you want and extend it a little bit, instead of creating an entirely new field from scratch.</li> <li>Put a <code>__str__()</code> method on the class you’re wrapping up as a field. There are a lot of places where the default behavior of the field code is to call <code>str()</code> on the value. (In our examples in this document, <code>value</code> would be a <code>Hand</code> instance, not a <code>HandField</code>). So if your <code>__str__()</code> method automatically converts to the string form of your Python object, you can save yourself a lot of work.</li> </ol>    <h2 id="writing-a-filefield-subclass">Writing a <code>FileField</code> subclass</h2> <p id="s-writing-a-filefield-subclass">In addition to the above methods, fields that deal with files have a few other special requirements which must be taken into account. The majority of the mechanics provided by <code>FileField</code>, such as controlling database storage and retrieval, can remain unchanged, leaving subclasses to deal with the challenge of supporting a particular type of file.</p> <p>Django provides a <code>File</code> class, which is used as a proxy to the file’s contents and operations. This can be subclassed to customize how the file is accessed, and what methods are available. It lives at <code>django.db.models.fields.files</code>, and its default behavior is explained in the <a class="reference internal" href="../ref/files/file"><span class="doc">file documentation</span></a>.</p> <p>Once a subclass of <code>File</code> is created, the new <code>FileField</code> subclass must be told to use it. To do so, assign the new <code>File</code> subclass to the special <code>attr_class</code> attribute of the <code>FileField</code> subclass.</p>  <h3 id="a-few-suggestions">A few suggestions</h3> <p id="s-a-few-suggestions">In addition to the above details, there are a few guidelines which can greatly improve the efficiency and readability of the field’s code.</p> <ol class="arabic simple"> <li>The source for Django’s own <code>ImageField</code> (in <code>django/db/models/fields/files.py</code>) is a great example of how to subclass <code>FileField</code> to support a particular type of file, as it incorporates all of the techniques described above.</li> <li>Cache file attributes wherever possible. Since files may be stored in remote storage systems, retrieving them may cost extra time, or even money, that isn’t always necessary. Once a file is retrieved to obtain some data about its content, cache as much of that data as possible to reduce the number of times the file must be retrieved on subsequent calls for that information.</li> </ol><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/4.0/howto/custom-model-fields/" class="_attribution-link">https://docs.djangoproject.com/en/4.0/howto/custom-model-fields/</a>
  </p>
</div>
