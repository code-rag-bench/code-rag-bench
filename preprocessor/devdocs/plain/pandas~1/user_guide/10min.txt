# 10 minutes to pandas

This is a short introduction to pandas, geared mainly for new users. You can
see more complex recipes in the Cookbook.

Customarily, we import as follows:

    
    In [1]: import numpy as np
    
    In [2]: import pandas as pd
    
## Object creation

See the Intro to data structures section.

Creating a `Series` by passing a list of values, letting pandas create a
default integer index:

    
    In [3]: s = pd.Series([1, 3, 5, np.nan, 6, 8])
    
    In [4]: s
    Out[4]: 
    0    1.0
    1    3.0
    2    5.0
    3    NaN
    4    6.0
    5    8.0
    dtype: float64
    
Creating a `DataFrame` by passing a NumPy array, with a datetime index and
labeled columns:

    
    In [5]: dates = pd.date_range("20130101", periods=6)
    
    In [6]: dates
    Out[6]: 
    DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',
                   '2013-01-05', '2013-01-06'],
                  dtype='datetime64[ns]', freq='D')
    
    In [7]: df = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=list("ABCD"))
    
    In [8]: df
    Out[8]: 
                       A         B         C         D
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401
    2013-01-06 -0.673690  0.113648 -1.478427  0.524988
    
Creating a `DataFrame` by passing a dictionary of objects that can be
converted into a series-like structure:

    
    In [9]: df2 = pd.DataFrame(
       ...:     {
       ...:         "A": 1.0,
       ...:         "B": pd.Timestamp("20130102"),
       ...:         "C": pd.Series(1, index=list(range(4)), dtype="float32"),
       ...:         "D": np.array([3] * 4, dtype="int32"),
       ...:         "E": pd.Categorical(["test", "train", "test", "train"]),
       ...:         "F": "foo",
       ...:     }
       ...: )
       ...: 
    
    In [10]: df2
    Out[10]: 
         A          B    C  D      E    F
    0  1.0 2013-01-02  1.0  3   test  foo
    1  1.0 2013-01-02  1.0  3  train  foo
    2  1.0 2013-01-02  1.0  3   test  foo
    3  1.0 2013-01-02  1.0  3  train  foo
    
The columns of the resulting `DataFrame` have different dtypes:

    
    In [11]: df2.dtypes
    Out[11]: 
    A           float64
    B    datetime64[ns]
    C           float32
    D             int32
    E          category
    F            object
    dtype: object
    
If you’re using IPython, tab completion for column names (as well as public
attributes) is automatically enabled. Here’s a subset of the attributes that
will be completed:

    
    In [12]: df2.<TAB>  # noqa: E225, E999
    df2.A                  df2.bool
    df2.abs                df2.boxplot
    df2.add                df2.C
    df2.add_prefix         df2.clip
    df2.add_suffix         df2.columns
    df2.align              df2.copy
    df2.all                df2.count
    df2.any                df2.combine
    df2.append             df2.D
    df2.apply              df2.describe
    df2.applymap           df2.diff
    df2.B                  df2.duplicated
    
As you can see, the columns `A`, `B`, `C`, and `D` are automatically tab
completed. `E` and `F` are there as well; the rest of the attributes have been
truncated for brevity.

## Viewing data

See the Basics section.

Here is how to view the top and bottom rows of the frame:

    
    In [13]: df.head()
    Out[13]: 
                       A         B         C         D
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401
    
    In [14]: df.tail(3)
    Out[14]: 
                       A         B         C         D
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401
    2013-01-06 -0.673690  0.113648 -1.478427  0.524988
    
Display the index, columns:

    
    In [15]: df.index
    Out[15]: 
    DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',
                   '2013-01-05', '2013-01-06'],
                  dtype='datetime64[ns]', freq='D')
    
    In [16]: df.columns
    Out[16]: Index(['A', 'B', 'C', 'D'], dtype='object')
    
`DataFrame.to_numpy()` gives a NumPy representation of the underlying data.
Note that this can be an expensive operation when your `DataFrame` has columns
with different data types, which comes down to a fundamental difference
between pandas and NumPy: NumPy arrays have one dtype for the entire array,
while pandas DataFrames have one dtype per column. When you call
`DataFrame.to_numpy()`, pandas will find the NumPy dtype that can hold all of
the dtypes in the DataFrame. This may end up being `object`, which requires
casting every value to a Python object.

For `df`, our `DataFrame` of all floating-point values, `DataFrame.to_numpy()`
is fast and doesn’t require copying data:

    
    In [17]: df.to_numpy()
    Out[17]: 
    array([[ 0.4691, -0.2829, -1.5091, -1.1356],
           [ 1.2121, -0.1732,  0.1192, -1.0442],
           [-0.8618, -2.1046, -0.4949,  1.0718],
           [ 0.7216, -0.7068, -1.0396,  0.2719],
           [-0.425 ,  0.567 ,  0.2762, -1.0874],
           [-0.6737,  0.1136, -1.4784,  0.525 ]])
    
For `df2`, the `DataFrame` with multiple dtypes, `DataFrame.to_numpy()` is
relatively expensive:

    
    In [18]: df2.to_numpy()
    Out[18]: 
    array([[1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],
           [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo'],
           [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],
           [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo']],
          dtype=object)
    
Note

`DataFrame.to_numpy()` does not include the index or column labels in the
output.

`describe()` shows a quick statistic summary of your data:

    
    In [19]: df.describe()
    Out[19]: 
                  A         B         C         D
    count  6.000000  6.000000  6.000000  6.000000
    mean   0.073711 -0.431125 -0.687758 -0.233103
    std    0.843157  0.922818  0.779887  0.973118
    min   -0.861849 -2.104569 -1.509059 -1.135632
    25%   -0.611510 -0.600794 -1.368714 -1.076610
    50%    0.022070 -0.228039 -0.767252 -0.386188
    75%    0.658444  0.041933 -0.034326  0.461706
    max    1.212112  0.567020  0.276232  1.071804
    
Transposing your data:

    
    In [20]: df.T
    Out[20]: 
       2013-01-01  2013-01-02  2013-01-03  2013-01-04  2013-01-05  2013-01-06
    A    0.469112    1.212112   -0.861849    0.721555   -0.424972   -0.673690
    B   -0.282863   -0.173215   -2.104569   -0.706771    0.567020    0.113648
    C   -1.509059    0.119209   -0.494929   -1.039575    0.276232   -1.478427
    D   -1.135632   -1.044236    1.071804    0.271860   -1.087401    0.524988
    
Sorting by an axis:

    
    In [21]: df.sort_index(axis=1, ascending=False)
    Out[21]: 
                       D         C         B         A
    2013-01-01 -1.135632 -1.509059 -0.282863  0.469112
    2013-01-02 -1.044236  0.119209 -0.173215  1.212112
    2013-01-03  1.071804 -0.494929 -2.104569 -0.861849
    2013-01-04  0.271860 -1.039575 -0.706771  0.721555
    2013-01-05 -1.087401  0.276232  0.567020 -0.424972
    2013-01-06  0.524988 -1.478427  0.113648 -0.673690
    
Sorting by values:

    
    In [22]: df.sort_values(by="B")
    Out[22]: 
                       A         B         C         D
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-06 -0.673690  0.113648 -1.478427  0.524988
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401
    
## Selection

Note

While standard Python / NumPy expressions for selecting and setting are
intuitive and come in handy for interactive work, for production code, we
recommend the optimized pandas data access methods, `.at`, `.iat`, `.loc` and
`.iloc`.

See the indexing documentation Indexing and Selecting Data and MultiIndex /
Advanced Indexing.

### Getting

Selecting a single column, which yields a `Series`, equivalent to `df.A`:

    
    In [23]: df["A"]
    Out[23]: 
    2013-01-01    0.469112
    2013-01-02    1.212112
    2013-01-03   -0.861849
    2013-01-04    0.721555
    2013-01-05   -0.424972
    2013-01-06   -0.673690
    Freq: D, Name: A, dtype: float64
    
Selecting via `[]`, which slices the rows:

    
    In [24]: df[0:3]
    Out[24]: 
                       A         B         C         D
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
    
    In [25]: df["20130102":"20130104"]
    Out[25]: 
                       A         B         C         D
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860
    
### Selection by label

See more in Selection by Label.

For getting a cross section using a label:

    
    In [26]: df.loc[dates[0]]
    Out[26]: 
    A    0.469112
    B   -0.282863
    C   -1.509059
    D   -1.135632
    Name: 2013-01-01 00:00:00, dtype: float64
    
Selecting on a multi-axis by label:

    
    In [27]: df.loc[:, ["A", "B"]]
    Out[27]: 
                       A         B
    2013-01-01  0.469112 -0.282863
    2013-01-02  1.212112 -0.173215
    2013-01-03 -0.861849 -2.104569
    2013-01-04  0.721555 -0.706771
    2013-01-05 -0.424972  0.567020
    2013-01-06 -0.673690  0.113648
    
Showing label slicing, both endpoints are included:

    
    In [28]: df.loc["20130102":"20130104", ["A", "B"]]
    Out[28]: 
                       A         B
    2013-01-02  1.212112 -0.173215
    2013-01-03 -0.861849 -2.104569
    2013-01-04  0.721555 -0.706771
    
Reduction in the dimensions of the returned object:

    
    In [29]: df.loc["20130102", ["A", "B"]]
    Out[29]: 
    A    1.212112
    B   -0.173215
    Name: 2013-01-02 00:00:00, dtype: float64
    
For getting a scalar value:

    
    In [30]: df.loc[dates[0], "A"]
    Out[30]: 0.4691122999071863
    
For getting fast access to a scalar (equivalent to the prior method):

    
    In [31]: df.at[dates[0], "A"]
    Out[31]: 0.4691122999071863
    
### Selection by position

See more in Selection by Position.

Select via the position of the passed integers:

    
    In [32]: df.iloc[3]
    Out[32]: 
    A    0.721555
    B   -0.706771
    C   -1.039575
    D    0.271860
    Name: 2013-01-04 00:00:00, dtype: float64
    
By integer slices, acting similar to NumPy/Python:

    
    In [33]: df.iloc[3:5, 0:2]
    Out[33]: 
                       A         B
    2013-01-04  0.721555 -0.706771
    2013-01-05 -0.424972  0.567020
    
By lists of integer position locations, similar to the NumPy/Python style:

    
    In [34]: df.iloc[[1, 2, 4], [0, 2]]
    Out[34]: 
                       A         C
    2013-01-02  1.212112  0.119209
    2013-01-03 -0.861849 -0.494929
    2013-01-05 -0.424972  0.276232
    
For slicing rows explicitly:

    
    In [35]: df.iloc[1:3, :]
    Out[35]: 
                       A         B         C         D
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
    
For slicing columns explicitly:

    
    In [36]: df.iloc[:, 1:3]
    Out[36]: 
                       B         C
    2013-01-01 -0.282863 -1.509059
    2013-01-02 -0.173215  0.119209
    2013-01-03 -2.104569 -0.494929
    2013-01-04 -0.706771 -1.039575
    2013-01-05  0.567020  0.276232
    2013-01-06  0.113648 -1.478427
    
For getting a value explicitly:

    
    In [37]: df.iloc[1, 1]
    Out[37]: -0.17321464905330858
    
For getting fast access to a scalar (equivalent to the prior method):

    
    In [38]: df.iat[1, 1]
    Out[38]: -0.17321464905330858
    
### Boolean indexing

Using a single column’s values to select data:

    
    In [39]: df[df["A"] > 0]
    Out[39]: 
                       A         B         C         D
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860
    
Selecting values from a DataFrame where a boolean condition is met:

    
    In [40]: df[df > 0]
    Out[40]: 
                       A         B         C         D
    2013-01-01  0.469112       NaN       NaN       NaN
    2013-01-02  1.212112       NaN  0.119209       NaN
    2013-01-03       NaN       NaN       NaN  1.071804
    2013-01-04  0.721555       NaN       NaN  0.271860
    2013-01-05       NaN  0.567020  0.276232       NaN
    2013-01-06       NaN  0.113648       NaN  0.524988
    
Using the `isin()` method for filtering:

    
    In [41]: df2 = df.copy()
    
    In [42]: df2["E"] = ["one", "one", "two", "three", "four", "three"]
    
    In [43]: df2
    Out[43]: 
                       A         B         C         D      E
    2013-01-01  0.469112 -0.282863 -1.509059 -1.135632    one
    2013-01-02  1.212112 -0.173215  0.119209 -1.044236    one
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804    two
    2013-01-04  0.721555 -0.706771 -1.039575  0.271860  three
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401   four
    2013-01-06 -0.673690  0.113648 -1.478427  0.524988  three
    
    In [44]: df2[df2["E"].isin(["two", "four"])]
    Out[44]: 
                       A         B         C         D     E
    2013-01-03 -0.861849 -2.104569 -0.494929  1.071804   two
    2013-01-05 -0.424972  0.567020  0.276232 -1.087401  four
    
### Setting

Setting a new column automatically aligns the data by the indexes:

    
    In [45]: s1 = pd.Series([1, 2, 3, 4, 5, 6], index=pd.date_range("20130102", periods=6))
    
    In [46]: s1
    Out[46]: 
    2013-01-02    1
    2013-01-03    2
    2013-01-04    3
    2013-01-05    4
    2013-01-06    5
    2013-01-07    6
    Freq: D, dtype: int64
    
    In [47]: df["F"] = s1
    
Setting values by label:

    
    In [48]: df.at[dates[0], "A"] = 0
    
Setting values by position:

    
    In [49]: df.iat[0, 1] = 0
    
Setting by assigning with a NumPy array:

    
    In [50]: df.loc[:, "D"] = np.array([5] * len(df))
    
The result of the prior setting operations:

    
    In [51]: df
    Out[51]: 
                       A         B         C  D    F
    2013-01-01  0.000000  0.000000 -1.509059  5  NaN
    2013-01-02  1.212112 -0.173215  0.119209  5  1.0
    2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0
    2013-01-04  0.721555 -0.706771 -1.039575  5  3.0
    2013-01-05 -0.424972  0.567020  0.276232  5  4.0
    2013-01-06 -0.673690  0.113648 -1.478427  5  5.0
    
A `where` operation with setting:

    
    In [52]: df2 = df.copy()
    
    In [53]: df2[df2 > 0] = -df2
    
    In [54]: df2
    Out[54]: 
                       A         B         C  D    F
    2013-01-01  0.000000  0.000000 -1.509059 -5  NaN
    2013-01-02 -1.212112 -0.173215 -0.119209 -5 -1.0
    2013-01-03 -0.861849 -2.104569 -0.494929 -5 -2.0
    2013-01-04 -0.721555 -0.706771 -1.039575 -5 -3.0
    2013-01-05 -0.424972 -0.567020 -0.276232 -5 -4.0
    2013-01-06 -0.673690 -0.113648 -1.478427 -5 -5.0
    
## Missing data

pandas primarily uses the value `np.nan` to represent missing data. It is by
default not included in computations. See the Missing Data section.

Reindexing allows you to change/add/delete the index on a specified axis. This
returns a copy of the data:

    
    In [55]: df1 = df.reindex(index=dates[0:4], columns=list(df.columns) + ["E"])
    
    In [56]: df1.loc[dates[0] : dates[1], "E"] = 1
    
    In [57]: df1
    Out[57]: 
                       A         B         C  D    F    E
    2013-01-01  0.000000  0.000000 -1.509059  5  NaN  1.0
    2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0
    2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0  NaN
    2013-01-04  0.721555 -0.706771 -1.039575  5  3.0  NaN
    
To drop any rows that have missing data:

    
    In [58]: df1.dropna(how="any")
    Out[58]: 
                       A         B         C  D    F    E
    2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0
    
Filling missing data:

    
    In [59]: df1.fillna(value=5)
    Out[59]: 
                       A         B         C  D    F    E
    2013-01-01  0.000000  0.000000 -1.509059  5  5.0  1.0
    2013-01-02  1.212112 -0.173215  0.119209  5  1.0  1.0
    2013-01-03 -0.861849 -2.104569 -0.494929  5  2.0  5.0
    2013-01-04  0.721555 -0.706771 -1.039575  5  3.0  5.0
    
To get the boolean mask where values are `nan`:

    
    In [60]: pd.isna(df1)
    Out[60]: 
                    A      B      C      D      F      E
    2013-01-01  False  False  False  False   True  False
    2013-01-02  False  False  False  False  False  False
    2013-01-03  False  False  False  False  False   True
    2013-01-04  False  False  False  False  False   True
    
## Operations

See the Basic section on Binary Ops.

### Stats

Operations in general exclude missing data.

Performing a descriptive statistic:

    
    In [61]: df.mean()
    Out[61]: 
    A   -0.004474
    B   -0.383981
    C   -0.687758
    D    5.000000
    F    3.000000
    dtype: float64
    
Same operation on the other axis:

    
    In [62]: df.mean(1)
    Out[62]: 
    2013-01-01    0.872735
    2013-01-02    1.431621
    2013-01-03    0.707731
    2013-01-04    1.395042
    2013-01-05    1.883656
    2013-01-06    1.592306
    Freq: D, dtype: float64
    
Operating with objects that have different dimensionality and need alignment.
In addition, pandas automatically broadcasts along the specified dimension:

    
    In [63]: s = pd.Series([1, 3, 5, np.nan, 6, 8], index=dates).shift(2)
    
    In [64]: s
    Out[64]: 
    2013-01-01    NaN
    2013-01-02    NaN
    2013-01-03    1.0
    2013-01-04    3.0
    2013-01-05    5.0
    2013-01-06    NaN
    Freq: D, dtype: float64
    
    In [65]: df.sub(s, axis="index")
    Out[65]: 
                       A         B         C    D    F
    2013-01-01       NaN       NaN       NaN  NaN  NaN
    2013-01-02       NaN       NaN       NaN  NaN  NaN
    2013-01-03 -1.861849 -3.104569 -1.494929  4.0  1.0
    2013-01-04 -2.278445 -3.706771 -4.039575  2.0  0.0
    2013-01-05 -5.424972 -4.432980 -4.723768  0.0 -1.0
    2013-01-06       NaN       NaN       NaN  NaN  NaN
    
### Apply

Applying functions to the data:

    
    In [66]: df.apply(np.cumsum)
    Out[66]: 
                       A         B         C   D     F
    2013-01-01  0.000000  0.000000 -1.509059   5   NaN
    2013-01-02  1.212112 -0.173215 -1.389850  10   1.0
    2013-01-03  0.350263 -2.277784 -1.884779  15   3.0
    2013-01-04  1.071818 -2.984555 -2.924354  20   6.0
    2013-01-05  0.646846 -2.417535 -2.648122  25  10.0
    2013-01-06 -0.026844 -2.303886 -4.126549  30  15.0
    
    In [67]: df.apply(lambda x: x.max() - x.min())
    Out[67]: 
    A    2.073961
    B    2.671590
    C    1.785291
    D    0.000000
    F    4.000000
    dtype: float64
    
### Histogramming

See more at Histogramming and Discretization.

    
    In [68]: s = pd.Series(np.random.randint(0, 7, size=10))
    
    In [69]: s
    Out[69]: 
    0    4
    1    2
    2    1
    3    2
    4    6
    5    4
    6    4
    7    6
    8    4
    9    4
    dtype: int64
    
    In [70]: s.value_counts()
    Out[70]: 
    4    5
    2    2
    6    2
    1    1
    dtype: int64
    
### String Methods

Series is equipped with a set of string processing methods in the `str`
attribute that make it easy to operate on each element of the array, as in the
code snippet below. Note that pattern-matching in `str` generally uses regular
expressions by default (and in some cases always uses them). See more at
Vectorized String Methods.

    
    In [71]: s = pd.Series(["A", "B", "C", "Aaba", "Baca", np.nan, "CABA", "dog", "cat"])
    
    In [72]: s.str.lower()
    Out[72]: 
    0       a
    1       b
    2       c
    3    aaba
    4    baca
    5     NaN
    6    caba
    7     dog
    8     cat
    dtype: object
    
## Merge

### Concat

pandas provides various facilities for easily combining together Series and
DataFrame objects with various kinds of set logic for the indexes and
relational algebra functionality in the case of join / merge-type operations.

See the Merging section.

Concatenating pandas objects together with `concat()`:

    
    In [73]: df = pd.DataFrame(np.random.randn(10, 4))
    
    In [74]: df
    Out[74]: 
              0         1         2         3
    0 -0.548702  1.467327 -1.015962 -0.483075
    1  1.637550 -1.217659 -0.291519 -1.745505
    2 -0.263952  0.991460 -0.919069  0.266046
    3 -0.709661  1.669052  1.037882 -1.705775
    4 -0.919854 -0.042379  1.247642 -0.009920
    5  0.290213  0.495767  0.362949  1.548106
    6 -1.131345 -0.089329  0.337863 -0.945867
    7 -0.932132  1.956030  0.017587 -0.016692
    8 -0.575247  0.254161 -1.143704  0.215897
    9  1.193555 -0.077118 -0.408530 -0.862495
    
    # break it into pieces
    In [75]: pieces = [df[:3], df[3:7], df[7:]]
    
    In [76]: pd.concat(pieces)
    Out[76]: 
              0         1         2         3
    0 -0.548702  1.467327 -1.015962 -0.483075
    1  1.637550 -1.217659 -0.291519 -1.745505
    2 -0.263952  0.991460 -0.919069  0.266046
    3 -0.709661  1.669052  1.037882 -1.705775
    4 -0.919854 -0.042379  1.247642 -0.009920
    5  0.290213  0.495767  0.362949  1.548106
    6 -1.131345 -0.089329  0.337863 -0.945867
    7 -0.932132  1.956030  0.017587 -0.016692
    8 -0.575247  0.254161 -1.143704  0.215897
    9  1.193555 -0.077118 -0.408530 -0.862495
    
Note

Adding a column to a `DataFrame` is relatively fast. However, adding a row
requires a copy, and may be expensive. We recommend passing a pre-built list
of records to the `DataFrame` constructor instead of building a `DataFrame` by
iteratively appending records to it.

### Join

SQL style merges. See the Database style joining section.

    
    In [77]: left = pd.DataFrame({"key": ["foo", "foo"], "lval": [1, 2]})
    
    In [78]: right = pd.DataFrame({"key": ["foo", "foo"], "rval": [4, 5]})
    
    In [79]: left
    Out[79]: 
       key  lval
    0  foo     1
    1  foo     2
    
    In [80]: right
    Out[80]: 
       key  rval
    0  foo     4
    1  foo     5
    
    In [81]: pd.merge(left, right, on="key")
    Out[81]: 
       key  lval  rval
    0  foo     1     4
    1  foo     1     5
    2  foo     2     4
    3  foo     2     5
    
Another example that can be given is:

    
    In [82]: left = pd.DataFrame({"key": ["foo", "bar"], "lval": [1, 2]})
    
    In [83]: right = pd.DataFrame({"key": ["foo", "bar"], "rval": [4, 5]})
    
    In [84]: left
    Out[84]: 
       key  lval
    0  foo     1
    1  bar     2
    
    In [85]: right
    Out[85]: 
       key  rval
    0  foo     4
    1  bar     5
    
    In [86]: pd.merge(left, right, on="key")
    Out[86]: 
       key  lval  rval
    0  foo     1     4
    1  bar     2     5
    
## Grouping

By “group by” we are referring to a process involving one or more of the
following steps:

>   * Splitting the data into groups based on some criteria
>   * Applying a function to each group independently
>   * Combining the results into a data structure
>

See the Grouping section.

    
    In [87]: df = pd.DataFrame(
       ....:     {
       ....:         "A": ["foo", "bar", "foo", "bar", "foo", "bar", "foo", "foo"],
       ....:         "B": ["one", "one", "two", "three", "two", "two", "one", "three"],
       ....:         "C": np.random.randn(8),
       ....:         "D": np.random.randn(8),
       ....:     }
       ....: )
       ....: 
    
    In [88]: df
    Out[88]: 
         A      B         C         D
    0  foo    one  1.346061 -1.577585
    1  bar    one  1.511763  0.396823
    2  foo    two  1.627081 -0.105381
    3  bar  three -0.990582 -0.532532
    4  foo    two -0.441652  1.453749
    5  bar    two  1.211526  1.208843
    6  foo    one  0.268520 -0.080952
    7  foo  three  0.024580 -0.264610
    
Grouping and then applying the `sum()` function to the resulting groups:

    
    In [89]: df.groupby("A").sum()
    Out[89]: 
                C         D
    A                      
    bar  1.732707  1.073134
    foo  2.824590 -0.574779
    
Grouping by multiple columns forms a hierarchical index, and again we can
apply the `sum()` function:

    
    In [90]: df.groupby(["A", "B"]).sum()
    Out[90]: 
                      C         D
    A   B                        
    bar one    1.511763  0.396823
        three -0.990582 -0.532532
        two    1.211526  1.208843
    foo one    1.614581 -1.658537
        three  0.024580 -0.264610
        two    1.185429  1.348368
    
## Reshaping

See the sections on Hierarchical Indexing and Reshaping.

### Stack

    
    In [91]: tuples = list(
       ....:     zip(
       ....:         *[
       ....:             ["bar", "bar", "baz", "baz", "foo", "foo", "qux", "qux"],
       ....:             ["one", "two", "one", "two", "one", "two", "one", "two"],
       ....:         ]
       ....:     )
       ....: )
       ....: 
    
    In [92]: index = pd.MultiIndex.from_tuples(tuples, names=["first", "second"])
    
    In [93]: df = pd.DataFrame(np.random.randn(8, 2), index=index, columns=["A", "B"])
    
    In [94]: df2 = df[:4]
    
    In [95]: df2
    Out[95]: 
                         A         B
    first second                    
    bar   one    -0.727965 -0.589346
          two     0.339969 -0.693205
    baz   one    -0.339355  0.593616
          two     0.884345  1.591431
    
The `stack()` method “compresses” a level in the DataFrame’s columns:

    
    In [96]: stacked = df2.stack()
    
    In [97]: stacked
    Out[97]: 
    first  second   
    bar    one     A   -0.727965
                   B   -0.589346
           two     A    0.339969
                   B   -0.693205
    baz    one     A   -0.339355
                   B    0.593616
           two     A    0.884345
                   B    1.591431
    dtype: float64
    
With a “stacked” DataFrame or Series (having a `MultiIndex` as the `index`),
the inverse operation of `stack()` is `unstack()`, which by default unstacks
the last level:

    
    In [98]: stacked.unstack()
    Out[98]: 
                         A         B
    first second                    
    bar   one    -0.727965 -0.589346
          two     0.339969 -0.693205
    baz   one    -0.339355  0.593616
          two     0.884345  1.591431
    
    In [99]: stacked.unstack(1)
    Out[99]: 
    second        one       two
    first                      
    bar   A -0.727965  0.339969
          B -0.589346 -0.693205
    baz   A -0.339355  0.884345
          B  0.593616  1.591431
    
    In [100]: stacked.unstack(0)
    Out[100]: 
    first          bar       baz
    second                      
    one    A -0.727965 -0.339355
           B -0.589346  0.593616
    two    A  0.339969  0.884345
           B -0.693205  1.591431
    
### Pivot tables

See the section on Pivot Tables.

    
    In [101]: df = pd.DataFrame(
       .....:     {
       .....:         "A": ["one", "one", "two", "three"] * 3,
       .....:         "B": ["A", "B", "C"] * 4,
       .....:         "C": ["foo", "foo", "foo", "bar", "bar", "bar"] * 2,
       .....:         "D": np.random.randn(12),
       .....:         "E": np.random.randn(12),
       .....:     }
       .....: )
       .....: 
    
    In [102]: df
    Out[102]: 
            A  B    C         D         E
    0     one  A  foo -1.202872  0.047609
    1     one  B  foo -1.814470 -0.136473
    2     two  C  foo  1.018601 -0.561757
    3   three  A  bar -0.595447 -1.623033
    4     one  B  bar  1.395433  0.029399
    5     one  C  bar -0.392670 -0.542108
    6     two  A  foo  0.007207  0.282696
    7   three  B  foo  1.928123 -0.087302
    8     one  C  foo -0.055224 -1.575170
    9     one  A  bar  2.395985  1.771208
    10    two  B  bar  1.552825  0.816482
    11  three  C  bar  0.166599  1.100230
    
We can produce pivot tables from this data very easily:

    
    In [103]: pd.pivot_table(df, values="D", index=["A", "B"], columns=["C"])
    Out[103]: 
    C             bar       foo
    A     B                    
    one   A  2.395985 -1.202872
          B  1.395433 -1.814470
          C -0.392670 -0.055224
    three A -0.595447       NaN
          B       NaN  1.928123
          C  0.166599       NaN
    two   A       NaN  0.007207
          B  1.552825       NaN
          C       NaN  1.018601
    
## Time series

pandas has simple, powerful, and efficient functionality for performing
resampling operations during frequency conversion (e.g., converting secondly
data into 5-minutely data). This is extremely common in, but not limited to,
financial applications. See the Time Series section.

    
    In [104]: rng = pd.date_range("1/1/2012", periods=100, freq="S")
    
    In [105]: ts = pd.Series(np.random.randint(0, 500, len(rng)), index=rng)
    
    In [106]: ts.resample("5Min").sum()
    Out[106]: 
    2012-01-01    24182
    Freq: 5T, dtype: int64
    
Time zone representation:

    
    In [107]: rng = pd.date_range("3/6/2012 00:00", periods=5, freq="D")
    
    In [108]: ts = pd.Series(np.random.randn(len(rng)), rng)
    
    In [109]: ts
    Out[109]: 
    2012-03-06    1.857704
    2012-03-07   -1.193545
    2012-03-08    0.677510
    2012-03-09   -0.153931
    2012-03-10    0.520091
    Freq: D, dtype: float64
    
    In [110]: ts_utc = ts.tz_localize("UTC")
    
    In [111]: ts_utc
    Out[111]: 
    2012-03-06 00:00:00+00:00    1.857704
    2012-03-07 00:00:00+00:00   -1.193545
    2012-03-08 00:00:00+00:00    0.677510
    2012-03-09 00:00:00+00:00   -0.153931
    2012-03-10 00:00:00+00:00    0.520091
    Freq: D, dtype: float64
    
Converting to another time zone:

    
    In [112]: ts_utc.tz_convert("US/Eastern")
    Out[112]: 
    2012-03-05 19:00:00-05:00    1.857704
    2012-03-06 19:00:00-05:00   -1.193545
    2012-03-07 19:00:00-05:00    0.677510
    2012-03-08 19:00:00-05:00   -0.153931
    2012-03-09 19:00:00-05:00    0.520091
    Freq: D, dtype: float64
    
Converting between time span representations:

    
    In [113]: rng = pd.date_range("1/1/2012", periods=5, freq="M")
    
    In [114]: ts = pd.Series(np.random.randn(len(rng)), index=rng)
    
    In [115]: ts
    Out[115]: 
    2012-01-31   -1.475051
    2012-02-29    0.722570
    2012-03-31   -0.322646
    2012-04-30   -1.601631
    2012-05-31    0.778033
    Freq: M, dtype: float64
    
    In [116]: ps = ts.to_period()
    
    In [117]: ps
    Out[117]: 
    2012-01   -1.475051
    2012-02    0.722570
    2012-03   -0.322646
    2012-04   -1.601631
    2012-05    0.778033
    Freq: M, dtype: float64
    
    In [118]: ps.to_timestamp()
    Out[118]: 
    2012-01-01   -1.475051
    2012-02-01    0.722570
    2012-03-01   -0.322646
    2012-04-01   -1.601631
    2012-05-01    0.778033
    Freq: MS, dtype: float64
    
Converting between period and timestamp enables some convenient arithmetic
functions to be used. In the following example, we convert a quarterly
frequency with year ending in November to 9am of the end of the month
following the quarter end:

    
    In [119]: prng = pd.period_range("1990Q1", "2000Q4", freq="Q-NOV")
    
    In [120]: ts = pd.Series(np.random.randn(len(prng)), prng)
    
    In [121]: ts.index = (prng.asfreq("M", "e") + 1).asfreq("H", "s") + 9
    
    In [122]: ts.head()
    Out[122]: 
    1990-03-01 09:00   -0.289342
    1990-06-01 09:00    0.233141
    1990-09-01 09:00   -0.223540
    1990-12-01 09:00    0.542054
    1991-03-01 09:00   -0.688585
    Freq: H, dtype: float64
    
## Categoricals

pandas can include categorical data in a `DataFrame`. For full docs, see the
categorical introduction and the API documentation.

    
    In [123]: df = pd.DataFrame(
       .....:     {"id": [1, 2, 3, 4, 5, 6], "raw_grade": ["a", "b", "b", "a", "a", "e"]}
       .....: )
       .....: 
    
Converting the raw grades to a categorical data type:

    
    In [124]: df["grade"] = df["raw_grade"].astype("category")
    
    In [125]: df["grade"]
    Out[125]: 
    0    a
    1    b
    2    b
    3    a
    4    a
    5    e
    Name: grade, dtype: category
    Categories (3, object): ['a', 'b', 'e']
    
Rename the categories to more meaningful names (assigning to
`Series.cat.categories()` is in place!):

    
    In [126]: df["grade"].cat.categories = ["very good", "good", "very bad"]
    
Reorder the categories and simultaneously add the missing categories (methods
under `Series.cat()` return a new `Series` by default):

    
    In [127]: df["grade"] = df["grade"].cat.set_categories(
       .....:     ["very bad", "bad", "medium", "good", "very good"]
       .....: )
       .....: 
    
    In [128]: df["grade"]
    Out[128]: 
    0    very good
    1         good
    2         good
    3    very good
    4    very good
    5     very bad
    Name: grade, dtype: category
    Categories (5, object): ['very bad', 'bad', 'medium', 'good', 'very good']
    
Sorting is per order in the categories, not lexical order:

    
    In [129]: df.sort_values(by="grade")
    Out[129]: 
       id raw_grade      grade
    5   6         e   very bad
    1   2         b       good
    2   3         b       good
    0   1         a  very good
    3   4         a  very good
    4   5         a  very good
    
Grouping by a categorical column also shows empty categories:

    
    In [130]: df.groupby("grade").size()
    Out[130]: 
    grade
    very bad     1
    bad          0
    medium       0
    good         2
    very good    3
    dtype: int64
    
## Plotting

See the Plotting docs.

We use the standard convention for referencing the matplotlib API:

    
    In [131]: import matplotlib.pyplot as plt
    
    In [132]: plt.close("all")
    
The `close()` method is used to close a figure window:

    
    In [133]: ts = pd.Series(np.random.randn(1000), index=pd.date_range("1/1/2000", periods=1000))
    
    In [134]: ts = ts.cumsum()
    
    In [135]: ts.plot();
    
![../_images/series_plot_basic.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAHgCAMAAAACDyzWAAAACXBIWXMAAA9hAAAPYQGoP6dpAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjUuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/YYfK9AAAA21BMVEX///+Cs9U0g7vo8ff+/v73+fv7/f4fd7Tx8fEAAADT5PDb6fOszOOLuNilyOGz0eYnfLfi7fVBi7/x9/pVl8aexN5OlMTG3OySvNoHBwfN4e5qpc251egcHBw6iL0iebV2rNFbnMhwqM/X19dHj8ItgLnA2ep7r9Pj4+MnJycQEBBlocuYwNxhYWHs9PnQ0NCvr69/f39gnspPT09DQ0MuLi5ra2vu7u7n5+fAwMC5ubmnp6eVlZVLS0vr7/Kenp7IyMje3t5aWlo4ODiHh4d3d3ePj48dcKpVkr2rKo9SAAAgAElEQVR42uyda3PayBKGEYxoW9zvGAi35WaDyYZKskn2nMrm7GZ3//8vOtMzg0AgWTYGYdD7fnBcNpGnSk/1bXp6EgkIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAIgiAoVhKzGyhOmom3BeDsFoqXZm8LwJtbmMBYGcDbm7cG4A3ikBjpBgBCeN8AEABiQRDeNwAEgFgQBAAhAIgFQQAQAoAAEAKAEAAEgNB1vu//vLv79BUAAsAz6fe77798vpsBQAB4Hv35WX65/7m1oBbeCgCMTPbtr/Lr549bC8rhrQDAyDS7/UN+/ete06gaFId4KwAwWgCFAfCDatFe4a0AwPO4YG0B/8VbAYDnTELKeCsAMDrpMsyPrQUl8VYAYITaK0T/U8FrAYBnXNA/NBB4MQDwjAASbCAAPCuAGbwYAHhOACd4MQDwnADm8WIA4DkBbOLFAMBzAtjHiwGAZ1vQv1PCdjAAPOOCJjTCiwGA51uQQ9iNA4BnXNCSKH2ah5fyabxyABi2oPSJtkKyZaIFXjkADF1Qj1KneDRJIb0BgOELGpNVOP6TbQYQ/f4AMHxBXUmKffQntxjAPl45AAxdkIzVTtCPUKMB0Tzgl0v0PwBAd0F1CWDn6E8eUrND1YBfJtGBAwDdBUlLdeR0NSOzmgFlGxRw4CRLVAswjQs0J8YOwLkE0HKOaJJKNE5IuzrJ8L8BCXJAA8ScBqAkbgAOJQ8jKh6vMT/Ppe0ytbjEXfKxaGn5B3OBaIKSuAE4JaXj+b4cUSoxpowEbVLsVnwspMyPK77Ad+k0RUnoDQO40AAezwe3iRzRUxBKoOp7v1cVmrUNFK3t/bp6oG2ErhbAiQawcYznVbigWJWWr8K1xbJ68N6HCrT184WnWi3/xxyH9GIGYIV6zMMxdkPsXlJTlC1RT6gCjw+Ai20Ai54PJOXP6yAwXgAmSilhBRZGXiRHhZJjooVq8uL8mnp7nxpSckRU9Ek7RO+40Sh0EQCyLLKO8LgWh5Kc5FqqBiixLvs0e42oM6B1jdADoHTckt4SQIkfgHkap7Kv3hGe8BnPFHchdDj5kL62um/Q0j0qNYi6PgCWqLgkwtDWGALYIDpCAirTi3yBQ7xBlivKHaL2frNXhmuOk3UftgdAdtwjnFOOI4AVBvDVh0Oy0vapBGNUo7YKCfvjvfpOgY1jaSsGzLpZR0MuYUBZgBI/ALl49/r+UZPfdimZo6miepokZ+dDeW6SkX5aYafaBg1xojSmqlwI+qjjCGDtGP2jOQ1gvyhjv5wyb8PyXoFRVf4qXKxO6F0RNpZKc27gmqIUHUsApfcMbN97rkqaP6rNTYONNKr7IV2TjSOnykXbxJ7rBoQ6f3ucfBy6NABlwhDYvvdcFQ2AKcv41Sm1qm6Fe1nPb1V8ivoj2e3Yc85RgHLeUOwAbL0+CUkZ/oj7YVQ1T1QSK3f2kWXy3anqxRrrniwVNa4PJle5jNhEI38sAXTILc0dqokLoDSn61bAvtv6NzUlwaHyzgwg2SZqLE+0b+Z4seaGhFCcAEyXu0H9o6GWz0pt58ASwMymq2rjUXOmM2aubGJSN0BY5G4McyXIMUkyFDsAEyJ16IiEqmlhkSaubjxq3s08NgYtZ2rOAxUVKgAX0hz2hnwsLyXSGe23s2iKjieAvEWWEv2X9ySk1w0EQ2qq7z1baQWqNkqJ9KKljJ3OdfkIVFefG2ZzuDJuWD+m8OpcCLpMAKVRciYvbIlfLk3PS8r4Vmn/vN1Uqs4iw8O66rxmEztSlUEFYDWXlKlwjlyJhPoodFUAir/+vHtQ383+e/fw2Q5a0IgmhZe4YTu7TCZttYmncl7eRFvtlpEdBWBN+mXepJO8irHaGymvmeskUkMXQEUsLm+6Ngv44e+fCsD0p4/vv737HLSgFeU7ipFnyuLeKadExbQ+51uVMNmTHYBVcdq2qJee6/PHKerZ2wBKcyi2AWy9NhmH3p4LFt8ZQPHtdsa3dd0ELMiiaXb3bIhYOIEP1cwwMF1qdbo13z4WZSBbbQl2Txd6jIWTVk9nwPz8NX/lhO6Iga4tBlQAJj58kl9+u/0asKAOlWvukIRUIV2y1RHLQA9s9t1kzCbDuiH3IPh08ukm5zF/jkYyXbbzuuehYjkT13mbKLDN32cOrQZBbx7AR3VP693vBiB1XevWgqRzbLrteUka9AbKUAU902x89GkgE9usa812NTbWTdJnF4kK5hSSMPmJijnT0vXn2g3js3sA5RoA1PdRS/0RAKD+wI3HpK3cSVkmJFsFA+hosOoSqCoFH+2UwV5S/7bAqW8h5zYbtNZel1OPyZbPxqGQKwBQ/PaLkR3ggvcsoDFWzgbACjeoBP0FZcCSVJRArdZdCD4fk0+YrvGU/yW7abdigssZH5OJyUXXYAHF9jcawG+3X55KQkxmWtgA6PCPgk5JdlQnleopaFPwdAUJp/bPvTQnyrW2e/6Otz580hb05F9bDChm7z88vH9/E1aGUed4DR9qS4PGTs8/sGPldQrCV32tC3l+NURJX8VNcfvU3LTcl8j3ANIKd4ddWxLyqKK9r2GFaDZWc90stWmtCh4XpHoPhDKZ0yc+KfItbU4XqtJj1d1hhEv/qBEt0VeYBT9vQX0ZrpmGZHaP5acBVLUTtpoNdzMt6M/IVKWnct8m9TfFGmkYuz42Ew2BsQXQkvGcef0t416fwErVkXknOKPSiUwt+DibdNO2Qq1G7aJr9aSbn/r6bAzXjymA0qnmTftUh5LZ9NMAKr/LVnOZEDmuIQdXTzJ5sYZr66S68J1TKXB3WGwBlPnCxLTjKTO0aVHxk8o85AdfcpaOM+fNKEz/q4qxFxdbACUemY7uhlL7FQbAgIkdc7LaMkNOvWCYlWh4Gv/9K9epk90dBr1xACcSNtMroPYrLB0IBswsXR0wwoCDxU27X8Z3JqHoYUpqTAFMUW/tAPVZIk5xAzcmqgeMFMw85/RxEuOJYgpgorRkCIXyrzVl5MhJBlWi6wfsWHB5MfTYb/0E15ZAFwGgULURdoB6v0LmGaXybqqQKWvXWz5gqq8dfEPDdnCJrZCYAqgdoONaIT7KW98txPRNXtw9wFMKekbLdT+cUeh6AdTo6Y4AmYWkrV0Ac7qJdHnQYP3nDCHMYTpMnAHUDrCszJulpxx4K4FNoqpgJ31IsvqcW8EWuOY1zgBqB6gdMQPIA8wrOxZQmkfnsAvmFtXwOcCYjRBrAHPUdbgWx/41q7xv0etr2ScvGgcPcwuvWxcILakxBpC7rNjqqelWtdZ+tsF7wOU6nW6Q6YQwnSPGAHL7csmTrO7U5fp6Cu/pinUOoR0hxgB2TCfgJlZb0Xh7c1Y1IZRPeJ1HhjChLcYATvZ6YKTJy6bzblimDoAUT5ippglpcIwBtOvTkbcLkPtUa5vTuivK1490t1yAMKMyzgAmzHEjD4CLrfPBA8oO/M+zHUtZqudt0BJfANNeAKULzm0BWKXCnIIPyx1BfJ9rDbTEF8AEeYosfOHRgLMSIUxSPKSTXik4OcKVEdBlA+iZUpqjeVUSV+omeUtkRJMp0fiEt/o2CHlwvAFceVOMAtV5EuBYB35lalmntVDOEe4sgS4ZQNvx2LeWPliuMw8hUeyfNARUfdOYUhlnAHe0dIckFPRObfuFo6RfKP57RdACANcS6xl/3CYtDaHIjAonXdYTZ/GgGALIvX/cA1Pl4kgUkzNWp82yAeClLShTJGfAw1Cb0fQrVybjAw6cQFcLYCLV0FPFc7wvEsXwqvFpo0wAeHkLKo3yyvhFc2SIMB4BAO5JhX/tSHbJ6CUXlkAxAVB1qURzatdCWz4A3JMamTWgQgQLSxPmcwDAHQk1OSuiwRmYzwEA96QmZ0U0xL6MSiAA3FWGxpWDJnIcoMEJj90BwAtdEM+2SiWjyQ4cwoAOALifGfDAymjqIxjQAQD3VCTK6fmBp1cWp9OvBcAfj+/u7j9wd0nIRTWhGvO9bxF16mFY/tUA+O3x249fH36G3pgeriRfDlePZtUYln9dLvjvd3xZ4ZM3poery9djRnRaoxSVrweAkejnp/DrWkOlTqxHdJObjXuDrwhA8ePhe+iF1eGqm67oSIR7gy8bQM+N6bP7x8QugAdYQHU6KapO0Z2KN7qzLgtAz43ps/v/cTzldcGHLKgWYa+8dzc4Ne6Dn4uygFsRvORP2Y+wG9OfUxuJLjLz9n010SJ9sTHg7P7j7MuXL0cow/CJ3f+zd61NaitHFD27DBKSQDwMGCHCwwnUOkUl15VUXPG9W8n//0l3umf0QMBaeLWS8HZ/sc3aVYN11NOP06dry03XZ81glwH4sAD8r4wFO68vRGNqGtV17D2sj1YegMzPetwsuLIDQX2OCNX4Mz4CjoU6ax4WZgDWBkAR9cGmM1lL7sMc6iwBMQDbeiCvPpLUiCSKQM7BWzoBkDPh9w7ATlDbLYhy/aeOWtmwkNIgOt/B7x2A9ZlHKoFKCE6DAyFwxyBiANZkWHNcJ4r5ITJhOQhkANZo2Pc7GLTgGjc3daVI4Uv/wrQ95i8wAKsyRFzcJQ+I28FwHmDzAyrOnOdIGICVmT0fQDjBOBAVU2OsALnoDm/bosYyOQPwlwcgsfI9zIQ9okAIB/iDDTbioo44TWYAVmYTGPSxFngkwVTxO6ewO7tg+7ddX8IAfG8A7IIusDem/ZzYhDlNrrIRrSwE5IYxA7BCCwT6AAaokgDID9zZ1+owkyhJjU/1DQwwAN8DAFEgBkAX0NMC3B1RpGhJ09P2dCjwuuUgkAFYmXlU+wsG6cWrgTYqRnmZmu8GFiwryACs0CzZ/cjkaDAdKeQZTxlBZwmzATfrGIAVGraDYRSBof7sABQJYePsgy30QtaWZgBWCkB/BW62tUauc7cLGFUfmADGlmUFGYCVAlDfwyqbQ+ldMBJotzHlKI5Imq0j8IIRBmCVAFxqEGcqMTIozG/SHAonSZvlNBgIoFpMmGEAVmghHKcCWIP0AyJG5/W5NIgGdAlHVLG5WqhhYwD+pA0X9hG2OUGuEAHom2chYEyt4kgi02VCDAOwUusD5KQq93QHZ6w/vJPXVJqJaIaJhVUZgBWbQ8z8xERGLBJdZ5BsawqIpAUws1Vw2H/TXe4MwPcHwMXZMJyxmdoY823Vn2dSthpcYuwfsHkSMs4YgBXa7oJhEOaK0QjPRbrQfc3KvgzAis2cXUyC0HycSDWMw87eiJSkmwJQQ5e4ZJwxACs0hNf5ekSZiPTQE4oMZdszUgD2aZkO44wBWKEhvM7XI07VhLAEnSWbIWQz+ussLc0ArNDsi3H0PoHN6yROT7lEJ9oO6a/zomEGYJW2LWxupahQIE+25SZpVPgUEGlLv7LLznQ9Bh8D8CdtcEEyjUisHydFYEv3LYmnm0mOLMBmmrZ9nkn/uqB6shiAb2rhxaUqHN5SRX1GlherH65h2rE3+nJjn13avyr8zMAPTQbgW9rhgmMaDEYyEVkq7l9wyAA4hbVkbeVYMccbNNXhL5CvTO/ZLc8A/AnTrrmvY4Ea3U81ExawkWJu2tlDuiYaM/MfjLgQuMbFZ6d7FiszAH/CnGsA9ET6oef+481e4uICiGyC5/wMw8b19OaxALi8skF0cI9sJwPwZ6Ic7UoKa7m3JBBMH3oa6hjBKgXd6ipR/wkeDYBXDiy+7h3dbwZgDTYGbw3zWb6FfLgq2eHBo7XtrogvDSUPlwHYHluBe4D+U36rWHw1UB/Bo7XtEICzs5qUiflWZLf8eX/79PHTH587FewJeYy0cBWD1/H22d00xmbKrjiy7j6Cmps3X/bzACy2Gnewia4GuG0C4P+///79+bmKTUmPYA6caM1ckOUhIlD3JgD9c0+xh/YPERuy3Z0C0J9RPmXl0v/TsnwdpsHn/fcP1usXVj+ECZ8gtTzGKQCXAM7+QjoLxbTa3jemvnfQsbv4ptgCgB6yHo+Rk7nxvQh6Pc9sOQC//vFcwcLqh7Au6DrlHE5atNgCHOMCr/AYjqH9U+yuZJ65lFA9qfYPvlDJwdcwneNUzKTVAPzfxw/PXytYWP0QZkDk0/OR5GjTHVkRgDY+r00rDle/5armeymGI+svgQKgOaB3qecO0c07GjYmndYBML+w+utf/v38zXz9wuqHMIIWXq2SHD2jmiAcdID8wNwkY/FTNtnSL7OWybwEYE+d2fLxXTKxzuSIkJDK7qPWATC/sBoTYAHE1y+sfgjzVWEioAFiqWeEuWJ+vFPunpsmNbSuPmrndzkk3Fu/I8nhpECHpRdDx+8Tih94P9xf0cjzLrzTnwXuXr+w+iFMV/UXi+oT05QvPc7PK5HEgnikcsg9bmtPJAYnBM+QLwoW16NOBJSZ+NRtXIrEiviRbusAmNn3/3z5/V/Pf7XeSRkGiy6u+s2O2nDyaekBRMNceeMIA5xrp4/CthL5x7A4AQaCAxU2hMLBzzM2WoQpcoF60ToAfvnH3z5++u2zcIrvohCNZWdPXbNHNcQ5I3exyYZLJjAwvQAdIebLSK4OLISi0WvbyzSRS/IwnF2AvzfEkTdAAcQGxROxktkvvUeUW3H1XFuKQq2hXxB37enJjDBPzAkXJfPrsmKIcWJ3AMO+e5231WQ40cU8JKIYUB56CTr0QxnBjmUMq8HLC1QYgHV7QOnlkZuqLtkthvJuRu5PFDzGNPCE1bYdyNiqXYtGttDDC9igryQLmygM4ZnosxGY9B6Z/Ss8LQZgUxYlGUUfTuKhkY9YIh1BAEyzJAQTDSOaIEEPkh/tbI+h6Ks4nG/rOP4n35pNMpNqO+nVuyhJyWIA1mHHJCJfwPhpKxOSDTo/T2QeoewZTBWDOqYK7joHwFaJnD8JmFGtiLbkHemiHdNbgjn8JC2/THISigzAps2eKYrBDJYLtTgkxB6+RXHTPA0PO1hnQ67JKQfAVg1wos7DCFNgdObI85FfRbxMCMBhetynkrErA7Dmx+dr6o6KKYgSsFOX1gqm9DnlJaaPmm+ZvEd7buCZwJ6D28oW4sXxNHLbsVrd6FPsqiKGZblmMAOwVjMgClWTdE9x4RTVVFeyQiNbHwKIhr2T3TpIV2JnEyYN20JiL5bF5ojc9oEUOqk0PUpJCXE5z80ArNWG+Mxk0iEnm0bo6Sj9PSlPp4EO2lGgUiqvalTDDjZtEZrGm3eCR1Y8BLcjm4i2OPiCCoCqqnso57kZgLUa1pd9tUNEczqqLzzOsl9Fd3IhFL/SzjkM9m2AtsisYtRHS+OtCMNXQplGzATT6OQHBktqszMA681GigM7i6SnYEQqZsKn6u/BFXfdLpqijzyoBe2tMAxVA+qzBYGjGLXDfjxN3rAwaQHvYcoAbJ9FcF6emCQa+x4MpGdEZd9IuA+zaxPPHTmEnpQ7b4NhCDtUqe7upSKlVq4ZzACs1/wCknp00Q5zWvrY/IhOWQAlEmeTrmWnFWtfUerLDDeWLCrB7emjaaoMwQBskW0LQ9siKAy3mJakDgO9XRRmKaQdgXGA8vSSN48hEHKSqBO8NENVcjsFA7BuB4L125yJ4I7oB0kVRl7Km1wRTYfukvhPbSAIPuUhZ/kv1PpKbqdgANZryyJLRACS3F3q84jlvs0xEGjp9dOsHSPD54LXwQsTVF65tIkBWK9dCPfsoy51f9Md7MO8zCBaDJrInO179C7ezspL/i9y68wYgK2xTTGUM4eyZKsnPs8k/EUZHXouLuSYGNMtaIbsysGqU5qNwACs18ZXZiUo/PPTuVoC4CBfzwBMKE2/DSPDTul6ZElfyQCs10K4rM9izyAnpV9cQDxV7eBBGxZfj0oSnUuvR2EA1mtxUY2jI5sLw+yCpfGeVf6Zy7pv3IbF12656l6HeBc3fnCKewzABmPAC5qcJm7lgEYslEM8l5N2lKrbqlxv622t/CGGt2JW7awSxQCs165V87AG3c1y3OFqsnDNfD1DUpyObdi6eSrthm/u59HO8nkGYPMAFNeaubqdM+5UvyHIqaI16MFLDwjcSpo0yGfSDMB67XiFpjmF1QJulzdmymO0Ig3Wy8/o6dC7cYvn82MGYM02vJZZrt0Xxmh7CTiXzc/HWXfoF9467vxMh5gB2LzJVYerWz8OIJ0YXjR91J7aRPaa2/p0RmFgADZvzstcl2Hys1PzdZh7tr+HN4ZCwjMZWAZg8+YVmr+X6aT0fOvmCVmjOyYDbg2F4LRVz12ZDMC2GNHyXyivrWNbJSt6w91gMyxdh75dMsRC+yQVHGEANm+7knqiw8YVzF24oxieNk3sYnbso+bNhAHYFjO2JfVEG6/D3DUln7SNe+cLGO0INjiN7zAAW2PDoJwAjN6sUJZpAZRPxM1Eb25+Xnvvgb/GafwjA7BFFpTaqtE0H6YLcMcJJqrevD4H4AI2JKK/ZwA+nDVXCJzQzevcJVZoKJCthNs05CpR00Q8zqe5ZQAMwAey5ghZcv4X+zXlhatN1feWGiNEgJkvh6YPOy+3PJkB+EA2h2ZWN/Q2yEgMuncSwhQA5xnFG8AVqbzVTRHJAHwoa4oROCdKbIGm+GPzJMcxTgEofGKIRGlMZhJqPwPwgUxrqBWCAFyYd4u1qj2uUmcOCT0CeP4SoahDyv5hAD6QTe/oQ1QLfOEBLbmk8A6TauwjVM6Xe5XkxGkkmyGbhp+39c8PXzrvZGF1VVZ+Iqh6AE6Rs7O/a3eOGUFgdwZwIGURO1ltGEoPOGj4ef/2DQH4TjYlVWROQdajvthT2r0KcVuItyLh6J3UskYSfdB6EoDLRp+3+Sd758KVttKF4QCT7AJyR0DkJoooUm89PbW2XdV67Pf//9GXmYBcJJCBZIYx77u6rFTBKftxkpnZe7+Pl6ccwHgYVoelgqaqkOMJgLKOORP7rusxdyYred20yCPzrS5EU7wf2k/PHMB4GFaHpXMtdtZ2Ijmx95R95qTNNbPH2SQ/QqnPA1jUCSD7dWcJAONhWB2WmhS4MUaIyk+bpUtPv9WJnbq3F5OyWjSoiSTVHG/BzpQDODOs/vvirAIQM+B6ZbW0aBtOAZS+Ab2fAdjip8hvDbPsVmk6mSsEkM0Mq794IH6Oi2F1SErRrHxdnThGYjNZuk06L7HPTybOIrXmWwY6001FLYbV7OLm5uYxfXsRF8PqkKSnRRu3IhTWddKZEHzurGS8pQs/x57fRpouQ/TF+xnbMNK/wVn1LdqY06V63f3BB9KOYaK1tfO2kj6cGHu9/VdEnb1mALERLTsFKjcPzoom/vVt8nAac11d+Tl2buEosSvuAnEUZ5Q0JOW3tl95H84tmvg59nChN6LXOQEAGqWk3GlsGGoE63bvt4Eze5meOwvOV750RG4PADRKZfXdOe63T0I8mAOQVxQv5jOWxfEcADRKZ+rdq3foSOPMAdii4vVia4eySK4BgEapqty92lnTs2HjMrgw2zZiSaovjr4j8vwBoFFS3x6mNN+wX5rAVmr+d6e2MH8nxc4iADRK6qtCghuDbB76YllpUVS5A0CjpLwqJDMIKwUsQbnFwvquKE4HgEYp599GMKolSFh1KA3qdxduJ4/FSwNAo1RQnY/VpbDuOg/ojLrzB4mVDt9hBIBGyTsXU6gilUPqjF5fNou38jzBCwAaJVvxYbATXke4Ei2n04pDPgBolFhX7WFwJTxrCKe7lFHImrwyDgCapYHaw+DULruASyrTUllz1l2FlACgWVJs1RDQcTCQ3vk0XvNUawBolpQeBpfOM2FtQ1ti22VxQc2bfSQBoFlSehjcpVww1+lASrzrbsnrjc8BoFG6kmjSvLOIyiHuOw7fpTWUikT/A4BGqR+om3loAA6k23H4q/6usw2rA0DTlFjIao9W9la1mGtWNO8KqjIA0DQ1FB4Gp+ZaOUe0ygGApikf5pS0acbiAEbakbACAE2TygZZzbUeiuHcUdQAoFmqh7gvsknnGzzsQrnMA0CzlFHYnEPYyEa86HYAoFkK83B284JHyhtuyykdABollflYojNvIW7xBoDrpTAd5mSrllgA8GNLYToM78sWuT0iADRMtWi3hieqVPN8su1E35QaABo3A4aWo7xGOSKejl+bdnIGgNBERCquwUMXwBTvr5u0ACA0rzyp6M7hAuhkKckOSgAQWhDrq8iHcQEsqTl0AYCmKafAsZD3VWvmQ8wFBIAfRyocC1uewUcDAELvpCIfZmKOlAGA0Dudy3u2SauxnTMSAIyDFOTDXHsTYOEDx7vNnbpeLfiEyKsUfT7MIVG/2zlgHxnAu4eHh09wStpmhVokSjhRA5hL2Wr+O7oA/Ov9DcNqefGrYzHSHIEGqct40AVge/T1P9uCW+YWEsaBg2h/won1wQH8+/3m9+gz/IK3kSjX7Ub5E44VVr/rMazmj9ht+hsc07e9BkcIoM1OFJpBqARwZlgtHl64IC5egjEDBlKOonROL3X75cjTUPUAuLSsv03DsHq7dTCRvG9wKmhey9CdXhW2YdUT76e/N88/2l+wDbP9NVgyU8UpFgMWM/X5q7OPDSC7eRkdXd657wjDRvSWAEoyUg9c3XEf9RJnH2ZAtnfLcvMAlKvObATOY60qKAbe53gDwIAAynlYJiiowwivhcsCQGgTgHKQ8Du7QCsLVqTwvEEA4IcFULI8OBMU2UphmyU2AIwdgFLd8nNXNQpYTVelSDcZAeAHAbBbpfvA05TjpfcFQpYAIADcqA5dDSh4cVxJQFUMlGBKW+wxAsC4qdS4PpZIiKkLqqoBWiqwsfuNx7kMAIQ2MZgIvBXNRP7W+CRAjn1BWSY+ADRdARoFpryZzCtxK5zR5imQWxeNHQAIBZjXumu3onODsZU7rGsAAAmqSURBVNWlAieuzJtc0XkywEaMu1iuxj3eADCgfDtVjmsVvvBN8gXFibBC4LuAzV6AjZgaKcyFBoCmL4UzfgvZnHBYED4zfAu6KzptVA47G9udlgEgAAwq36xRbi7DG9yLFQUTFA6paPM8l035CO5l+hgAAsBAqvnNZ0Q9XlhJfEuFSl6LF4ffDG42OiySWkN2AGiw/Ao3+JyX4r01eGIfHc6d7CY2HPIyR2ELfgBouvycgyt88ktMTt8oOXewVtjU8/5aaRoCADRbPZ/uaXztcdijOb19qb++tWC9SkXEGwAGlF+jSu5xmbuiwQoAN7QW5BMm4g0AAyrv0z6NZ171T+iMqLwMYIGqTpOtA/AE8QaAAeXXJ5AjV6vRFRE/WEtU5wB0n5JfcxVWfg4MAE3W+z6BbIpR19uEcf8csOxZYf4pyTU5DIp6ogLAj6Hr5dyCVFJMbgORd9C95i4fSzs1JSperalmkq50AoBxFisuVRnxpmoNx3L/2b3snvGz4uTSd9giK7C5BkAH8QaAQbV8FidaxpAL2TW//+PJWPZSHRzr8sQYv/M4R20uPgA0XdXFJYP9tvNs9/3y9ZPrzBfci3Yf8QaAgbXUxe/gbd+PDf16G/CkVN9lcEllRw4AaL6Gi3PZ4ZS/Ij/0PfcHcPU0l+8UNGxDA0CDlaDE4sPp8S9fjmT9L8Grv8Y3bzqINwAMrgb15u4A3eXtYApgzq/6ozj5htVLYKoh3gAwuBZOdnnl0XB6Ce75LWdP/OvO+b9fId4AMLgOJofB9pW7GBkTVQvTs9+xH4ClAfXXANhDvAFgcE1dC93lr0gCvG96/PUsO+G72ZwqrQbQXrc+BoDQCk2zEdz5jvHJL+O4F1EqHqw/zbheXR4sKpiOEW8AGFzNyarVXfNW3Fnw0P2sk8puqj1ntZUnvtmg7bMAIPTGjNcdJkGUHQfvGc1WFhQ3VdmzAsAPo2k6zDFRIbm4J7hWKwuKz4lOUog3AJQQK3pTmddTshH4eSsLilvKe3IAQOPV8aAR52sS7m4rC4oPNGTja4337cvR6IsFw+pddOZ1Exfna+XgBb0rC4rzWnah9cX7dvTz9PQHnJJ2UkskvbAuJQL0npzpeFWqzFhHKpa2eDOn/dv7DIbVu2jMr8EVkXsv8azeqst1TssutLZ4P6V/f23/OoVh9W4qUdfmhR72vYy/b8LLVj08WPzHRJwA/JFu3z79GX2DYfVuV5IkNa26bBbVWJx4NBcLQIYSy2hjAZwZVv9I/3RxG/2EYfVuuqd8U/oErSXSrnKLByJ9hSbpugBkM8Pq7+Ki+/IKw+rd1KNGURzCySgjTlBqi4mpJyoNCnXNgLPDok9Hv70ZEIbVO8m9nZOvJq/wNTNPn5nbj650lTcG1Bvvf9uPp5/de0Bsw+yknGi/JlnMy/jFN7PYh6NJSRYrAO3X0egfdxWMjegd92FI+grstTc/5x08ZmXDdaXuSNaexJvt24CMU17eudriRycZ75nJpYVJ3AC0AOCO8vqQyz6LZyM0hHmIM3uhKuINAKXFL6QD6WfxbIQh5RKzyZMd6EkGBIDmA1iXz+I7IbqqubeOc92NDrWk4wNA05XaYv7j7c09T8LkbOtlrKUiDgAar9I2tgr9iX11Z1YEoi0XAQDGUF4Be8Y6o+6U30Rw+2sACO0or41RyRrQWwpMT1cuAgCMoUQJprsCdj903q7KY8QbAKoSvwksMmtuF7u60ccQAEKhToFlzx/dS2SwteUiAMBYrp09ACuts0mBXEZbLgIAjKPYPXnJB9Muv/pyEQBgPHXeEVuA00oQfbkIADDWmjZZ1VaWDgDjrYnhYTap7SgYAMZak0vvgLQdBQPAWKtJZWaL9rwJxBsAqleWimOqW1LNtQAgFJoc7ttwZUs11wKAUHi651dffjDSQrwBoJZVCNEwr8WnFQBClsXyVer36b6EeANAPcrT1ZLvKwAEFQqnwIKXno94A0B9d4Gy3WUAIBSa6hzAFOINAHUC6CDeAFCTrv0MhAEgpEQ50laSCQAh0eCojngDQG06Jyoh3gBQJ4A24g0Atakk5XIDAKHQp8As4g0AdYoh3gAwtgKAEOINAAGgWn2feMbBJwQAaom3/eDqc5vBKQkAaou3PbqDYTWkLd7slrMHw2oAqCvev365H2BYDQB1GFa7Dy7St+7Hf2FYDQCV/ayZYTWHbSQ+wrAaAKq77Zv/pP3KP4FhNQDUE+/HNHcLxjYMANQU7z8v3lyIjWgAuG8DuvgExUd7d8//nIbipef9AvDb0gx4+Smqh2G+1sXaUWsb1vovSw06qmFdpL/t9z3BpRXVwzBfa/2otQ1r/ZelBh3VsPY+HeunFdXDMF9r/ai1DWv9l6UGHdWwkA8Y31HvxaD37p2z72wDATRy1HsxaDPjDUEQBG0hkYSDUWPQKvX5i4nvipGjNvOtxrsCAPdq5BG8dvuv+/fXu5DflSgHbeaoIxs0AASAHx7Ax5fR6Nczz0e4/efo65MZoYxs0GaO2mgAb29Pb359Ze67cnl7+qXtGBHKyAZt5qiNvwQ/pG/cd+W3ZZ16KdOhviuXEV3MIhm0maOObNAqAHz+0x4dpR/dd+VpqVh499d+ebWsT0cRhDKyQZs56sgGrQLAy38eT0/dUT+7v5phvyuv7e//b+fcdSOEgSjqwrtiP4HC1TbGEgLEY4EE8dz8/ycFeymSgq0yiInvqZBojoYZ29gwSW4IHiWZNE9rMukDEtDFoaGIypSLYDKqJ1hN0UnztCaTPiABpZnGZqaISlExlOZpTSZNzlo6bRSWBGX5SMOUnTRPa0JpcuhKJ1dPyU6apzWhNDEsS4dnvXMepYRA6bCvd76jFAAAAAD+EctsTG7PImWmwsJeXCoTdtoulydjpgc362UODbdQj7EKI09/Tyv6e9KpYA2PSZPJXlSqTYryKkRXDkPZcbPOvp6GW6jbuB1T8/R2FKxvjZBqsZ3zP0VgG/bqWyvu9qB8+MvvS46wXukNt1C/BkjlbQKO7sOgxO4RxKJx3WrKbHuOpudlffIE3JXe2iV7iexmO9TZBVRciI/QTRexWFwLm2jhZX3uBNyXFuN5S52aSmkhB9st+kdUqrMn4I71uRNwX1pHsb/5N25zA6cpeM/61Am4L62jydPzEVkp95rxe2Vcn/wlZN/6xAn4RnrNv6uf+Scq09R1fWG2DfPGWieZSZKAlbSOCr3e8jIBX32C+213dJ0bJIeN6DfWsbvVsJLuX7cEcDMErCENAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOBgvgH2n/gpLz3AEwAAAABJRU5ErkJggg==)

If running under Jupyter Notebook, the plot will appear on `plot()`. Otherwise
use matplotlib.pyplot.show to show it or matplotlib.pyplot.savefig to write it
to a file.

    
    In [136]: plt.show();
    
On a DataFrame, the `plot()` method is a convenience to plot all of the
columns with labels:

    
    In [137]: df = pd.DataFrame(
       .....:     np.random.randn(1000, 4), index=ts.index, columns=["A", "B", "C", "D"]
       .....: )
       .....: 
    
    In [138]: df = df.cumsum()
    
    In [139]: plt.figure();
    
    In [140]: df.plot();
    
    In [141]: plt.legend(loc='best');
    
![../_images/frame_plot_basic.png](data:image/png;base64,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)

## Getting data in/out

### CSV

Writing to a csv file:

    
    In [142]: df.to_csv("foo.csv")
    
Reading from a csv file:

    
    In [143]: pd.read_csv("foo.csv")
    Out[143]: 
         Unnamed: 0          A          B          C          D
    0    2000-01-01   0.350262   0.843315   1.798556   0.782234
    1    2000-01-02  -0.586873   0.034907   1.923792  -0.562651
    2    2000-01-03  -1.245477  -0.963406   2.269575  -1.612566
    3    2000-01-04  -0.252830  -0.498066   3.176886  -1.275581
    4    2000-01-05  -1.044057   0.118042   2.768571   0.386039
    ..          ...        ...        ...        ...        ...
    995  2002-09-22 -48.017654  31.474551  69.146374 -47.541670
    996  2002-09-23 -47.207912  32.627390  68.505254 -48.828331
    997  2002-09-24 -48.907133  31.990402  67.310924 -49.391051
    998  2002-09-25 -50.146062  33.716770  67.717434 -49.037577
    999  2002-09-26 -49.724318  33.479952  68.108014 -48.822030
    
    [1000 rows x 5 columns]
    
### HDF5

Reading and writing to HDFStores.

Writing to a HDF5 Store:

    
    In [144]: df.to_hdf("foo.h5", "df")
    
Reading from a HDF5 Store:

    
    In [145]: pd.read_hdf("foo.h5", "df")
    Out[145]: 
                        A          B          C          D
    2000-01-01   0.350262   0.843315   1.798556   0.782234
    2000-01-02  -0.586873   0.034907   1.923792  -0.562651
    2000-01-03  -1.245477  -0.963406   2.269575  -1.612566
    2000-01-04  -0.252830  -0.498066   3.176886  -1.275581
    2000-01-05  -1.044057   0.118042   2.768571   0.386039
    ...               ...        ...        ...        ...
    2002-09-22 -48.017654  31.474551  69.146374 -47.541670
    2002-09-23 -47.207912  32.627390  68.505254 -48.828331
    2002-09-24 -48.907133  31.990402  67.310924 -49.391051
    2002-09-25 -50.146062  33.716770  67.717434 -49.037577
    2002-09-26 -49.724318  33.479952  68.108014 -48.822030
    
    [1000 rows x 4 columns]
    
### Excel

Reading and writing to MS Excel.

Writing to an excel file:

    
    In [146]: df.to_excel("foo.xlsx", sheet_name="Sheet1")
    
Reading from an excel file:

    
    In [147]: pd.read_excel("foo.xlsx", "Sheet1", index_col=None, na_values=["NA"])
    Out[147]: 
        Unnamed: 0          A          B          C          D
    0   2000-01-01   0.350262   0.843315   1.798556   0.782234
    1   2000-01-02  -0.586873   0.034907   1.923792  -0.562651
    2   2000-01-03  -1.245477  -0.963406   2.269575  -1.612566
    3   2000-01-04  -0.252830  -0.498066   3.176886  -1.275581
    4   2000-01-05  -1.044057   0.118042   2.768571   0.386039
    ..         ...        ...        ...        ...        ...
    995 2002-09-22 -48.017654  31.474551  69.146374 -47.541670
    996 2002-09-23 -47.207912  32.627390  68.505254 -48.828331
    997 2002-09-24 -48.907133  31.990402  67.310924 -49.391051
    998 2002-09-25 -50.146062  33.716770  67.717434 -49.037577
    999 2002-09-26 -49.724318  33.479952  68.108014 -48.822030
    
    [1000 rows x 5 columns]
    
## Gotchas

If you are attempting to perform an operation you might see an exception like:

    
    >>> if pd.Series([False, True, False]):
    ...     print("I was true")
    Traceback
        ...
    ValueError: The truth value of an array is ambiguous. Use a.empty, a.any() or a.all().
    
See Comparisons for an explanation and what to do.

See Gotchas as well.

© 2008–2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData
Development Team  
Licensed under the 3-clause BSD License.  
https://pandas.pydata.org/pandas-docs/version/1.4.0/user_guide/10min.html

