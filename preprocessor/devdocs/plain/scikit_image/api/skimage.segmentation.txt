# Module: segmentation

`skimage.segmentation.active_contour`(image, snake) | Active contour model.  
---|---  
`skimage.segmentation.chan_vese`(image[, mu, …]) | Chan-Vese segmentation algorithm.  
`skimage.segmentation.checkerboard_level_set`(…) | Create a checkerboard level set with binary values.  
`skimage.segmentation.circle_level_set`(…[, …]) | Create a circle level set with binary values.  
`skimage.segmentation.clear_border`(labels[, …]) | Clear objects connected to the label image border.  
`skimage.segmentation.disk_level_set`(…[, …]) | Create a disk level set with binary values.  
`skimage.segmentation.expand_labels`(label_image) | Expand labels in label image by `distance` pixels without overlapping.  
`skimage.segmentation.felzenszwalb`(image[, …]) | Computes Felsenszwalb’s efficient graph based image segmentation.  
`skimage.segmentation.find_boundaries`(label_img) | Return bool array where boundaries between labeled regions are True.  
`skimage.segmentation.flood`(image, seed_point, *) | Mask corresponding to a flood fill.  
`skimage.segmentation.flood_fill`(image, …) | Perform flood filling on an image.  
`skimage.segmentation.inverse_gaussian_gradient`(image) | Inverse of gradient magnitude.  
`skimage.segmentation.join_segmentations`(s1, s2) | Return the join of the two input segmentations.  
`skimage.segmentation.mark_boundaries`(image, …) | Return image with boundaries between labeled regions highlighted.  
`skimage.segmentation.morphological_chan_vese`(…) | Morphological Active Contours without Edges (MorphACWE)  
`skimage.segmentation.morphological_geodesic_active_contour`(…) | Morphological Geodesic Active Contours (MorphGAC).  
`skimage.segmentation.quickshift`(image[, …]) | Segments image using quickshift clustering in Color-(x,y) space.  
`skimage.segmentation.random_walker`(data, labels) | Random walker algorithm for segmentation from markers.  
`skimage.segmentation.relabel_sequential`(…) | Relabel arbitrary labels to {`offset`, …  
`skimage.segmentation.slic`(image[, …]) | Segments image using k-means clustering in Color-(x,y,z) space.  
`skimage.segmentation.watershed`(image[, …]) | Find watershed basins in `image` flooded from given `markers`.  
## active_contour

`skimage.segmentation.active_contour(image, snake, alpha=0.01, beta=0.1,
w_line=0, w_edge=1, gamma=0.01, max_px_move=1.0, max_iterations=2500,
convergence=0.1, *, boundary_condition='periodic', coordinates='rc')` [source]

    
Active contour model.

Active contours by fitting snakes to features of images. Supports single and
multichannel 2D images. Snakes can be periodic (for segmentation) or have
fixed and/or free ends. The output snake has the same length as the input
boundary. As the number of points is constant, make sure that the initial
snake has enough points to capture the details of the final contour.

Parameters

    
`image(N, M) or (N, M, 3) ndarray`

    
Input image.

`snake(N, 2) ndarray`

    
Initial snake coordinates. For periodic boundary conditions, endpoints must
not be duplicated.

`alphafloat, optional`

    
Snake length shape parameter. Higher values makes snake contract faster.

`betafloat, optional`

    
Snake smoothness shape parameter. Higher values makes snake smoother.

`w_linefloat, optional`

    
Controls attraction to brightness. Use negative values to attract toward dark
regions.

`w_edgefloat, optional`

    
Controls attraction to edges. Use negative values to repel snake from edges.

`gammafloat, optional`

    
Explicit time stepping parameter.

`max_px_movefloat, optional`

    
Maximum pixel distance to move per iteration.

`max_iterationsint, optional`

    
Maximum iterations to optimize snake shape.

`convergencefloat, optional`

    
Convergence criteria.

`boundary_conditionstring, optional`

    
Boundary conditions for the contour. Can be one of ‘periodic’, ‘free’,
‘fixed’, ‘free-fixed’, or ‘fixed-free’. ‘periodic’ attaches the two ends of
the snake, ‘fixed’ holds the end-points in place, and ‘free’ allows free
movement of the ends. ‘fixed’ and ‘free’ can be combined by parsing ‘fixed-
free’, ‘free-fixed’. Parsing ‘fixed-fixed’ or ‘free-free’ yields same
behaviour as ‘fixed’ and ‘free’, respectively.

`coordinates{‘rc’}, optional`

    
This option remains for compatibility purpose only and has no effect. It was
introduced in 0.16 with the `'xy'` option, but since 0.18, only the `'rc'`
option is valid. Coordinates must be set in a row-column format.

Returns

    
`snake(N, 2) ndarray`

    
Optimised snake, same shape as input parameter.

#### References

`1`

    
Kass, M.; Witkin, A.; Terzopoulos, D. “Snakes: Active contour models”.
International Journal of Computer Vision 1 (4): 321 (1988).
DOI:10.1007/BF00133570

#### Examples

    
    >>> from skimage.draw import circle_perimeter
    >>> from skimage.filters import gaussian
    
Create and smooth image:

    
    >>> img = np.zeros((100, 100))
    >>> rr, cc = circle_perimeter(35, 45, 25)
    >>> img[rr, cc] = 1
    >>> img = gaussian(img, 2)
    
Initialize spline:

    
    >>> s = np.linspace(0, 2*np.pi, 100)
    >>> init = 50 * np.array([np.sin(s), np.cos(s)]).T + 50
    
Fit spline to image:

    
    >>> snake = active_contour(img, init, w_edge=0, w_line=1, coordinates='rc')  
    >>> dist = np.sqrt((45-snake[:, 0])**2 + (35-snake[:, 1])**2)  
    >>> int(np.mean(dist))  
    25
    
## chan_vese

`skimage.segmentation.chan_vese(image, mu=0.25, lambda1=1.0, lambda2=1.0,
tol=0.001, max_iter=500, dt=0.5, init_level_set='checkerboard',
extended_output=False)` [source]

    
Chan-Vese segmentation algorithm.

Active contour model by evolving a level set. Can be used to segment objects
without clearly defined boundaries.

Parameters

    
`image(M, N) ndarray`

    
Grayscale image to be segmented.

`mufloat, optional`

    
‘edge length’ weight parameter. Higher `mu` values will produce a ‘round’
edge, while values closer to zero will detect smaller objects.

`lambda1float, optional`

    
‘difference from average’ weight parameter for the output region with value
‘True’. If it is lower than `lambda2`, this region will have a larger range of
values than the other.

`lambda2float, optional`

    
‘difference from average’ weight parameter for the output region with value
‘False’. If it is lower than `lambda1`, this region will have a larger range
of values than the other.

`tolfloat, positive, optional`

    
Level set variation tolerance between iterations. If the L2 norm difference
between the level sets of successive iterations normalized by the area of the
image is below this value, the algorithm will assume that the solution was
reached.

`max_iteruint, optional`

    
Maximum number of iterations allowed before the algorithm interrupts itself.

`dtfloat, optional`

    
A multiplication factor applied at calculations for each step, serves to
accelerate the algorithm. While higher values may speed up the algorithm, they
may also lead to convergence problems.

`init_level_setstr or (M, N) ndarray, optional`

    
Defines the starting level set used by the algorithm. If a string is inputted,
a level set that matches the image size will automatically be generated.
Alternatively, it is possible to define a custom level set, which should be an
array of float values, with the same shape as ‘image’. Accepted string values
are as follows.

‘checkerboard’

    
the starting level set is defined as sin(x/5*pi)*sin(y/5*pi), where x and y
are pixel coordinates. This level set has fast convergence, but may fail to
detect implicit edges.

‘disk’

    
the starting level set is defined as the opposite of the distance from the
center of the image minus half of the minimum value between image width and
image height. This is somewhat slower, but is more likely to properly detect
implicit edges.

‘small disk’

    
the starting level set is defined as the opposite of the distance from the
center of the image minus a quarter of the minimum value between image width
and image height.

`extended_outputbool, optional`

    
If set to True, the return value will be a tuple containing the three return
values (see below). If set to False which is the default value, only the
‘segmentation’ array will be returned.

Returns

    
`segmentation(M, N) ndarray, bool`

    
Segmentation produced by the algorithm.

`phi(M, N) ndarray of floats`

    
Final level set computed by the algorithm.

`energieslist of floats`

    
Shows the evolution of the ‘energy’ for each step of the algorithm. This
should allow to check whether the algorithm converged.

#### Notes

The Chan-Vese Algorithm is designed to segment objects without clearly defined
boundaries. This algorithm is based on level sets that are evolved iteratively
to minimize an energy, which is defined by weighted values corresponding to
the sum of differences intensity from the average value outside the segmented
region, the sum of differences from the average value inside the segmented
region, and a term which is dependent on the length of the boundary of the
segmented region.

This algorithm was first proposed by Tony Chan and Luminita Vese, in a
publication entitled “An Active Contour Model Without Edges” [1].

This implementation of the algorithm is somewhat simplified in the sense that
the area factor ‘nu’ described in the original paper is not implemented, and
is only suitable for grayscale images.

Typical values for `lambda1` and `lambda2` are 1. If the ‘background’ is very
different from the segmented object in terms of distribution (for example, a
uniform black image with figures of varying intensity), then these values
should be different from each other.

Typical values for mu are between 0 and 1, though higher values can be used
when dealing with shapes with very ill-defined contours.

The ‘energy’ which this algorithm tries to minimize is defined as the sum of
the differences from the average within the region squared and weighed by the
‘lambda’ factors to which is added the length of the contour multiplied by the
‘mu’ factor.

Supports 2D grayscale images only, and does not implement the area term
described in the original article.

#### References

`1`

    
An Active Contour Model without Edges, Tony Chan and Luminita Vese, Scale-
Space Theories in Computer Vision, 1999, DOI:10.1007/3-540-48236-9_13

`2`

    
Chan-Vese Segmentation, Pascal Getreuer Image Processing On Line, 2 (2012),
pp. 214-224, DOI:10.5201/ipol.2012.g-cv

`3`

    
The Chan-Vese Algorithm - Project Report, Rami Cohen, 2011 arXiv:1107.2782

## checkerboard_level_set

`skimage.segmentation.checkerboard_level_set(image_shape, square_size=5)`
[source]

    
Create a checkerboard level set with binary values.

Parameters

    
`image_shapetuple of positive integers`

    
Shape of the image.

`square_sizeint, optional`

    
Size of the squares of the checkerboard. It defaults to 5.

Returns

    
`outarray with shape image_shape`

    
Binary level set of the checkerboard.

See also

`circle_level_set`

## circle_level_set

`skimage.segmentation.circle_level_set(image_shape, center=None, radius=None)`
[source]

    
Create a circle level set with binary values.

Parameters

    
`image_shapetuple of positive integers`

    
Shape of the image

`centertuple of positive integers, optional`

    
Coordinates of the center of the circle given in (row, column). If not given,
it defaults to the center of the image.

`radiusfloat, optional`

    
Radius of the circle. If not given, it is set to the 75% of the smallest image
dimension.

Returns

    
`outarray with shape image_shape`

    
Binary level set of the circle with the given `radius` and `center`.

Warns

    
Deprecated:

    
New in version 0.17: This function is deprecated and will be removed in
scikit-image 0.19. Please use the function named `disk_level_set` instead.

See also

`checkerboard_level_set`

## clear_border

`skimage.segmentation.clear_border(labels, buffer_size=0, bgval=0,
in_place=False, mask=None)` [source]

    
Clear objects connected to the label image border.

Parameters

    
`labels(M[, N[, …, P]]) array of int or bool`

    
Imaging data labels.

`buffer_sizeint, optional`

    
The width of the border examined. By default, only objects that touch the
outside of the image are removed.

`bgvalfloat or int, optional`

    
Cleared objects are set to this value.

`in_placebool, optional`

    
Whether or not to manipulate the labels array in-place.

`maskndarray of bool, same shape as image, optional.`

    
Image data mask. Objects in labels image overlapping with False pixels of mask
will be removed. If defined, the argument buffer_size will be ignored.

Returns

    
`out(M[, N[, …, P]]) array`

    
Imaging data labels with cleared borders

#### Examples

    
    >>> import numpy as np
    >>> from skimage.segmentation import clear_border
    >>> labels = np.array([[0, 0, 0, 0, 0, 0, 0, 1, 0],
    ...                    [1, 1, 0, 0, 1, 0, 0, 1, 0],
    ...                    [1, 1, 0, 1, 0, 1, 0, 0, 0],
    ...                    [0, 0, 0, 1, 1, 1, 1, 0, 0],
    ...                    [0, 1, 1, 1, 1, 1, 1, 1, 0],
    ...                    [0, 0, 0, 0, 0, 0, 0, 0, 0]])
    >>> clear_border(labels)
    array([[0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 1, 0, 0, 0, 0],
           [0, 0, 0, 1, 0, 1, 0, 0, 0],
           [0, 0, 0, 1, 1, 1, 1, 0, 0],
           [0, 1, 1, 1, 1, 1, 1, 1, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0]])
    >>> mask = np.array([[0, 0, 1, 1, 1, 1, 1, 1, 1],
    ...                  [0, 0, 1, 1, 1, 1, 1, 1, 1],
    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],
    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],
    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],
    ...                  [1, 1, 1, 1, 1, 1, 1, 1, 1]]).astype(bool)
    >>> clear_border(labels, mask=mask)
    array([[0, 0, 0, 0, 0, 0, 0, 1, 0],
           [0, 0, 0, 0, 1, 0, 0, 1, 0],
           [0, 0, 0, 1, 0, 1, 0, 0, 0],
           [0, 0, 0, 1, 1, 1, 1, 0, 0],
           [0, 1, 1, 1, 1, 1, 1, 1, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0]])
    
## disk_level_set

`skimage.segmentation.disk_level_set(image_shape, *, center=None,
radius=None)` [source]

    
Create a disk level set with binary values.

Parameters

    
`image_shapetuple of positive integers`

    
Shape of the image

`centertuple of positive integers, optional`

    
Coordinates of the center of the disk given in (row, column). If not given, it
defaults to the center of the image.

`radiusfloat, optional`

    
Radius of the disk. If not given, it is set to the 75% of the smallest image
dimension.

Returns

    
`outarray with shape image_shape`

    
Binary level set of the disk with the given `radius` and `center`.

See also

`checkerboard_level_set`

## expand_labels

`skimage.segmentation.expand_labels(label_image, distance=1)` [source]

    
Expand labels in label image by `distance` pixels without overlapping.

Given a label image, `expand_labels` grows label regions (connected
components) outwards by up to `distance` pixels without overflowing into
neighboring regions. More specifically, each background pixel that is within
Euclidean distance of <= `distance` pixels of a connected component is
assigned the label of that connected component. Where multiple connected
components are within `distance` pixels of a background pixel, the label value
of the closest connected component will be assigned (see Notes for the case of
multiple labels at equal distance).

Parameters

    
`label_imagendarray of dtype int`

    
label image

`distancefloat`

    
Euclidean distance in pixels by which to grow the labels. Default is one.

Returns

    
`enlarged_labelsndarray of dtype int`

    
Labeled array, where all connected regions have been enlarged

See also

`skimage.measure.label(), skimage.segmentation.watershed(),`
`skimage.morphology.dilation()`

#### Notes

Where labels are spaced more than `distance` pixels are apart, this is
equivalent to a morphological dilation with a disc or hyperball of radius
`distance`. However, in contrast to a morphological dilation, `expand_labels`
will not expand a label region into a neighboring region.

This implementation of `expand_labels` is derived from CellProfiler [1], where
it is known as module “IdentifySecondaryObjects (Distance-N)” [2].

There is an important edge case when a pixel has the same distance to multiple
regions, as it is not defined which region expands into that space. Here, the
exact behavior depends on the upstream implementation of
`scipy.ndimage.distance_transform_edt`.

#### References

`1`

    
https://cellprofiler.org

`2`

    
https://github.com/CellProfiler/CellProfiler/blob/082930ea95add7b72243a4fa3d39ae5145995e9c/cellprofiler/modules/identifysecondaryobjects.py#L559

#### Examples

    
    >>> labels = np.array([0, 1, 0, 0, 0, 0, 2])
    >>> expand_labels(labels, distance=1)
    array([1, 1, 1, 0, 0, 2, 2])
    
Labels will not overwrite each other:

    
    >>> expand_labels(labels, distance=3)
    array([1, 1, 1, 1, 2, 2, 2])
    
In case of ties, behavior is undefined, but currently resolves to the label
closest to `(0,) * ndim` in lexicographical order.

    
    >>> labels_tied = np.array([0, 1, 0, 2, 0])
    >>> expand_labels(labels_tied, 1)
    array([1, 1, 1, 2, 2])
    >>> labels2d = np.array(
    ...     [[0, 1, 0, 0],
    ...      [2, 0, 0, 0],
    ...      [0, 3, 0, 0]]
    ... )
    >>> expand_labels(labels2d, 1)
    array([[2, 1, 1, 0],
           [2, 2, 0, 0],
           [2, 3, 3, 0]])
    
## felzenszwalb

`skimage.segmentation.felzenszwalb(image, scale=1, sigma=0.8, min_size=20,
multichannel=True)` [source]

    
Computes Felsenszwalb’s efficient graph based image segmentation.

Produces an oversegmentation of a multichannel (i.e. RGB) image using a fast,
minimum spanning tree based clustering on the image grid. The parameter
`scale` sets an observation level. Higher scale means less and larger
segments. `sigma` is the diameter of a Gaussian kernel, used for smoothing the
image prior to segmentation.

The number of produced segments as well as their size can only be controlled
indirectly through `scale`. Segment size within an image can vary greatly
depending on local contrast.

For RGB images, the algorithm uses the euclidean distance between pixels in
color space.

Parameters

    
`image(width, height, 3) or (width, height) ndarray`

    
Input image.

`scalefloat`

    
Free parameter. Higher means larger clusters.

`sigmafloat`

    
Width (standard deviation) of Gaussian kernel used in preprocessing.

`min_sizeint`

    
Minimum component size. Enforced using postprocessing.

`multichannelbool, optional (default: True)`

    
Whether the last axis of the image is to be interpreted as multiple channels.
A value of False, for a 3D image, is not currently supported.

Returns

    
`segment_mask(width, height) ndarray`

    
Integer mask indicating segment labels.

#### Notes

The `k` parameter used in the original paper renamed to `scale` here.

#### References

`1`

    
Efficient graph-based image segmentation, Felzenszwalb, P.F. and Huttenlocher,
D.P. International Journal of Computer Vision, 2004

#### Examples

    
    >>> from skimage.segmentation import felzenszwalb
    >>> from skimage.data import coffee
    >>> img = coffee()
    >>> segments = felzenszwalb(img, scale=3.0, sigma=0.95, min_size=5)
    
## find_boundaries

`skimage.segmentation.find_boundaries(label_img, connectivity=1, mode='thick',
background=0)` [source]

    
Return bool array where boundaries between labeled regions are True.

Parameters

    
`label_imgarray of int or bool`

    
An array in which different regions are labeled with either different integers
or boolean values.

`connectivityint in {1, …, label_img.ndim}, optional`

    
A pixel is considered a boundary pixel if any of its neighbors has a different
label. `connectivity` controls which pixels are considered neighbors. A
connectivity of 1 (default) means pixels sharing an edge (in 2D) or a face (in
3D) will be considered neighbors. A connectivity of `label_img.ndim` means
pixels sharing a corner will be considered neighbors.

`modestring in {‘thick’, ‘inner’, ‘outer’, ‘subpixel’}`

    
How to mark the boundaries:

  * thick: any pixel not completely surrounded by pixels of the same label (defined by `connectivity`) is marked as a boundary. This results in boundaries that are 2 pixels thick.
  * inner: outline the pixels just inside of objects, leaving background pixels untouched.
  * outer: outline pixels in the background around object boundaries. When two objects touch, their boundary is also marked.
  * subpixel: return a doubled image, with pixels between the original pixels marked as boundary where appropriate.

`backgroundint, optional`

    
For modes ‘inner’ and ‘outer’, a definition of a background label is required.
See `mode` for descriptions of these two.

Returns

    
`boundariesarray of bool, same shape as label_img`

    
A bool image where `True` represents a boundary pixel. For `mode` equal to
‘subpixel’, `boundaries.shape[i]` is equal to `2 * label_img.shape[i] - 1` for
all `i` (a pixel is inserted in between all other pairs of pixels).

#### Examples

    
    >>> labels = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    ...                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    ...                    [0, 0, 0, 0, 0, 5, 5, 5, 0, 0],
    ...                    [0, 0, 1, 1, 1, 5, 5, 5, 0, 0],
    ...                    [0, 0, 1, 1, 1, 5, 5, 5, 0, 0],
    ...                    [0, 0, 1, 1, 1, 5, 5, 5, 0, 0],
    ...                    [0, 0, 0, 0, 0, 5, 5, 5, 0, 0],
    ...                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    ...                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=np.uint8)
    >>> find_boundaries(labels, mode='thick').astype(np.uint8)
    array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],
           [0, 0, 1, 1, 1, 1, 1, 1, 1, 0],
           [0, 1, 1, 1, 1, 1, 0, 1, 1, 0],
           [0, 1, 1, 0, 1, 1, 0, 1, 1, 0],
           [0, 1, 1, 1, 1, 1, 0, 1, 1, 0],
           [0, 0, 1, 1, 1, 1, 1, 1, 1, 0],
           [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
    >>> find_boundaries(labels, mode='inner').astype(np.uint8)
    array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],
           [0, 0, 1, 1, 1, 1, 0, 1, 0, 0],
           [0, 0, 1, 0, 1, 1, 0, 1, 0, 0],
           [0, 0, 1, 1, 1, 1, 0, 1, 0, 0],
           [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
    >>> find_boundaries(labels, mode='outer').astype(np.uint8)
    array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],
           [0, 0, 1, 1, 1, 1, 0, 0, 1, 0],
           [0, 1, 0, 0, 1, 1, 0, 0, 1, 0],
           [0, 1, 0, 0, 1, 1, 0, 0, 1, 0],
           [0, 1, 0, 0, 1, 1, 0, 0, 1, 0],
           [0, 0, 1, 1, 1, 1, 0, 0, 1, 0],
           [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
    >>> labels_small = labels[::2, ::3]
    >>> labels_small
    array([[0, 0, 0, 0],
           [0, 0, 5, 0],
           [0, 1, 5, 0],
           [0, 0, 5, 0],
           [0, 0, 0, 0]], dtype=uint8)
    >>> find_boundaries(labels_small, mode='subpixel').astype(np.uint8)
    array([[0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 1, 1, 1, 0],
           [0, 0, 0, 1, 0, 1, 0],
           [0, 1, 1, 1, 0, 1, 0],
           [0, 1, 0, 1, 0, 1, 0],
           [0, 1, 1, 1, 0, 1, 0],
           [0, 0, 0, 1, 0, 1, 0],
           [0, 0, 0, 1, 1, 1, 0],
           [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
    >>> bool_image = np.array([[False, False, False, False, False],
    ...                        [False, False, False, False, False],
    ...                        [False, False,  True,  True,  True],
    ...                        [False, False,  True,  True,  True],
    ...                        [False, False,  True,  True,  True]],
    ...                       dtype=bool)
    >>> find_boundaries(bool_image)
    array([[False, False, False, False, False],
           [False, False,  True,  True,  True],
           [False,  True,  True,  True,  True],
           [False,  True,  True, False, False],
           [False,  True,  True, False, False]])
    
## flood

`skimage.segmentation.flood(image, seed_point, *, selem=None,
connectivity=None, tolerance=None)` [source]

    
Mask corresponding to a flood fill.

Starting at a specific `seed_point`, connected points equal or within
`tolerance` of the seed value are found.

Parameters

    
`imagendarray`

    
An n-dimensional array.

`seed_pointtuple or int`

    
The point in `image` used as the starting point for the flood fill. If the
image is 1D, this point may be given as an integer.

`selemndarray, optional`

    
A structuring element used to determine the neighborhood of each evaluated
pixel. It must contain only 1’s and 0’s, have the same number of dimensions as
`image`. If not given, all adjacent pixels are considered as part of the
neighborhood (fully connected).

`connectivityint, optional`

    
A number used to determine the neighborhood of each evaluated pixel. Adjacent
pixels whose squared distance from the center is larger or equal to
`connectivity` are considered neighbors. Ignored if `selem` is not None.

`tolerancefloat or int, optional`

    
If None (default), adjacent values must be strictly equal to the initial value
of `image` at `seed_point`. This is fastest. If a value is given, a comparison
will be done at every point and if within tolerance of the initial value will
also be filled (inclusive).

Returns

    
`maskndarray`

    
A Boolean array with the same shape as `image` is returned, with True values
for areas connected to and equal (or within tolerance of) the seed point. All
other values are False.

#### Notes

The conceptual analogy of this operation is the ‘paint bucket’ tool in many
raster graphics programs. This function returns just the mask representing the
fill.

If indices are desired rather than masks for memory reasons, the user can
simply run `numpy.nonzero` on the result, save the indices, and discard this
mask.

#### Examples

    
    >>> from skimage.morphology import flood
    >>> image = np.zeros((4, 7), dtype=int)
    >>> image[1:3, 1:3] = 1
    >>> image[3, 0] = 1
    >>> image[1:3, 4:6] = 2
    >>> image[3, 6] = 3
    >>> image
    array([[0, 0, 0, 0, 0, 0, 0],
           [0, 1, 1, 0, 2, 2, 0],
           [0, 1, 1, 0, 2, 2, 0],
           [1, 0, 0, 0, 0, 0, 3]])
    
Fill connected ones with 5, with full connectivity (diagonals included):

    
    >>> mask = flood(image, (1, 1))
    >>> image_flooded = image.copy()
    >>> image_flooded[mask] = 5
    >>> image_flooded
    array([[0, 0, 0, 0, 0, 0, 0],
           [0, 5, 5, 0, 2, 2, 0],
           [0, 5, 5, 0, 2, 2, 0],
           [5, 0, 0, 0, 0, 0, 3]])
    
Fill connected ones with 5, excluding diagonal points (connectivity 1):

    
    >>> mask = flood(image, (1, 1), connectivity=1)
    >>> image_flooded = image.copy()
    >>> image_flooded[mask] = 5
    >>> image_flooded
    array([[0, 0, 0, 0, 0, 0, 0],
           [0, 5, 5, 0, 2, 2, 0],
           [0, 5, 5, 0, 2, 2, 0],
           [1, 0, 0, 0, 0, 0, 3]])
    
Fill with a tolerance:

    
    >>> mask = flood(image, (0, 0), tolerance=1)
    >>> image_flooded = image.copy()
    >>> image_flooded[mask] = 5
    >>> image_flooded
    array([[5, 5, 5, 5, 5, 5, 5],
           [5, 5, 5, 5, 2, 2, 5],
           [5, 5, 5, 5, 2, 2, 5],
           [5, 5, 5, 5, 5, 5, 3]])
    
### Examples using `skimage.segmentation.flood`

![Flood
Fill](data:image/png;base64,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)

Flood Fill

## flood_fill

`skimage.segmentation.flood_fill(image, seed_point, new_value, *, selem=None,
connectivity=None, tolerance=None, in_place=False, inplace=None)` [source]

    
Perform flood filling on an image.

Starting at a specific `seed_point`, connected points equal or within
`tolerance` of the seed value are found, then set to `new_value`.

Parameters

    
`imagendarray`

    
An n-dimensional array.

`seed_pointtuple or int`

    
The point in `image` used as the starting point for the flood fill. If the
image is 1D, this point may be given as an integer.

`new_valueimage type`

    
New value to set the entire fill. This must be chosen in agreement with the
dtype of `image`.

`selemndarray, optional`

    
A structuring element used to determine the neighborhood of each evaluated
pixel. It must contain only 1’s and 0’s, have the same number of dimensions as
`image`. If not given, all adjacent pixels are considered as part of the
neighborhood (fully connected).

`connectivityint, optional`

    
A number used to determine the neighborhood of each evaluated pixel. Adjacent
pixels whose squared distance from the center is less than or equal to
`connectivity` are considered neighbors. Ignored if `selem` is not None.

`tolerancefloat or int, optional`

    
If None (default), adjacent values must be strictly equal to the value of
`image` at `seed_point` to be filled. This is fastest. If a tolerance is
provided, adjacent points with values within plus or minus tolerance from the
seed point are filled (inclusive).

`in_placebool, optional`

    
If True, flood filling is applied to `image` in place. If False, the flood
filled result is returned without modifying the input `image` (default).

`inplacebool, optional`

    
This parameter is deprecated and will be removed in version 0.19.0 in favor of
in_place. If True, flood filling is applied to `image` inplace. If False, the
flood filled result is returned without modifying the input `image` (default).

Returns

    
`filledndarray`

    
An array with the same shape as `image` is returned, with values in areas
connected to and equal (or within tolerance of) the seed point replaced with
`new_value`.

#### Notes

The conceptual analogy of this operation is the ‘paint bucket’ tool in many
raster graphics programs.

#### Examples

    
    >>> from skimage.morphology import flood_fill
    >>> image = np.zeros((4, 7), dtype=int)
    >>> image[1:3, 1:3] = 1
    >>> image[3, 0] = 1
    >>> image[1:3, 4:6] = 2
    >>> image[3, 6] = 3
    >>> image
    array([[0, 0, 0, 0, 0, 0, 0],
           [0, 1, 1, 0, 2, 2, 0],
           [0, 1, 1, 0, 2, 2, 0],
           [1, 0, 0, 0, 0, 0, 3]])
    
Fill connected ones with 5, with full connectivity (diagonals included):

    
    >>> flood_fill(image, (1, 1), 5)
    array([[0, 0, 0, 0, 0, 0, 0],
           [0, 5, 5, 0, 2, 2, 0],
           [0, 5, 5, 0, 2, 2, 0],
           [5, 0, 0, 0, 0, 0, 3]])
    
Fill connected ones with 5, excluding diagonal points (connectivity 1):

    
    >>> flood_fill(image, (1, 1), 5, connectivity=1)
    array([[0, 0, 0, 0, 0, 0, 0],
           [0, 5, 5, 0, 2, 2, 0],
           [0, 5, 5, 0, 2, 2, 0],
           [1, 0, 0, 0, 0, 0, 3]])
    
Fill with a tolerance:

    
    >>> flood_fill(image, (0, 0), 5, tolerance=1)
    array([[5, 5, 5, 5, 5, 5, 5],
           [5, 5, 5, 5, 2, 2, 5],
           [5, 5, 5, 5, 2, 2, 5],
           [5, 5, 5, 5, 5, 5, 3]])
    
### Examples using `skimage.segmentation.flood_fill`

![Flood
Fill](data:image/png;base64,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)

Flood Fill

## inverse_gaussian_gradient

`skimage.segmentation.inverse_gaussian_gradient(image, alpha=100.0,
sigma=5.0)` [source]

    
Inverse of gradient magnitude.

Compute the magnitude of the gradients in the image and then inverts the
result in the range [0, 1]. Flat areas are assigned values close to 1, while
areas close to borders are assigned values close to 0.

This function or a similar one defined by the user should be applied over the
image as a preprocessing step before calling
`morphological_geodesic_active_contour`.

Parameters

    
`image(M, N) or (L, M, N) array`

    
Grayscale image or volume.

`alphafloat, optional`

    
Controls the steepness of the inversion. A larger value will make the
transition between the flat areas and border areas steeper in the resulting
array.

`sigmafloat, optional`

    
Standard deviation of the Gaussian filter applied over the image.

Returns

    
`gimage(M, N) or (L, M, N) array`

    
Preprocessed image (or volume) suitable for
`morphological_geodesic_active_contour`.

## join_segmentations

`skimage.segmentation.join_segmentations(s1, s2)` [source]

    
Return the join of the two input segmentations.

The join J of S1 and S2 is defined as the segmentation in which two voxels are
in the same segment if and only if they are in the same segment in both S1 and
S2.

Parameters

    
`s1, s2numpy arrays`

    
s1 and s2 are label fields of the same shape.

Returns

    
`jnumpy array`

    
The join segmentation of s1 and s2.

#### Examples

    
    >>> from skimage.segmentation import join_segmentations
    >>> s1 = np.array([[0, 0, 1, 1],
    ...                [0, 2, 1, 1],
    ...                [2, 2, 2, 1]])
    >>> s2 = np.array([[0, 1, 1, 0],
    ...                [0, 1, 1, 0],
    ...                [0, 1, 1, 1]])
    >>> join_segmentations(s1, s2)
    array([[0, 1, 3, 2],
           [0, 5, 3, 2],
           [4, 5, 5, 3]])
    
## mark_boundaries

`skimage.segmentation.mark_boundaries(image, label_img, color=(1, 1, 0),
outline_color=None, mode='outer', background_label=0)` [source]

    
Return image with boundaries between labeled regions highlighted.

Parameters

    
`image(M, N[, 3]) array`

    
Grayscale or RGB image.

`label_img(M, N) array of int`

    
Label array where regions are marked by different integer values.

`colorlength-3 sequence, optional`

    
RGB color of boundaries in the output image.

`outline_colorlength-3 sequence, optional`

    
RGB color surrounding boundaries in the output image. If None, no outline is
drawn.

`modestring in {‘thick’, ‘inner’, ‘outer’, ‘subpixel’}, optional`

    
The mode for finding boundaries.

`background_labelint, optional`

    
Which label to consider background (this is only useful for modes `inner` and
`outer`).

Returns

    
`marked(M, N, 3) array of float`

    
An image in which the boundaries between labels are superimposed on the
original image.

See also

`find_boundaries`

### Examples using `skimage.segmentation.mark_boundaries`

![Trainable segmentation using local features and random
forests](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAADECAMAAABz285eAAADAFBMVEUwZ40vaY/c4OHZ393+5yTc4ePc4eH///9EAFQ1t3jf4eClpaXZ3+DarMD/6SHBwsPX29zap8DWqsHY3d/XssXfqsLb4N/frsXXrcXapbw6AEqsqKrYt8ovtXrdtsvatcfXvcuDdIbKnbvbscUvZI7brMU2unckVHTfpb/+/v7fssjR1tXk5+XSssbWo8DbsMKvra69kLTFxMXascjRp8DbusnMpLzdoLzDlbfRrMTVp7y4b6W+cqfVsMHCdqqysbLSn73Fo7339/e0i7Dx8fHBnLrcvM4oYIjWt8RmeITr6+vSnra+a6PZn7evqMD7+/ve4ODWrLvLpsHcw8++ia2xc6XKrcLTuMnf4eG1aaKenp7Hycjc29xEAFLWwdDKlLaioqKGhobSkbS3o77FcKa/uMjJi6+4g6u7urvNlIbXmLn/7SDWpLi1tbXOztaWlpaMlpyxl7bX2NfYma8kW4DQ0dDEvcyvfqnKxM/dpbiampnfm7bMgbBzXZW/mK3JeKvEfK23rcHv5ia6eqvh5OOtZJ7InbHKtsfayNK1lKCQgKjakqrGiZHArsSRkZFdfZuxiZ8ucouRgZYunoH55yK6s8XelLQvrHp8e3ssjIbMzc64YprJk6nh4S2+f5u+v7+MjYzdy9ctf4hadZeheqNKvG1RlIvF1jiRQX+yoaWkjK/Fpoyy0ECrcp4ySYK7eJKcyl6ezEh2bm/m6J2ro7melrE3AEdixGCvgZWcTI7T3TK2kIHai6Ld0tmlYHfb055wgqLbnI2btleqxHPEkXjg5NHk5bfTkpY9FmWxeHerVZPXpa6prozj4ovct7zc0n+Dy1KeZpbUnp+lomfBpnxCAlhtpmTKurSLtlRrVXTOvIBlZmd1h5TYb4uVdIrAq7DFtZ/VvqBSl3PFfoKKYI9DiH0+BF1vd5fXqnXSro02KXPUzLPu2RnXf5pnkH5zjWpPVWvTtWKws55FO2ZAWHjhoaBDb3pdd3GHn19UZ4+/ZWTw6kDp527MtE7m10wjWHQUYn+yAAAgAElEQVR42uyY3WvbWBrGixxbxRKxQeCL6mZ7KawF1/+AqUbDsrqoxbKkRlZ2fTAFL8EREThjDL0YryF0aMRONwWNwWtTCmHa7LBxOp0lvQgktHTZhhQmSdMEkm2YlnZ60U67dAuFYd/3yOnH0EmTTPoR0BNJlo4sWeeX5zznHO1jfb1W+3wEPhgfjA/GB+OD8cH4YHwwPhgfjA/Glw/GB+OD8cH4YHwwPhgfjA/GB+OD8eWD8cH4YHwwPhgfjA/GB+OD8cH4YHz5YHwwPhgfjA/mgwOTVja9Ki69dGBLr/8SLZYke+M4rL5y2vR+wv6lNUj/5L4v/TZrqrsNJi5qpqqnVTstmTIr17Bso0SxVaJorKTDCVNS4iQNpyRNZ1VThUVX4HmUsGw7WljWSK3O2njIslxKY2uypCqqBlBMIpuaVMvU8elNbccVkKxcRLHTaVNTarKssbIsybpCTM1MO/WSCo8OD7l7YEoicdpWwm5xKaedJG4cylyn7aTiLdFwdFLJsoroxttOsWK1WcVNmMQttFpWC64SE4SIpFVcMVNuciVrpBwn5RKZzbkkQkiBMxOuA4UrNc61V5JGipAEKe0cDDFki1Q4q110XYvUiduEp1pJZkmxneKahETaTmEXwXCORjQnYbktxbJcAw1PNCJbouWWnOSKy7IZq52yZKclESmdssQ2J1a0Cr2qneO4eiLFafCNStohilVJFutsrpRys0mHszlHhUInUllpWqzlVnLxirjzpqQkV1YSIpFaiSZnVxySKxgmZ0mG06qkOSuStIyasYtNKWFolmzA7zSdlVKLkxMSa2lWLWc5JAmmSRRZGzySk8Vcy2XTCRJxDNMhTg6vKjqFYqmYJAXiJkkzVyCVQrZQYkW3VSIk3iKioRrFVrvQaidzktF0inHL2bljUkbLqNTB2IVkyjTqLa7EmSmr2GpVRE5MEpLlauIuhi+kryIpaU3RDDetamqExWNaosqswkKqaWoaizQFd1lFlrIkRb+DZ+AUhIkqqXBaS6PYNHxLhUVLe9+hN2BxT5HTO3eMKkusrMgVoqThj94efh0eHJ8VfxB/bfe666Rldpya3XIwhkvse5NSV3b3hj8DRqqYImtzBsdxIpfLcZAauc768xJFbvsykps2lLhx8B2I27pjMEUyTrFUqtfr/f34AZtSf39/PF6CpUQ/OpstqfTaknq8uWkASHr74oG3ros3tw5Ga4I1i81oR4GoDRteEKJCNCrwgUA0IASiUTNAD2J8SOdDVLFQkG4ZWKkY/IzFYjwPXwQJuBPj8TJBgJtkE5tb+tTF/W9dB7YBhirVjMajuHjieYYRkA3UE2hgzUBYW6glj4UxqlCMjzExnqH7DBNjQFAEf7xAL6J84EYBWPYmmAgaZUP4v4ZVgBVIUArwH+eRCB7Q6sOi4zGQwXIKJcbreEAXvBQtQ3GiEYU9CkZ4gQXFU0ENoaYBrGjHMWaM8WjoIaYjRKLrOt3Ah+elGN/xF3D1bh3Ys2DsaMf7UBf4jwsYEoAAQgWqDo1LR690qm0CIAYp4Ip0MGOgJBCgaBAlQhFi1DWBvQzG44IhCeYI8J5nvGYhCBCr4BGsfwzrjcYIeY7R0Tp6CI7DQI6HUNJjZsykCRNA95nUOEhmr4Zv1EtY9IuA5jejG7GCucFA7wPe0DtQaMPBriis67FQJowKMTyaiJpKD/Fe06MZ5XlmrzrGa0he77Phfux3oIeGygEcHU0Tw8yFFf0TCmUwVQBTiHKh1qF9dgj7Ki9lOnETDeyhpqQaWjKnJYowfSl6vRJ6hMct9rHQmjAqMF0hgnmMk42mxFC3wJaSAYUBErYnikvHMQ2mSwyzF7nw2LD2Dhgpkc1lnYJYY2uVJB3VBTA3vQ4JsAheclI8AeyJsDHRDVIJ6XomDK0IGenhMIQMHGTQNsxG38TTO1IjQpJvDkaquQc+GDBi0yhUUjmZjbeS2JQoG57HlEWPBKlxsBnxngEgYsLQtpCETjvnDLYjQBLWw5kQRk0GeYVol97pkDBivJ03gCm1PxgwClcopZRCRMKmFMApgOkNYRgdGhAf9NpTAHtrOmKjSQwHNbkmP1fNW18qwYINZQBWLYQ7oVr9fTel3t7ebYSv9GKAR6dEMA+AbAmCX2Dl7Sgf6AxL+M4QhhFOH9mRvubeAxiA0dvZ27+wsLCT7hrDF7sRHic/oCBDk0bwOhdoWrRHYpjM4M3P3qxTp2BZ/W519TvU6urqwdV27h2C6QBZuPP9V8/1mydPnvx222BKttctCdiKYKLM4DwaJwR0qoS+wTMAJ3PsuPxTQeN6qS1dvjI1OzExMTs3uzx/d37+h7vL8/PnT/7tn+/GMb2UCQL5L+jJ4tLY2Nj44uLY2Ohoo1r9dgfjGG8aCRZh6FuEoPcqgaGTaBzn4qAOiNUGj9fCGLfQC8G4RcfE1ZkgKHb58pUrU1O3bt3607fj/wBNP9+Mfzk09Eh8u2Aokd6FO1e/Byj71scnJxuNRrWvr7ujxkh31/bBNG36Ssm2PeN4s8no68QcO17D4S8MYijBTDAY8ohM3bqHOr+8lr828+lguWfo0+FbPcP54cOHZx4N9vzw6K2BoSZZuNpBsjQ9vTQ+4gEZGenqanRRTVa7qksPtgmGu3l86/pMDnZUC4UvA5QJRHL+0vzdf398+MZ/gNDwtZnyH369vDxYvpHv6cn3DM0Yvzua2j3H9L7QfpokYJOv9n2+vjS2NN7o62tUF89MgkO6urrHRsEmXc81sm3HFMvl/jJ9ubm54qXS/StXIEEmYDM7CzkyO7d8/uTJE2v5+1NTc1Ozc3OzU4Vfzcx8/NHA2tGe4XJ5cPjo0Z6Zyh//fHZXMoZ64w6QuPr4Kujx44cPHz558GBxfHSyMdLXuL1+fXr9zPri2Eh1CZ2CjnlJ3VsCo6VMLaHZRYVOCWi+4AAX8wWUyeAOzBC9F5fBWhC9ARiWl+cvge7NXzrxly/X1gYGDuWHTpcnpn58Bkxm524M5QeOXZs5dOjc4HB+qGfocD4/PDyz+vffr/1yx3gR8vDB06djo43G5CjNU1BfH0ZJ39Li+l9vn/n89ni1uxsgdL3KpHsEli2BUcwKFzGMYpJVuciLt1Q87ZvxvQKO83Q6VwoGAQowOX/io0/Onjt79tzAwNcXjgwMHMsPXBgsT6FZfnz2bO3+/Rs9AxdOD5avTc+8ovH5e/P/2twx6sEDb6Ry9fH/nk6PVikGqHi3V38kMDJaHW2MffHF9Wpjstr9Cg9oS6jJ0bHr33zzYGsj33jOdnLZApslOImMd4YyAt+ZEsGMOUPfQgWAyvyJEwMffXIun88fAUtkB4/01yP95cH+Y/8n1fxj2jisOA5rugx1EFGFOR5y/qC25fwQgUSKWe5ykNCqqnqhUsVVuzQtDXdnOC8hMlUOJ1g5H66DEPYUaowDF8iEIIANs2mNCHgjckqVQqggPxTQhoYzJ1JY1mWjpZ3UZto7m1Ag/DD0xU4E5J/75Ps+7z0Cc3l0/PF45ej31+x2KjM/85DRyPhHZkZG7ty5fueTSF38pL2vr33VPWbH3r/+etUGAipPOqFbfrckCdGq6K5orEjqbO1P+jEpEfm2dXb3tkqlVkj1r1jAHDvecOzssS1HX33WSvP/UwAj+8UX4fVzmMDSxPn0UaDF7e4x2DmO8VOCkRMEwWh0GkuEPAY+ymOcQiUD84eyv2bgOMEwdf++x+MJAI1hURSHh4dF6bXOBW9OrdFF7Yt/fDPRuAKUKAXpt2dfl5BAdLq7x3oTIjwUCYoEqWIDM38QLPxm+AuRZVeyiVSSZT+9Nm1rcQsMPL3A+P3OLU5K4EoEgeMoygnpYASm4X37+GgoBMGZ6vAEAp6hgVvD7e1ABed5k4kvK+PhT7FjPWDeew9sAmb9+htpaY379l7/KlTmcDR2V9TWVlTUVvR3do+1qiNMEhZVzGAWLXhRxfzsly9Ijm18WtVRZbM9YllbU66BEig/cBEoQON0QlqgnxgjxzkNbifzvpEbH/3f08GBoQF4tUM96IOsWBEcN/OYCbWaTTxOoGLM8pWi8sUfv5to7a6Af/c22Fn7IzpdvSo6x1xgkdbW3taE54j8BDClpZ9/XhptnNFQFcHmW7qIsrKrXe68PIEyGAx+iAwj5YTZVVIZaSeD0y5U2o1Ot2BgH4WBhdVqJUWaFnERx2kcwRGrxYyiOE3itBVDh9dODJx5v5hrnP/2wz6SFO2KtaFIf6+tt3Wua5aHsjEwo1/+8P3o/cfX7o9em4bJg3ttXV1lLS25br9A5QkctBEHUgHzMgxjsNsZo9MgUNBgPYbiKbDJQF+fSPModAzN0yhGIxjPYwhC0jSB0eIwjlsR6xpgdvz+639/+/B16dj77gn4JGlTbcXSZ18BCTi2sW2sdUUeaqgNgpl5Onr3Lx7P9QU1IYBZYQXJc9qdTu7al6Ulds64C4zrZMC2grB3vGM85Lk7zbLQPcMiTwMLE08QOEISNIIAGMCBh1k2yHq9oGDausaCd/beveaHD/9+r7uzYnnLdnbXLiUSmcMglF51wspYXI76eocrQb0RMBl3pjumL3l856ouNF2oSj1ZPJXtE5xOgwF2EiMMntLH46AWUM0Wzt/jnAqFPIMgFCgQiuQTUqKCYjyEhERJQIJbaVCMGJwt15bfnA2yYZH2rg5mx8iE5JLapBUl2xY9eiJ0ICMQkt75Obxi8ySoHTVKpTKuptnhUqvXD+Y/5wuw3MB1gsjNhbWNc9pP+mD2cHAncOBYgbK77UZ7cXGo4+qFjsDQwJA4bCVQgIBbSWBBYCa6CDOJIsRFpEmSxEkrTuJ4eDZL96H2THK6/jYbHFwjMSNtm1aXyZxxYOrU1nYCk4SITxTLts6CvMQr46RSKmua6+tjAbPj8Lu7P2rYcVr6uaGMrqKirq6r11sMFHXIbgSNbPExIBUYyZy9spKiDNS5wFBgaCgwELZdJUEjKAGzxoxZzCaLBZNUgphN+LDXGw7fsIkiiuEojYjB8v2X3tS9VpCYfESvb1pDviP/XNOvSf0wdmDw9PaubFh1ggtKMQ+nPsolyub1mL5Rdbj4D0dTU186++rm3af+1tXVFRjxUQboF4YzNpQW+/ycYLcbBD+4xjnugZi034KYWExQKFDAzGZ45UMDwfzBCAtqRkQ2OHvzZvUsy05fonGavwFgcrNO5BYkJ8vliedX//mY394BMLX9tVKvPP9Lap627l51NCSrtI7a0RwPBelwRD52xcctqNjAbD598YNdx9/N+GjzruNDxAXPDzOfORlYT2BB8RtO+mD8uGFClzAdIRBKe581sq0BDp62mnkzDv2DWYgiBMV5nEYRDEXDQU3O27LtKq2+msVJBLPNlp/Ll+8/kZwjLyjUrAGm4Ul/Um3/Er/OhwW+0rvaHJ4vV82zzlE61BsEszs1I+PssaMvvQXj+lQVVZw38xljN0AHGRmupNiXxzF2zjA+R4VEUeBgRsEsOIqjCILkoxAZzIx0wQgSMRME5lGdJie9ID8za6f2TzbQjO12Xbn+SNaJRHnim0fWACO1EkQjabkO2tQYzUos1TzfOcoalxSgjSTm8ObNb0WvgoweP9PAfOATAIsANw8jXPblUe7s0F1plX1wi7CUlaEWAjjwFjNCYCRBWDIxWFVQiA0JpsUQHd0U1OYUFGTlb0uR7dEHYcebvlBYLj8iP7gn+eUTe7auDWZZrzzroNhKUbNAKfXqBPUCxcQOZsGCVwwXsTDju7w3+1R2NuXuEbJ9M6HBi46HD6/MF0KgiAnT0WSTJFudCUMwMDB0FgwghDRhTWydVpVTdkim2qlS3QhbTdO2Qm25Ni0zMfGVA+cPrh8MTKC2seU6SDJr5L0qmLh4xQYT82Ol9nANRnvqxIRvrrqvT0BU3nhDRBCUtFjKzPTHV2DHN/NNwTCsbHBB3bDZCBQz0zCyMSuO8qhFx+p/k6baulX1iky2TzdIwidM5RqNXJ5y4ECa7uC59YFJgpswcvU871eFw1EPcnVEp08E1DKtBOVYGpl1g8nIsFOwwLjzTu/de9oQmg4MSIubdXISl04dAjFjAAbHTYSXra7WabV11bavbLfZsM3rZVkveBd2ftTKFup1ySmqbSkpO1WFg17SYrtRqNWc0WiKMhPz31lPYoBK55h6+emjdsHDK6WlTZo+9S6FwuVwKObQLOKgbF6aofWDAcWUcsZf/dlJTXlAKw8ipw8yOYlCo0iuJfGWKwiKwJPqC3Xp6Xp9XaG+wHQJclN93saCf0XSgrI6rUaT8or0VqU3sRYLwn5VqD2jke8/eKAssygjVjBJcCi3rqQVaZNd8OzK+Jqamvi4Gof6eTDRyDh+UmL8nFGgKnPdW+6HISoICbcOz0tgUJhCBKwq5MdXMNQWrNPvS7OkFWXlJKtUKVo9lGZb+oesFzFbLU2Dupx8jUymBTD70guDNtTqZU2F2sTERPnLBe/E1krSbtvWq1jl8qlZ9OgSnMi7PtJV6kWtpGxWLI7MRhJDVT4OBEIeGM0EYdaZTARcyJOTPBgXxTA4fQAMHqzTymXlBULatvSU7dt3ymS6AtnO7ap03W2Qjm2wCclJk/2fefMLbePKwrjzVJZwCXeYy4zIeEbM5JrJBM1EOzMajf6YcRR5TVyRjWRJOF2srQhSJLSkoQXjyKQCrRKHit24ASXpGtGYJoQ2xq9Zsl0wGEz3YSFh2X3YdB9SQvOyD3ko+7pn4rRNmq3/bFOnFyQ08zY/nfOd7zswGtwmIq/r/bVuf/Vxv1VHKIPQGLuwKRjf7/ur2aHBLc3j5+nsm4ekOHjpO3eBzPUH2wZz6MjhX772W/8NgoOffXKn9tmfb9+9ebPj25NZkI0T8RNQMZCEhuPx4Q5UzInltXqdwxWmJPN1lXI60TxP00SN1sv5C91uv1yhHIwkICOaVG/nu6uP7lUqdSPJGI1iYFONuXXr1vrebUMDt2vg+w6IzvwLN+cXH85vt5X2//rM7uMnj0MkOHz85s2/QEqGb/D2UCGJJzEZwEAgBGmJg1d5/8bkas+bFh1dxZiohKNVDspF40RN1Ot6vVzXMdG4UJgSImpSsOhVWq32RFVnWCbEJmMjH28M5vCHlzeOyf9LQzY/vkhvF8wbb17Z+6s3P4BI8MaVu6//AUoEpksi0fITYALMyfCJL996F8D4Fm4y8f6N5ZW6XsXYAYV14OkplAf0ExSI/6EyK3I8XEpwLZKkLLlyWNZ1D0NQagQCkfDGGrN/z38ub9PA/R9na2AO//zU7lMfnDkOBnhvB9IyWNrE5GS+nZ8ejvs7yvjrX96fjbd8iUnEAUx3rY6rDgUuKg3zoCQcw2imKfpgJD7NKpxpwm9R5JoqKLNh25KEWMiPrKQcizCbie+Zyy/u3YZelN6BHx8M/E1HoY3813/23l1a8lcJkJNbw/H2sm/hal8s379/It6O51t5SAA+mF69ohKqOigCFUM4zpM12eN8MJpmi6ZpCwp4GHFUCNmKLdkIRdyIMmZLSGJZezONeet5MINXr/oebvA5OkMbSMzLBPOt8/0jiAoEH2ildj7erzWdZvPttdqHN545v195r9cDJwslg3WOckQRqSnyElX8ASUCFzhKhrKjo4KQs0UJObSQlg3DQOl0IIm2B2Zwcd3D+fsDcPZPDdzQpYEdBvOv7nJ7Ke4v5CBH13pqyVOxM1sOT1+8c6f7t9sf3Z1eavfvlcs9xwcDlp/jAqyomIJrmpKCOVGRCO8KohC2xixTkxRRQ4ZEDFsZlWLWWCxZNBY2BfNscXwtsutrycX5S+vBaIda6Vswq48fP67FOx3IidNr93SnXjIQxboul2Zny8srK/1Wa7i/8m65hylRA0QzCZuOhqamBEmylQa2QiGJrXicatsj0QlmVBJoRrVnDIk9FmBcKxZLxvCmFbP48MH1r539pRdGy9XLT3LjTojvswavX4qde/RFZ3Ipn0/UyjotT4N4KGjaIlh3Wp1+t1Z7tNpvlXugLZ4HjWSnw1K1Kk9n+aglB8atkCDEMlA4NpVTWQ0hmh6xx7LeMYaNnI1Ou8HcaGQzMO9A5zz43qm8b5efG6/usMYcPH0+G7ZWluOJu0vx1XKA1KMQ/xSJ1UFiNVKeLVXy/eVEqwwTyYvAqDZDoVS6EOXT6WAqhqQcCQomkjhFMb20HLKLLsPKrjWuWLI8MaHjQKaX2bRi3vFLY/GFTe1zdbNvhzXm4LlryTDTqLU78eHZWmWcRCcCwIDodfgCu6JxuF4ulz1wMBqjU8hCVpRRsqfdaL6I0JyTsYMsQpJtCGwxnM4GEKuSYggzjJd0x3FIQg1G2QoYePonaXDbPu6lgtl/5PA343pZmrAYr9bP5zul2kIJE4xV6JpSSdN4qqqagvzxrJAm7zUdVRNCCstkrfRI6qOig3JYyeAgy1qmomgmIwgMUbGqSixmSw0jiJIxZqzITmwNzOKrB3PgyoGnBu/o3guRdsSqd7uTneHKUq1cxr7n13VCmHCWVzhOljXwLw7pNT2wvg7heUHIFqRUOuViUcMooEK9CIIpGgGMDdFkGJcSlOQtCzGNt8fH9Zi1icE7+hTM/OBGWXFHwBw5+bvd65Fgz5V/lFPjvLdQS7TbE/l+rVJ2MCHgX71sITJCKbaIqCiiojX/1GvCo2NqYImxhKVoIeuGZF7ADhQJDG9ZsKUADsA883Q2FvA8yw0xseRIFvGbRIKT//zF+j7y8tCPR2aLYPacOrMeIl/7zem0xYTC1dVEeyKe7/Rrs3XsJyIhlGVFylEqyLwosWBsm1AvHFXMrC7x1agshwusOzIyZTMMEtxqOu0K9ijLU0pMGijVA7wbCzgZxsrZ3NY05qnI+A7vlYE5dODQN2uHixgzoWhlrRuPt9ud9upypVx3iGhZXlTWKc/zMiRqFfHW+WvXTGJQVhhJZSMXC2m3WsdJORwMlqjJeEhxdTdr8RCaCLi70SBospRhjJlG7tPCFsE87aUfanJfksG7aPA4xpaqteX+7S64vdvtiqdykkg4vu6YIL+Ygum3Tdtg2FxTyQWDbjopRKz0OW/ur2PVvFWUeYVHKuElKRkyDaI2mxAgmk1i5KQg814vZ5zfGpiBgas/G7o+dP36D7QsLwXM/r0XG0UvVoykJmqPHj+qfXKhWtIxebKN0+xR+Pc5AppLNM5Rc8zUNUVBbBDzpsQWAp9+9fnMOTlaKLIowghBKSdJY6xAKSsZ6oxhE5WMirYwdwyf2yqYXfMP/v7QX+T+BCrm4AKOBWKCVcrnqxPtac/TScDPhJiIomhgDZQYOsm/EFEmGi6C3ARjAoOCxZGZf3/+FYqMnC3gRjrEsz3KJnOs12DdaCEXRAa0koA4aY4NbhnMd7dLrxaM42AEYEqyy+hIMXTMECgJniLepmMKNRVKDY4i7ASm5FQkxLDpgssYfLEwPrOwIKdS4WpDCo7xrCEqQYGfmrKxmskwLDJyseT4XITNBc9uHczAroGfCBjQGATyyzAwTzBHVSwIsocVHhNtdG5OFEdFDSTmv9Saz4vb6BnHewt0eA96ec3oZYXftxIGZ1hZUfRj9ApErPXKiAhtK8mRIAlyNqHjZXAIE5E1ZoqhUGwn7tZhD0MPQ9th5tKUoZed2wzMLYeBQPoPLEsDOZSeS299J9DSU3d7GxthXmR8+fI83+f7ed+3CTSAKylKQleAjwJTLSyEoNx3HN93zbas2ybRGqIKah6fRfwfihrt0SSMEMA4+/b/EOZHV0WYG0eiUsMYAxC3GwJWjIYgMskgjRqf2nUqddc3FKlrtk2IwiyKefIXaB6MBrZFFAFEI5115qozMhE0kFSYgXynDSSgKKoNXOpFIk3o8WR1hPnp9f8c6vdEyGObAMSUtxK61AURJIIaocMGkSxeMkYN9R/u7mIggDFQLGVclaOBSBQtU6J3AyPNC8cxQEQkGDzKGc/H3JNqoBkDrXIdR529/b4Dt6sjzNMnv3r85P7dBxyWbkxShnhg5cMWGdxb6gaVFFEsIpo6KlM9pDKz/TByWeFWVDZbNFqcDkN17iLGaGG6SFUZs2XR4YVCGAtMzlrj8SbWkCHxECSGNIynKyPM5795vPb085u3fsaRYIKB62Je/EbDlbpE6hqI1F8cHi75wz+HH1aHH1bLf14u/uunf39fvjoHmtJObdGwkNK1tMqyeMmE8aK6yKY/DAmugDBrNx48uLxqdptDZI8bDEYopIZSFKJACDCM7vmLPM9nP9/5apb6geM7/X5k8zf+S9+ezfJ0dtTZCWb7+1/6tp33cz8Y+S8ON7gf87JTdrUsw8AKrcwq0mThZvP8B0HkVRDmk5uffnzv+rOnHzxGgS7ykNKSg6LIdaLlamPj/ESUkaiqHJpbUHQFwdxuWpZHEAZmm4c8EdptMh7f91yN1L2eqprfHG5we44J1BAFLiGw8uZ24ma5PLR+/ccVnEq3JpfbtghAO6eabTPPDkwBnJ+YaZqLRhs2gQsF3O67uAIIesBKA+YpXclMo+ygCyIvI8dv242Nzw6BRiMJEzLd6obALQDJnL4WZ2GV/Xklx/WkoJImBU6n9qbScwhVy0Db709EfcQQhBigqB1vV5EL3Qrj3fF4rJk2XO/WS7jYrGtDh0iekmHts8Mm6dnACxfafBwTGnCm8nsadufD7HerKQyDEIRpT8veRHPYFhBDYpMLw8vIjcLxvsOgH5goobpfxQCP47F4uX+1kZlbAjkrjvQutpLKerTUJLXw4gWZD7ezLJFNmgzuULglUfp8NYVBUJTVznD8ppcTkbWiVgtuvH9lIYu1TGawAiHPz5laOEFJQUa1i8wkhBhvkiEptvYLH7pQGmY7Swu5/pYyn0OvtAd3Bk7uBUEY2vM4f7mKwtz6FkL2aKZZycscMbfI25sNUj//OouRr6q04DygBq1u5uwAAAw/SURBVJ1YDugsYHbc6rNE4wFQIot4u5huKYS3Wtc7OODCdALdJnE7haqOpj3fll1gHzu+XLy8sZIVI+Vl8NUb6qQAF56ISp70189P6kMkzcPheHe9i6HYSlOa6unUNEUMUamasBnjsqC9FpWIlfeHyjdLy+6ZeqTtQy3hvZlE4aQ3zt86fpBMVrSVgiIFD7ciUWQFEMQWD6zcY3b3OAIsTnfrlgYIZPk4xn25p6ceRixFMgSxtzMYJrAkkT7Sg4e/XFpuS72TfYh1CaKT41R3tiw1Raq+OsLc/ujuFw9ur93itHTjuVTYNlQZ1yWnXBQPAoHnmLokwRZtITKkJUz84629qmkUdBxzmlaJKGxgi8rhIAz39VHQ+fL5q+VBqDpqnmDXo3LllZRgU3dtG2vj6coIc/3+k7V7f/j92sfX7v12EvYGqF8aBtRTiZYlbWw2uucnXdezurbKtFMpi3IPSpeXGsBir9XfcnTOnZpVmiWd0uOer+v57O275Vky8ae6lCSy7nte5SZ42pMBBQj870P96zf/cXVaae3Z3cd3b929fe3TBxOVFwyl+Q5aB5IaBLS2KWRcGA6HqZ9vK4vkbDpqYS3R3sxPjYODbmtTEDUM1y+3bnS/Z+edjp/7787PKm/42u4MAaI56SLPSyqQe2ZLIP73XTW7OhXz7Nqzx598ce/SY557HkCemLLmHlaMUkKNjW79/Giv1Z7Nyn1P2I3LxBQhvHj9179dgNff3T8QiSOD1vBhTyx02w5YR+84/k+W2aIvhrYTDaK4ice1ja412xm0cby7OV1N83UhYZpFVSghxDommWuYe4wsza0qHM7BHqYRJIZZLP5yVrVe/+nHZ76cqgxi2RFV23VnHCGD3Pl6yYOzLQ2hPZIRwUKzthH2twTFUjRtfxVZ6aMj1U4ZymnQkUom0Uzb263VeSuVRaiB8mCxwGeq1BAiPqWHWr2e0dwJmJrrQIb6oK2yfOQf+X7nxfLC0ycdJLv9nlDXOFpnAGjjeNSfyis6ricvU5amRVgUJVVbu9x6qXX+qk73993FXDvd63rVBQWJrIrorCyhG0FT7nCwHDn9thvItOfv+PrRybJrXQ5uCMY1GrrkotqMI0lKU3ta7a9k8p2YiJbzwkUIuNu/2GuWUob33p9kPMNK7P7i75vz5DSce4wV/2LvjELbRu8Afn0YgxoRbFxqYRFrcsNKEtlWIiuyQNiKak+LEK1sJQ6KsR0PLC/IFxoRjNMje2hw7DNNvWOUkYU6JnlJjly5uxTM5ty6l94dgUDCsT0cLu12o5TSlzHYmpdNCV3vYnttUq70Cv77QfanT39//n3S//v+8qf/H+7ssgACzqCQGjMOOBFS4pekTDCnZNZZdn2FYoiwWSIRR4DXbrhpXydN2UXd4VKdbycYlkEICgeM6kSXSbhitIUEt6P7zuY82g/TaKD2xA3ToYoAoqj4J3uABsEQ7Ed4PHGwVtWYkHCYIGIKts6sPt1AWJLy4ybRGVKj8AjK8YK7BnKqOLL0lhpfZRjzmQELBA3ccKvXkC5n9xl9gtcfMBfhK7VaBA56lhwOowMQ87MbVyFRIDCcv2KB/AhOkogZgmiMlCZKT330EgRQBKTV8ts8c5n3YzZOC9Egxe6+nb5Swj9CqBMmj9GpReEE0e0Az595eLsb8qBooFgTItGcphsZXuSqt24moO2iuOPHr4A2QKC4IOKhzShJ+nLI+0+HWTebEJKYTgMQczStJEM1S0QA1MBX/3jjYM799ViBdS655p6HlJw1IXwyiaM8WNTyDlPFw3o69VGp003geLamoZceFIu1pa2QJGlqMiDW+EwM0zRY0/ispgFmxEexQQ+Gr68g7O5VwabcorZQlC+GVCRBCxUVFEPiV/E3Debczz4+Vigm17gh/iwI6fgSH3OEK1tCsfheLNBv7LTkA2D24e1KJ0eaipojP7q3k4dhi5Mdtud2g4IWxoJS0g6AURanBQlHcEB3Ewnp9vVZ//AA4GaIrahimdfsdiJh3hIFSkALH77YJZj++esH8+vfHwuMNT7zPGxtlcxXQqKjP2CKkRNGMBAImI3Fh5uVTpufqtW26bmdGr+1bVNHGBN9mSFxP0YoGQxjGJodwTcYJ+Cg0Uwssb5CEgOAIIRUAE0CnOYWaSm4UxRBjnpUeFnY2tcP5s+/+fdxwEzHe8aeBTr2svlYvV4DQjZbNGqZrz7ocoSh/jubnZawxVR78jf4R3lAC89LCRvj8UP8hMKyCsmyq0wyTAm8EpYUAaRLyYHN61gMnDDahCxI+4z5oii4EVo1qRpB/PHN39o8LpjvDtfXkvX6E60fikY1Hnr3l4/Afgg/sDFdwLVgsV7fCnFUSJRmBT9Do2afA8NYfXjGFYLiEnlGCbKrgJ25muzcXCGDnIUy0QKognCectI+wEkFYQW5/OD+mwZz7tzfTxxS0nWzXjdXtmDuXbJIRyN724k8fgCm2wmG54v1/akABfgTEGgigyQrUgw7y5IkNoshGKusop4cy9IWQnrPXX2qoGpANNLZLExluVyOMusGRo1GIXHpDycBc+rU6zllThw58Vadj5qE4ud5PADdvZs3wRUe7taNL9wFQVp9/3HEgTK0iksekt0gFYzjiBxCsrNoLibtBm2EPirhgCdhvr1CbWuACNL0tgiZQY7BzMgIr/IcB7uXTjKP+eijH4gT+btEGHU8qYuwJZr/9NO7+REGjuoz37N02FHh6/v3IxaCRWkCwxRSUnKShCFJBcF5blVR/byKJdwWAWCw4OoKIoo0J1JmjqLhIKISIzkE5VVa1bgTOZFffHHuBzLBC6NRaIKej1mMgbuPp9Bf1XZg8531syYYj3L7+4+hTsHn0cfoIOnxZw4uI5I2BRGM21idzZCKlNO4CSeRE0vXsxCMsiqNmJyaChMcN++PXZvXQLOqzp7gtsPrWmv2CmAsQXMo78kgpDFQgXDTk5rocDxcB0NQODr15f79pWgxa8T8LGLyMBmEIQlcpHASj7HBTCbH7yKaiNkxQrx8XQyHeXSJmCWAooVOSmRSP8FouLjNmf/ydvpKIGDxOEwo5gkYA3giX4FskP3h7TN2p92yNfXho2J0aRtBzBkMwli/b2RDIjOqijMKiUk8b0qYRV4aMOPE5opE0oLtmu4RuMEQDWi4PjcOU+G9z/PRt/IvWu/SWbvHZ7ZYKls77pA07NjKByZCd953u8+eP9812rtzo0vdyXT5MDaKeXb2ggTGDiMKQusOJG6xZ89n7XQigdsc6ysxNXvw/NYAR8Gq4BTMplDWrTr39jrtL/euTz2Xd069c+p1yCs8+lcoVaul0i+sX35WXauWNqqltbXC059UC17vWolNpQqlwtoHpVJ1dXW39GF1tXrvXqH6TalUKOjH3bp589bNwr1vVguFD/75WVWvWiqVdCWFanVNr1BY07dr+rEv8ZWWf/p9yX/+/65/nfRS8vYdylhfR9+34lp+Vth3ZDte/k7NjmcHjM3Ihx8Pq409PyQ1/lxbx+kXg4mnO1qIYbKvVfFvWxX2LRhaFafHv33fc0Iw0/9LMXgkmeuFqdbuXksVvb0N1Z5p/vFxZbplItmh1jhbq73UMlXvxZ4Xfm87rfMrgBma6Wgq64j3eq29crmhuJxKxXvj6aO9O+jqG53sGZsZalhvGB+1unpb6G4lgwbXxaYFi4beAwWNCSYjhsWZOW98sKGyd0guRyYbTo9Fuacs9zbrPh6Y9KLclK7zotflLS9Py0fPztMLC9ax5T7DUQRjn3jjU5PytPdoUyfHran0cs/MsVKB9qSto01tsLoOFRz9VRfk5ZmpBVdq8Wjnfm3wjhkWInLTTSfD4nKHde6VwJTTzY0vy3Nxl9y4Y3H5E9mrvy40dIssl2U5fTSr8sVJQ9xqlVMzx8o/GzHIvU0dZogYDE0K5ia/XijLButRCzi0YJXTejMaxr64VY6nZZc89EpgBtORprJUemixYzDVaH8HT/eUB8sNtu9iefqCd+hSuoHudOpC31gr3S1tesdY8/QqfajgUhPEOe/gYrnBWB+2Vm/G0dLRdO9UarBjsW18v1fj2wbTljaYNpg2mDaYNpg2mDaYNpg2mDaYNpj/tkPHAgAAAACD/K2HsacQQowYMWLEiBEjRowYMYgRI0aMGDFixIgRIwYxYsSIEfMInJXdHv3f0WUAAAAASUVORK5CYII=)

Trainable segmentation using local features and random forests

## morphological_chan_vese

`skimage.segmentation.morphological_chan_vese(image, iterations,
init_level_set='checkerboard', smoothing=1, lambda1=1, lambda2=1,
iter_callback=<function <lambda>>)` [source]

    
Morphological Active Contours without Edges (MorphACWE)

Active contours without edges implemented with morphological operators. It can
be used to segment objects in images and volumes without well defined borders.
It is required that the inside of the object looks different on average than
the outside (i.e., the inner area of the object should be darker or lighter
than the outer area on average).

Parameters

    
`image(M, N) or (L, M, N) array`

    
Grayscale image or volume to be segmented.

`iterationsuint`

    
Number of iterations to run

`init_level_setstr, (M, N) array, or (L, M, N) array`

    
Initial level set. If an array is given, it will be binarized and used as the
initial level set. If a string is given, it defines the method to generate a
reasonable initial level set with the shape of the `image`. Accepted values
are ‘checkerboard’ and ‘circle’. See the documentation of
`checkerboard_level_set` and `circle_level_set` respectively for details about
how these level sets are created.

`smoothinguint, optional`

    
Number of times the smoothing operator is applied per iteration. Reasonable
values are around 1-4. Larger values lead to smoother segmentations.

`lambda1float, optional`

    
Weight parameter for the outer region. If `lambda1` is larger than `lambda2`,
the outer region will contain a larger range of values than the inner region.

`lambda2float, optional`

    
Weight parameter for the inner region. If `lambda2` is larger than `lambda1`,
the inner region will contain a larger range of values than the outer region.

`iter_callbackfunction, optional`

    
If given, this function is called once per iteration with the current level
set as the only argument. This is useful for debugging or for plotting
intermediate results during the evolution.

Returns

    
`out(M, N) or (L, M, N) array`

    
Final segmentation (i.e., the final level set)

See also

`circle_level_set,` `checkerboard_level_set`

#### Notes

This is a version of the Chan-Vese algorithm that uses morphological operators
instead of solving a partial differential equation (PDE) for the evolution of
the contour. The set of morphological operators used in this algorithm are
proved to be infinitesimally equivalent to the Chan-Vese PDE (see [1]).
However, morphological operators are do not suffer from the numerical
stability issues typically found in PDEs (it is not necessary to find the
right time step for the evolution), and are computationally faster.

The algorithm and its theoretical derivation are described in [1].

#### References

`1(1,2)`

    
A Morphological Approach to Curvature-based Evolution of Curves and Surfaces,
Pablo Márquez-Neila, Luis Baumela, Luis Álvarez. In IEEE Transactions on
Pattern Analysis and Machine Intelligence (PAMI), 2014,
DOI:10.1109/TPAMI.2013.106

## morphological_geodesic_active_contour

`skimage.segmentation.morphological_geodesic_active_contour(gimage,
iterations, init_level_set='circle', smoothing=1, threshold='auto', balloon=0,
iter_callback=<function <lambda>>)` [source]

    
Morphological Geodesic Active Contours (MorphGAC).

Geodesic active contours implemented with morphological operators. It can be
used to segment objects with visible but noisy, cluttered, broken borders.

Parameters

    
`gimage(M, N) or (L, M, N) array`

    
Preprocessed image or volume to be segmented. This is very rarely the original
image. Instead, this is usually a preprocessed version of the original image
that enhances and highlights the borders (or other structures) of the object
to segment. `morphological_geodesic_active_contour` will try to stop the
contour evolution in areas where `gimage` is small. See
`morphsnakes.inverse_gaussian_gradient` as an example function to perform this
preprocessing. Note that the quality of
`morphological_geodesic_active_contour` might greatly depend on this
preprocessing.

`iterationsuint`

    
Number of iterations to run.

`init_level_setstr, (M, N) array, or (L, M, N) array`

    
Initial level set. If an array is given, it will be binarized and used as the
initial level set. If a string is given, it defines the method to generate a
reasonable initial level set with the shape of the `image`. Accepted values
are ‘checkerboard’ and ‘circle’. See the documentation of
`checkerboard_level_set` and `circle_level_set` respectively for details about
how these level sets are created.

`smoothinguint, optional`

    
Number of times the smoothing operator is applied per iteration. Reasonable
values are around 1-4. Larger values lead to smoother segmentations.

`thresholdfloat, optional`

    
Areas of the image with a value smaller than this threshold will be considered
borders. The evolution of the contour will stop in this areas.

`balloonfloat, optional`

    
Balloon force to guide the contour in non-informative areas of the image,
i.e., areas where the gradient of the image is too small to push the contour
towards a border. A negative value will shrink the contour, while a positive
value will expand the contour in these areas. Setting this to zero will
disable the balloon force.

`iter_callbackfunction, optional`

    
If given, this function is called once per iteration with the current level
set as the only argument. This is useful for debugging or for plotting
intermediate results during the evolution.

Returns

    
`out(M, N) or (L, M, N) array`

    
Final segmentation (i.e., the final level set)

See also

`inverse_gaussian_gradient, circle_level_set,` `checkerboard_level_set`

#### Notes

This is a version of the Geodesic Active Contours (GAC) algorithm that uses
morphological operators instead of solving partial differential equations
(PDEs) for the evolution of the contour. The set of morphological operators
used in this algorithm are proved to be infinitesimally equivalent to the GAC
PDEs (see [1]). However, morphological operators are do not suffer from the
numerical stability issues typically found in PDEs (e.g., it is not necessary
to find the right time step for the evolution), and are computationally
faster.

The algorithm and its theoretical derivation are described in [1].

#### References

`1(1,2)`

    
A Morphological Approach to Curvature-based Evolution of Curves and Surfaces,
Pablo Márquez-Neila, Luis Baumela, Luis Álvarez. In IEEE Transactions on
Pattern Analysis and Machine Intelligence (PAMI), 2014,
DOI:10.1109/TPAMI.2013.106

## quickshift

`skimage.segmentation.quickshift(image, ratio=1.0, kernel_size=5, max_dist=10,
return_tree=False, sigma=0, convert2lab=True, random_seed=42)` [source]

    
Segments image using quickshift clustering in Color-(x,y) space.

Produces an oversegmentation of the image using the quickshift mode-seeking
algorithm.

Parameters

    
`image(width, height, channels) ndarray`

    
Input image.

`ratiofloat, optional, between 0 and 1`

    
Balances color-space proximity and image-space proximity. Higher values give
more weight to color-space.

`kernel_sizefloat, optional`

    
Width of Gaussian kernel used in smoothing the sample density. Higher means
fewer clusters.

`max_distfloat, optional`

    
Cut-off point for data distances. Higher means fewer clusters.

`return_treebool, optional`

    
Whether to return the full segmentation hierarchy tree and distances.

`sigmafloat, optional`

    
Width for Gaussian smoothing as preprocessing. Zero means no smoothing.

`convert2labbool, optional`

    
Whether the input should be converted to Lab colorspace prior to segmentation.
For this purpose, the input is assumed to be RGB.

`random_seedint, optional`

    
Random seed used for breaking ties.

Returns

    
`segment_mask(width, height) ndarray`

    
Integer mask indicating segment labels.

#### Notes

The authors advocate to convert the image to Lab color space prior to
segmentation, though this is not strictly necessary. For this to work, the
image must be given in RGB format.

#### References

`1`

    
Quick shift and kernel methods for mode seeking, Vedaldi, A. and Soatto, S.
European Conference on Computer Vision, 2008

## random_walker

`skimage.segmentation.random_walker(data, labels, beta=130, mode='cg_j',
tol=0.001, copy=True, multichannel=False, return_full_prob=False,
spacing=None, *, prob_tol=0.001)` [source]

    
Random walker algorithm for segmentation from markers.

Random walker algorithm is implemented for gray-level or multichannel images.

Parameters

    
`dataarray_like`

    
Image to be segmented in phases. Gray-level `data` can be two- or three-
dimensional; multichannel data can be three- or four- dimensional
(multichannel=True) with the highest dimension denoting channels. Data spacing
is assumed isotropic unless the `spacing` keyword argument is used.

`labelsarray of ints, of same shape as data without channels dimension`

    
Array of seed markers labeled with different positive integers for different
phases. Zero-labeled pixels are unlabeled pixels. Negative labels correspond
to inactive pixels that are not taken into account (they are removed from the
graph). If labels are not consecutive integers, the labels array will be
transformed so that labels are consecutive. In the multichannel case, `labels`
should have the same shape as a single channel of `data`, i.e. without the
final dimension denoting channels.

`betafloat, optional`

    
Penalization coefficient for the random walker motion (the greater `beta`, the
more difficult the diffusion).

`modestring, available options {‘cg’, ‘cg_j’, ‘cg_mg’, ‘bf’}`

    
Mode for solving the linear system in the random walker algorithm.

  * ‘bf’ (brute force): an LU factorization of the Laplacian is computed. This is fast for small images (<1024x1024), but very slow and memory-intensive for large images (e.g., 3-D volumes).
  * ‘cg’ (conjugate gradient): the linear system is solved iteratively using the Conjugate Gradient method from scipy.sparse.linalg. This is less memory-consuming than the brute force method for large images, but it is quite slow.
  * ‘cg_j’ (conjugate gradient with Jacobi preconditionner): the Jacobi preconditionner is applyed during the Conjugate gradient method iterations. This may accelerate the convergence of the ‘cg’ method.
  * ‘cg_mg’ (conjugate gradient with multigrid preconditioner): a preconditioner is computed using a multigrid solver, then the solution is computed with the Conjugate Gradient method. This mode requires that the pyamg module is installed.

`tolfloat, optional`

    
Tolerance to achieve when solving the linear system using the conjugate
gradient based modes (‘cg’, ‘cg_j’ and ‘cg_mg’).

`copybool, optional`

    
If copy is False, the `labels` array will be overwritten with the result of
the segmentation. Use copy=False if you want to save on memory.

`multichannelbool, optional`

    
If True, input data is parsed as multichannel data (see ‘data’ above for
proper input format in this case).

`return_full_probbool, optional`

    
If True, the probability that a pixel belongs to each of the labels will be
returned, instead of only the most likely label.

`spacingiterable of floats, optional`

    
Spacing between voxels in each spatial dimension. If `None`, then the spacing
between pixels/voxels in each dimension is assumed 1.

`prob_tolfloat, optional`

    
Tolerance on the resulting probability to be in the interval [0, 1]. If the
tolerance is not satisfied, a warning is displayed.

Returns

    
`outputndarray`

    
  * If `return_full_prob` is False, array of ints of same shape and data type as `labels`, in which each pixel has been labeled according to the marker that reached the pixel first by anisotropic diffusion.
  * If `return_full_prob` is True, array of floats of shape `(nlabels, labels.shape)`. `output[label_nb, i, j]` is the probability that label `label_nb` reaches the pixel `(i, j)` first.

See also

`skimage.morphology.watershed`

    
watershed segmentation A segmentation algorithm based on mathematical
morphology and “flooding” of regions from markers.

#### Notes

Multichannel inputs are scaled with all channel data combined. Ensure all
channels are separately normalized prior to running this algorithm.

The `spacing` argument is specifically for anisotropic datasets, where data
points are spaced differently in one or more spatial dimensions. Anisotropic
data is commonly encountered in medical imaging.

The algorithm was first proposed in [1].

The algorithm solves the diffusion equation at infinite times for sources
placed on markers of each phase in turn. A pixel is labeled with the phase
that has the greatest probability to diffuse first to the pixel.

The diffusion equation is solved by minimizing x.T L x for each phase, where L
is the Laplacian of the weighted graph of the image, and x is the probability
that a marker of the given phase arrives first at a pixel by diffusion (x=1 on
markers of the phase, x=0 on the other markers, and the other coefficients are
looked for). Each pixel is attributed the label for which it has a maximal
value of x. The Laplacian L of the image is defined as:

  * L_ii = d_i, the number of neighbors of pixel i (the degree of i)
  * L_ij = -w_ij if i and j are adjacent pixels

The weight w_ij is a decreasing function of the norm of the local gradient.
This ensures that diffusion is easier between pixels of similar values.

When the Laplacian is decomposed into blocks of marked and unmarked pixels:

    
    L = M B.T
        B A
    
with first indices corresponding to marked pixels, and then to unmarked
pixels, minimizing x.T L x for one phase amount to solving:

    
    A x = - B x_m
    
where x_m = 1 on markers of the given phase, and 0 on other markers. This
linear system is solved in the algorithm using a direct method for small
images, and an iterative method for larger images.

#### References

`1`

    
Leo Grady, Random walks for image segmentation, IEEE Trans Pattern Anal Mach
Intell. 2006 Nov;28(11):1768-83. DOI:10.1109/TPAMI.2006.233.

#### Examples

    
    >>> np.random.seed(0)
    >>> a = np.zeros((10, 10)) + 0.2 * np.random.rand(10, 10)
    >>> a[5:8, 5:8] += 1
    >>> b = np.zeros_like(a, dtype=np.int32)
    >>> b[3, 3] = 1  # Marker for first phase
    >>> b[6, 6] = 2  # Marker for second phase
    >>> random_walker(a, b)
    array([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],
           [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],
           [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],
           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], dtype=int32)
    
## relabel_sequential

`skimage.segmentation.relabel_sequential(label_field, offset=1)` [source]

    
Relabel arbitrary labels to {`offset`, … `offset` \+ number_of_labels}.

This function also returns the forward map (mapping the original labels to the
reduced labels) and the inverse map (mapping the reduced labels back to the
original ones).

Parameters

    
`label_fieldnumpy array of int, arbitrary shape`

    
An array of labels, which must be non-negative integers.

`offsetint, optional`

    
The return labels will start at `offset`, which should be strictly positive.

Returns

    
`relabelednumpy array of int, same shape as label_field`

    
The input label field with labels mapped to {offset, …, number_of_labels +
offset - 1}. The data type will be the same as `label_field`, except when
offset + number_of_labels causes overflow of the current data type.

`forward_mapArrayMap`

    
The map from the original label space to the returned label space. Can be used
to re-apply the same mapping. See examples for usage. The output data type
will be the same as `relabeled`.

`inverse_mapArrayMap`

    
The map from the new label space to the original space. This can be used to
reconstruct the original label field from the relabeled one. The output data
type will be the same as `label_field`.

#### Notes

The label 0 is assumed to denote the background and is never remapped.

The forward map can be extremely big for some inputs, since its length is
given by the maximum of the label field. However, in most situations,
`label_field.max()` is much smaller than `label_field.size`, and in these
cases the forward map is guaranteed to be smaller than either the input or
output images.

#### Examples

    
    >>> from skimage.segmentation import relabel_sequential
    >>> label_field = np.array([1, 1, 5, 5, 8, 99, 42])
    >>> relab, fw, inv = relabel_sequential(label_field)
    >>> relab
    array([1, 1, 2, 2, 3, 5, 4])
    >>> print(fw)
    ArrayMap:
      1 → 1
      5 → 2
      8 → 3
      42 → 4
      99 → 5
    >>> np.array(fw)
    array([0, 1, 0, 0, 0, 2, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5])
    >>> np.array(inv)
    array([ 0,  1,  5,  8, 42, 99])
    >>> (fw[label_field] == relab).all()
    True
    >>> (inv[relab] == label_field).all()
    True
    >>> relab, fw, inv = relabel_sequential(label_field, offset=5)
    >>> relab
    array([5, 5, 6, 6, 7, 9, 8])
    
## slic

`skimage.segmentation.slic(image, n_segments=100, compactness=10.0,
max_iter=10, sigma=0, spacing=None, multichannel=True, convert2lab=None,
enforce_connectivity=True, min_size_factor=0.5, max_size_factor=3,
slic_zero=False, start_label=None, mask=None)` [source]

    
Segments image using k-means clustering in Color-(x,y,z) space.

Parameters

    
`image2D, 3D or 4D ndarray`

    
Input image, which can be 2D or 3D, and grayscale or multichannel (see
`multichannel` parameter). Input image must either be NaN-free or the NaN’s
must be masked out

`n_segmentsint, optional`

    
The (approximate) number of labels in the segmented output image.

`compactnessfloat, optional`

    
Balances color proximity and space proximity. Higher values give more weight
to space proximity, making superpixel shapes more square/cubic. In SLICO mode,
this is the initial compactness. This parameter depends strongly on image
contrast and on the shapes of objects in the image. We recommend exploring
possible values on a log scale, e.g., 0.01, 0.1, 1, 10, 100, before refining
around a chosen value.

`max_iterint, optional`

    
Maximum number of iterations of k-means.

`sigmafloat or (3,) array-like of floats, optional`

    
Width of Gaussian smoothing kernel for pre-processing for each dimension of
the image. The same sigma is applied to each dimension in case of a scalar
value. Zero means no smoothing. Note, that `sigma` is automatically scaled if
it is scalar and a manual voxel spacing is provided (see Notes section).

`spacing(3,) array-like of floats, optional`

    
The voxel spacing along each image dimension. By default, `slic` assumes
uniform spacing (same voxel resolution along z, y and x). This parameter
controls the weights of the distances along z, y, and x during k-means
clustering.

`multichannelbool, optional`

    
Whether the last axis of the image is to be interpreted as multiple channels
or another spatial dimension.

`convert2labbool, optional`

    
Whether the input should be converted to Lab colorspace prior to segmentation.
The input image must be RGB. Highly recommended. This option defaults to
`True` when `multichannel=True` and `image.shape[-1] == 3`.

`enforce_connectivitybool, optional`

    
Whether the generated segments are connected or not

`min_size_factorfloat, optional`

    
Proportion of the minimum segment size to be removed with respect to the
supposed segment size ``depth*width*height/n_segments``

`max_size_factorfloat, optional`

    
Proportion of the maximum connected segment size. A value of 3 works in most
of the cases.

`slic_zerobool, optional`

    
Run SLIC-zero, the zero-parameter mode of SLIC. [2]

start_label: int, optional

    
The labels’ index start. Should be 0 or 1.

New in version 0.17: `start_label` was introduced in 0.17

`mask2D ndarray, optional`

    
If provided, superpixels are computed only where mask is True, and seed points
are homogeneously distributed over the mask using a K-means clustering
strategy.

New in version 0.17: `mask` was introduced in 0.17

Returns

    
`labels2D or 3D array`

    
Integer mask indicating segment labels.

Raises

    
ValueError

    
If `convert2lab` is set to `True` but the last array dimension is not of
length 3.

ValueError

    
If `start_label` is not 0 or 1.

#### Notes

  * If `sigma > 0`, the image is smoothed using a Gaussian kernel prior to segmentation.
  * If `sigma` is scalar and `spacing` is provided, the kernel width is divided along each dimension by the spacing. For example, if `sigma=1` and `spacing=[5, 1, 1]`, the effective `sigma` is `[0.2, 1, 1]`. This ensures sensible smoothing for anisotropic images.
  * The image is rescaled to be in [0, 1] prior to processing.
  * Images of shape (M, N, 3) are interpreted as 2D RGB images by default. To interpret them as 3D with the last dimension having length 3, use `multichannel=False`.
  * `start_label` is introduced to handle the issue [4]. The labels indexing starting at 0 will be deprecated in future versions. If `mask` is not `None` labels indexing starts at 1 and masked area is set to 0.

#### References

`1`

    
Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi, Pascal Fua,
and Sabine Süsstrunk, SLIC Superpixels Compared to State-of-the-art Superpixel
Methods, TPAMI, May 2012. DOI:10.1109/TPAMI.2012.120

`2`

    
https://www.epfl.ch/labs/ivrl/research/slic-superpixels/#SLICO

`3`

    
Irving, Benjamin. “maskSLIC: regional superpixel generation with application
to local pathology characterisation in medical images.”, 2016,
arXiv:1606.09518

`4`

    
https://github.com/scikit-image/scikit-image/issues/3722

#### Examples

    
    >>> from skimage.segmentation import slic
    >>> from skimage.data import astronaut
    >>> img = astronaut()
    >>> segments = slic(img, n_segments=100, compactness=10)
    
Increasing the compactness parameter yields more square regions:

    
    >>> segments = slic(img, n_segments=100, compactness=20)
    
## watershed

`skimage.segmentation.watershed(image, markers=None, connectivity=1,
offset=None, mask=None, compactness=0, watershed_line=False)` [source]

    
Find watershed basins in `image` flooded from given `markers`.

Parameters

    
`imagendarray (2-D, 3-D, …) of integers`

    
Data array where the lowest value points are labeled first.

`markersint, or ndarray of int, same shape as image, optional`

    
The desired number of markers, or an array marking the basins with the values
to be assigned in the label matrix. Zero means not a marker. If `None` (no
markers given), the local minima of the image are used as markers.

`connectivityndarray, optional`

    
An array with the same number of dimensions as `image` whose non-zero elements
indicate neighbors for connection. Following the scipy convention, default is
a one-connected array of the dimension of the image.

`offsetarray_like of shape image.ndim, optional`

    
offset of the connectivity (one offset per dimension)

`maskndarray of bools or 0s and 1s, optional`

    
Array of same shape as `image`. Only points at which mask == True will be
labeled.

`compactnessfloat, optional`

    
Use compact watershed [3] with given compactness parameter. Higher values
result in more regularly-shaped watershed basins.

`watershed_linebool, optional`

    
If watershed_line is True, a one-pixel wide line separates the regions
obtained by the watershed algorithm. The line has the label 0.

Returns

    
`outndarray`

    
A labeled matrix of the same type and shape as markers

See also

`skimage.segmentation.random_walker`

    
random walker segmentation A segmentation algorithm based on anisotropic
diffusion, usually slower than the watershed but with good results on noisy
data and boundaries with holes.

#### Notes

This function implements a watershed algorithm [1] [2] that apportions pixels
into marked basins. The algorithm uses a priority queue to hold the pixels
with the metric for the priority queue being pixel value, then the time of
entry into the queue - this settles ties in favor of the closest marker.

Some ideas taken from Soille, “Automated Basin Delineation from Digital
Elevation Models Using Mathematical Morphology”, Signal Processing 20 (1990)
171-182

The most important insight in the paper is that entry time onto the queue
solves two problems: a pixel should be assigned to the neighbor with the
largest gradient or, if there is no gradient, pixels on a plateau should be
split between markers on opposite sides.

This implementation converts all arguments to specific, lowest common
denominator types, then passes these to a C algorithm.

Markers can be determined manually, or automatically using for example the
local minima of the gradient of the image, or the local maxima of the distance
function to the background for separating overlapping objects (see example).

#### References

`1`

    
https://en.wikipedia.org/wiki/Watershed_%28image_processing%29

`2`

    
http://cmm.ensmp.fr/~beucher/wtshed.html

`3`

    
Peer Neubert & Peter Protzel (2014). Compact Watershed and Preemptive SLIC: On
Improving Trade-offs of Superpixel Segmentation Algorithms. ICPR 2014, pp
996-1001. DOI:10.1109/ICPR.2014.181 https://www.tu-
chemnitz.de/etit/proaut/publications/cws_pSLIC_ICPR.pdf

#### Examples

The watershed algorithm is useful to separate overlapping objects.

We first generate an initial image with two overlapping circles:

    
    >>> x, y = np.indices((80, 80))
    >>> x1, y1, x2, y2 = 28, 28, 44, 52
    >>> r1, r2 = 16, 20
    >>> mask_circle1 = (x - x1)**2 + (y - y1)**2 < r1**2
    >>> mask_circle2 = (x - x2)**2 + (y - y2)**2 < r2**2
    >>> image = np.logical_or(mask_circle1, mask_circle2)
    
Next, we want to separate the two circles. We generate markers at the maxima
of the distance to the background:

    
    >>> from scipy import ndimage as ndi
    >>> distance = ndi.distance_transform_edt(image)
    >>> from skimage.feature import peak_local_max
    >>> local_maxi = peak_local_max(distance, labels=image,
    ...                             footprint=np.ones((3, 3)),
    ...                             indices=False)
    >>> markers = ndi.label(local_maxi)[0]
    
Finally, we run the watershed on the image and markers:

    
    >>> labels = watershed(-distance, markers, mask=image)
    
The algorithm works also for 3-D images, and can be used for example to
separate overlapping spheres.

### Examples using `skimage.segmentation.watershed`

![Watershed
segmentation](data:image/png;base64,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)

Watershed segmentation

![Markers for watershed
transform](data:image/png;base64,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)

Markers for watershed transform

![Segment human cells \(in
mitosis\)](data:image/png;base64,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)

Segment human cells (in mitosis)

© 2019 the scikit-image team  
Licensed under the BSD 3-clause License.  
https://scikit-image.org/docs/0.18.x/api/skimage.segmentation.html

  *[ISP]: Internet Service Provider
  *[LIFO]: last-in, first-out
  *[FIFO]: first-in, first-out

