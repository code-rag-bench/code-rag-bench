# Module: transform

`skimage.transform.downscale_local_mean`(…) | Down-sample N-dimensional image by local averaging.  
---|---  
`skimage.transform.estimate_transform`(ttype, …) | Estimate 2D geometric transformation parameters.  
`skimage.transform.frt2`(a) | Compute the 2-dimensional finite radon transform (FRT) for an n x n integer array.  
`skimage.transform.hough_circle`(image, radius) | Perform a circular Hough transform.  
`skimage.transform.hough_circle_peaks`(…[, …]) | Return peaks in a circle Hough transform.  
`skimage.transform.hough_ellipse`(image[, …]) | Perform an elliptical Hough transform.  
`skimage.transform.hough_line`(image[, theta]) | Perform a straight line Hough transform.  
`skimage.transform.hough_line_peaks`(hspace, …) | Return peaks in a straight line Hough transform.  
`skimage.transform.ifrt2`(a) | Compute the 2-dimensional inverse finite radon transform (iFRT) for an (n+1) x n integer array.  
`skimage.transform.integral_image`(image) | Integral image / summed area table.  
`skimage.transform.integrate`(ii, start, end) | Use an integral image to integrate over a given window.  
`skimage.transform.iradon`(radon_image[, …]) | Inverse radon transform.  
`skimage.transform.iradon_sart`(radon_image[, …]) | Inverse radon transform.  
`skimage.transform.matrix_transform`(coords, …) | Apply 2D matrix transform.  
`skimage.transform.order_angles_golden_ratio`(theta) | Order angles to reduce the amount of correlated information in subsequent projections.  
`skimage.transform.probabilistic_hough_line`(image) | Return lines from a progressive probabilistic line Hough transform.  
`skimage.transform.pyramid_expand`(image[, …]) | Upsample and then smooth image.  
`skimage.transform.pyramid_gaussian`(image[, …]) | Yield images of the Gaussian pyramid formed by the input image.  
`skimage.transform.pyramid_laplacian`(image[, …]) | Yield images of the laplacian pyramid formed by the input image.  
`skimage.transform.pyramid_reduce`(image[, …]) | Smooth and then downsample image.  
`skimage.transform.radon`(image[, theta, …]) | Calculates the radon transform of an image given specified projection angles.  
`skimage.transform.rescale`(image, scale[, …]) | Scale image by a certain factor.  
`skimage.transform.resize`(image, output_shape) | Resize image to match a certain size.  
`skimage.transform.rotate`(image, angle[, …]) | Rotate image by a certain angle around its center.  
`skimage.transform.swirl`(image[, center, …]) | Perform a swirl transformation.  
`skimage.transform.warp`(image, inverse_map[, …]) | Warp an image according to a given coordinate transformation.  
`skimage.transform.warp_coords`(coord_map, shape) | Build the source coordinates for the output of a 2-D image warp.  
`skimage.transform.warp_polar`(image[, …]) | Remap image to polar or log-polar coordinates space.  
`skimage.transform.AffineTransform`([matrix, …]) | 2D affine transformation.  
`skimage.transform.EssentialMatrixTransform`([…]) | Essential matrix transformation.  
`skimage.transform.EuclideanTransform`([…]) | 2D Euclidean transformation.  
`skimage.transform.FundamentalMatrixTransform`([…]) | Fundamental matrix transformation.  
`skimage.transform.PiecewiseAffineTransform`() | 2D piecewise affine transformation.  
`skimage.transform.PolynomialTransform`([params]) | 2D polynomial transformation.  
`skimage.transform.ProjectiveTransform`([matrix]) | Projective transformation.  
`skimage.transform.SimilarityTransform`([…]) | 2D similarity transformation.  
## downscale_local_mean

`skimage.transform.downscale_local_mean(image, factors, cval=0, clip=True)`
[source]

    
Down-sample N-dimensional image by local averaging.

The image is padded with `cval` if it is not perfectly divisible by the
integer factors.

In contrast to interpolation in `skimage.transform.resize` and
`skimage.transform.rescale` this function calculates the local mean of
elements in each block of size `factors` in the input image.

Parameters

    
`imagendarray`

    
N-dimensional input image.

`factorsarray_like`

    
Array containing down-sampling integer factor along each axis.

`cvalfloat, optional`

    
Constant padding value if image is not perfectly divisible by the integer
factors.

`clipbool, optional`

    
Unused, but kept here for API consistency with the other transforms in this
module. (The local mean will never fall outside the range of values in the
input image, assuming the provided `cval` also falls within that range.)

Returns

    
`imagendarray`

    
Down-sampled image with same number of dimensions as input image. For integer
inputs, the output dtype will be `float64`. See `numpy.mean()` for details.

#### Examples

    
    >>> a = np.arange(15).reshape(3, 5)
    >>> a
    array([[ 0,  1,  2,  3,  4],
           [ 5,  6,  7,  8,  9],
           [10, 11, 12, 13, 14]])
    >>> downscale_local_mean(a, (2, 3))
    array([[3.5, 4. ],
           [5.5, 4.5]])
    
## estimate_transform

`skimage.transform.estimate_transform(ttype, src, dst, **kwargs)` [source]

    
Estimate 2D geometric transformation parameters.

You can determine the over-, well- and under-determined parameters with the
total least-squares method.

Number of source and destination coordinates must match.

Parameters

    
`ttype{‘euclidean’, similarity’, ‘affine’, ‘piecewise-affine’, ‘projective’,
‘polynomial’}`

    
Type of transform.

`kwargsarray or int`

    
Function parameters (src, dst, n, angle):

    
    NAME / TTYPE        FUNCTION PARAMETERS
    'euclidean'         `src, `dst`
    'similarity'        `src, `dst`
    'affine'            `src, `dst`
    'piecewise-affine'  `src, `dst`
    'projective'        `src, `dst`
    'polynomial'        `src, `dst`, `order` (polynomial order,
                                              default order is 2)
    
Also see examples below.

Returns

    
`tformGeometricTransform`

    
Transform object containing the transformation parameters and providing access
to forward and inverse transformation functions.

#### Examples

    
    >>> import numpy as np
    >>> from skimage import transform
    
    
    >>> # estimate transformation parameters
    >>> src = np.array([0, 0, 10, 10]).reshape((2, 2))
    >>> dst = np.array([12, 14, 1, -20]).reshape((2, 2))
    
    
    >>> tform = transform.estimate_transform('similarity', src, dst)
    
    
    >>> np.allclose(tform.inverse(tform(src)), src)
    True
    
    
    >>> # warp image using the estimated transformation
    >>> from skimage import data
    >>> image = data.camera()
    
    
    >>> warp(image, inverse_map=tform.inverse) 
    
    
    >>> # create transformation with explicit parameters
    >>> tform2 = transform.SimilarityTransform(scale=1.1, rotation=1,
    ...     translation=(10, 20))
    
    
    >>> # unite transformations, applied in order from left to right
    >>> tform3 = tform + tform2
    >>> np.allclose(tform3(src), tform2(tform(src)))
    True
    
## frt2

`skimage.transform.frt2(a)` [source]

    
Compute the 2-dimensional finite radon transform (FRT) for an n x n integer
array.

Parameters

    
`aarray_like`

    
A 2-D square n x n integer array.

Returns

    
`FRT2-D ndarray`

    
Finite Radon Transform array of (n+1) x n integer coefficients.

See also

`ifrt2`

    
The two-dimensional inverse FRT.

#### Notes

The FRT has a unique inverse if and only if n is prime. [FRT] The idea for
this algorithm is due to Vlad Negnevitski.

#### References

`FRT`

    
A. Kingston and I. Svalbe, “Projective transforms on periodic discrete image
arrays,” in P. Hawkes (Ed), Advances in Imaging and Electron Physics, 139
(2006)

#### Examples

Generate a test image: Use a prime number for the array dimensions

    
    >>> SIZE = 59
    >>> img = np.tri(SIZE, dtype=np.int32)
    
Apply the Finite Radon Transform:

    
    >>> f = frt2(img)
    
## hough_circle

`skimage.transform.hough_circle(image, radius, normalize=True,
full_output=False)` [source]

    
Perform a circular Hough transform.

Parameters

    
`image(M, N) ndarray`

    
Input image with nonzero values representing edges.

`radiusscalar or sequence of scalars`

    
Radii at which to compute the Hough transform. Floats are converted to
integers.

`normalizeboolean, optional (default True)`

    
Normalize the accumulator with the number of pixels used to draw the radius.

`full_outputboolean, optional (default False)`

    
Extend the output size by twice the largest radius in order to detect centers
outside the input picture.

Returns

    
`H3D ndarray (radius index, (M + 2R, N + 2R) ndarray)`

    
Hough transform accumulator for each radius. R designates the larger radius if
full_output is True. Otherwise, R = 0.

#### Examples

    
    >>> from skimage.transform import hough_circle
    >>> from skimage.draw import circle_perimeter
    >>> img = np.zeros((100, 100), dtype=bool)
    >>> rr, cc = circle_perimeter(25, 35, 23)
    >>> img[rr, cc] = 1
    >>> try_radii = np.arange(5, 50)
    >>> res = hough_circle(img, try_radii)
    >>> ridx, r, c = np.unravel_index(np.argmax(res), res.shape)
    >>> r, c, try_radii[ridx]
    (25, 35, 23)
    
## hough_circle_peaks

`skimage.transform.hough_circle_peaks(hspaces, radii, min_xdistance=1,
min_ydistance=1, threshold=None, num_peaks=inf, total_num_peaks=inf,
normalize=False)` [source]

    
Return peaks in a circle Hough transform.

Identifies most prominent circles separated by certain distances in given
Hough spaces. Non-maximum suppression with different sizes is applied
separately in the first and second dimension of the Hough space to identify
peaks. For circles with different radius but close in distance, only the one
with highest peak is kept.

Parameters

    
`hspaces(N, M) array`

    
Hough spaces returned by the `hough_circle` function.

`radii(M,) array`

    
Radii corresponding to Hough spaces.

`min_xdistanceint, optional`

    
Minimum distance separating centers in the x dimension.

`min_ydistanceint, optional`

    
Minimum distance separating centers in the y dimension.

`thresholdfloat, optional`

    
Minimum intensity of peaks in each Hough space. Default is `0.5 *
max(hspace)`.

`num_peaksint, optional`

    
Maximum number of peaks in each Hough space. When the number of peaks exceeds
`num_peaks`, only `num_peaks` coordinates based on peak intensity are
considered for the corresponding radius.

`total_num_peaksint, optional`

    
Maximum number of peaks. When the number of peaks exceeds `num_peaks`, return
`num_peaks` coordinates based on peak intensity.

`normalizebool, optional`

    
If True, normalize the accumulator by the radius to sort the prominent peaks.

Returns

    
`accum, cx, cy, radtuple of array`

    
Peak values in Hough space, x and y center coordinates and radii.

#### Notes

Circles with bigger radius have higher peaks in Hough space. If larger circles
are preferred over smaller ones, `normalize` should be False. Otherwise,
circles will be returned in the order of decreasing voting number.

#### Examples

    
    >>> from skimage import transform, draw
    >>> img = np.zeros((120, 100), dtype=int)
    >>> radius, x_0, y_0 = (20, 99, 50)
    >>> y, x = draw.circle_perimeter(y_0, x_0, radius)
    >>> img[x, y] = 1
    >>> hspaces = transform.hough_circle(img, radius)
    >>> accum, cx, cy, rad = hough_circle_peaks(hspaces, [radius,])
    
## hough_ellipse

`skimage.transform.hough_ellipse(image, threshold=4, accuracy=1, min_size=4,
max_size=None)` [source]

    
Perform an elliptical Hough transform.

Parameters

    
`image(M, N) ndarray`

    
Input image with nonzero values representing edges.

`thresholdint, optional`

    
Accumulator threshold value.

`accuracydouble, optional`

    
Bin size on the minor axis used in the accumulator.

`min_sizeint, optional`

    
Minimal major axis length.

`max_sizeint, optional`

    
Maximal minor axis length. If None, the value is set to the half of the
smaller image dimension.

Returns

    
`resultndarray with fields [(accumulator, yc, xc, a, b, orientation)].`

    
Where `(yc, xc)` is the center, `(a, b)` the major and minor axes,
respectively. The `orientation` value follows `skimage.draw.ellipse_perimeter`
convention.

#### Notes

The accuracy must be chosen to produce a peak in the accumulator distribution.
In other words, a flat accumulator distribution with low values may be caused
by a too low bin size.

#### References

`1`

    
Xie, Yonghong, and Qiang Ji. “A new efficient ellipse detection method.”
Pattern Recognition, 2002. Proceedings. 16th International Conference on. Vol.
2. IEEE, 2002

#### Examples

    
    >>> from skimage.transform import hough_ellipse
    >>> from skimage.draw import ellipse_perimeter
    >>> img = np.zeros((25, 25), dtype=np.uint8)
    >>> rr, cc = ellipse_perimeter(10, 10, 6, 8)
    >>> img[cc, rr] = 1
    >>> result = hough_ellipse(img, threshold=8)
    >>> result.tolist()
    [(10, 10.0, 10.0, 8.0, 6.0, 0.0)]
    
## hough_line

`skimage.transform.hough_line(image, theta=None)` [source]

    
Perform a straight line Hough transform.

Parameters

    
`image(M, N) ndarray`

    
Input image with nonzero values representing edges.

`theta1D ndarray of double, optional`

    
Angles at which to compute the transform, in radians. Defaults to a vector of
180 angles evenly spaced from -pi/2 to pi/2.

Returns

    
`hspace2-D ndarray of uint64`

    
Hough transform accumulator.

`anglesndarray`

    
Angles at which the transform is computed, in radians.

`distancesndarray`

    
Distance values.

#### Notes

The origin is the top left corner of the original image. X and Y axis are
horizontal and vertical edges respectively. The distance is the minimal
algebraic distance from the origin to the detected line. The angle accuracy
can be improved by decreasing the step size in the `theta` array.

#### Examples

Generate a test image:

    
    >>> img = np.zeros((100, 150), dtype=bool)
    >>> img[30, :] = 1
    >>> img[:, 65] = 1
    >>> img[35:45, 35:50] = 1
    >>> for i in range(90):
    ...     img[i, i] = 1
    >>> img += np.random.random(img.shape) > 0.95
    
Apply the Hough transform:

    
    >>> out, angles, d = hough_line(img)
    
    
    import numpy as np
    import matplotlib.pyplot as plt
    
    from skimage.transform import hough_line
    from skimage.draw import line
    
    img = np.zeros((100, 150), dtype=bool)
    img[30, :] = 1
    img[:, 65] = 1
    img[35:45, 35:50] = 1
    rr, cc = line(60, 130, 80, 10)
    img[rr, cc] = 1
    img += np.random.random(img.shape) > 0.95
    
    out, angles, d = hough_line(img)
    
    fix, axes = plt.subplots(1, 2, figsize=(7, 4))
    
    axes[0].imshow(img, cmap=plt.cm.gray)
    axes[0].set_title('Input image')
    
    axes[1].imshow(
        out, cmap=plt.cm.bone,
        extent=(np.rad2deg(angles[-1]), np.rad2deg(angles[0]), d[-1], d[0]))
    axes[1].set_title('Hough transform')
    axes[1].set_xlabel('Angle (degree)')
    axes[1].set_ylabel('Distance (pixel)')
    
    plt.tight_layout()
    plt.show()
    
(Source code, png, pdf)

![../_images/hough_tf.png](data:image/png;base64,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)

## hough_line_peaks

`skimage.transform.hough_line_peaks(hspace, angles, dists, min_distance=9,
min_angle=10, threshold=None, num_peaks=inf)` [source]

    
Return peaks in a straight line Hough transform.

Identifies most prominent lines separated by a certain angle and distance in a
Hough transform. Non-maximum suppression with different sizes is applied
separately in the first (distances) and second (angles) dimension of the Hough
space to identify peaks.

Parameters

    
`hspace(N, M) array`

    
Hough space returned by the `hough_line` function.

`angles(M,) array`

    
Angles returned by the `hough_line` function. Assumed to be continuous.
(`angles[-1] - angles[0] == PI`).

`dists(N, ) array`

    
Distances returned by the `hough_line` function.

`min_distanceint, optional`

    
Minimum distance separating lines (maximum filter size for first dimension of
hough space).

`min_angleint, optional`

    
Minimum angle separating lines (maximum filter size for second dimension of
hough space).

`thresholdfloat, optional`

    
Minimum intensity of peaks. Default is `0.5 * max(hspace)`.

`num_peaksint, optional`

    
Maximum number of peaks. When the number of peaks exceeds `num_peaks`, return
`num_peaks` coordinates based on peak intensity.

Returns

    
`accum, angles, diststuple of array`

    
Peak values in Hough space, angles and distances.

#### Examples

    
    >>> from skimage.transform import hough_line, hough_line_peaks
    >>> from skimage.draw import line
    >>> img = np.zeros((15, 15), dtype=bool)
    >>> rr, cc = line(0, 0, 14, 14)
    >>> img[rr, cc] = 1
    >>> rr, cc = line(0, 14, 14, 0)
    >>> img[cc, rr] = 1
    >>> hspace, angles, dists = hough_line(img)
    >>> hspace, angles, dists = hough_line_peaks(hspace, angles, dists)
    >>> len(angles)
    2
    
## ifrt2

`skimage.transform.ifrt2(a)` [source]

    
Compute the 2-dimensional inverse finite radon transform (iFRT) for an (n+1) x
n integer array.

Parameters

    
`aarray_like`

    
A 2-D (n+1) row x n column integer array.

Returns

    
`iFRT2-D n x n ndarray`

    
Inverse Finite Radon Transform array of n x n integer coefficients.

See also

`frt2`

    
The two-dimensional FRT

#### Notes

The FRT has a unique inverse if and only if n is prime. See [1] for an
overview. The idea for this algorithm is due to Vlad Negnevitski.

#### References

`1`

    
A. Kingston and I. Svalbe, “Projective transforms on periodic discrete image
arrays,” in P. Hawkes (Ed), Advances in Imaging and Electron Physics, 139
(2006)

#### Examples

    
    >>> SIZE = 59
    >>> img = np.tri(SIZE, dtype=np.int32)
    
Apply the Finite Radon Transform:

    
    >>> f = frt2(img)
    
Apply the Inverse Finite Radon Transform to recover the input

    
    >>> fi = ifrt2(f)
    
Check that it’s identical to the original

    
    >>> assert len(np.nonzero(img-fi)[0]) == 0
    
## integral_image

`skimage.transform.integral_image(image)` [source]

    
Integral image / summed area table.

The integral image contains the sum of all elements above and to the left of
it, i.e.:

\\[S[m, n] = \sum_{i \leq m} \sum_{j \leq n} X[i, j]\\]

Parameters

    
`imagendarray`

    
Input image.

Returns

    
`Sndarray`

    
Integral image/summed area table of same shape as input image.

#### References

`1`

    
F.C. Crow, “Summed-area tables for texture mapping,” ACM SIGGRAPH Computer
Graphics, vol. 18, 1984, pp. 207-212.

## integrate

`skimage.transform.integrate(ii, start, end)` [source]

    
Use an integral image to integrate over a given window.

Parameters

    
`iindarray`

    
Integral image.

`startList of tuples, each tuple of length equal to dimension of ii`

    
Coordinates of top left corner of window(s). Each tuple in the list contains
the starting row, col, … index i.e `[(row_win1, col_win1, …), (row_win2,
col_win2,…), …]`.

`endList of tuples, each tuple of length equal to dimension of ii`

    
Coordinates of bottom right corner of window(s). Each tuple in the list
containing the end row, col, … index i.e `[(row_win1, col_win1, …), (row_win2,
col_win2, …), …]`.

Returns

    
`Sscalar or ndarray`

    
Integral (sum) over the given window(s).

#### Examples

    
    >>> arr = np.ones((5, 6), dtype=float)
    >>> ii = integral_image(arr)
    >>> integrate(ii, (1, 0), (1, 2))  # sum from (1, 0) to (1, 2)
    array([3.])
    >>> integrate(ii, [(3, 3)], [(4, 5)])  # sum from (3, 3) to (4, 5)
    array([6.])
    >>> # sum from (1, 0) to (1, 2) and from (3, 3) to (4, 5)
    >>> integrate(ii, [(1, 0), (3, 3)], [(1, 2), (4, 5)])
    array([3., 6.])
    
## iradon

`skimage.transform.iradon(radon_image, theta=None, output_size=None,
filter_name='ramp', interpolation='linear', circle=True, preserve_range=True)`
[source]

    
Inverse radon transform.

Reconstruct an image from the radon transform, using the filtered back
projection algorithm.

Parameters

    
`radon_imagearray`

    
Image containing radon transform (sinogram). Each column of the image
corresponds to a projection along a different angle. The tomography rotation
axis should lie at the pixel index `radon_image.shape[0] // 2` along the 0th
dimension of `radon_image`.

`thetaarray_like, optional`

    
Reconstruction angles (in degrees). Default: m angles evenly spaced between 0
and 180 (if the shape of `radon_image` is (N, M)).

`output_sizeint, optional`

    
Number of rows and columns in the reconstruction.

`filter_namestr, optional`

    
Filter used in frequency domain filtering. Ramp filter used by default.
Filters available: ramp, shepp-logan, cosine, hamming, hann. Assign None to
use no filter.

`interpolationstr, optional`

    
Interpolation method used in reconstruction. Methods available: ‘linear’,
‘nearest’, and ‘cubic’ (‘cubic’ is slow).

`circleboolean, optional`

    
Assume the reconstructed image is zero outside the inscribed circle. Also
changes the default output_size to match the behaviour of `radon` called with
`circle=True`.

`preserve_rangebool, optional`

    
Whether to keep the original range of values. Otherwise, the input image is
converted according to the conventions of `img_as_float`. Also see
https://scikit-image.org/docs/dev/user_guide/data_types.html

Returns

    
`reconstructedndarray`

    
Reconstructed image. The rotation axis will be located in the pixel with
indices `(reconstructed.shape[0] // 2, reconstructed.shape[1] // 2)`.

Changed in version 0.19: In `iradon`, `filter` argument is deprecated in favor
of `filter_name`.

#### Notes

It applies the Fourier slice theorem to reconstruct an image by multiplying
the frequency domain of the filter with the FFT of the projection data. This
algorithm is called filtered back projection.

#### References

`1`

    
AC Kak, M Slaney, “Principles of Computerized Tomographic Imaging”, IEEE Press
1988.

`2`

    
B.R. Ramesh, N. Srinivasa, K. Rajgopal, “An Algorithm for Computing the
Discrete Radon Transform With Some Applications”, Proceedings of the Fourth
IEEE Region 10 International Conference, TENCON ‘89, 1989

## iradon_sart

`skimage.transform.iradon_sart(radon_image, theta=None, image=None,
projection_shifts=None, clip=None, relaxation=0.15, dtype=None)` [source]

    
Inverse radon transform.

Reconstruct an image from the radon transform, using a single iteration of the
Simultaneous Algebraic Reconstruction Technique (SART) algorithm.

Parameters

    
`radon_image2D array`

    
Image containing radon transform (sinogram). Each column of the image
corresponds to a projection along a different angle. The tomography rotation
axis should lie at the pixel index `radon_image.shape[0] // 2` along the 0th
dimension of `radon_image`.

`theta1D array, optional`

    
Reconstruction angles (in degrees). Default: m angles evenly spaced between 0
and 180 (if the shape of `radon_image` is (N, M)).

`image2D array, optional`

    
Image containing an initial reconstruction estimate. Shape of this array
should be `(radon_image.shape[0], radon_image.shape[0])`. The default is an
array of zeros.

`projection_shifts1D array, optional`

    
Shift the projections contained in `radon_image` (the sinogram) by this many
pixels before reconstructing the image. The i’th value defines the shift of
the i’th column of `radon_image`.

`cliplength-2 sequence of floats, optional`

    
Force all values in the reconstructed tomogram to lie in the range `[clip[0],
clip[1]]`

`relaxationfloat, optional`

    
Relaxation parameter for the update step. A higher value can improve the
convergence rate, but one runs the risk of instabilities. Values close to or
higher than 1 are not recommended.

`dtypedtype, optional`

    
Output data type, must be floating point. By default, if input data type is
not float, input is cast to double, otherwise dtype is set to input data type.

Returns

    
`reconstructedndarray`

    
Reconstructed image. The rotation axis will be located in the pixel with
indices `(reconstructed.shape[0] // 2, reconstructed.shape[1] // 2)`.

#### Notes

Algebraic Reconstruction Techniques are based on formulating the tomography
reconstruction problem as a set of linear equations. Along each ray, the
projected value is the sum of all the values of the cross section along the
ray. A typical feature of SART (and a few other variants of algebraic
techniques) is that it samples the cross section at equidistant points along
the ray, using linear interpolation between the pixel values of the cross
section. The resulting set of linear equations are then solved using a
slightly modified Kaczmarz method.

When using SART, a single iteration is usually sufficient to obtain a good
reconstruction. Further iterations will tend to enhance high-frequency
information, but will also often increase the noise.

#### References

`1`

    
AC Kak, M Slaney, “Principles of Computerized Tomographic Imaging”, IEEE Press
1988.

`2`

    
AH Andersen, AC Kak, “Simultaneous algebraic reconstruction technique (SART):
a superior implementation of the ART algorithm”, Ultrasonic Imaging 6 pp 81–94
(1984)

`3`

    
S Kaczmarz, “Angenäherte auflösung von systemen linearer gleichungen”,
Bulletin International de l’Academie Polonaise des Sciences et des Lettres 35
pp 355–357 (1937)

`4`

    
Kohler, T. “A projection access scheme for iterative reconstruction based on
the golden section.” Nuclear Science Symposium Conference Record, 2004 IEEE.
Vol. 6. IEEE, 2004.

`5`

    
Kaczmarz’ method, Wikipedia, https://en.wikipedia.org/wiki/Kaczmarz_method

## matrix_transform

`skimage.transform.matrix_transform(coords, matrix)` [source]

    
Apply 2D matrix transform.

Parameters

    
`coords(N, 2) array`

    
x, y coordinates to transform

`matrix(3, 3) array`

    
Homogeneous transformation matrix.

Returns

    
`coords(N, 2) array`

    
Transformed coordinates.

## order_angles_golden_ratio

`skimage.transform.order_angles_golden_ratio(theta)` [source]

    
Order angles to reduce the amount of correlated information in subsequent
projections.

Parameters

    
`theta1D array of floats`

    
Projection angles in degrees. Duplicate angles are not allowed.

Returns

    
`indices_generatorgenerator yielding unsigned integers`

    
The returned generator yields indices into `theta` such that `theta[indices]`
gives the approximate golden ratio ordering of the projections. In total,
`len(theta)` indices are yielded. All non-negative integers < `len(theta)` are
yielded exactly once.

#### Notes

The method used here is that of the golden ratio introduced by T. Kohler.

#### References

`1`

    
Kohler, T. “A projection access scheme for iterative reconstruction based on
the golden section.” Nuclear Science Symposium Conference Record, 2004 IEEE.
Vol. 6. IEEE, 2004.

`2`

    
Winkelmann, Stefanie, et al. “An optimal radial profile order based on the
Golden Ratio for time-resolved MRI.” Medical Imaging, IEEE Transactions on
26.1 (2007): 68-76.

## probabilistic_hough_line

`skimage.transform.probabilistic_hough_line(image, threshold=10,
line_length=50, line_gap=10, theta=None, seed=None)` [source]

    
Return lines from a progressive probabilistic line Hough transform.

Parameters

    
`image(M, N) ndarray`

    
Input image with nonzero values representing edges.

`thresholdint, optional`

    
Threshold

`line_lengthint, optional`

    
Minimum accepted length of detected lines. Increase the parameter to extract
longer lines.

`line_gapint, optional`

    
Maximum gap between pixels to still form a line. Increase the parameter to
merge broken lines more aggressively.

`theta1D ndarray, dtype=double, optional`

    
Angles at which to compute the transform, in radians. If None, use a range
from -pi/2 to pi/2.

`seedint, optional`

    
Seed to initialize the random number generator.

Returns

    
`lineslist`

    
List of lines identified, lines in format ((x0, y0), (x1, y1)), indicating
line start and end.

#### References

`1`

    
C. Galamhos, J. Matas and J. Kittler, “Progressive probabilistic Hough
transform for line detection”, in IEEE Computer Society Conference on Computer
Vision and Pattern Recognition, 1999.

## pyramid_expand

`skimage.transform.pyramid_expand(image, upscale=2, sigma=None, order=1,
mode='reflect', cval=0, multichannel=False, preserve_range=False)` [source]

    
Upsample and then smooth image.

Parameters

    
`imagendarray`

    
Input image.

`upscalefloat, optional`

    
Upscale factor.

`sigmafloat, optional`

    
Sigma for Gaussian filter. Default is `2 * upscale / 6.0` which corresponds to
a filter mask twice the size of the scale factor that covers more than 99% of
the Gaussian distribution.

`orderint, optional`

    
Order of splines used in interpolation of upsampling. See
`skimage.transform.warp` for detail.

`mode{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional`

    
The mode parameter determines how the array borders are handled, where cval is
the value when mode is equal to ‘constant’.

`cvalfloat, optional`

    
Value to fill past edges of input if mode is ‘constant’.

`multichannelbool, optional`

    
Whether the last axis of the image is to be interpreted as multiple channels
or another spatial dimension.

`preserve_rangebool, optional`

    
Whether to keep the original range of values. Otherwise, the input image is
converted according to the conventions of `img_as_float`. Also see
https://scikit-image.org/docs/dev/user_guide/data_types.html

Returns

    
`outarray`

    
Upsampled and smoothed float image.

#### References

`1`

    
http://persci.mit.edu/pub_pdfs/pyramid83.pdf

## pyramid_gaussian

`skimage.transform.pyramid_gaussian(image, max_layer=-1, downscale=2,
sigma=None, order=1, mode='reflect', cval=0, multichannel=False,
preserve_range=False)` [source]

    
Yield images of the Gaussian pyramid formed by the input image.

Recursively applies the `pyramid_reduce` function to the image, and yields the
downscaled images.

Note that the first image of the pyramid will be the original, unscaled image.
The total number of images is `max_layer + 1`. In case all layers are
computed, the last image is either a one-pixel image or the image where the
reduction does not change its shape.

Parameters

    
`imagendarray`

    
Input image.

`max_layerint, optional`

    
Number of layers for the pyramid. 0th layer is the original image. Default is
-1 which builds all possible layers.

`downscalefloat, optional`

    
Downscale factor.

`sigmafloat, optional`

    
Sigma for Gaussian filter. Default is `2 * downscale / 6.0` which corresponds
to a filter mask twice the size of the scale factor that covers more than 99%
of the Gaussian distribution.

`orderint, optional`

    
Order of splines used in interpolation of downsampling. See
`skimage.transform.warp` for detail.

`mode{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional`

    
The mode parameter determines how the array borders are handled, where cval is
the value when mode is equal to ‘constant’.

`cvalfloat, optional`

    
Value to fill past edges of input if mode is ‘constant’.

`multichannelbool, optional`

    
Whether the last axis of the image is to be interpreted as multiple channels
or another spatial dimension.

`preserve_rangebool, optional`

    
Whether to keep the original range of values. Otherwise, the input image is
converted according to the conventions of `img_as_float`. Also see
https://scikit-image.org/docs/dev/user_guide/data_types.html

Returns

    
`pyramidgenerator`

    
Generator yielding pyramid layers as float images.

#### References

`1`

    
http://persci.mit.edu/pub_pdfs/pyramid83.pdf

## pyramid_laplacian

`skimage.transform.pyramid_laplacian(image, max_layer=-1, downscale=2,
sigma=None, order=1, mode='reflect', cval=0, multichannel=False,
preserve_range=False)` [source]

    
Yield images of the laplacian pyramid formed by the input image.

Each layer contains the difference between the downsampled and the
downsampled, smoothed image:

    
    layer = resize(prev_layer) - smooth(resize(prev_layer))
    
Note that the first image of the pyramid will be the difference between the
original, unscaled image and its smoothed version. The total number of images
is `max_layer + 1`. In case all layers are computed, the last image is either
a one-pixel image or the image where the reduction does not change its shape.

Parameters

    
`imagendarray`

    
Input image.

`max_layerint, optional`

    
Number of layers for the pyramid. 0th layer is the original image. Default is
-1 which builds all possible layers.

`downscalefloat, optional`

    
Downscale factor.

`sigmafloat, optional`

    
Sigma for Gaussian filter. Default is `2 * downscale / 6.0` which corresponds
to a filter mask twice the size of the scale factor that covers more than 99%
of the Gaussian distribution.

`orderint, optional`

    
Order of splines used in interpolation of downsampling. See
`skimage.transform.warp` for detail.

`mode{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional`

    
The mode parameter determines how the array borders are handled, where cval is
the value when mode is equal to ‘constant’.

`cvalfloat, optional`

    
Value to fill past edges of input if mode is ‘constant’.

`multichannelbool, optional`

    
Whether the last axis of the image is to be interpreted as multiple channels
or another spatial dimension.

`preserve_rangebool, optional`

    
Whether to keep the original range of values. Otherwise, the input image is
converted according to the conventions of `img_as_float`. Also see
https://scikit-image.org/docs/dev/user_guide/data_types.html

Returns

    
`pyramidgenerator`

    
Generator yielding pyramid layers as float images.

#### References

`1`

    
http://persci.mit.edu/pub_pdfs/pyramid83.pdf

`2`

    
http://sepwww.stanford.edu/data/media/public/sep/morgan/texturematch/paper_html/node3.html

## pyramid_reduce

`skimage.transform.pyramid_reduce(image, downscale=2, sigma=None, order=1,
mode='reflect', cval=0, multichannel=False, preserve_range=False)` [source]

    
Smooth and then downsample image.

Parameters

    
`imagendarray`

    
Input image.

`downscalefloat, optional`

    
Downscale factor.

`sigmafloat, optional`

    
Sigma for Gaussian filter. Default is `2 * downscale / 6.0` which corresponds
to a filter mask twice the size of the scale factor that covers more than 99%
of the Gaussian distribution.

`orderint, optional`

    
Order of splines used in interpolation of downsampling. See
`skimage.transform.warp` for detail.

`mode{‘reflect’, ‘constant’, ‘edge’, ‘symmetric’, ‘wrap’}, optional`

    
The mode parameter determines how the array borders are handled, where cval is
the value when mode is equal to ‘constant’.

`cvalfloat, optional`

    
Value to fill past edges of input if mode is ‘constant’.

`multichannelbool, optional`

    
Whether the last axis of the image is to be interpreted as multiple channels
or another spatial dimension.

`preserve_rangebool, optional`

    
Whether to keep the original range of values. Otherwise, the input image is
converted according to the conventions of `img_as_float`. Also see
https://scikit-image.org/docs/dev/user_guide/data_types.html

Returns

    
`outarray`

    
Smoothed and downsampled float image.

#### References

`1`

    
http://persci.mit.edu/pub_pdfs/pyramid83.pdf

## radon

`skimage.transform.radon(image, theta=None, circle=True, *,
preserve_range=False)` [source]

    
Calculates the radon transform of an image given specified projection angles.

Parameters

    
`imagearray_like`

    
Input image. The rotation axis will be located in the pixel with indices
`(image.shape[0] // 2, image.shape[1] // 2)`.

`thetaarray_like, optional`

    
Projection angles (in degrees). If `None`, the value is set to np.arange(180).

`circleboolean, optional`

    
Assume image is zero outside the inscribed circle, making the width of each
projection (the first dimension of the sinogram) equal to `min(image.shape)`.

`preserve_rangebool, optional`

    
Whether to keep the original range of values. Otherwise, the input image is
converted according to the conventions of `img_as_float`. Also see
https://scikit-image.org/docs/dev/user_guide/data_types.html

Returns

    
`radon_imagendarray`

    
Radon transform (sinogram). The tomography rotation axis will lie at the pixel
index `radon_image.shape[0] // 2` along the 0th dimension of `radon_image`.

#### Notes

Based on code of Justin K. Romberg
(https://www.clear.rice.edu/elec431/projects96/DSP/bpanalysis.html)

#### References

`1`

    
AC Kak, M Slaney, “Principles of Computerized Tomographic Imaging”, IEEE Press
1988.

`2`

    
B.R. Ramesh, N. Srinivasa, K. Rajgopal, “An Algorithm for Computing the
Discrete Radon Transform With Some Applications”, Proceedings of the Fourth
IEEE Region 10 International Conference, TENCON ‘89, 1989

## rescale

`skimage.transform.rescale(image, scale, order=None, mode='reflect', cval=0,
clip=True, preserve_range=False, multichannel=False, anti_aliasing=None,
anti_aliasing_sigma=None)` [source]

    
Scale image by a certain factor.

Performs interpolation to up-scale or down-scale N-dimensional images. Note
that anti-aliasing should be enabled when down-sizing images to avoid aliasing
artifacts. For down-sampling with an integer factor also see
`skimage.transform.downscale_local_mean`.

Parameters

    
`imagendarray`

    
Input image.

`scale{float, tuple of floats}`

    
Scale factors. Separate scale factors can be defined as `(rows, cols[, …][,
dim])`.

Returns

    
`scaledndarray`

    
Scaled version of the input.

Other Parameters

    
`orderint, optional`

    
The order of the spline interpolation, default is 0 if image.dtype is bool and
1 otherwise. The order has to be in the range 0-5. See
`skimage.transform.warp` for detail.

`mode{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional`

    
Points outside the boundaries of the input are filled according to the given
mode. Modes match the behaviour of `numpy.pad`.

`cvalfloat, optional`

    
Used in conjunction with mode ‘constant’, the value outside the image
boundaries.

`clipbool, optional`

    
Whether to clip the output to the range of values of the input image. This is
enabled by default, since higher order interpolation may produce values
outside the given input range.

`preserve_rangebool, optional`

    
Whether to keep the original range of values. Otherwise, the input image is
converted according to the conventions of `img_as_float`. Also see
https://scikit-image.org/docs/dev/user_guide/data_types.html

`multichannelbool, optional`

    
Whether the last axis of the image is to be interpreted as multiple channels
or another spatial dimension.

`anti_aliasingbool, optional`

    
Whether to apply a Gaussian filter to smooth the image prior to down-scaling.
It is crucial to filter when down-sampling the image to avoid aliasing
artifacts. If input image data type is bool, no anti-aliasing is applied.

`anti_aliasing_sigma{float, tuple of floats}, optional`

    
Standard deviation for Gaussian filtering to avoid aliasing artifacts. By
default, this value is chosen as (s - 1) / 2 where s is the down-scaling
factor.

#### Notes

Modes ‘reflect’ and ‘symmetric’ are similar, but differ in whether the edge
pixels are duplicated during the reflection. As an example, if an array has
values [0, 1, 2] and was padded to the right by four values using symmetric,
the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it would be [0,
1, 2, 1, 0, 1, 2].

#### Examples

    
    >>> from skimage import data
    >>> from skimage.transform import rescale
    >>> image = data.camera()
    >>> rescale(image, 0.1).shape
    (51, 51)
    >>> rescale(image, 0.5).shape
    (256, 256)
    
## resize

`skimage.transform.resize(image, output_shape, order=None, mode='reflect',
cval=0, clip=True, preserve_range=False, anti_aliasing=None,
anti_aliasing_sigma=None)` [source]

    
Resize image to match a certain size.

Performs interpolation to up-size or down-size N-dimensional images. Note that
anti-aliasing should be enabled when down-sizing images to avoid aliasing
artifacts. For down-sampling with an integer factor also see
`skimage.transform.downscale_local_mean`.

Parameters

    
`imagendarray`

    
Input image.

`output_shapetuple or ndarray`

    
Size of the generated output image `(rows, cols[, …][, dim])`. If `dim` is not
provided, the number of channels is preserved. In case the number of input
channels does not equal the number of output channels a n-dimensional
interpolation is applied.

Returns

    
`resizedndarray`

    
Resized version of the input.

Other Parameters

    
`orderint, optional`

    
The order of the spline interpolation, default is 0 if image.dtype is bool and
1 otherwise. The order has to be in the range 0-5. See
`skimage.transform.warp` for detail.

`mode{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional`

    
Points outside the boundaries of the input are filled according to the given
mode. Modes match the behaviour of `numpy.pad`.

`cvalfloat, optional`

    
Used in conjunction with mode ‘constant’, the value outside the image
boundaries.

`clipbool, optional`

    
Whether to clip the output to the range of values of the input image. This is
enabled by default, since higher order interpolation may produce values
outside the given input range.

`preserve_rangebool, optional`

    
Whether to keep the original range of values. Otherwise, the input image is
converted according to the conventions of `img_as_float`. Also see
https://scikit-image.org/docs/dev/user_guide/data_types.html

`anti_aliasingbool, optional`

    
Whether to apply a Gaussian filter to smooth the image prior to down-scaling.
It is crucial to filter when down-sampling the image to avoid aliasing
artifacts. If input image data type is bool, no anti-aliasing is applied.

`anti_aliasing_sigma{float, tuple of floats}, optional`

    
Standard deviation for Gaussian filtering to avoid aliasing artifacts. By
default, this value is chosen as (s - 1) / 2 where s is the down-scaling
factor, where s > 1\. For the up-size case, s < 1, no anti-aliasing is
performed prior to rescaling.

#### Notes

Modes ‘reflect’ and ‘symmetric’ are similar, but differ in whether the edge
pixels are duplicated during the reflection. As an example, if an array has
values [0, 1, 2] and was padded to the right by four values using symmetric,
the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it would be [0,
1, 2, 1, 0, 1, 2].

#### Examples

    
    >>> from skimage import data
    >>> from skimage.transform import resize
    >>> image = data.camera()
    >>> resize(image, (100, 100)).shape
    (100, 100)
    
## rotate

`skimage.transform.rotate(image, angle, resize=False, center=None, order=None,
mode='constant', cval=0, clip=True, preserve_range=False)` [source]

    
Rotate image by a certain angle around its center.

Parameters

    
`imagendarray`

    
Input image.

`anglefloat`

    
Rotation angle in degrees in counter-clockwise direction.

`resizebool, optional`

    
Determine whether the shape of the output image will be automatically
calculated, so the complete rotated image exactly fits. Default is False.

`centeriterable of length 2`

    
The rotation center. If `center=None`, the image is rotated around its center,
i.e. `center=(cols / 2 - 0.5, rows / 2 - 0.5)`. Please note that this
parameter is (cols, rows), contrary to normal skimage ordering.

Returns

    
`rotatedndarray`

    
Rotated version of the input.

Other Parameters

    
`orderint, optional`

    
The order of the spline interpolation, default is 0 if image.dtype is bool and
1 otherwise. The order has to be in the range 0-5. See
`skimage.transform.warp` for detail.

`mode{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional`

    
Points outside the boundaries of the input are filled according to the given
mode. Modes match the behaviour of `numpy.pad`.

`cvalfloat, optional`

    
Used in conjunction with mode ‘constant’, the value outside the image
boundaries.

`clipbool, optional`

    
Whether to clip the output to the range of values of the input image. This is
enabled by default, since higher order interpolation may produce values
outside the given input range.

`preserve_rangebool, optional`

    
Whether to keep the original range of values. Otherwise, the input image is
converted according to the conventions of `img_as_float`. Also see
https://scikit-image.org/docs/dev/user_guide/data_types.html

#### Notes

Modes ‘reflect’ and ‘symmetric’ are similar, but differ in whether the edge
pixels are duplicated during the reflection. As an example, if an array has
values [0, 1, 2] and was padded to the right by four values using symmetric,
the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it would be [0,
1, 2, 1, 0, 1, 2].

#### Examples

    
    >>> from skimage import data
    >>> from skimage.transform import rotate
    >>> image = data.camera()
    >>> rotate(image, 2).shape
    (512, 512)
    >>> rotate(image, 2, resize=True).shape
    (530, 530)
    >>> rotate(image, 90, resize=True).shape
    (512, 512)
    
### Examples using `skimage.transform.rotate`

![Different
perimeters](data:image/png;base64,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)

Different perimeters

![Measure region
properties](data:image/png;base64,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)

Measure region properties

## swirl

`skimage.transform.swirl(image, center=None, strength=1, radius=100,
rotation=0, output_shape=None, order=None, mode='reflect', cval=0, clip=True,
preserve_range=False)` [source]

    
Perform a swirl transformation.

Parameters

    
`imagendarray`

    
Input image.

`center(column, row) tuple or (2,) ndarray, optional`

    
Center coordinate of transformation.

`strengthfloat, optional`

    
The amount of swirling applied.

`radiusfloat, optional`

    
The extent of the swirl in pixels. The effect dies out rapidly beyond
`radius`.

`rotationfloat, optional`

    
Additional rotation applied to the image.

Returns

    
`swirledndarray`

    
Swirled version of the input.

Other Parameters

    
`output_shapetuple (rows, cols), optional`

    
Shape of the output image generated. By default the shape of the input image
is preserved.

`orderint, optional`

    
The order of the spline interpolation, default is 0 if image.dtype is bool and
1 otherwise. The order has to be in the range 0-5. See
`skimage.transform.warp` for detail.

`mode{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional`

    
Points outside the boundaries of the input are filled according to the given
mode, with ‘constant’ used as the default. Modes match the behaviour of
`numpy.pad`.

`cvalfloat, optional`

    
Used in conjunction with mode ‘constant’, the value outside the image
boundaries.

`clipbool, optional`

    
Whether to clip the output to the range of values of the input image. This is
enabled by default, since higher order interpolation may produce values
outside the given input range.

`preserve_rangebool, optional`

    
Whether to keep the original range of values. Otherwise, the input image is
converted according to the conventions of `img_as_float`. Also see
https://scikit-image.org/docs/dev/user_guide/data_types.html

## warp

`skimage.transform.warp(image, inverse_map, map_args={}, output_shape=None,
order=None, mode='constant', cval=0.0, clip=True, preserve_range=False)`
[source]

    
Warp an image according to a given coordinate transformation.

Parameters

    
`imagendarray`

    
Input image.

`inverse_maptransformation object, callable cr = f(cr, **kwargs), or ndarray`

    
Inverse coordinate map, which transforms coordinates in the output images into
their corresponding coordinates in the input image.

There are a number of different options to define this map, depending on the
dimensionality of the input image. A 2-D image can have 2 dimensions for gray-
scale images, or 3 dimensions with color information.

  * For 2-D images, you can directly pass a transformation object, e.g. `skimage.transform.SimilarityTransform`, or its inverse.
  * For 2-D images, you can pass a `(3, 3)` homogeneous transformation matrix, e.g. `skimage.transform.SimilarityTransform.params`.
  * For 2-D images, a function that transforms a `(M, 2)` array of `(col, row)` coordinates in the output image to their corresponding coordinates in the input image. Extra parameters to the function can be specified through `map_args`.
  * For N-D images, you can directly pass an array of coordinates. The first dimension specifies the coordinates in the input image, while the subsequent dimensions determine the position in the output image. E.g. in case of 2-D images, you need to pass an array of shape `(2, rows, cols)`, where `rows` and `cols` determine the shape of the output image, and the first dimension contains the `(row, col)` coordinate in the input image. See `scipy.ndimage.map_coordinates` for further documentation.

Note, that a `(3, 3)` matrix is interpreted as a homogeneous transformation
matrix, so you cannot interpolate values from a 3-D input, if the output is of
shape `(3,)`.

See example section for usage.

`map_argsdict, optional`

    
Keyword arguments passed to `inverse_map`.

`output_shapetuple (rows, cols), optional`

    
Shape of the output image generated. By default the shape of the input image
is preserved. Note that, even for multi-band images, only rows and columns
need to be specified.

`orderint, optional`

    
The order of interpolation. The order has to be in the range 0-5:

    
  * 0: Nearest-neighbor
  * 1: Bi-linear (default)
  * 2: Bi-quadratic
  * 3: Bi-cubic
  * 4: Bi-quartic
  * 5: Bi-quintic

Default is 0 if image.dtype is bool and 1 otherwise.

`mode{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}, optional`

    
Points outside the boundaries of the input are filled according to the given
mode. Modes match the behaviour of `numpy.pad`.

`cvalfloat, optional`

    
Used in conjunction with mode ‘constant’, the value outside the image
boundaries.

`clipbool, optional`

    
Whether to clip the output to the range of values of the input image. This is
enabled by default, since higher order interpolation may produce values
outside the given input range.

`preserve_rangebool, optional`

    
Whether to keep the original range of values. Otherwise, the input image is
converted according to the conventions of `img_as_float`. Also see
https://scikit-image.org/docs/dev/user_guide/data_types.html

Returns

    
`warpeddouble ndarray`

    
The warped input image.

#### Notes

  * The input image is converted to a `double` image.
  * In case of a `SimilarityTransform`, `AffineTransform` and `ProjectiveTransform` and `order` in [0, 3] this function uses the underlying transformation matrix to warp the image with a much faster routine.

#### Examples

    
    >>> from skimage.transform import warp
    >>> from skimage import data
    >>> image = data.camera()
    
The following image warps are all equal but differ substantially in execution
time. The image is shifted to the bottom.

Use a geometric transform to warp an image (fast):

    
    >>> from skimage.transform import SimilarityTransform
    >>> tform = SimilarityTransform(translation=(0, -10))
    >>> warped = warp(image, tform)
    
Use a callable (slow):

    
    >>> def shift_down(xy):
    ...     xy[:, 1] -= 10
    ...     return xy
    >>> warped = warp(image, shift_down)
    
Use a transformation matrix to warp an image (fast):

    
    >>> matrix = np.array([[1, 0, 0], [0, 1, -10], [0, 0, 1]])
    >>> warped = warp(image, matrix)
    >>> from skimage.transform import ProjectiveTransform
    >>> warped = warp(image, ProjectiveTransform(matrix=matrix))
    
You can also use the inverse of a geometric transformation (fast):

    
    >>> warped = warp(image, tform.inverse)
    
For N-D images you can pass a coordinate array, that specifies the coordinates
in the input image for every element in the output image. E.g. if you want to
rescale a 3-D cube, you can do:

    
    >>> cube_shape = np.array([30, 30, 30])
    >>> cube = np.random.rand(*cube_shape)
    
Setup the coordinate array, that defines the scaling:

    
    >>> scale = 0.1
    >>> output_shape = (scale * cube_shape).astype(int)
    >>> coords0, coords1, coords2 = np.mgrid[:output_shape[0],
    ...                    :output_shape[1], :output_shape[2]]
    >>> coords = np.array([coords0, coords1, coords2])
    
Assume that the cube contains spatial data, where the first array element
center is at coordinate (0.5, 0.5, 0.5) in real space, i.e. we have to account
for this extra offset when scaling the image:

    
    >>> coords = (coords + 0.5) / scale - 0.5
    >>> warped = warp(cube, coords)
    
### Examples using `skimage.transform.warp`

![Registration using optical
flow](data:image/png;base64,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)

Registration using optical flow

## warp_coords

`skimage.transform.warp_coords(coord_map, shape, dtype=<class
'numpy.float64'>)` [source]

    
Build the source coordinates for the output of a 2-D image warp.

Parameters

    
`coord_mapcallable like GeometricTransform.inverse`

    
Return input coordinates for given output coordinates. Coordinates are in the
shape (P, 2), where P is the number of coordinates and each element is a
`(row, col)` pair.

`shapetuple`

    
Shape of output image `(rows, cols[, bands])`.

`dtypenp.dtype or string`

    
dtype for return value (sane choices: float32 or float64).

Returns

    
`coords(ndim, rows, cols[, bands]) array of dtype dtype`

    
Coordinates for `scipy.ndimage.map_coordinates`, that will yield an image of
shape (orows, ocols, bands) by drawing from source points according to the
`coord_transform_fn`.

#### Notes

This is a lower-level routine that produces the source coordinates for 2-D
images used by `warp()`.

It is provided separately from `warp` to give additional flexibility to users
who would like, for example, to re-use a particular coordinate mapping, to use
specific dtypes at various points along the the image-warping process, or to
implement different post-processing logic than `warp` performs after the call
to `ndi.map_coordinates`.

#### Examples

Produce a coordinate map that shifts an image up and to the right:

    
    >>> from skimage import data
    >>> from scipy.ndimage import map_coordinates
    >>>
    >>> def shift_up10_left20(xy):
    ...     return xy - np.array([-20, 10])[None, :]
    >>>
    >>> image = data.astronaut().astype(np.float32)
    >>> coords = warp_coords(shift_up10_left20, image.shape)
    >>> warped_image = map_coordinates(image, coords)
    
## warp_polar

`skimage.transform.warp_polar(image, center=None, *, radius=None,
output_shape=None, scaling='linear', multichannel=False, **kwargs)` [source]

    
Remap image to polar or log-polar coordinates space.

Parameters

    
`imagendarray`

    
Input image. Only 2-D arrays are accepted by default. If `multichannel=True`,
3-D arrays are accepted and the last axis is interpreted as multiple channels.

`centertuple (row, col), optional`

    
Point in image that represents the center of the transformation (i.e., the
origin in cartesian space). Values can be of type `float`. If no value is
given, the center is assumed to be the center point of the image.

`radiusfloat, optional`

    
Radius of the circle that bounds the area to be transformed.

`output_shapetuple (row, col), optional`

`scaling{‘linear’, ‘log’}, optional`

    
Specify whether the image warp is polar or log-polar. Defaults to ‘linear’.

`multichannelbool, optional`

    
Whether the image is a 3-D array in which the third axis is to be interpreted
as multiple channels. If set to `False` (default), only 2-D arrays are
accepted.

`**kwargskeyword arguments`

    
Passed to `transform.warp`.

Returns

    
`warpedndarray`

    
The polar or log-polar warped image.

#### Examples

Perform a basic polar warp on a grayscale image:

    
    >>> from skimage import data
    >>> from skimage.transform import warp_polar
    >>> image = data.checkerboard()
    >>> warped = warp_polar(image)
    
Perform a log-polar warp on a grayscale image:

    
    >>> warped = warp_polar(image, scaling='log')
    
Perform a log-polar warp on a grayscale image while specifying center, radius,
and output shape:

    
    >>> warped = warp_polar(image, (100,100), radius=100,
    ...                     output_shape=image.shape, scaling='log')
    
Perform a log-polar warp on a color image:

    
    >>> image = data.astronaut()
    >>> warped = warp_polar(image, scaling='log', multichannel=True)
    
## AffineTransform

`class skimage.transform.AffineTransform(matrix=None, scale=None,
rotation=None, shear=None, translation=None)` [source]

    
Bases: `skimage.transform._geometric.ProjectiveTransform`

2D affine transformation.

Has the following form:

    
    X = a0*x + a1*y + a2 =
      = sx*x*cos(rotation) - sy*y*sin(rotation + shear) + a2
    
    Y = b0*x + b1*y + b2 =
      = sx*x*sin(rotation) + sy*y*cos(rotation + shear) + b2
    
where `sx` and `sy` are scale factors in the x and y directions, and the
homogeneous transformation matrix is:

    
    [[a0  a1  a2]
     [b0  b1  b2]
     [0   0    1]]
    
Parameters

    
`matrix(3, 3) array, optional`

    
Homogeneous transformation matrix.

`scale{s as float or (sx, sy) as array, list or tuple}, optional`

    
Scale factor(s). If a single value, it will be assigned to both sx and sy.

New in version 0.17: Added support for supplying a single scalar value.

`rotationfloat, optional`

    
Rotation angle in counter-clockwise direction as radians.

`shearfloat, optional`

    
Shear angle in counter-clockwise direction as radians.

`translation(tx, ty) as array, list or tuple, optional`

    
Translation parameters.

Attributes

    
`params(3, 3) array`

    
Homogeneous transformation matrix.

`__init__(matrix=None, scale=None, rotation=None, shear=None,
translation=None)` [source]

    
Initialize self. See help(type(self)) for accurate signature.

`property rotation`

`property scale`

`property shear`

`property translation`

## EssentialMatrixTransform

`class skimage.transform.EssentialMatrixTransform(rotation=None,
translation=None, matrix=None)` [source]

    
Bases: `skimage.transform._geometric.FundamentalMatrixTransform`

Essential matrix transformation.

The essential matrix relates corresponding points between a pair of calibrated
images. The matrix transforms normalized, homogeneous image points in one
image to epipolar lines in the other image.

The essential matrix is only defined for a pair of moving images capturing a
non-planar scene. In the case of pure rotation or planar scenes, the
homography describes the geometric relation between two images
(`ProjectiveTransform`). If the intrinsic calibration of the images is
unknown, the fundamental matrix describes the projective relation between the
two images (`FundamentalMatrixTransform`).

Parameters

    
`rotation(3, 3) array, optional`

    
Rotation matrix of the relative camera motion.

`translation(3, 1) array, optional`

    
Translation vector of the relative camera motion. The vector must have unit
length.

`matrix(3, 3) array, optional`

    
Essential matrix.

#### References

`1`

    
Hartley, Richard, and Andrew Zisserman. Multiple view geometry in computer
vision. Cambridge university press, 2003.

Attributes

    
`params(3, 3) array`

    
Essential matrix.

`__init__(rotation=None, translation=None, matrix=None)` [source]

    
Initialize self. See help(type(self)) for accurate signature.

`estimate(src, dst)` [source]

    
Estimate essential matrix using 8-point algorithm.

The 8-point algorithm requires at least 8 corresponding point pairs for a
well-conditioned solution, otherwise the over-determined solution is
estimated.

Parameters

    
`src(N, 2) array`

    
Source coordinates.

`dst(N, 2) array`

    
Destination coordinates.

Returns

    
`successbool`

    
True, if model estimation succeeds.

## EuclideanTransform

`class skimage.transform.EuclideanTransform(matrix=None, rotation=None,
translation=None)` [source]

    
Bases: `skimage.transform._geometric.ProjectiveTransform`

2D Euclidean transformation.

Has the following form:

    
    X = a0 * x - b0 * y + a1 =
      = x * cos(rotation) - y * sin(rotation) + a1
    
    Y = b0 * x + a0 * y + b1 =
      = x * sin(rotation) + y * cos(rotation) + b1
    
where the homogeneous transformation matrix is:

    
    [[a0  b0  a1]
     [b0  a0  b1]
     [0   0    1]]
    
The Euclidean transformation is a rigid transformation with rotation and
translation parameters. The similarity transformation extends the Euclidean
transformation with a single scaling factor.

Parameters

    
`matrix(3, 3) array, optional`

    
Homogeneous transformation matrix.

`rotationfloat, optional`

    
Rotation angle in counter-clockwise direction as radians.

`translation(tx, ty) as array, list or tuple, optional`

    
x, y translation parameters.

Attributes

    
`params(3, 3) array`

    
Homogeneous transformation matrix.

`__init__(matrix=None, rotation=None, translation=None)` [source]

    
Initialize self. See help(type(self)) for accurate signature.

`estimate(src, dst)` [source]

    
Estimate the transformation from a set of corresponding points.

You can determine the over-, well- and under-determined parameters with the
total least-squares method.

Number of source and destination coordinates must match.

Parameters

    
`src(N, 2) array`

    
Source coordinates.

`dst(N, 2) array`

    
Destination coordinates.

Returns

    
`successbool`

    
True, if model estimation succeeds.

`property rotation`

`property translation`

## FundamentalMatrixTransform

`class skimage.transform.FundamentalMatrixTransform(matrix=None)` [source]

    
Bases: `skimage.transform._geometric.GeometricTransform`

Fundamental matrix transformation.

The fundamental matrix relates corresponding points between a pair of
uncalibrated images. The matrix transforms homogeneous image points in one
image to epipolar lines in the other image.

The fundamental matrix is only defined for a pair of moving images. In the
case of pure rotation or planar scenes, the homography describes the geometric
relation between two images (`ProjectiveTransform`). If the intrinsic
calibration of the images is known, the essential matrix describes the metric
relation between the two images (`EssentialMatrixTransform`).

Parameters

    
`matrix(3, 3) array, optional`

    
Fundamental matrix.

#### References

`1`

    
Hartley, Richard, and Andrew Zisserman. Multiple view geometry in computer
vision. Cambridge university press, 2003.

Attributes

    
`params(3, 3) array`

    
Fundamental matrix.

`__init__(matrix=None)` [source]

    
Initialize self. See help(type(self)) for accurate signature.

`estimate(src, dst)` [source]

    
Estimate fundamental matrix using 8-point algorithm.

The 8-point algorithm requires at least 8 corresponding point pairs for a
well-conditioned solution, otherwise the over-determined solution is
estimated.

Parameters

    
`src(N, 2) array`

    
Source coordinates.

`dst(N, 2) array`

    
Destination coordinates.

Returns

    
`successbool`

    
True, if model estimation succeeds.

`inverse(coords)` [source]

    
Apply inverse transformation.

Parameters

    
`coords(N, 2) array`

    
Destination coordinates.

Returns

    
`coords(N, 3) array`

    
Epipolar lines in the source image.

`residuals(src, dst)` [source]

    
Compute the Sampson distance.

The Sampson distance is the first approximation to the geometric error.

Parameters

    
`src(N, 2) array`

    
Source coordinates.

`dst(N, 2) array`

    
Destination coordinates.

Returns

    
`residuals(N, ) array`

    
Sampson distance.

## PiecewiseAffineTransform

`class skimage.transform.PiecewiseAffineTransform` [source]

    
Bases: `skimage.transform._geometric.GeometricTransform`

2D piecewise affine transformation.

Control points are used to define the mapping. The transform is based on a
Delaunay triangulation of the points to form a mesh. Each triangle is used to
find a local affine transform.

Attributes

    
`affineslist of AffineTransform objects`

    
Affine transformations for each triangle in the mesh.

`inverse_affineslist of AffineTransform objects`

    
Inverse affine transformations for each triangle in the mesh.

`__init__()` [source]

    
Initialize self. See help(type(self)) for accurate signature.

`estimate(src, dst)` [source]

    
Estimate the transformation from a set of corresponding points.

Number of source and destination coordinates must match.

Parameters

    
`src(N, 2) array`

    
Source coordinates.

`dst(N, 2) array`

    
Destination coordinates.

Returns

    
`successbool`

    
True, if model estimation succeeds.

`inverse(coords)` [source]

    
Apply inverse transformation.

Coordinates outside of the mesh will be set to `- 1`.

Parameters

    
`coords(N, 2) array`

    
Source coordinates.

Returns

    
`coords(N, 2) array`

    
Transformed coordinates.

## PolynomialTransform

`class skimage.transform.PolynomialTransform(params=None)` [source]

    
Bases: `skimage.transform._geometric.GeometricTransform`

2D polynomial transformation.

Has the following form:

    
    X = sum[j=0:order]( sum[i=0:j]( a_ji * x**(j - i) * y**i ))
    Y = sum[j=0:order]( sum[i=0:j]( b_ji * x**(j - i) * y**i ))
    
Parameters

    
`params(2, N) array, optional`

    
Polynomial coefficients where `N * 2 = (order + 1) * (order + 2)`. So, a_ji is
defined in `params[0, :]` and b_ji in `params[1, :]`.

Attributes

    
`params(2, N) array`

    
Polynomial coefficients where `N * 2 = (order + 1) * (order + 2)`. So, a_ji is
defined in `params[0, :]` and b_ji in `params[1, :]`.

`__init__(params=None)` [source]

    
Initialize self. See help(type(self)) for accurate signature.

`estimate(src, dst, order=2)` [source]

    
Estimate the transformation from a set of corresponding points.

You can determine the over-, well- and under-determined parameters with the
total least-squares method.

Number of source and destination coordinates must match.

The transformation is defined as:

    
    X = sum[j=0:order]( sum[i=0:j]( a_ji * x**(j - i) * y**i ))
    Y = sum[j=0:order]( sum[i=0:j]( b_ji * x**(j - i) * y**i ))
    
These equations can be transformed to the following form:

    
    0 = sum[j=0:order]( sum[i=0:j]( a_ji * x**(j - i) * y**i )) - X
    0 = sum[j=0:order]( sum[i=0:j]( b_ji * x**(j - i) * y**i )) - Y
    
which exist for each set of corresponding points, so we have a set of N * 2
equations. The coefficients appear linearly so we can write A x = 0, where:

    
    A   = [[1 x y x**2 x*y y**2 ... 0 ...             0 -X]
           [0 ...                 0 1 x y x**2 x*y y**2 -Y]
            ...
            ...
          ]
    x.T = [a00 a10 a11 a20 a21 a22 ... ann
           b00 b10 b11 b20 b21 b22 ... bnn c3]
    
In case of total least-squares the solution of this homogeneous system of
equations is the right singular vector of A which corresponds to the smallest
singular value normed by the coefficient c3.

Parameters

    
`src(N, 2) array`

    
Source coordinates.

`dst(N, 2) array`

    
Destination coordinates.

`orderint, optional`

    
Polynomial order (number of coefficients is order + 1).

Returns

    
`successbool`

    
True, if model estimation succeeds.

`inverse(coords)` [source]

    
Apply inverse transformation.

Parameters

    
`coords(N, 2) array`

    
Destination coordinates.

Returns

    
`coords(N, 2) array`

    
Source coordinates.

## ProjectiveTransform

`class skimage.transform.ProjectiveTransform(matrix=None)` [source]

    
Bases: `skimage.transform._geometric.GeometricTransform`

Projective transformation.

Apply a projective transformation (homography) on coordinates.

For each homogeneous coordinate \\(\mathbf{x} = [x, y, 1]^T\\), its target
position is calculated by multiplying with the given matrix, \\(H\\), to give
\\(H \mathbf{x}\\):

    
    [[a0 a1 a2]
     [b0 b1 b2]
     [c0 c1 1 ]].
    
E.g., to rotate by theta degrees clockwise, the matrix should be:

    
    [[cos(theta) -sin(theta) 0]
     [sin(theta)  cos(theta) 0]
     [0            0         1]]
    
or, to translate x by 10 and y by 20:

    
    [[1 0 10]
     [0 1 20]
     [0 0 1 ]].
    
Parameters

    
`matrix(3, 3) array, optional`

    
Homogeneous transformation matrix.

Attributes

    
`params(3, 3) array`

    
Homogeneous transformation matrix.

`__init__(matrix=None)` [source]

    
Initialize self. See help(type(self)) for accurate signature.

`estimate(src, dst)` [source]

    
Estimate the transformation from a set of corresponding points.

You can determine the over-, well- and under-determined parameters with the
total least-squares method.

Number of source and destination coordinates must match.

The transformation is defined as:

    
    X = (a0*x + a1*y + a2) / (c0*x + c1*y + 1)
    Y = (b0*x + b1*y + b2) / (c0*x + c1*y + 1)
    
These equations can be transformed to the following form:

    
    0 = a0*x + a1*y + a2 - c0*x*X - c1*y*X - X
    0 = b0*x + b1*y + b2 - c0*x*Y - c1*y*Y - Y
    
which exist for each set of corresponding points, so we have a set of N * 2
equations. The coefficients appear linearly so we can write A x = 0, where:

    
    A   = [[x y 1 0 0 0 -x*X -y*X -X]
           [0 0 0 x y 1 -x*Y -y*Y -Y]
            ...
            ...
          ]
    x.T = [a0 a1 a2 b0 b1 b2 c0 c1 c3]
    
In case of total least-squares the solution of this homogeneous system of
equations is the right singular vector of A which corresponds to the smallest
singular value normed by the coefficient c3.

In case of the affine transformation the coefficients c0 and c1 are 0. Thus
the system of equations is:

    
    A   = [[x y 1 0 0 0 -X]
           [0 0 0 x y 1 -Y]
            ...
            ...
          ]
    x.T = [a0 a1 a2 b0 b1 b2 c3]
    
Parameters

    
`src(N, 2) array`

    
Source coordinates.

`dst(N, 2) array`

    
Destination coordinates.

Returns

    
`successbool`

    
True, if model estimation succeeds.

`inverse(coords)` [source]

    
Apply inverse transformation.

Parameters

    
`coords(N, 2) array`

    
Destination coordinates.

Returns

    
`coords(N, 2) array`

    
Source coordinates.

## SimilarityTransform

`class skimage.transform.SimilarityTransform(matrix=None, scale=None,
rotation=None, translation=None)` [source]

    
Bases: `skimage.transform._geometric.EuclideanTransform`

2D similarity transformation.

Has the following form:

    
    X = a0 * x - b0 * y + a1 =
      = s * x * cos(rotation) - s * y * sin(rotation) + a1
    
    Y = b0 * x + a0 * y + b1 =
      = s * x * sin(rotation) + s * y * cos(rotation) + b1
    
where `s` is a scale factor and the homogeneous transformation matrix is:

    
    [[a0  b0  a1]
     [b0  a0  b1]
     [0   0    1]]
    
The similarity transformation extends the Euclidean transformation with a
single scaling factor in addition to the rotation and translation parameters.

Parameters

    
`matrix(3, 3) array, optional`

    
Homogeneous transformation matrix.

`scalefloat, optional`

    
Scale factor.

`rotationfloat, optional`

    
Rotation angle in counter-clockwise direction as radians.

`translation(tx, ty) as array, list or tuple, optional`

    
x, y translation parameters.

Attributes

    
`params(3, 3) array`

    
Homogeneous transformation matrix.

`__init__(matrix=None, scale=None, rotation=None, translation=None)` [source]

    
Initialize self. See help(type(self)) for accurate signature.

`estimate(src, dst)` [source]

    
Estimate the transformation from a set of corresponding points.

You can determine the over-, well- and under-determined parameters with the
total least-squares method.

Number of source and destination coordinates must match.

Parameters

    
`src(N, 2) array`

    
Source coordinates.

`dst(N, 2) array`

    
Destination coordinates.

Returns

    
`successbool`

    
True, if model estimation succeeds.

`property scale`

© 2019 the scikit-image team  
Licensed under the BSD 3-clause License.  
https://scikit-image.org/docs/0.18.x/api/skimage.transform.html

  *[ISP]: Internet Service Provider
  *[LIFO]: last-in, first-out
  *[FIFO]: first-in, first-out

